"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});

// node_modules/@mozilla/readability/Readability.js
var require_Readability = __commonJS({
  "node_modules/@mozilla/readability/Readability.js"(exports2, module2) {
    function Readability2(doc, options) {
      if (options && options.documentElement) {
        doc = options;
        options = arguments[2];
      } else if (!doc || !doc.documentElement) {
        throw new Error("First argument to Readability constructor should be a document object.");
      }
      options = options || {};
      this._doc = doc;
      this._docJSDOMParser = this._doc.firstChild.__JSDOMParser__;
      this._articleTitle = null;
      this._articleByline = null;
      this._articleDir = null;
      this._articleSiteName = null;
      this._attempts = [];
      this._debug = !!options.debug;
      this._maxElemsToParse = options.maxElemsToParse || this.DEFAULT_MAX_ELEMS_TO_PARSE;
      this._nbTopCandidates = options.nbTopCandidates || this.DEFAULT_N_TOP_CANDIDATES;
      this._charThreshold = options.charThreshold || this.DEFAULT_CHAR_THRESHOLD;
      this._classesToPreserve = this.CLASSES_TO_PRESERVE.concat(options.classesToPreserve || []);
      this._keepClasses = !!options.keepClasses;
      this._serializer = options.serializer || function(el) {
        return el.innerHTML;
      };
      this._disableJSONLD = !!options.disableJSONLD;
      this._allowedVideoRegex = options.allowedVideoRegex || this.REGEXPS.videos;
      this._flags = this.FLAG_STRIP_UNLIKELYS | this.FLAG_WEIGHT_CLASSES | this.FLAG_CLEAN_CONDITIONALLY;
      if (this._debug) {
        let logNode = function(node) {
          if (node.nodeType == node.TEXT_NODE) {
            return `${node.nodeName} ("${node.textContent}")`;
          }
          let attrPairs = Array.from(node.attributes || [], function(attr) {
            return `${attr.name}="${attr.value}"`;
          }).join(" ");
          return `<${node.localName} ${attrPairs}>`;
        };
        this.log = function() {
          if (typeof console !== "undefined") {
            let args = Array.from(arguments, (arg) => {
              if (arg && arg.nodeType == this.ELEMENT_NODE) {
                return logNode(arg);
              }
              return arg;
            });
            args.unshift("Reader: (Readability)");
            console.log.apply(console, args);
          } else if (typeof dump !== "undefined") {
            var msg = Array.prototype.map.call(arguments, function(x3) {
              return x3 && x3.nodeName ? logNode(x3) : x3;
            }).join(" ");
            dump("Reader: (Readability) " + msg + "\n");
          }
        };
      } else {
        this.log = function() {
        };
      }
    }
    Readability2.prototype = {
      FLAG_STRIP_UNLIKELYS: 1,
      FLAG_WEIGHT_CLASSES: 2,
      FLAG_CLEAN_CONDITIONALLY: 4,
      // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
      ELEMENT_NODE: 1,
      TEXT_NODE: 3,
      // Max number of nodes supported by this parser. Default: 0 (no limit)
      DEFAULT_MAX_ELEMS_TO_PARSE: 0,
      // The number of top candidates to consider when analysing how
      // tight the competition is among candidates.
      DEFAULT_N_TOP_CANDIDATES: 5,
      // Element tags to score by default.
      DEFAULT_TAGS_TO_SCORE: "section,h2,h3,h4,h5,h6,p,td,pre".toUpperCase().split(","),
      // The default number of chars an article must have in order to return a result
      DEFAULT_CHAR_THRESHOLD: 500,
      // All of the regular expressions in use within readability.
      // Defined up here so we don't instantiate them repeatedly in loops.
      REGEXPS: {
        // NOTE: These two regular expressions are duplicated in
        // Readability-readerable.js. Please keep both copies in sync.
        unlikelyCandidates: /-ad-|ai2html|banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|footer|gdpr|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote/i,
        okMaybeItsACandidate: /and|article|body|column|content|main|shadow/i,
        positive: /article|body|content|entry|hentry|h-entry|main|page|pagination|post|text|blog|story/i,
        negative: /-ad-|hidden|^hid$| hid$| hid |^hid |banner|combx|comment|com-|contact|foot|footer|footnote|gdpr|masthead|media|meta|outbrain|promo|related|scroll|share|shoutbox|sidebar|skyscraper|sponsor|shopping|tags|tool|widget/i,
        extraneous: /print|archive|comment|discuss|e[\-]?mail|share|reply|all|login|sign|single|utility/i,
        byline: /byline|author|dateline|writtenby|p-author/i,
        replaceFonts: /<(\/?)font[^>]*>/gi,
        normalize: /\s{2,}/g,
        videos: /\/\/(www\.)?((dailymotion|youtube|youtube-nocookie|player\.vimeo|v\.qq)\.com|(archive|upload\.wikimedia)\.org|player\.twitch\.tv)/i,
        shareElements: /(\b|_)(share|sharedaddy)(\b|_)/i,
        nextLink: /(next|weiter|continue|>([^\|]|$)|»([^\|]|$))/i,
        prevLink: /(prev|earl|old|new|<|«)/i,
        tokenize: /\W+/g,
        whitespace: /^\s*$/,
        hasContent: /\S$/,
        hashUrl: /^#.+/,
        srcsetUrl: /(\S+)(\s+[\d.]+[xw])?(\s*(?:,|$))/g,
        b64DataUrl: /^data:\s*([^\s;,]+)\s*;\s*base64\s*,/i,
        // See: https://schema.org/Article
        jsonLdArticleTypes: /^Article|AdvertiserContentArticle|NewsArticle|AnalysisNewsArticle|AskPublicNewsArticle|BackgroundNewsArticle|OpinionNewsArticle|ReportageNewsArticle|ReviewNewsArticle|Report|SatiricalArticle|ScholarlyArticle|MedicalScholarlyArticle|SocialMediaPosting|BlogPosting|LiveBlogPosting|DiscussionForumPosting|TechArticle|APIReference$/
      },
      UNLIKELY_ROLES: ["menu", "menubar", "complementary", "navigation", "alert", "alertdialog", "dialog"],
      DIV_TO_P_ELEMS: /* @__PURE__ */ new Set(["BLOCKQUOTE", "DL", "DIV", "IMG", "OL", "P", "PRE", "TABLE", "UL"]),
      ALTER_TO_DIV_EXCEPTIONS: ["DIV", "ARTICLE", "SECTION", "P"],
      PRESENTATIONAL_ATTRIBUTES: ["align", "background", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "hspace", "rules", "style", "valign", "vspace"],
      DEPRECATED_SIZE_ATTRIBUTE_ELEMS: ["TABLE", "TH", "TD", "HR", "PRE"],
      // The commented out elements qualify as phrasing content but tend to be
      // removed by readability when put into paragraphs, so we ignore them here.
      PHRASING_ELEMS: [
        // "CANVAS", "IFRAME", "SVG", "VIDEO",
        "ABBR",
        "AUDIO",
        "B",
        "BDO",
        "BR",
        "BUTTON",
        "CITE",
        "CODE",
        "DATA",
        "DATALIST",
        "DFN",
        "EM",
        "EMBED",
        "I",
        "IMG",
        "INPUT",
        "KBD",
        "LABEL",
        "MARK",
        "MATH",
        "METER",
        "NOSCRIPT",
        "OBJECT",
        "OUTPUT",
        "PROGRESS",
        "Q",
        "RUBY",
        "SAMP",
        "SCRIPT",
        "SELECT",
        "SMALL",
        "SPAN",
        "STRONG",
        "SUB",
        "SUP",
        "TEXTAREA",
        "TIME",
        "VAR",
        "WBR"
      ],
      // These are the classes that readability sets itself.
      CLASSES_TO_PRESERVE: ["page"],
      // These are the list of HTML entities that need to be escaped.
      HTML_ESCAPE_MAP: {
        "lt": "<",
        "gt": ">",
        "amp": "&",
        "quot": '"',
        "apos": "'"
      },
      /**
       * Run any post-process modifications to article content as necessary.
       *
       * @param Element
       * @return void
      **/
      _postProcessContent: function(articleContent) {
        this._fixRelativeUris(articleContent);
        this._simplifyNestedElements(articleContent);
        if (!this._keepClasses) {
          this._cleanClasses(articleContent);
        }
      },
      /**
       * Iterates over a NodeList, calls `filterFn` for each node and removes node
       * if function returned `true`.
       *
       * If function is not passed, removes all the nodes in node list.
       *
       * @param NodeList nodeList The nodes to operate on
       * @param Function filterFn the function to use as a filter
       * @return void
       */
      _removeNodes: function(nodeList, filterFn) {
        if (this._docJSDOMParser && nodeList._isLiveNodeList) {
          throw new Error("Do not pass live node lists to _removeNodes");
        }
        for (var i3 = nodeList.length - 1; i3 >= 0; i3--) {
          var node = nodeList[i3];
          var parentNode = node.parentNode;
          if (parentNode) {
            if (!filterFn || filterFn.call(this, node, i3, nodeList)) {
              parentNode.removeChild(node);
            }
          }
        }
      },
      /**
       * Iterates over a NodeList, and calls _setNodeTag for each node.
       *
       * @param NodeList nodeList The nodes to operate on
       * @param String newTagName the new tag name to use
       * @return void
       */
      _replaceNodeTags: function(nodeList, newTagName) {
        if (this._docJSDOMParser && nodeList._isLiveNodeList) {
          throw new Error("Do not pass live node lists to _replaceNodeTags");
        }
        for (const node of nodeList) {
          this._setNodeTag(node, newTagName);
        }
      },
      /**
       * Iterate over a NodeList, which doesn't natively fully implement the Array
       * interface.
       *
       * For convenience, the current object context is applied to the provided
       * iterate function.
       *
       * @param  NodeList nodeList The NodeList.
       * @param  Function fn       The iterate function.
       * @return void
       */
      _forEachNode: function(nodeList, fn2) {
        Array.prototype.forEach.call(nodeList, fn2, this);
      },
      /**
       * Iterate over a NodeList, and return the first node that passes
       * the supplied test function
       *
       * For convenience, the current object context is applied to the provided
       * test function.
       *
       * @param  NodeList nodeList The NodeList.
       * @param  Function fn       The test function.
       * @return void
       */
      _findNode: function(nodeList, fn2) {
        return Array.prototype.find.call(nodeList, fn2, this);
      },
      /**
       * Iterate over a NodeList, return true if any of the provided iterate
       * function calls returns true, false otherwise.
       *
       * For convenience, the current object context is applied to the
       * provided iterate function.
       *
       * @param  NodeList nodeList The NodeList.
       * @param  Function fn       The iterate function.
       * @return Boolean
       */
      _someNode: function(nodeList, fn2) {
        return Array.prototype.some.call(nodeList, fn2, this);
      },
      /**
       * Iterate over a NodeList, return true if all of the provided iterate
       * function calls return true, false otherwise.
       *
       * For convenience, the current object context is applied to the
       * provided iterate function.
       *
       * @param  NodeList nodeList The NodeList.
       * @param  Function fn       The iterate function.
       * @return Boolean
       */
      _everyNode: function(nodeList, fn2) {
        return Array.prototype.every.call(nodeList, fn2, this);
      },
      /**
       * Concat all nodelists passed as arguments.
       *
       * @return ...NodeList
       * @return Array
       */
      _concatNodeLists: function() {
        var slice = Array.prototype.slice;
        var args = slice.call(arguments);
        var nodeLists = args.map(function(list) {
          return slice.call(list);
        });
        return Array.prototype.concat.apply([], nodeLists);
      },
      _getAllNodesWithTag: function(node, tagNames) {
        if (node.querySelectorAll) {
          return node.querySelectorAll(tagNames.join(","));
        }
        return [].concat.apply([], tagNames.map(function(tag) {
          var collection = node.getElementsByTagName(tag);
          return Array.isArray(collection) ? collection : Array.from(collection);
        }));
      },
      /**
       * Removes the class="" attribute from every element in the given
       * subtree, except those that match CLASSES_TO_PRESERVE and
       * the classesToPreserve array from the options object.
       *
       * @param Element
       * @return void
       */
      _cleanClasses: function(node) {
        var classesToPreserve = this._classesToPreserve;
        var className = (node.getAttribute("class") || "").split(/\s+/).filter(function(cls) {
          return classesToPreserve.indexOf(cls) != -1;
        }).join(" ");
        if (className) {
          node.setAttribute("class", className);
        } else {
          node.removeAttribute("class");
        }
        for (node = node.firstElementChild; node; node = node.nextElementSibling) {
          this._cleanClasses(node);
        }
      },
      /**
       * Converts each <a> and <img> uri in the given element to an absolute URI,
       * ignoring #ref URIs.
       *
       * @param Element
       * @return void
       */
      _fixRelativeUris: function(articleContent) {
        var baseURI = this._doc.baseURI;
        var documentURI = this._doc.documentURI;
        function toAbsoluteURI(uri) {
          if (baseURI == documentURI && uri.charAt(0) == "#") {
            return uri;
          }
          try {
            return new URL(uri, baseURI).href;
          } catch (ex) {
          }
          return uri;
        }
        var links = this._getAllNodesWithTag(articleContent, ["a"]);
        this._forEachNode(links, function(link) {
          var href = link.getAttribute("href");
          if (href) {
            if (href.indexOf("javascript:") === 0) {
              if (link.childNodes.length === 1 && link.childNodes[0].nodeType === this.TEXT_NODE) {
                var text = this._doc.createTextNode(link.textContent);
                link.parentNode.replaceChild(text, link);
              } else {
                var container = this._doc.createElement("span");
                while (link.firstChild) {
                  container.appendChild(link.firstChild);
                }
                link.parentNode.replaceChild(container, link);
              }
            } else {
              link.setAttribute("href", toAbsoluteURI(href));
            }
          }
        });
        var medias = this._getAllNodesWithTag(articleContent, [
          "img",
          "picture",
          "figure",
          "video",
          "audio",
          "source"
        ]);
        this._forEachNode(medias, function(media) {
          var src = media.getAttribute("src");
          var poster = media.getAttribute("poster");
          var srcset = media.getAttribute("srcset");
          if (src) {
            media.setAttribute("src", toAbsoluteURI(src));
          }
          if (poster) {
            media.setAttribute("poster", toAbsoluteURI(poster));
          }
          if (srcset) {
            var newSrcset = srcset.replace(this.REGEXPS.srcsetUrl, function(_3, p1, p22, p3) {
              return toAbsoluteURI(p1) + (p22 || "") + p3;
            });
            media.setAttribute("srcset", newSrcset);
          }
        });
      },
      _simplifyNestedElements: function(articleContent) {
        var node = articleContent;
        while (node) {
          if (node.parentNode && ["DIV", "SECTION"].includes(node.tagName) && !(node.id && node.id.startsWith("readability"))) {
            if (this._isElementWithoutContent(node)) {
              node = this._removeAndGetNext(node);
              continue;
            } else if (this._hasSingleTagInsideElement(node, "DIV") || this._hasSingleTagInsideElement(node, "SECTION")) {
              var child = node.children[0];
              for (var i3 = 0; i3 < node.attributes.length; i3++) {
                child.setAttribute(node.attributes[i3].name, node.attributes[i3].value);
              }
              node.parentNode.replaceChild(child, node);
              node = child;
              continue;
            }
          }
          node = this._getNextNode(node);
        }
      },
      /**
       * Get the article title as an H1.
       *
       * @return string
       **/
      _getArticleTitle: function() {
        var doc = this._doc;
        var curTitle = "";
        var origTitle = "";
        try {
          curTitle = origTitle = doc.title.trim();
          if (typeof curTitle !== "string")
            curTitle = origTitle = this._getInnerText(doc.getElementsByTagName("title")[0]);
        } catch (e3) {
        }
        var titleHadHierarchicalSeparators = false;
        function wordCount(str2) {
          return str2.split(/\s+/).length;
        }
        if (/ [\|\-\\\/>»] /.test(curTitle)) {
          titleHadHierarchicalSeparators = / [\\\/>»] /.test(curTitle);
          curTitle = origTitle.replace(/(.*)[\|\-\\\/>»] .*/gi, "$1");
          if (wordCount(curTitle) < 3)
            curTitle = origTitle.replace(/[^\|\-\\\/>»]*[\|\-\\\/>»](.*)/gi, "$1");
        } else if (curTitle.indexOf(": ") !== -1) {
          var headings = this._concatNodeLists(
            doc.getElementsByTagName("h1"),
            doc.getElementsByTagName("h2")
          );
          var trimmedTitle = curTitle.trim();
          var match = this._someNode(headings, function(heading) {
            return heading.textContent.trim() === trimmedTitle;
          });
          if (!match) {
            curTitle = origTitle.substring(origTitle.lastIndexOf(":") + 1);
            if (wordCount(curTitle) < 3) {
              curTitle = origTitle.substring(origTitle.indexOf(":") + 1);
            } else if (wordCount(origTitle.substr(0, origTitle.indexOf(":"))) > 5) {
              curTitle = origTitle;
            }
          }
        } else if (curTitle.length > 150 || curTitle.length < 15) {
          var hOnes = doc.getElementsByTagName("h1");
          if (hOnes.length === 1)
            curTitle = this._getInnerText(hOnes[0]);
        }
        curTitle = curTitle.trim().replace(this.REGEXPS.normalize, " ");
        var curTitleWordCount = wordCount(curTitle);
        if (curTitleWordCount <= 4 && (!titleHadHierarchicalSeparators || curTitleWordCount != wordCount(origTitle.replace(/[\|\-\\\/>»]+/g, "")) - 1)) {
          curTitle = origTitle;
        }
        return curTitle;
      },
      /**
       * Prepare the HTML document for readability to scrape it.
       * This includes things like stripping javascript, CSS, and handling terrible markup.
       *
       * @return void
       **/
      _prepDocument: function() {
        var doc = this._doc;
        this._removeNodes(this._getAllNodesWithTag(doc, ["style"]));
        if (doc.body) {
          this._replaceBrs(doc.body);
        }
        this._replaceNodeTags(this._getAllNodesWithTag(doc, ["font"]), "SPAN");
      },
      /**
       * Finds the next node, starting from the given node, and ignoring
       * whitespace in between. If the given node is an element, the same node is
       * returned.
       */
      _nextNode: function(node) {
        var next = node;
        while (next && next.nodeType != this.ELEMENT_NODE && this.REGEXPS.whitespace.test(next.textContent)) {
          next = next.nextSibling;
        }
        return next;
      },
      /**
       * Replaces 2 or more successive <br> elements with a single <p>.
       * Whitespace between <br> elements are ignored. For example:
       *   <div>foo<br>bar<br> <br><br>abc</div>
       * will become:
       *   <div>foo<br>bar<p>abc</p></div>
       */
      _replaceBrs: function(elem) {
        this._forEachNode(this._getAllNodesWithTag(elem, ["br"]), function(br3) {
          var next = br3.nextSibling;
          var replaced = false;
          while ((next = this._nextNode(next)) && next.tagName == "BR") {
            replaced = true;
            var brSibling = next.nextSibling;
            next.parentNode.removeChild(next);
            next = brSibling;
          }
          if (replaced) {
            var p3 = this._doc.createElement("p");
            br3.parentNode.replaceChild(p3, br3);
            next = p3.nextSibling;
            while (next) {
              if (next.tagName == "BR") {
                var nextElem = this._nextNode(next.nextSibling);
                if (nextElem && nextElem.tagName == "BR")
                  break;
              }
              if (!this._isPhrasingContent(next))
                break;
              var sibling = next.nextSibling;
              p3.appendChild(next);
              next = sibling;
            }
            while (p3.lastChild && this._isWhitespace(p3.lastChild)) {
              p3.removeChild(p3.lastChild);
            }
            if (p3.parentNode.tagName === "P")
              this._setNodeTag(p3.parentNode, "DIV");
          }
        });
      },
      _setNodeTag: function(node, tag) {
        this.log("_setNodeTag", node, tag);
        if (this._docJSDOMParser) {
          node.localName = tag.toLowerCase();
          node.tagName = tag.toUpperCase();
          return node;
        }
        var replacement = node.ownerDocument.createElement(tag);
        while (node.firstChild) {
          replacement.appendChild(node.firstChild);
        }
        node.parentNode.replaceChild(replacement, node);
        if (node.readability)
          replacement.readability = node.readability;
        for (var i3 = 0; i3 < node.attributes.length; i3++) {
          try {
            replacement.setAttribute(node.attributes[i3].name, node.attributes[i3].value);
          } catch (ex) {
          }
        }
        return replacement;
      },
      /**
       * Prepare the article node for display. Clean out any inline styles,
       * iframes, forms, strip extraneous <p> tags, etc.
       *
       * @param Element
       * @return void
       **/
      _prepArticle: function(articleContent) {
        this._cleanStyles(articleContent);
        this._markDataTables(articleContent);
        this._fixLazyImages(articleContent);
        this._cleanConditionally(articleContent, "form");
        this._cleanConditionally(articleContent, "fieldset");
        this._clean(articleContent, "object");
        this._clean(articleContent, "embed");
        this._clean(articleContent, "footer");
        this._clean(articleContent, "link");
        this._clean(articleContent, "aside");
        var shareElementThreshold = this.DEFAULT_CHAR_THRESHOLD;
        this._forEachNode(articleContent.children, function(topCandidate) {
          this._cleanMatchedNodes(topCandidate, function(node, matchString) {
            return this.REGEXPS.shareElements.test(matchString) && node.textContent.length < shareElementThreshold;
          });
        });
        this._clean(articleContent, "iframe");
        this._clean(articleContent, "input");
        this._clean(articleContent, "textarea");
        this._clean(articleContent, "select");
        this._clean(articleContent, "button");
        this._cleanHeaders(articleContent);
        this._cleanConditionally(articleContent, "table");
        this._cleanConditionally(articleContent, "ul");
        this._cleanConditionally(articleContent, "div");
        this._replaceNodeTags(this._getAllNodesWithTag(articleContent, ["h1"]), "h2");
        this._removeNodes(this._getAllNodesWithTag(articleContent, ["p"]), function(paragraph) {
          var imgCount = paragraph.getElementsByTagName("img").length;
          var embedCount = paragraph.getElementsByTagName("embed").length;
          var objectCount = paragraph.getElementsByTagName("object").length;
          var iframeCount = paragraph.getElementsByTagName("iframe").length;
          var totalCount = imgCount + embedCount + objectCount + iframeCount;
          return totalCount === 0 && !this._getInnerText(paragraph, false);
        });
        this._forEachNode(this._getAllNodesWithTag(articleContent, ["br"]), function(br3) {
          var next = this._nextNode(br3.nextSibling);
          if (next && next.tagName == "P")
            br3.parentNode.removeChild(br3);
        });
        this._forEachNode(this._getAllNodesWithTag(articleContent, ["table"]), function(table) {
          var tbody = this._hasSingleTagInsideElement(table, "TBODY") ? table.firstElementChild : table;
          if (this._hasSingleTagInsideElement(tbody, "TR")) {
            var row = tbody.firstElementChild;
            if (this._hasSingleTagInsideElement(row, "TD")) {
              var cell = row.firstElementChild;
              cell = this._setNodeTag(cell, this._everyNode(cell.childNodes, this._isPhrasingContent) ? "P" : "DIV");
              table.parentNode.replaceChild(cell, table);
            }
          }
        });
      },
      /**
       * Initialize a node with the readability object. Also checks the
       * className/id for special names to add to its score.
       *
       * @param Element
       * @return void
      **/
      _initializeNode: function(node) {
        node.readability = { "contentScore": 0 };
        switch (node.tagName) {
          case "DIV":
            node.readability.contentScore += 5;
            break;
          case "PRE":
          case "TD":
          case "BLOCKQUOTE":
            node.readability.contentScore += 3;
            break;
          case "ADDRESS":
          case "OL":
          case "UL":
          case "DL":
          case "DD":
          case "DT":
          case "LI":
          case "FORM":
            node.readability.contentScore -= 3;
            break;
          case "H1":
          case "H2":
          case "H3":
          case "H4":
          case "H5":
          case "H6":
          case "TH":
            node.readability.contentScore -= 5;
            break;
        }
        node.readability.contentScore += this._getClassWeight(node);
      },
      _removeAndGetNext: function(node) {
        var nextNode = this._getNextNode(node, true);
        node.parentNode.removeChild(node);
        return nextNode;
      },
      /**
       * Traverse the DOM from node to node, starting at the node passed in.
       * Pass true for the second parameter to indicate this node itself
       * (and its kids) are going away, and we want the next node over.
       *
       * Calling this in a loop will traverse the DOM depth-first.
       */
      _getNextNode: function(node, ignoreSelfAndKids) {
        if (!ignoreSelfAndKids && node.firstElementChild) {
          return node.firstElementChild;
        }
        if (node.nextElementSibling) {
          return node.nextElementSibling;
        }
        do {
          node = node.parentNode;
        } while (node && !node.nextElementSibling);
        return node && node.nextElementSibling;
      },
      // compares second text to first one
      // 1 = same text, 0 = completely different text
      // works the way that it splits both texts into words and then finds words that are unique in second text
      // the result is given by the lower length of unique parts
      _textSimilarity: function(textA, textB) {
        var tokensA = textA.toLowerCase().split(this.REGEXPS.tokenize).filter(Boolean);
        var tokensB = textB.toLowerCase().split(this.REGEXPS.tokenize).filter(Boolean);
        if (!tokensA.length || !tokensB.length) {
          return 0;
        }
        var uniqTokensB = tokensB.filter((token) => !tokensA.includes(token));
        var distanceB = uniqTokensB.join(" ").length / tokensB.join(" ").length;
        return 1 - distanceB;
      },
      _checkByline: function(node, matchString) {
        if (this._articleByline) {
          return false;
        }
        if (node.getAttribute !== void 0) {
          var rel = node.getAttribute("rel");
          var itemprop = node.getAttribute("itemprop");
        }
        if ((rel === "author" || itemprop && itemprop.indexOf("author") !== -1 || this.REGEXPS.byline.test(matchString)) && this._isValidByline(node.textContent)) {
          this._articleByline = node.textContent.trim();
          return true;
        }
        return false;
      },
      _getNodeAncestors: function(node, maxDepth) {
        maxDepth = maxDepth || 0;
        var i3 = 0, ancestors = [];
        while (node.parentNode) {
          ancestors.push(node.parentNode);
          if (maxDepth && ++i3 === maxDepth)
            break;
          node = node.parentNode;
        }
        return ancestors;
      },
      /***
       * grabArticle - Using a variety of metrics (content score, classname, element types), find the content that is
       *         most likely to be the stuff a user wants to read. Then return it wrapped up in a div.
       *
       * @param page a document to run upon. Needs to be a full document, complete with body.
       * @return Element
      **/
      _grabArticle: function(page) {
        this.log("**** grabArticle ****");
        var doc = this._doc;
        var isPaging = page !== null;
        page = page ? page : this._doc.body;
        if (!page) {
          this.log("No body found in document. Abort.");
          return null;
        }
        var pageCacheHtml = page.innerHTML;
        while (true) {
          this.log("Starting grabArticle loop");
          var stripUnlikelyCandidates = this._flagIsActive(this.FLAG_STRIP_UNLIKELYS);
          var elementsToScore = [];
          var node = this._doc.documentElement;
          let shouldRemoveTitleHeader = true;
          while (node) {
            if (node.tagName === "HTML") {
              this._articleLang = node.getAttribute("lang");
            }
            var matchString = node.className + " " + node.id;
            if (!this._isProbablyVisible(node)) {
              this.log("Removing hidden node - " + matchString);
              node = this._removeAndGetNext(node);
              continue;
            }
            if (node.getAttribute("aria-modal") == "true" && node.getAttribute("role") == "dialog") {
              node = this._removeAndGetNext(node);
              continue;
            }
            if (this._checkByline(node, matchString)) {
              node = this._removeAndGetNext(node);
              continue;
            }
            if (shouldRemoveTitleHeader && this._headerDuplicatesTitle(node)) {
              this.log("Removing header: ", node.textContent.trim(), this._articleTitle.trim());
              shouldRemoveTitleHeader = false;
              node = this._removeAndGetNext(node);
              continue;
            }
            if (stripUnlikelyCandidates) {
              if (this.REGEXPS.unlikelyCandidates.test(matchString) && !this.REGEXPS.okMaybeItsACandidate.test(matchString) && !this._hasAncestorTag(node, "table") && !this._hasAncestorTag(node, "code") && node.tagName !== "BODY" && node.tagName !== "A") {
                this.log("Removing unlikely candidate - " + matchString);
                node = this._removeAndGetNext(node);
                continue;
              }
              if (this.UNLIKELY_ROLES.includes(node.getAttribute("role"))) {
                this.log("Removing content with role " + node.getAttribute("role") + " - " + matchString);
                node = this._removeAndGetNext(node);
                continue;
              }
            }
            if ((node.tagName === "DIV" || node.tagName === "SECTION" || node.tagName === "HEADER" || node.tagName === "H1" || node.tagName === "H2" || node.tagName === "H3" || node.tagName === "H4" || node.tagName === "H5" || node.tagName === "H6") && this._isElementWithoutContent(node)) {
              node = this._removeAndGetNext(node);
              continue;
            }
            if (this.DEFAULT_TAGS_TO_SCORE.indexOf(node.tagName) !== -1) {
              elementsToScore.push(node);
            }
            if (node.tagName === "DIV") {
              var p3 = null;
              var childNode = node.firstChild;
              while (childNode) {
                var nextSibling = childNode.nextSibling;
                if (this._isPhrasingContent(childNode)) {
                  if (p3 !== null) {
                    p3.appendChild(childNode);
                  } else if (!this._isWhitespace(childNode)) {
                    p3 = doc.createElement("p");
                    node.replaceChild(p3, childNode);
                    p3.appendChild(childNode);
                  }
                } else if (p3 !== null) {
                  while (p3.lastChild && this._isWhitespace(p3.lastChild)) {
                    p3.removeChild(p3.lastChild);
                  }
                  p3 = null;
                }
                childNode = nextSibling;
              }
              if (this._hasSingleTagInsideElement(node, "P") && this._getLinkDensity(node) < 0.25) {
                var newNode = node.children[0];
                node.parentNode.replaceChild(newNode, node);
                node = newNode;
                elementsToScore.push(node);
              } else if (!this._hasChildBlockElement(node)) {
                node = this._setNodeTag(node, "P");
                elementsToScore.push(node);
              }
            }
            node = this._getNextNode(node);
          }
          var candidates = [];
          this._forEachNode(elementsToScore, function(elementToScore) {
            if (!elementToScore.parentNode || typeof elementToScore.parentNode.tagName === "undefined")
              return;
            var innerText = this._getInnerText(elementToScore);
            if (innerText.length < 25)
              return;
            var ancestors2 = this._getNodeAncestors(elementToScore, 5);
            if (ancestors2.length === 0)
              return;
            var contentScore = 0;
            contentScore += 1;
            contentScore += innerText.split(",").length;
            contentScore += Math.min(Math.floor(innerText.length / 100), 3);
            this._forEachNode(ancestors2, function(ancestor, level) {
              if (!ancestor.tagName || !ancestor.parentNode || typeof ancestor.parentNode.tagName === "undefined")
                return;
              if (typeof ancestor.readability === "undefined") {
                this._initializeNode(ancestor);
                candidates.push(ancestor);
              }
              if (level === 0)
                var scoreDivider = 1;
              else if (level === 1)
                scoreDivider = 2;
              else
                scoreDivider = level * 3;
              ancestor.readability.contentScore += contentScore / scoreDivider;
            });
          });
          var topCandidates = [];
          for (var c3 = 0, cl = candidates.length; c3 < cl; c3 += 1) {
            var candidate = candidates[c3];
            var candidateScore = candidate.readability.contentScore * (1 - this._getLinkDensity(candidate));
            candidate.readability.contentScore = candidateScore;
            this.log("Candidate:", candidate, "with score " + candidateScore);
            for (var t3 = 0; t3 < this._nbTopCandidates; t3++) {
              var aTopCandidate = topCandidates[t3];
              if (!aTopCandidate || candidateScore > aTopCandidate.readability.contentScore) {
                topCandidates.splice(t3, 0, candidate);
                if (topCandidates.length > this._nbTopCandidates)
                  topCandidates.pop();
                break;
              }
            }
          }
          var topCandidate = topCandidates[0] || null;
          var neededToCreateTopCandidate = false;
          var parentOfTopCandidate;
          if (topCandidate === null || topCandidate.tagName === "BODY") {
            topCandidate = doc.createElement("DIV");
            neededToCreateTopCandidate = true;
            while (page.firstChild) {
              this.log("Moving child out:", page.firstChild);
              topCandidate.appendChild(page.firstChild);
            }
            page.appendChild(topCandidate);
            this._initializeNode(topCandidate);
          } else if (topCandidate) {
            var alternativeCandidateAncestors = [];
            for (var i3 = 1; i3 < topCandidates.length; i3++) {
              if (topCandidates[i3].readability.contentScore / topCandidate.readability.contentScore >= 0.75) {
                alternativeCandidateAncestors.push(this._getNodeAncestors(topCandidates[i3]));
              }
            }
            var MINIMUM_TOPCANDIDATES = 3;
            if (alternativeCandidateAncestors.length >= MINIMUM_TOPCANDIDATES) {
              parentOfTopCandidate = topCandidate.parentNode;
              while (parentOfTopCandidate.tagName !== "BODY") {
                var listsContainingThisAncestor = 0;
                for (var ancestorIndex = 0; ancestorIndex < alternativeCandidateAncestors.length && listsContainingThisAncestor < MINIMUM_TOPCANDIDATES; ancestorIndex++) {
                  listsContainingThisAncestor += Number(alternativeCandidateAncestors[ancestorIndex].includes(parentOfTopCandidate));
                }
                if (listsContainingThisAncestor >= MINIMUM_TOPCANDIDATES) {
                  topCandidate = parentOfTopCandidate;
                  break;
                }
                parentOfTopCandidate = parentOfTopCandidate.parentNode;
              }
            }
            if (!topCandidate.readability) {
              this._initializeNode(topCandidate);
            }
            parentOfTopCandidate = topCandidate.parentNode;
            var lastScore = topCandidate.readability.contentScore;
            var scoreThreshold = lastScore / 3;
            while (parentOfTopCandidate.tagName !== "BODY") {
              if (!parentOfTopCandidate.readability) {
                parentOfTopCandidate = parentOfTopCandidate.parentNode;
                continue;
              }
              var parentScore = parentOfTopCandidate.readability.contentScore;
              if (parentScore < scoreThreshold)
                break;
              if (parentScore > lastScore) {
                topCandidate = parentOfTopCandidate;
                break;
              }
              lastScore = parentOfTopCandidate.readability.contentScore;
              parentOfTopCandidate = parentOfTopCandidate.parentNode;
            }
            parentOfTopCandidate = topCandidate.parentNode;
            while (parentOfTopCandidate.tagName != "BODY" && parentOfTopCandidate.children.length == 1) {
              topCandidate = parentOfTopCandidate;
              parentOfTopCandidate = topCandidate.parentNode;
            }
            if (!topCandidate.readability) {
              this._initializeNode(topCandidate);
            }
          }
          var articleContent = doc.createElement("DIV");
          if (isPaging)
            articleContent.id = "readability-content";
          var siblingScoreThreshold = Math.max(10, topCandidate.readability.contentScore * 0.2);
          parentOfTopCandidate = topCandidate.parentNode;
          var siblings = parentOfTopCandidate.children;
          for (var s3 = 0, sl = siblings.length; s3 < sl; s3++) {
            var sibling = siblings[s3];
            var append = false;
            this.log("Looking at sibling node:", sibling, sibling.readability ? "with score " + sibling.readability.contentScore : "");
            this.log("Sibling has score", sibling.readability ? sibling.readability.contentScore : "Unknown");
            if (sibling === topCandidate) {
              append = true;
            } else {
              var contentBonus = 0;
              if (sibling.className === topCandidate.className && topCandidate.className !== "")
                contentBonus += topCandidate.readability.contentScore * 0.2;
              if (sibling.readability && sibling.readability.contentScore + contentBonus >= siblingScoreThreshold) {
                append = true;
              } else if (sibling.nodeName === "P") {
                var linkDensity = this._getLinkDensity(sibling);
                var nodeContent = this._getInnerText(sibling);
                var nodeLength = nodeContent.length;
                if (nodeLength > 80 && linkDensity < 0.25) {
                  append = true;
                } else if (nodeLength < 80 && nodeLength > 0 && linkDensity === 0 && nodeContent.search(/\.( |$)/) !== -1) {
                  append = true;
                }
              }
            }
            if (append) {
              this.log("Appending node:", sibling);
              if (this.ALTER_TO_DIV_EXCEPTIONS.indexOf(sibling.nodeName) === -1) {
                this.log("Altering sibling:", sibling, "to div.");
                sibling = this._setNodeTag(sibling, "DIV");
              }
              articleContent.appendChild(sibling);
              siblings = parentOfTopCandidate.children;
              s3 -= 1;
              sl -= 1;
            }
          }
          if (this._debug)
            this.log("Article content pre-prep: " + articleContent.innerHTML);
          this._prepArticle(articleContent);
          if (this._debug)
            this.log("Article content post-prep: " + articleContent.innerHTML);
          if (neededToCreateTopCandidate) {
            topCandidate.id = "readability-page-1";
            topCandidate.className = "page";
          } else {
            var div = doc.createElement("DIV");
            div.id = "readability-page-1";
            div.className = "page";
            while (articleContent.firstChild) {
              div.appendChild(articleContent.firstChild);
            }
            articleContent.appendChild(div);
          }
          if (this._debug)
            this.log("Article content after paging: " + articleContent.innerHTML);
          var parseSuccessful = true;
          var textLength = this._getInnerText(articleContent, true).length;
          if (textLength < this._charThreshold) {
            parseSuccessful = false;
            page.innerHTML = pageCacheHtml;
            if (this._flagIsActive(this.FLAG_STRIP_UNLIKELYS)) {
              this._removeFlag(this.FLAG_STRIP_UNLIKELYS);
              this._attempts.push({ articleContent, textLength });
            } else if (this._flagIsActive(this.FLAG_WEIGHT_CLASSES)) {
              this._removeFlag(this.FLAG_WEIGHT_CLASSES);
              this._attempts.push({ articleContent, textLength });
            } else if (this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY)) {
              this._removeFlag(this.FLAG_CLEAN_CONDITIONALLY);
              this._attempts.push({ articleContent, textLength });
            } else {
              this._attempts.push({ articleContent, textLength });
              this._attempts.sort(function(a3, b3) {
                return b3.textLength - a3.textLength;
              });
              if (!this._attempts[0].textLength) {
                return null;
              }
              articleContent = this._attempts[0].articleContent;
              parseSuccessful = true;
            }
          }
          if (parseSuccessful) {
            var ancestors = [parentOfTopCandidate, topCandidate].concat(this._getNodeAncestors(parentOfTopCandidate));
            this._someNode(ancestors, function(ancestor) {
              if (!ancestor.tagName)
                return false;
              var articleDir = ancestor.getAttribute("dir");
              if (articleDir) {
                this._articleDir = articleDir;
                return true;
              }
              return false;
            });
            return articleContent;
          }
        }
      },
      /**
       * Check whether the input string could be a byline.
       * This verifies that the input is a string, and that the length
       * is less than 100 chars.
       *
       * @param possibleByline {string} - a string to check whether its a byline.
       * @return Boolean - whether the input string is a byline.
       */
      _isValidByline: function(byline) {
        if (typeof byline == "string" || byline instanceof String) {
          byline = byline.trim();
          return byline.length > 0 && byline.length < 100;
        }
        return false;
      },
      /**
       * Converts some of the common HTML entities in string to their corresponding characters.
       *
       * @param str {string} - a string to unescape.
       * @return string without HTML entity.
       */
      _unescapeHtmlEntities: function(str2) {
        if (!str2) {
          return str2;
        }
        var htmlEscapeMap = this.HTML_ESCAPE_MAP;
        return str2.replace(/&(quot|amp|apos|lt|gt);/g, function(_3, tag) {
          return htmlEscapeMap[tag];
        }).replace(/&#(?:x([0-9a-z]{1,4})|([0-9]{1,4}));/gi, function(_3, hex, numStr) {
          var num = parseInt(hex || numStr, hex ? 16 : 10);
          return String.fromCharCode(num);
        });
      },
      /**
       * Try to extract metadata from JSON-LD object.
       * For now, only Schema.org objects of type Article or its subtypes are supported.
       * @return Object with any metadata that could be extracted (possibly none)
       */
      _getJSONLD: function(doc) {
        var scripts = this._getAllNodesWithTag(doc, ["script"]);
        var metadata;
        this._forEachNode(scripts, function(jsonLdElement) {
          if (!metadata && jsonLdElement.getAttribute("type") === "application/ld+json") {
            try {
              var content = jsonLdElement.textContent.replace(/^\s*<!\[CDATA\[|\]\]>\s*$/g, "");
              var parsed = JSON.parse(content);
              if (!parsed["@context"] || !parsed["@context"].match(/^https?\:\/\/schema\.org$/)) {
                return;
              }
              if (!parsed["@type"] && Array.isArray(parsed["@graph"])) {
                parsed = parsed["@graph"].find(function(it3) {
                  return (it3["@type"] || "").match(
                    this.REGEXPS.jsonLdArticleTypes
                  );
                });
              }
              if (!parsed || !parsed["@type"] || !parsed["@type"].match(this.REGEXPS.jsonLdArticleTypes)) {
                return;
              }
              metadata = {};
              if (typeof parsed.name === "string" && typeof parsed.headline === "string" && parsed.name !== parsed.headline) {
                var title = this._getArticleTitle();
                var nameMatches = this._textSimilarity(parsed.name, title) > 0.75;
                var headlineMatches = this._textSimilarity(parsed.headline, title) > 0.75;
                if (headlineMatches && !nameMatches) {
                  metadata.title = parsed.headline;
                } else {
                  metadata.title = parsed.name;
                }
              } else if (typeof parsed.name === "string") {
                metadata.title = parsed.name.trim();
              } else if (typeof parsed.headline === "string") {
                metadata.title = parsed.headline.trim();
              }
              if (parsed.author) {
                if (typeof parsed.author.name === "string") {
                  metadata.byline = parsed.author.name.trim();
                } else if (Array.isArray(parsed.author) && parsed.author[0] && typeof parsed.author[0].name === "string") {
                  metadata.byline = parsed.author.filter(function(author) {
                    return author && typeof author.name === "string";
                  }).map(function(author) {
                    return author.name.trim();
                  }).join(", ");
                }
              }
              if (typeof parsed.description === "string") {
                metadata.excerpt = parsed.description.trim();
              }
              if (parsed.publisher && typeof parsed.publisher.name === "string") {
                metadata.siteName = parsed.publisher.name.trim();
              }
              return;
            } catch (err) {
              this.log(err.message);
            }
          }
        });
        return metadata ? metadata : {};
      },
      /**
       * Attempts to get excerpt and byline metadata for the article.
       *
       * @param {Object} jsonld — object containing any metadata that
       * could be extracted from JSON-LD object.
       *
       * @return Object with optional "excerpt" and "byline" properties
       */
      _getArticleMetadata: function(jsonld) {
        var metadata = {};
        var values = {};
        var metaElements = this._doc.getElementsByTagName("meta");
        var propertyPattern = /\s*(dc|dcterm|og|twitter)\s*:\s*(author|creator|description|title|site_name)\s*/gi;
        var namePattern = /^\s*(?:(dc|dcterm|og|twitter|weibo:(article|webpage))\s*[\.:]\s*)?(author|creator|description|title|site_name)\s*$/i;
        this._forEachNode(metaElements, function(element) {
          var elementName = element.getAttribute("name");
          var elementProperty = element.getAttribute("property");
          var content = element.getAttribute("content");
          if (!content) {
            return;
          }
          var matches = null;
          var name = null;
          if (elementProperty) {
            matches = elementProperty.match(propertyPattern);
            if (matches) {
              name = matches[0].toLowerCase().replace(/\s/g, "");
              values[name] = content.trim();
            }
          }
          if (!matches && elementName && namePattern.test(elementName)) {
            name = elementName;
            if (content) {
              name = name.toLowerCase().replace(/\s/g, "").replace(/\./g, ":");
              values[name] = content.trim();
            }
          }
        });
        metadata.title = jsonld.title || values["dc:title"] || values["dcterm:title"] || values["og:title"] || values["weibo:article:title"] || values["weibo:webpage:title"] || values["title"] || values["twitter:title"];
        if (!metadata.title) {
          metadata.title = this._getArticleTitle();
        }
        metadata.byline = jsonld.byline || values["dc:creator"] || values["dcterm:creator"] || values["author"];
        metadata.excerpt = jsonld.excerpt || values["dc:description"] || values["dcterm:description"] || values["og:description"] || values["weibo:article:description"] || values["weibo:webpage:description"] || values["description"] || values["twitter:description"];
        metadata.siteName = jsonld.siteName || values["og:site_name"];
        metadata.title = this._unescapeHtmlEntities(metadata.title);
        metadata.byline = this._unescapeHtmlEntities(metadata.byline);
        metadata.excerpt = this._unescapeHtmlEntities(metadata.excerpt);
        metadata.siteName = this._unescapeHtmlEntities(metadata.siteName);
        return metadata;
      },
      /**
       * Check if node is image, or if node contains exactly only one image
       * whether as a direct child or as its descendants.
       *
       * @param Element
      **/
      _isSingleImage: function(node) {
        if (node.tagName === "IMG") {
          return true;
        }
        if (node.children.length !== 1 || node.textContent.trim() !== "") {
          return false;
        }
        return this._isSingleImage(node.children[0]);
      },
      /**
       * Find all <noscript> that are located after <img> nodes, and which contain only one
       * <img> element. Replace the first image with the image from inside the <noscript> tag,
       * and remove the <noscript> tag. This improves the quality of the images we use on
       * some sites (e.g. Medium).
       *
       * @param Element
      **/
      _unwrapNoscriptImages: function(doc) {
        var imgs = Array.from(doc.getElementsByTagName("img"));
        this._forEachNode(imgs, function(img) {
          for (var i3 = 0; i3 < img.attributes.length; i3++) {
            var attr = img.attributes[i3];
            switch (attr.name) {
              case "src":
              case "srcset":
              case "data-src":
              case "data-srcset":
                return;
            }
            if (/\.(jpg|jpeg|png|webp)/i.test(attr.value)) {
              return;
            }
          }
          img.parentNode.removeChild(img);
        });
        var noscripts = Array.from(doc.getElementsByTagName("noscript"));
        this._forEachNode(noscripts, function(noscript) {
          var tmp = doc.createElement("div");
          tmp.innerHTML = noscript.innerHTML;
          if (!this._isSingleImage(tmp)) {
            return;
          }
          var prevElement = noscript.previousElementSibling;
          if (prevElement && this._isSingleImage(prevElement)) {
            var prevImg = prevElement;
            if (prevImg.tagName !== "IMG") {
              prevImg = prevElement.getElementsByTagName("img")[0];
            }
            var newImg = tmp.getElementsByTagName("img")[0];
            for (var i3 = 0; i3 < prevImg.attributes.length; i3++) {
              var attr = prevImg.attributes[i3];
              if (attr.value === "") {
                continue;
              }
              if (attr.name === "src" || attr.name === "srcset" || /\.(jpg|jpeg|png|webp)/i.test(attr.value)) {
                if (newImg.getAttribute(attr.name) === attr.value) {
                  continue;
                }
                var attrName = attr.name;
                if (newImg.hasAttribute(attrName)) {
                  attrName = "data-old-" + attrName;
                }
                newImg.setAttribute(attrName, attr.value);
              }
            }
            noscript.parentNode.replaceChild(tmp.firstElementChild, prevElement);
          }
        });
      },
      /**
       * Removes script tags from the document.
       *
       * @param Element
      **/
      _removeScripts: function(doc) {
        this._removeNodes(this._getAllNodesWithTag(doc, ["script", "noscript"]));
      },
      /**
       * Check if this node has only whitespace and a single element with given tag
       * Returns false if the DIV node contains non-empty text nodes
       * or if it contains no element with given tag or more than 1 element.
       *
       * @param Element
       * @param string tag of child element
      **/
      _hasSingleTagInsideElement: function(element, tag) {
        if (element.children.length != 1 || element.children[0].tagName !== tag) {
          return false;
        }
        return !this._someNode(element.childNodes, function(node) {
          return node.nodeType === this.TEXT_NODE && this.REGEXPS.hasContent.test(node.textContent);
        });
      },
      _isElementWithoutContent: function(node) {
        return node.nodeType === this.ELEMENT_NODE && node.textContent.trim().length == 0 && (node.children.length == 0 || node.children.length == node.getElementsByTagName("br").length + node.getElementsByTagName("hr").length);
      },
      /**
       * Determine whether element has any children block level elements.
       *
       * @param Element
       */
      _hasChildBlockElement: function(element) {
        return this._someNode(element.childNodes, function(node) {
          return this.DIV_TO_P_ELEMS.has(node.tagName) || this._hasChildBlockElement(node);
        });
      },
      /***
       * Determine if a node qualifies as phrasing content.
       * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Phrasing_content
      **/
      _isPhrasingContent: function(node) {
        return node.nodeType === this.TEXT_NODE || this.PHRASING_ELEMS.indexOf(node.tagName) !== -1 || (node.tagName === "A" || node.tagName === "DEL" || node.tagName === "INS") && this._everyNode(node.childNodes, this._isPhrasingContent);
      },
      _isWhitespace: function(node) {
        return node.nodeType === this.TEXT_NODE && node.textContent.trim().length === 0 || node.nodeType === this.ELEMENT_NODE && node.tagName === "BR";
      },
      /**
       * Get the inner text of a node - cross browser compatibly.
       * This also strips out any excess whitespace to be found.
       *
       * @param Element
       * @param Boolean normalizeSpaces (default: true)
       * @return string
      **/
      _getInnerText: function(e3, normalizeSpaces) {
        normalizeSpaces = typeof normalizeSpaces === "undefined" ? true : normalizeSpaces;
        var textContent = e3.textContent.trim();
        if (normalizeSpaces) {
          return textContent.replace(this.REGEXPS.normalize, " ");
        }
        return textContent;
      },
      /**
       * Get the number of times a string s appears in the node e.
       *
       * @param Element
       * @param string - what to split on. Default is ","
       * @return number (integer)
      **/
      _getCharCount: function(e3, s3) {
        s3 = s3 || ",";
        return this._getInnerText(e3).split(s3).length - 1;
      },
      /**
       * Remove the style attribute on every e and under.
       * TODO: Test if getElementsByTagName(*) is faster.
       *
       * @param Element
       * @return void
      **/
      _cleanStyles: function(e3) {
        if (!e3 || e3.tagName.toLowerCase() === "svg")
          return;
        for (var i3 = 0; i3 < this.PRESENTATIONAL_ATTRIBUTES.length; i3++) {
          e3.removeAttribute(this.PRESENTATIONAL_ATTRIBUTES[i3]);
        }
        if (this.DEPRECATED_SIZE_ATTRIBUTE_ELEMS.indexOf(e3.tagName) !== -1) {
          e3.removeAttribute("width");
          e3.removeAttribute("height");
        }
        var cur = e3.firstElementChild;
        while (cur !== null) {
          this._cleanStyles(cur);
          cur = cur.nextElementSibling;
        }
      },
      /**
       * Get the density of links as a percentage of the content
       * This is the amount of text that is inside a link divided by the total text in the node.
       *
       * @param Element
       * @return number (float)
      **/
      _getLinkDensity: function(element) {
        var textLength = this._getInnerText(element).length;
        if (textLength === 0)
          return 0;
        var linkLength = 0;
        this._forEachNode(element.getElementsByTagName("a"), function(linkNode) {
          var href = linkNode.getAttribute("href");
          var coefficient = href && this.REGEXPS.hashUrl.test(href) ? 0.3 : 1;
          linkLength += this._getInnerText(linkNode).length * coefficient;
        });
        return linkLength / textLength;
      },
      /**
       * Get an elements class/id weight. Uses regular expressions to tell if this
       * element looks good or bad.
       *
       * @param Element
       * @return number (Integer)
      **/
      _getClassWeight: function(e3) {
        if (!this._flagIsActive(this.FLAG_WEIGHT_CLASSES))
          return 0;
        var weight = 0;
        if (typeof e3.className === "string" && e3.className !== "") {
          if (this.REGEXPS.negative.test(e3.className))
            weight -= 25;
          if (this.REGEXPS.positive.test(e3.className))
            weight += 25;
        }
        if (typeof e3.id === "string" && e3.id !== "") {
          if (this.REGEXPS.negative.test(e3.id))
            weight -= 25;
          if (this.REGEXPS.positive.test(e3.id))
            weight += 25;
        }
        return weight;
      },
      /**
       * Clean a node of all elements of type "tag".
       * (Unless it's a youtube/vimeo video. People love movies.)
       *
       * @param Element
       * @param string tag to clean
       * @return void
       **/
      _clean: function(e3, tag) {
        var isEmbed = ["object", "embed", "iframe"].indexOf(tag) !== -1;
        this._removeNodes(this._getAllNodesWithTag(e3, [tag]), function(element) {
          if (isEmbed) {
            for (var i3 = 0; i3 < element.attributes.length; i3++) {
              if (this._allowedVideoRegex.test(element.attributes[i3].value)) {
                return false;
              }
            }
            if (element.tagName === "object" && this._allowedVideoRegex.test(element.innerHTML)) {
              return false;
            }
          }
          return true;
        });
      },
      /**
       * Check if a given node has one of its ancestor tag name matching the
       * provided one.
       * @param  HTMLElement node
       * @param  String      tagName
       * @param  Number      maxDepth
       * @param  Function    filterFn a filter to invoke to determine whether this node 'counts'
       * @return Boolean
       */
      _hasAncestorTag: function(node, tagName, maxDepth, filterFn) {
        maxDepth = maxDepth || 3;
        tagName = tagName.toUpperCase();
        var depth = 0;
        while (node.parentNode) {
          if (maxDepth > 0 && depth > maxDepth)
            return false;
          if (node.parentNode.tagName === tagName && (!filterFn || filterFn(node.parentNode)))
            return true;
          node = node.parentNode;
          depth++;
        }
        return false;
      },
      /**
       * Return an object indicating how many rows and columns this table has.
       */
      _getRowAndColumnCount: function(table) {
        var rows = 0;
        var columns = 0;
        var trs = table.getElementsByTagName("tr");
        for (var i3 = 0; i3 < trs.length; i3++) {
          var rowspan = trs[i3].getAttribute("rowspan") || 0;
          if (rowspan) {
            rowspan = parseInt(rowspan, 10);
          }
          rows += rowspan || 1;
          var columnsInThisRow = 0;
          var cells = trs[i3].getElementsByTagName("td");
          for (var j3 = 0; j3 < cells.length; j3++) {
            var colspan = cells[j3].getAttribute("colspan") || 0;
            if (colspan) {
              colspan = parseInt(colspan, 10);
            }
            columnsInThisRow += colspan || 1;
          }
          columns = Math.max(columns, columnsInThisRow);
        }
        return { rows, columns };
      },
      /**
       * Look for 'data' (as opposed to 'layout') tables, for which we use
       * similar checks as
       * https://searchfox.org/mozilla-central/rev/f82d5c549f046cb64ce5602bfd894b7ae807c8f8/accessible/generic/TableAccessible.cpp#19
       */
      _markDataTables: function(root) {
        var tables = root.getElementsByTagName("table");
        for (var i3 = 0; i3 < tables.length; i3++) {
          var table = tables[i3];
          var role = table.getAttribute("role");
          if (role == "presentation") {
            table._readabilityDataTable = false;
            continue;
          }
          var datatable = table.getAttribute("datatable");
          if (datatable == "0") {
            table._readabilityDataTable = false;
            continue;
          }
          var summary = table.getAttribute("summary");
          if (summary) {
            table._readabilityDataTable = true;
            continue;
          }
          var caption = table.getElementsByTagName("caption")[0];
          if (caption && caption.childNodes.length > 0) {
            table._readabilityDataTable = true;
            continue;
          }
          var dataTableDescendants = ["col", "colgroup", "tfoot", "thead", "th"];
          var descendantExists = function(tag) {
            return !!table.getElementsByTagName(tag)[0];
          };
          if (dataTableDescendants.some(descendantExists)) {
            this.log("Data table because found data-y descendant");
            table._readabilityDataTable = true;
            continue;
          }
          if (table.getElementsByTagName("table")[0]) {
            table._readabilityDataTable = false;
            continue;
          }
          var sizeInfo = this._getRowAndColumnCount(table);
          if (sizeInfo.rows >= 10 || sizeInfo.columns > 4) {
            table._readabilityDataTable = true;
            continue;
          }
          table._readabilityDataTable = sizeInfo.rows * sizeInfo.columns > 10;
        }
      },
      /* convert images and figures that have properties like data-src into images that can be loaded without JS */
      _fixLazyImages: function(root) {
        this._forEachNode(this._getAllNodesWithTag(root, ["img", "picture", "figure"]), function(elem) {
          if (elem.src && this.REGEXPS.b64DataUrl.test(elem.src)) {
            var parts = this.REGEXPS.b64DataUrl.exec(elem.src);
            if (parts[1] === "image/svg+xml") {
              return;
            }
            var srcCouldBeRemoved = false;
            for (var i3 = 0; i3 < elem.attributes.length; i3++) {
              var attr = elem.attributes[i3];
              if (attr.name === "src") {
                continue;
              }
              if (/\.(jpg|jpeg|png|webp)/i.test(attr.value)) {
                srcCouldBeRemoved = true;
                break;
              }
            }
            if (srcCouldBeRemoved) {
              var b64starts = elem.src.search(/base64\s*/i) + 7;
              var b64length = elem.src.length - b64starts;
              if (b64length < 133) {
                elem.removeAttribute("src");
              }
            }
          }
          if ((elem.src || elem.srcset && elem.srcset != "null") && elem.className.toLowerCase().indexOf("lazy") === -1) {
            return;
          }
          for (var j3 = 0; j3 < elem.attributes.length; j3++) {
            attr = elem.attributes[j3];
            if (attr.name === "src" || attr.name === "srcset" || attr.name === "alt") {
              continue;
            }
            var copyTo = null;
            if (/\.(jpg|jpeg|png|webp)\s+\d/.test(attr.value)) {
              copyTo = "srcset";
            } else if (/^\s*\S+\.(jpg|jpeg|png|webp)\S*\s*$/.test(attr.value)) {
              copyTo = "src";
            }
            if (copyTo) {
              if (elem.tagName === "IMG" || elem.tagName === "PICTURE") {
                elem.setAttribute(copyTo, attr.value);
              } else if (elem.tagName === "FIGURE" && !this._getAllNodesWithTag(elem, ["img", "picture"]).length) {
                var img = this._doc.createElement("img");
                img.setAttribute(copyTo, attr.value);
                elem.appendChild(img);
              }
            }
          }
        });
      },
      _getTextDensity: function(e3, tags) {
        var textLength = this._getInnerText(e3, true).length;
        if (textLength === 0) {
          return 0;
        }
        var childrenLength = 0;
        var children = this._getAllNodesWithTag(e3, tags);
        this._forEachNode(children, (child) => childrenLength += this._getInnerText(child, true).length);
        return childrenLength / textLength;
      },
      /**
       * Clean an element of all tags of type "tag" if they look fishy.
       * "Fishy" is an algorithm based on content length, classnames, link density, number of images & embeds, etc.
       *
       * @return void
       **/
      _cleanConditionally: function(e3, tag) {
        if (!this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY))
          return;
        this._removeNodes(this._getAllNodesWithTag(e3, [tag]), function(node) {
          var isDataTable = function(t3) {
            return t3._readabilityDataTable;
          };
          var isList = tag === "ul" || tag === "ol";
          if (!isList) {
            var listLength = 0;
            var listNodes = this._getAllNodesWithTag(node, ["ul", "ol"]);
            this._forEachNode(listNodes, (list) => listLength += this._getInnerText(list).length);
            isList = listLength / this._getInnerText(node).length > 0.9;
          }
          if (tag === "table" && isDataTable(node)) {
            return false;
          }
          if (this._hasAncestorTag(node, "table", -1, isDataTable)) {
            return false;
          }
          if (this._hasAncestorTag(node, "code")) {
            return false;
          }
          var weight = this._getClassWeight(node);
          this.log("Cleaning Conditionally", node);
          var contentScore = 0;
          if (weight + contentScore < 0) {
            return true;
          }
          if (this._getCharCount(node, ",") < 10) {
            var p3 = node.getElementsByTagName("p").length;
            var img = node.getElementsByTagName("img").length;
            var li2 = node.getElementsByTagName("li").length - 100;
            var input = node.getElementsByTagName("input").length;
            var headingDensity = this._getTextDensity(node, ["h1", "h2", "h3", "h4", "h5", "h6"]);
            var embedCount = 0;
            var embeds = this._getAllNodesWithTag(node, ["object", "embed", "iframe"]);
            for (var i3 = 0; i3 < embeds.length; i3++) {
              for (var j3 = 0; j3 < embeds[i3].attributes.length; j3++) {
                if (this._allowedVideoRegex.test(embeds[i3].attributes[j3].value)) {
                  return false;
                }
              }
              if (embeds[i3].tagName === "object" && this._allowedVideoRegex.test(embeds[i3].innerHTML)) {
                return false;
              }
              embedCount++;
            }
            var linkDensity = this._getLinkDensity(node);
            var contentLength = this._getInnerText(node).length;
            var haveToRemove = img > 1 && p3 / img < 0.5 && !this._hasAncestorTag(node, "figure") || !isList && li2 > p3 || input > Math.floor(p3 / 3) || !isList && headingDensity < 0.9 && contentLength < 25 && (img === 0 || img > 2) && !this._hasAncestorTag(node, "figure") || !isList && weight < 25 && linkDensity > 0.2 || weight >= 25 && linkDensity > 0.5 || (embedCount === 1 && contentLength < 75 || embedCount > 1);
            if (isList && haveToRemove) {
              for (var x3 = 0; x3 < node.children.length; x3++) {
                let child = node.children[x3];
                if (child.children.length > 1) {
                  return haveToRemove;
                }
              }
              let li_count = node.getElementsByTagName("li").length;
              if (img == li_count) {
                return false;
              }
            }
            return haveToRemove;
          }
          return false;
        });
      },
      /**
       * Clean out elements that match the specified conditions
       *
       * @param Element
       * @param Function determines whether a node should be removed
       * @return void
       **/
      _cleanMatchedNodes: function(e3, filter) {
        var endOfSearchMarkerNode = this._getNextNode(e3, true);
        var next = this._getNextNode(e3);
        while (next && next != endOfSearchMarkerNode) {
          if (filter.call(this, next, next.className + " " + next.id)) {
            next = this._removeAndGetNext(next);
          } else {
            next = this._getNextNode(next);
          }
        }
      },
      /**
       * Clean out spurious headers from an Element.
       *
       * @param Element
       * @return void
      **/
      _cleanHeaders: function(e3) {
        let headingNodes = this._getAllNodesWithTag(e3, ["h1", "h2"]);
        this._removeNodes(headingNodes, function(node) {
          let shouldRemove = this._getClassWeight(node) < 0;
          if (shouldRemove) {
            this.log("Removing header with low class weight:", node);
          }
          return shouldRemove;
        });
      },
      /**
       * Check if this node is an H1 or H2 element whose content is mostly
       * the same as the article title.
       *
       * @param Element  the node to check.
       * @return boolean indicating whether this is a title-like header.
       */
      _headerDuplicatesTitle: function(node) {
        if (node.tagName != "H1" && node.tagName != "H2") {
          return false;
        }
        var heading = this._getInnerText(node, false);
        this.log("Evaluating similarity of header:", heading, this._articleTitle);
        return this._textSimilarity(this._articleTitle, heading) > 0.75;
      },
      _flagIsActive: function(flag) {
        return (this._flags & flag) > 0;
      },
      _removeFlag: function(flag) {
        this._flags = this._flags & ~flag;
      },
      _isProbablyVisible: function(node) {
        return (!node.style || node.style.display != "none") && !node.hasAttribute("hidden") && (!node.hasAttribute("aria-hidden") || node.getAttribute("aria-hidden") != "true" || node.className && node.className.indexOf && node.className.indexOf("fallback-image") !== -1);
      },
      /**
       * Runs readability.
       *
       * Workflow:
       *  1. Prep the document by removing script tags, css, etc.
       *  2. Build readability's DOM tree.
       *  3. Grab the article content from the current dom tree.
       *  4. Replace the current DOM tree with the new one.
       *  5. Read peacefully.
       *
       * @return void
       **/
      parse: function() {
        if (this._maxElemsToParse > 0) {
          var numTags = this._doc.getElementsByTagName("*").length;
          if (numTags > this._maxElemsToParse) {
            throw new Error("Aborting parsing document; " + numTags + " elements found");
          }
        }
        this._unwrapNoscriptImages(this._doc);
        var jsonLd = this._disableJSONLD ? {} : this._getJSONLD(this._doc);
        this._removeScripts(this._doc);
        this._prepDocument();
        var metadata = this._getArticleMetadata(jsonLd);
        this._articleTitle = metadata.title;
        var articleContent = this._grabArticle();
        if (!articleContent)
          return null;
        this.log("Grabbed: " + articleContent.innerHTML);
        this._postProcessContent(articleContent);
        if (!metadata.excerpt) {
          var paragraphs = articleContent.getElementsByTagName("p");
          if (paragraphs.length > 0) {
            metadata.excerpt = paragraphs[0].textContent.trim();
          }
        }
        var textContent = articleContent.textContent;
        return {
          title: this._articleTitle,
          byline: metadata.byline || this._articleByline,
          dir: this._articleDir,
          lang: this._articleLang,
          content: this._serializer(articleContent),
          textContent,
          length: textContent.length,
          excerpt: metadata.excerpt,
          siteName: metadata.siteName || this._articleSiteName
        };
      }
    };
    if (typeof module2 === "object") {
      module2.exports = Readability2;
    }
  }
});

// node_modules/@mozilla/readability/Readability-readerable.js
var require_Readability_readerable = __commonJS({
  "node_modules/@mozilla/readability/Readability-readerable.js"(exports2, module2) {
    var REGEXPS = {
      // NOTE: These two regular expressions are duplicated in
      // Readability.js. Please keep both copies in sync.
      unlikelyCandidates: /-ad-|ai2html|banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|footer|gdpr|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote/i,
      okMaybeItsACandidate: /and|article|body|column|content|main|shadow/i
    };
    function isNodeVisible(node) {
      return (!node.style || node.style.display != "none") && !node.hasAttribute("hidden") && (!node.hasAttribute("aria-hidden") || node.getAttribute("aria-hidden") != "true" || node.className && node.className.indexOf && node.className.indexOf("fallback-image") !== -1);
    }
    function isProbablyReaderable(doc, options = {}) {
      if (typeof options == "function") {
        options = { visibilityChecker: options };
      }
      var defaultOptions2 = { minScore: 20, minContentLength: 140, visibilityChecker: isNodeVisible };
      options = Object.assign(defaultOptions2, options);
      var nodes = doc.querySelectorAll("p, pre, article");
      var brNodes = doc.querySelectorAll("div > br");
      if (brNodes.length) {
        var set = new Set(nodes);
        [].forEach.call(brNodes, function(node) {
          set.add(node.parentNode);
        });
        nodes = Array.from(set);
      }
      var score = 0;
      return [].some.call(nodes, function(node) {
        if (!options.visibilityChecker(node)) {
          return false;
        }
        var matchString = node.className + " " + node.id;
        if (REGEXPS.unlikelyCandidates.test(matchString) && !REGEXPS.okMaybeItsACandidate.test(matchString)) {
          return false;
        }
        if (node.matches("li p")) {
          return false;
        }
        var textContentLength = node.textContent.trim().length;
        if (textContentLength < options.minContentLength) {
          return false;
        }
        score += Math.sqrt(textContentLength - options.minContentLength);
        if (score > options.minScore) {
          return true;
        }
        return false;
      });
    }
    if (typeof module2 === "object") {
      module2.exports = isProbablyReaderable;
    }
  }
});

// node_modules/@mozilla/readability/index.js
var require_readability = __commonJS({
  "node_modules/@mozilla/readability/index.js"(exports2, module2) {
    var Readability2 = require_Readability();
    var isProbablyReaderable = require_Readability_readerable();
    module2.exports = {
      Readability: Readability2,
      isProbablyReaderable
    };
  }
});

// node_modules/unpdf/dist/pdfjs.mjs
var pdfjs_exports = {};
__export(pdfjs_exports, {
  resolvePDFJS: () => resolvePDFJS
});
function _mergeNamespaces(e3, t3) {
  for (var i3 = 0; i3 < t3.length; i3++) {
    const a3 = t3[i3];
    if ("string" != typeof a3 && !Array.isArray(a3)) {
      for (const t4 in a3) if ("default" !== t4 && !(t4 in e3)) {
        const i4 = Object.getOwnPropertyDescriptor(a3, t4);
        i4 && Object.defineProperty(e3, t4, i4.get ? i4 : { enumerable: true, get: function() {
          return a3[t4];
        } });
      }
    }
  }
  return Object.freeze(e3);
}
function createNotImplementedError(e3) {
  throw new Error(`[unenv] ${e3} is not implemented yet!`);
}
function notImplemented(e3) {
  return Object.assign(() => {
    throw createNotImplementedError(e3);
  }, { __unenv__: true });
}
function notImplementedAsync(e3) {
  const t3 = notImplemented(e3);
  return t3.__promisify__ = () => notImplemented(e3 + ".__promisify__"), t3.native = t3, t3;
}
function callbackify(e3) {
  const fnc = function(...t3) {
    const i3 = t3.pop();
    e3().catch((e4) => i3(e4)).then((e4) => i3(void 0, e4));
  };
  return fnc.__promisify__ = e3, fnc.native = fnc, fnc;
}
function _addListener(e3, t3, i3, a3) {
  _checkListener(i3), void 0 !== e3._events.newListener && e3.emit("newListener", t3, i3.listener || i3), e3._events[t3] || (e3._events[t3] = []), a3 ? e3._events[t3].unshift(i3) : e3._events[t3].push(i3);
  const s3 = _getMaxListeners(e3);
  if (s3 > 0 && e3._events[t3].length > s3 && !e3._events[t3].warned) {
    e3._events[t3].warned = true;
    const i4 = new Error(`[unenv] Possible EventEmitter memory leak detected. ${e3._events[t3].length} ${t3} listeners added. Use emitter.setMaxListeners() to increase limit`);
    i4.name = "MaxListenersExceededWarning", i4.emitter = e3, i4.type = t3, i4.count = e3._events[t3]?.length, console.warn(i4);
  }
  return e3;
}
function _wrapOnce(e3, t3, i3) {
  let a3 = false;
  const wrapper = (...s3) => {
    if (!a3) return e3.removeListener(t3, wrapper), a3 = true, 0 === s3.length ? i3.call(e3) : i3.apply(e3, s3);
  };
  return wrapper.listener = i3, wrapper;
}
function _getMaxListeners(e3) {
  return e3._maxListeners ?? Ut.defaultMaxListeners;
}
function _listeners(e3, t3, i3) {
  let a3 = e3._events[t3];
  return "function" == typeof a3 && (a3 = [a3]), i3 ? a3.map((e4) => e4.listener || e4) : a3;
}
function _checkListener(e3) {
  if ("function" != typeof e3) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e3);
}
function toByteArray(e3) {
  let t3;
  const i3 = function(e4) {
    const t4 = e4.length;
    if (t4 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    let i4 = e4.indexOf("=");
    return -1 === i4 && (i4 = t4), [i4, i4 === t4 ? 0 : 4 - i4 % 4];
  }(e3), a3 = i3[0], s3 = i3[1], n3 = new Pt(function(e4, t4, i4) {
    return 3 * (t4 + i4) / 4 - i4;
  }(0, a3, s3));
  let r3 = 0;
  const o3 = s3 > 0 ? a3 - 4 : a3;
  let g3;
  for (g3 = 0; g3 < o3; g3 += 4) t3 = Yt[e3.charCodeAt(g3)] << 18 | Yt[e3.charCodeAt(g3 + 1)] << 12 | Yt[e3.charCodeAt(g3 + 2)] << 6 | Yt[e3.charCodeAt(g3 + 3)], n3[r3++] = t3 >> 16 & 255, n3[r3++] = t3 >> 8 & 255, n3[r3++] = 255 & t3;
  return 2 === s3 && (t3 = Yt[e3.charCodeAt(g3)] << 2 | Yt[e3.charCodeAt(g3 + 1)] >> 4, n3[r3++] = 255 & t3), 1 === s3 && (t3 = Yt[e3.charCodeAt(g3)] << 10 | Yt[e3.charCodeAt(g3 + 1)] << 4 | Yt[e3.charCodeAt(g3 + 2)] >> 2, n3[r3++] = t3 >> 8 & 255, n3[r3++] = 255 & t3), n3;
}
function encodeChunk(e3, t3, i3) {
  let a3;
  const s3 = [];
  for (let r3 = t3; r3 < i3; r3 += 3) a3 = (e3[r3] << 16 & 16711680) + (e3[r3 + 1] << 8 & 65280) + (255 & e3[r3 + 2]), s3.push(Jt[(n3 = a3) >> 18 & 63] + Jt[n3 >> 12 & 63] + Jt[n3 >> 6 & 63] + Jt[63 & n3]);
  var n3;
  return s3.join("");
}
function fromByteArray(e3) {
  let t3;
  const i3 = e3.length, a3 = i3 % 3, s3 = [], n3 = 16383;
  for (let t4 = 0, r3 = i3 - a3; t4 < r3; t4 += n3) s3.push(encodeChunk(e3, t4, t4 + n3 > r3 ? r3 : t4 + n3));
  return 1 === a3 ? (t3 = e3[i3 - 1], s3.push(Jt[t3 >> 2] + Jt[t3 << 4 & 63] + "==")) : 2 === a3 && (t3 = (e3[i3 - 2] << 8) + e3[i3 - 1], s3.push(Jt[t3 >> 10] + Jt[t3 >> 4 & 63] + Jt[t3 << 2 & 63] + "=")), s3.join("");
}
function read(e3, t3, i3, a3, s3) {
  let n3, r3;
  const o3 = 8 * s3 - a3 - 1, g3 = (1 << o3) - 1, c3 = g3 >> 1;
  let h3 = -7, l3 = i3 ? s3 - 1 : 0;
  const C3 = i3 ? -1 : 1;
  let d3 = e3[t3 + l3];
  for (l3 += C3, n3 = d3 & (1 << -h3) - 1, d3 >>= -h3, h3 += o3; h3 > 0; ) n3 = 256 * n3 + e3[t3 + l3], l3 += C3, h3 -= 8;
  for (r3 = n3 & (1 << -h3) - 1, n3 >>= -h3, h3 += a3; h3 > 0; ) r3 = 256 * r3 + e3[t3 + l3], l3 += C3, h3 -= 8;
  if (0 === n3) n3 = 1 - c3;
  else {
    if (n3 === g3) return r3 ? Number.NaN : (d3 ? -1 : 1) * Number.POSITIVE_INFINITY;
    r3 += Math.pow(2, a3), n3 -= c3;
  }
  return (d3 ? -1 : 1) * r3 * Math.pow(2, n3 - a3);
}
function write(e3, t3, i3, a3, s3, n3) {
  let r3, o3, g3, c3 = 8 * n3 - s3 - 1;
  const h3 = (1 << c3) - 1, l3 = h3 >> 1, C3 = 23 === s3 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  let d3 = a3 ? 0 : n3 - 1;
  const u3 = a3 ? 1 : -1, Q3 = t3 < 0 || 0 === t3 && 1 / t3 < 0 ? 1 : 0;
  for (t3 = Math.abs(t3), Number.isNaN(t3) || t3 === Number.POSITIVE_INFINITY ? (o3 = Number.isNaN(t3) ? 1 : 0, r3 = h3) : (r3 = Math.floor(Math.log2(t3)), t3 * (g3 = Math.pow(2, -r3)) < 1 && (r3--, g3 *= 2), (t3 += r3 + l3 >= 1 ? C3 / g3 : C3 * Math.pow(2, 1 - l3)) * g3 >= 2 && (r3++, g3 /= 2), r3 + l3 >= h3 ? (o3 = 0, r3 = h3) : r3 + l3 >= 1 ? (o3 = (t3 * g3 - 1) * Math.pow(2, s3), r3 += l3) : (o3 = t3 * Math.pow(2, l3 - 1) * Math.pow(2, s3), r3 = 0)); s3 >= 8; ) e3[i3 + d3] = 255 & o3, d3 += u3, o3 /= 256, s3 -= 8;
  for (r3 = r3 << s3 | o3, c3 += s3; c3 > 0; ) e3[i3 + d3] = 255 & r3, d3 += u3, r3 /= 256, c3 -= 8;
  e3[i3 + d3 - u3] |= 128 * Q3;
}
function createBuffer(e3) {
  if (e3 > qt) throw new RangeError('The value "' + e3 + '" is invalid for option "size"');
  const t3 = new Uint8Array(e3);
  return Object.setPrototypeOf(t3, Buffer$1.prototype), t3;
}
function Buffer$1(e3, t3, i3) {
  if ("number" == typeof e3) {
    if ("string" == typeof t3) throw new TypeError('The "string" argument must be of type string. Received type number');
    return allocUnsafe(e3);
  }
  return from(e3, t3, i3);
}
function from(e3, t3, i3) {
  if ("string" == typeof e3) return function(e4, t4) {
    "string" == typeof t4 && "" !== t4 || (t4 = "utf8");
    if (!Buffer$1.isEncoding(t4)) throw new TypeError("Unknown encoding: " + t4);
    const i4 = 0 | byteLength(e4, t4);
    let a4 = createBuffer(i4);
    const s4 = a4.write(e4, t4);
    s4 !== i4 && (a4 = a4.slice(0, s4));
    return a4;
  }(e3, t3);
  if (ArrayBuffer.isView(e3)) return function(e4) {
    if (isInstance(e4, Uint8Array)) {
      const t4 = new Uint8Array(e4);
      return fromArrayBuffer(t4.buffer, t4.byteOffset, t4.byteLength);
    }
    return fromArrayLike(e4);
  }(e3);
  if (null == e3) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e3);
  if (isInstance(e3, ArrayBuffer) || e3 && isInstance(e3.buffer, ArrayBuffer)) return fromArrayBuffer(e3, t3, i3);
  if ("undefined" != typeof SharedArrayBuffer && (isInstance(e3, SharedArrayBuffer) || e3 && isInstance(e3.buffer, SharedArrayBuffer))) return fromArrayBuffer(e3, t3, i3);
  if ("number" == typeof e3) throw new TypeError('The "value" argument must not be of type number. Received type number');
  const a3 = e3.valueOf && e3.valueOf();
  if (null != a3 && a3 !== e3) return Buffer$1.from(a3, t3, i3);
  const s3 = function(e4) {
    if (Buffer$1.isBuffer(e4)) {
      const t4 = 0 | checked(e4.length), i4 = createBuffer(t4);
      return 0 === i4.length || e4.copy(i4, 0, 0, t4), i4;
    }
    if (void 0 !== e4.length) return "number" != typeof e4.length || numberIsNaN(e4.length) ? createBuffer(0) : fromArrayLike(e4);
    if ("Buffer" === e4.type && Array.isArray(e4.data)) return fromArrayLike(e4.data);
  }(e3);
  if (s3) return s3;
  if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e3[Symbol.toPrimitive]) return Buffer$1.from(e3[Symbol.toPrimitive]("string"), t3, i3);
  throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e3);
}
function assertSize(e3) {
  if ("number" != typeof e3) throw new TypeError('"size" argument must be of type number');
  if (e3 < 0) throw new RangeError('The value "' + e3 + '" is invalid for option "size"');
}
function allocUnsafe(e3) {
  return assertSize(e3), createBuffer(e3 < 0 ? 0 : 0 | checked(e3));
}
function fromArrayLike(e3) {
  const t3 = e3.length < 0 ? 0 : 0 | checked(e3.length), i3 = createBuffer(t3);
  for (let a3 = 0; a3 < t3; a3 += 1) i3[a3] = 255 & e3[a3];
  return i3;
}
function fromArrayBuffer(e3, t3, i3) {
  if (t3 < 0 || e3.byteLength < t3) throw new RangeError('"offset" is outside of buffer bounds');
  if (e3.byteLength < t3 + (i3 || 0)) throw new RangeError('"length" is outside of buffer bounds');
  let a3;
  return a3 = void 0 === t3 && void 0 === i3 ? new Uint8Array(e3) : void 0 === i3 ? new Uint8Array(e3, t3) : new Uint8Array(e3, t3, i3), Object.setPrototypeOf(a3, Buffer$1.prototype), a3;
}
function checked(e3) {
  if (e3 >= qt) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + qt.toString(16) + " bytes");
  return 0 | e3;
}
function byteLength(e3, t3) {
  if (Buffer$1.isBuffer(e3)) return e3.length;
  if (ArrayBuffer.isView(e3) || isInstance(e3, ArrayBuffer)) return e3.byteLength;
  if ("string" != typeof e3) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e3);
  const i3 = e3.length, a3 = arguments.length > 2 && true === arguments[2];
  if (!a3 && 0 === i3) return 0;
  let s3 = false;
  for (; ; ) switch (t3) {
    case "ascii":
    case "latin1":
    case "binary":
      return i3;
    case "utf8":
    case "utf-8":
      return utf8ToBytes(e3).length;
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return 2 * i3;
    case "hex":
      return i3 >>> 1;
    case "base64":
      return base64ToBytes(e3).length;
    default:
      if (s3) return a3 ? -1 : utf8ToBytes(e3).length;
      t3 = ("" + t3).toLowerCase(), s3 = true;
  }
}
function slowToString(e3, t3, i3) {
  let a3 = false;
  if ((void 0 === t3 || t3 < 0) && (t3 = 0), t3 > this.length) return "";
  if ((void 0 === i3 || i3 > this.length) && (i3 = this.length), i3 <= 0) return "";
  if ((i3 >>>= 0) <= (t3 >>>= 0)) return "";
  for (e3 || (e3 = "utf8"); ; ) switch (e3) {
    case "hex":
      return hexSlice(this, t3, i3);
    case "utf8":
    case "utf-8":
      return utf8Slice(this, t3, i3);
    case "ascii":
      return asciiSlice(this, t3, i3);
    case "latin1":
    case "binary":
      return latin1Slice(this, t3, i3);
    case "base64":
      return base64Slice(this, t3, i3);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return utf16leSlice(this, t3, i3);
    default:
      if (a3) throw new TypeError("Unknown encoding: " + e3);
      e3 = (e3 + "").toLowerCase(), a3 = true;
  }
}
function swap(e3, t3, i3) {
  const a3 = e3[t3];
  e3[t3] = e3[i3], e3[i3] = a3;
}
function bidirectionalIndexOf(e3, t3, i3, a3, s3) {
  if (0 === e3.length) return -1;
  if ("string" == typeof i3 ? (a3 = i3, i3 = 0) : i3 > 2147483647 ? i3 = 2147483647 : i3 < -2147483648 && (i3 = -2147483648), numberIsNaN(i3 = +i3) && (i3 = s3 ? 0 : e3.length - 1), i3 < 0 && (i3 = e3.length + i3), i3 >= e3.length) {
    if (s3) return -1;
    i3 = e3.length - 1;
  } else if (i3 < 0) {
    if (!s3) return -1;
    i3 = 0;
  }
  if ("string" == typeof t3 && (t3 = Buffer$1.from(t3, a3)), Buffer$1.isBuffer(t3)) return 0 === t3.length ? -1 : arrayIndexOf(e3, t3, i3, a3, s3);
  if ("number" == typeof t3) return t3 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? s3 ? Uint8Array.prototype.indexOf.call(e3, t3, i3) : Uint8Array.prototype.lastIndexOf.call(e3, t3, i3) : arrayIndexOf(e3, [t3], i3, a3, s3);
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(e3, t3, i3, a3, s3) {
  let n3, r3 = 1, o3 = e3.length, g3 = t3.length;
  if (void 0 !== a3 && ("ucs2" === (a3 = String(a3).toLowerCase()) || "ucs-2" === a3 || "utf16le" === a3 || "utf-16le" === a3)) {
    if (e3.length < 2 || t3.length < 2) return -1;
    r3 = 2, o3 /= 2, g3 /= 2, i3 /= 2;
  }
  function read2(e4, t4) {
    return 1 === r3 ? e4[t4] : e4.readUInt16BE(t4 * r3);
  }
  if (s3) {
    let a4 = -1;
    for (n3 = i3; n3 < o3; n3++) if (read2(e3, n3) === read2(t3, -1 === a4 ? 0 : n3 - a4)) {
      if (-1 === a4 && (a4 = n3), n3 - a4 + 1 === g3) return a4 * r3;
    } else -1 !== a4 && (n3 -= n3 - a4), a4 = -1;
  } else for (i3 + g3 > o3 && (i3 = o3 - g3), n3 = i3; n3 >= 0; n3--) {
    let i4 = true;
    for (let a4 = 0; a4 < g3; a4++) if (read2(e3, n3 + a4) !== read2(t3, a4)) {
      i4 = false;
      break;
    }
    if (i4) return n3;
  }
  return -1;
}
function hexWrite(e3, t3, i3, a3) {
  i3 = Number(i3) || 0;
  const s3 = e3.length - i3;
  a3 ? (a3 = Number(a3)) > s3 && (a3 = s3) : a3 = s3;
  const n3 = t3.length;
  let r3;
  for (a3 > n3 / 2 && (a3 = n3 / 2), r3 = 0; r3 < a3; ++r3) {
    const a4 = Number.parseInt(t3.slice(2 * r3, 2 * r3 + 2), 16);
    if (numberIsNaN(a4)) return r3;
    e3[i3 + r3] = a4;
  }
  return r3;
}
function utf8Write(e3, t3, i3, a3) {
  return blitBuffer(utf8ToBytes(t3, e3.length - i3), e3, i3, a3);
}
function asciiWrite(e3, t3, i3, a3) {
  return blitBuffer(function(e4) {
    const t4 = [];
    for (let i4 = 0; i4 < e4.length; ++i4) t4.push(255 & e4.charCodeAt(i4));
    return t4;
  }(t3), e3, i3, a3);
}
function base64Write(e3, t3, i3, a3) {
  return blitBuffer(base64ToBytes(t3), e3, i3, a3);
}
function ucs2Write(e3, t3, i3, a3) {
  return blitBuffer(function(e4, t4) {
    let i4, a4, s3;
    const n3 = [];
    for (let r3 = 0; r3 < e4.length && !((t4 -= 2) < 0); ++r3) i4 = e4.charCodeAt(r3), a4 = i4 >> 8, s3 = i4 % 256, n3.push(s3, a4);
    return n3;
  }(t3, e3.length - i3), e3, i3, a3);
}
function base64Slice(e3, t3, i3) {
  return 0 === t3 && i3 === e3.length ? fromByteArray(e3) : fromByteArray(e3.slice(t3, i3));
}
function utf8Slice(e3, t3, i3) {
  i3 = Math.min(e3.length, i3);
  const a3 = [];
  let s3 = t3;
  for (; s3 < i3; ) {
    const t4 = e3[s3];
    let n3 = null, r3 = t4 > 239 ? 4 : t4 > 223 ? 3 : t4 > 191 ? 2 : 1;
    if (s3 + r3 <= i3) {
      let i4, a4, o3, g3;
      switch (r3) {
        case 1:
          t4 < 128 && (n3 = t4);
          break;
        case 2:
          i4 = e3[s3 + 1], 128 == (192 & i4) && (g3 = (31 & t4) << 6 | 63 & i4, g3 > 127 && (n3 = g3));
          break;
        case 3:
          i4 = e3[s3 + 1], a4 = e3[s3 + 2], 128 == (192 & i4) && 128 == (192 & a4) && (g3 = (15 & t4) << 12 | (63 & i4) << 6 | 63 & a4, g3 > 2047 && (g3 < 55296 || g3 > 57343) && (n3 = g3));
          break;
        case 4:
          i4 = e3[s3 + 1], a4 = e3[s3 + 2], o3 = e3[s3 + 3], 128 == (192 & i4) && 128 == (192 & a4) && 128 == (192 & o3) && (g3 = (15 & t4) << 18 | (63 & i4) << 12 | (63 & a4) << 6 | 63 & o3, g3 > 65535 && g3 < 1114112 && (n3 = g3));
      }
    }
    null === n3 ? (n3 = 65533, r3 = 1) : n3 > 65535 && (n3 -= 65536, a3.push(n3 >>> 10 & 1023 | 55296), n3 = 56320 | 1023 & n3), a3.push(n3), s3 += r3;
  }
  return function(e4) {
    const t4 = e4.length;
    if (t4 <= _t) return String.fromCharCode.apply(String, e4);
    let i4 = "", a4 = 0;
    for (; a4 < t4; ) i4 += String.fromCharCode.apply(String, e4.slice(a4, a4 += _t));
    return i4;
  }(a3);
}
function asciiSlice(e3, t3, i3) {
  let a3 = "";
  i3 = Math.min(e3.length, i3);
  for (let s3 = t3; s3 < i3; ++s3) a3 += String.fromCharCode(127 & e3[s3]);
  return a3;
}
function latin1Slice(e3, t3, i3) {
  let a3 = "";
  i3 = Math.min(e3.length, i3);
  for (let s3 = t3; s3 < i3; ++s3) a3 += String.fromCharCode(e3[s3]);
  return a3;
}
function hexSlice(e3, t3, i3) {
  const a3 = e3.length;
  (!t3 || t3 < 0) && (t3 = 0), (!i3 || i3 < 0 || i3 > a3) && (i3 = a3);
  let s3 = "";
  for (let a4 = t3; a4 < i3; ++a4) s3 += Xt[e3[a4]];
  return s3;
}
function utf16leSlice(e3, t3, i3) {
  const a3 = e3.slice(t3, i3);
  let s3 = "";
  for (let e4 = 0; e4 < a3.length - 1; e4 += 2) s3 += String.fromCharCode(a3[e4] + 256 * a3[e4 + 1]);
  return s3;
}
function checkOffset(e3, t3, i3) {
  if (e3 % 1 != 0 || e3 < 0) throw new RangeError("offset is not uint");
  if (e3 + t3 > i3) throw new RangeError("Trying to access beyond buffer length");
}
function checkInt(e3, t3, i3, a3, s3, n3) {
  if (!Buffer$1.isBuffer(e3)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (t3 > s3 || t3 < n3) throw new RangeError('"value" argument is out of bounds');
  if (i3 + a3 > e3.length) throw new RangeError("Index out of range");
}
function wrtBigUInt64LE(e3, t3, i3, a3, s3) {
  checkIntBI(t3, a3, s3, e3, i3, 7);
  let n3 = Number(t3 & BigInt(4294967295));
  e3[i3++] = n3, n3 >>= 8, e3[i3++] = n3, n3 >>= 8, e3[i3++] = n3, n3 >>= 8, e3[i3++] = n3;
  let r3 = Number(t3 >> BigInt(32) & BigInt(4294967295));
  return e3[i3++] = r3, r3 >>= 8, e3[i3++] = r3, r3 >>= 8, e3[i3++] = r3, r3 >>= 8, e3[i3++] = r3, i3;
}
function wrtBigUInt64BE(e3, t3, i3, a3, s3) {
  checkIntBI(t3, a3, s3, e3, i3, 7);
  let n3 = Number(t3 & BigInt(4294967295));
  e3[i3 + 7] = n3, n3 >>= 8, e3[i3 + 6] = n3, n3 >>= 8, e3[i3 + 5] = n3, n3 >>= 8, e3[i3 + 4] = n3;
  let r3 = Number(t3 >> BigInt(32) & BigInt(4294967295));
  return e3[i3 + 3] = r3, r3 >>= 8, e3[i3 + 2] = r3, r3 >>= 8, e3[i3 + 1] = r3, r3 >>= 8, e3[i3] = r3, i3 + 8;
}
function checkIEEE754(e3, t3, i3, a3, s3, n3) {
  if (i3 + a3 > e3.length) throw new RangeError("Index out of range");
  if (i3 < 0) throw new RangeError("Index out of range");
}
function writeFloat(e3, t3, i3, a3, s3) {
  return t3 = +t3, i3 >>>= 0, s3 || checkIEEE754(e3, 0, i3, 4), write(e3, t3, i3, a3, 23, 4), i3 + 4;
}
function writeDouble(e3, t3, i3, a3, s3) {
  return t3 = +t3, i3 >>>= 0, s3 || checkIEEE754(e3, 0, i3, 8), write(e3, t3, i3, a3, 52, 8), i3 + 8;
}
function E(e3, t3, i3) {
  Wt[e3] = class extends i3 {
    constructor() {
      super(), Object.defineProperty(this, "message", { value: Reflect.apply(t3, this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e3}]`, this.stack, delete this.name;
    }
    get code() {
      return e3;
    }
    set code(e4) {
      Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: e4, writable: true });
    }
    toString() {
      return `${this.name} [${e3}]: ${this.message}`;
    }
  };
}
function addNumericalSeparator(e3) {
  let t3 = "", i3 = e3.length;
  const a3 = "-" === e3[0] ? 1 : 0;
  for (; i3 >= a3 + 4; i3 -= 3) t3 = `_${e3.slice(i3 - 3, i3)}${t3}`;
  return `${e3.slice(0, i3)}${t3}`;
}
function checkIntBI(e3, t3, i3, a3, s3, n3) {
  if (e3 > i3 || e3 < t3) {
    const i4 = "bigint" == typeof t3 ? "n" : "";
    let a4;
    throw a4 = 0 === t3 || t3 === BigInt(0) ? `>= 0${i4} and < 2${i4} ** ${8 * (n3 + 1)}${i4}` : `>= -(2${i4} ** ${8 * (n3 + 1) - 1}${i4}) and < 2 ** ${8 * (n3 + 1) - 1}${i4}`, new Wt.ERR_OUT_OF_RANGE("value", a4, e3);
  }
  !function(e4, t4, i4) {
    validateNumber(t4, "offset"), void 0 !== e4[t4] && void 0 !== e4[t4 + i4] || boundsError(t4, e4.length - (i4 + 1));
  }(a3, s3, n3);
}
function validateNumber(e3, t3) {
  if ("number" != typeof e3) throw new Wt.ERR_INVALID_ARG_TYPE(t3, "number", e3);
}
function boundsError(e3, t3, i3) {
  if (Math.floor(e3) !== e3) throw validateNumber(e3, i3), new Wt.ERR_OUT_OF_RANGE("offset", "an integer", e3);
  if (t3 < 0) throw new Wt.ERR_BUFFER_OUT_OF_BOUNDS();
  throw new Wt.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${t3}`, e3);
}
function utf8ToBytes(e3, t3) {
  let i3;
  t3 = t3 || Number.POSITIVE_INFINITY;
  const a3 = e3.length;
  let s3 = null;
  const n3 = [];
  for (let r3 = 0; r3 < a3; ++r3) {
    if (i3 = e3.charCodeAt(r3), i3 > 55295 && i3 < 57344) {
      if (!s3) {
        if (i3 > 56319) {
          (t3 -= 3) > -1 && n3.push(239, 191, 189);
          continue;
        }
        if (r3 + 1 === a3) {
          (t3 -= 3) > -1 && n3.push(239, 191, 189);
          continue;
        }
        s3 = i3;
        continue;
      }
      if (i3 < 56320) {
        (t3 -= 3) > -1 && n3.push(239, 191, 189), s3 = i3;
        continue;
      }
      i3 = 65536 + (s3 - 55296 << 10 | i3 - 56320);
    } else s3 && (t3 -= 3) > -1 && n3.push(239, 191, 189);
    if (s3 = null, i3 < 128) {
      if ((t3 -= 1) < 0) break;
      n3.push(i3);
    } else if (i3 < 2048) {
      if ((t3 -= 2) < 0) break;
      n3.push(i3 >> 6 | 192, 63 & i3 | 128);
    } else if (i3 < 65536) {
      if ((t3 -= 3) < 0) break;
      n3.push(i3 >> 12 | 224, i3 >> 6 & 63 | 128, 63 & i3 | 128);
    } else {
      if (!(i3 < 1114112)) throw new Error("Invalid code point");
      if ((t3 -= 4) < 0) break;
      n3.push(i3 >> 18 | 240, i3 >> 12 & 63 | 128, i3 >> 6 & 63 | 128, 63 & i3 | 128);
    }
  }
  return n3;
}
function base64ToBytes(e3) {
  return toByteArray(function(e4) {
    if ((e4 = (e4 = e4.split("=")[0]).trim().replace(jt, "")).length < 2) return "";
    for (; e4.length % 4 != 0; ) e4 += "=";
    return e4;
  }(e3));
}
function blitBuffer(e3, t3, i3, a3) {
  let s3;
  for (s3 = 0; s3 < a3 && !(s3 + i3 >= t3.length || s3 >= e3.length); ++s3) t3[s3 + i3] = e3[s3];
  return s3;
}
function isInstance(e3, t3) {
  return e3 instanceof t3 || null != e3 && null != e3.constructor && null != e3.constructor.name && e3.constructor.name === t3.name;
}
function numberIsNaN(e3) {
  return e3 != e3;
}
function defineBigIntMethod(e3) {
  return "undefined" == typeof BigInt ? BufferBigIntNotDefined : e3;
}
function BufferBigIntNotDefined() {
  throw new Error("BigInt not supported");
}
function getDuplex() {
  return Object.assign(zt.prototype, Tt.prototype), Object.assign(zt.prototype, Zt.prototype), zt;
}
function _distinct(e3) {
  const t3 = {};
  for (const [i3, a3] of Object.entries(e3)) i3 && (t3[i3] = (Array.isArray(a3) ? a3 : [a3]).filter(Boolean));
  return t3;
}
function getDefaultExportFromCjs(e3) {
  return e3 && e3.__esModule && Object.prototype.hasOwnProperty.call(e3, "default") ? e3.default : e3;
}
function requireProxy() {
  if (CA) return dA.exports;
  CA = 1, Object.defineProperty(BA, "__esModule", { value: true });
  const fn2 = function() {
  };
  return dA.exports = function createMock2(e3, t3 = {}) {
    fn2.prototype.name = e3;
    const i3 = {};
    return new Proxy(fn2, { get: (a3, s3) => "caller" === s3 ? null : "__createMock__" === s3 ? createMock2 : "__unenv__" === s3 || (s3 in t3 ? t3[s3] : i3[s3] = i3[s3] || createMock2(`${e3}.${s3.toString()}`)), apply: (t4, i4, a3) => createMock2(`${e3}()`), construct: (t4, i4, a3) => createMock2(`[${e3}]`), enumerate: () => [] });
  }("mock"), dA.exports;
}
function getVerbosityLevel() {
  return Ns;
}
function info(e3) {
  Ns >= qi && console.log(`Info: ${e3}`);
}
function warn(e3) {
  Ns >= Ki && console.log(`Warning: ${e3}`);
}
function unreachable(e3) {
  throw new Error(e3);
}
function assert(e3, t3) {
  e3 || unreachable(t3);
}
function createValidAbsoluteUrl(e3, t3 = null, i3 = null) {
  if (!e3) return null;
  try {
    if (i3 && "string" == typeof e3) {
      if (i3.addDefaultProtocol && e3.startsWith("www.")) {
        const t4 = e3.match(/\./g);
        t4?.length >= 2 && (e3 = `http://${e3}`);
      }
      if (i3.tryConvertEncoding) try {
        e3 = stringToUTF8String(e3);
      } catch {
      }
    }
    const a3 = t3 ? new URL(e3, t3) : new URL(e3);
    if (function(e4) {
      switch (e4?.protocol) {
        case "http:":
        case "https:":
        case "ftp:":
        case "mailto:":
        case "tel:":
          return true;
        default:
          return false;
      }
    }(a3)) return a3;
  } catch {
  }
  return null;
}
function shadow(e3, t3, i3, a3 = false) {
  return Object.defineProperty(e3, t3, { value: i3, enumerable: !a3, configurable: true, writable: false }), i3;
}
function bytesToString(e3) {
  "object" == typeof e3 && void 0 !== e3?.length || unreachable("Invalid argument for bytesToString");
  const t3 = e3.length, i3 = 8192;
  if (t3 < i3) return String.fromCharCode.apply(null, e3);
  const a3 = [];
  for (let s3 = 0; s3 < t3; s3 += i3) {
    const n3 = Math.min(s3 + i3, t3), r3 = e3.subarray(s3, n3);
    a3.push(String.fromCharCode.apply(null, r3));
  }
  return a3.join("");
}
function stringToBytes(e3) {
  "string" != typeof e3 && unreachable("Invalid argument for stringToBytes");
  const t3 = e3.length, i3 = new Uint8Array(t3);
  for (let a3 = 0; a3 < t3; ++a3) i3[a3] = 255 & e3.charCodeAt(a3);
  return i3;
}
function string32(e3) {
  return String.fromCharCode(e3 >> 24 & 255, e3 >> 16 & 255, e3 >> 8 & 255, 255 & e3);
}
function objectSize(e3) {
  return Object.keys(e3).length;
}
function stringToPDFString(e3) {
  if (e3[0] >= "\xEF") {
    let t4;
    if ("\xFE" === e3[0] && "\xFF" === e3[1] ? (t4 = "utf-16be", e3.length % 2 == 1 && (e3 = e3.slice(0, -1))) : "\xFF" === e3[0] && "\xFE" === e3[1] ? (t4 = "utf-16le", e3.length % 2 == 1 && (e3 = e3.slice(0, -1))) : "\xEF" === e3[0] && "\xBB" === e3[1] && "\xBF" === e3[2] && (t4 = "utf-8"), t4) try {
      const i3 = new TextDecoder(t4, { fatal: true }), a3 = stringToBytes(e3), s3 = i3.decode(a3);
      return s3.includes("\x1B") ? s3.replaceAll(/\x1b[^\x1b]*(?:\x1b|$)/g, "") : s3;
    } catch (e4) {
      warn(`stringToPDFString: "${e4}".`);
    }
  }
  const t3 = [];
  for (let i3 = 0, a3 = e3.length; i3 < a3; i3++) {
    const s3 = e3.charCodeAt(i3);
    if (27 === s3) {
      for (; ++i3 < a3 && 27 !== e3.charCodeAt(i3); ) ;
      continue;
    }
    const n3 = vs[s3];
    t3.push(n3 ? String.fromCharCode(n3) : e3.charAt(i3));
  }
  return t3.join("");
}
function stringToUTF8String(e3) {
  return decodeURIComponent(escape(e3));
}
function utf8StringToString(e3) {
  return unescape(encodeURIComponent(e3));
}
function isArrayEqual(e3, t3) {
  if (e3.length !== t3.length) return false;
  for (let i3 = 0, a3 = e3.length; i3 < a3; i3++) if (e3[i3] !== t3[i3]) return false;
  return true;
}
function getModificationDate(e3 = /* @__PURE__ */ new Date()) {
  return [e3.getUTCFullYear().toString(), (e3.getUTCMonth() + 1).toString().padStart(2, "0"), e3.getUTCDate().toString().padStart(2, "0"), e3.getUTCHours().toString().padStart(2, "0"), e3.getUTCMinutes().toString().padStart(2, "0"), e3.getUTCSeconds().toString().padStart(2, "0")].join("");
}
function isName(e3, t3) {
  return e3 instanceof Name && (void 0 === t3 || e3.name === t3);
}
function isCmd(e3, t3) {
  return e3 instanceof Cmd && (void 0 === t3 || e3.cmd === t3);
}
function isDict(e3, t3) {
  return e3 instanceof Dict && (void 0 === t3 || isName(e3.get("Type"), t3));
}
function isRefsEqual(e3, t3) {
  return e3.num === t3.num && e3.gen === t3.gen;
}
function getLookupTableFactory(e3) {
  let t3;
  return function() {
    return e3 && (t3 = /* @__PURE__ */ Object.create(null), e3(t3), e3 = null), t3;
  };
}
function arrayBuffersToBytes(e3) {
  const t3 = e3.length;
  if (0 === t3) return new Uint8Array(0);
  if (1 === t3) return new Uint8Array(e3[0]);
  let i3 = 0;
  for (let a4 = 0; a4 < t3; a4++) i3 += e3[a4].byteLength;
  const a3 = new Uint8Array(i3);
  let s3 = 0;
  for (let i4 = 0; i4 < t3; i4++) {
    const t4 = new Uint8Array(e3[i4]);
    a3.set(t4, s3), s3 += t4.byteLength;
  }
  return a3;
}
function getInheritableProperty({ dict: e3, key: t3, getArray: i3 = false, stopWhenFound: a3 = true }) {
  let s3;
  const n3 = new RefSet();
  for (; e3 instanceof Dict && (!e3.objId || !n3.has(e3.objId)); ) {
    e3.objId && n3.put(e3.objId);
    const r3 = i3 ? e3.getArray(t3) : e3.get(t3);
    if (void 0 !== r3) {
      if (a3) return r3;
      (s3 || (s3 = [])).push(r3);
    }
    e3 = e3.get("Parent");
  }
  return s3;
}
function toRomanNumerals(e3, t3 = false) {
  assert(Number.isInteger(e3) && e3 > 0, "The number should be a positive integer.");
  const i3 = [];
  let a3;
  for (; e3 >= 1e3; ) e3 -= 1e3, i3.push("M");
  a3 = e3 / 100 | 0, e3 %= 100, i3.push(en[a3]), a3 = e3 / 10 | 0, e3 %= 10, i3.push(en[10 + a3]), i3.push(en[20 + e3]);
  const s3 = i3.join("");
  return t3 ? s3.toLowerCase() : s3;
}
function log2(e3) {
  return e3 <= 0 ? 0 : Math.ceil(Math.log2(e3));
}
function readInt8(e3, t3) {
  return e3[t3] << 24 >> 24;
}
function readUint16(e3, t3) {
  return e3[t3] << 8 | e3[t3 + 1];
}
function readUint32(e3, t3) {
  return (e3[t3] << 24 | e3[t3 + 1] << 16 | e3[t3 + 2] << 8 | e3[t3 + 3]) >>> 0;
}
function isWhiteSpace(e3) {
  return 32 === e3 || 9 === e3 || 13 === e3 || 10 === e3;
}
function isNumberArray(e3, t3) {
  return Array.isArray(e3) ? (null === t3 || e3.length === t3) && e3.every((e4) => "number" == typeof e4) : ArrayBuffer.isView(e3) && (0 === e3.length || "number" == typeof e3[0]) && (null === t3 || e3.length === t3);
}
function lookupMatrix(e3, t3) {
  return isNumberArray(e3, 6) ? e3 : t3;
}
function lookupRect(e3, t3) {
  return isNumberArray(e3, 4) ? e3 : t3;
}
function lookupNormalRect(e3, t3) {
  return isNumberArray(e3, 4) ? Util.normalizeRect(e3) : t3;
}
function parseXFAPath(e3) {
  const t3 = /(.+)\[(\d+)\]$/;
  return e3.split(".").map((e4) => {
    const i3 = e4.match(t3);
    return i3 ? { name: i3[1], pos: parseInt(i3[2], 10) } : { name: e4, pos: 0 };
  });
}
function escapePDFName(e3) {
  const t3 = [];
  let i3 = 0;
  for (let a3 = 0, s3 = e3.length; a3 < s3; a3++) {
    const s4 = e3.charCodeAt(a3);
    (s4 < 33 || s4 > 126 || 35 === s4 || 40 === s4 || 41 === s4 || 60 === s4 || 62 === s4 || 91 === s4 || 93 === s4 || 123 === s4 || 125 === s4 || 47 === s4 || 37 === s4) && (i3 < a3 && t3.push(e3.substring(i3, a3)), t3.push(`#${s4.toString(16)}`), i3 = a3 + 1);
  }
  return 0 === t3.length ? e3 : (i3 < e3.length && t3.push(e3.substring(i3, e3.length)), t3.join(""));
}
function escapeString(e3) {
  return e3.replaceAll(/([()\\\n\r])/g, (e4) => "\n" === e4 ? "\\n" : "\r" === e4 ? "\\r" : `\\${e4}`);
}
function _collectJS(e3, t3, i3, a3) {
  if (!e3) return;
  let s3 = null;
  if (e3 instanceof Ref) {
    if (a3.has(e3)) return;
    s3 = e3, a3.put(s3), e3 = t3.fetch(e3);
  }
  if (Array.isArray(e3)) for (const s4 of e3) _collectJS(s4, t3, i3, a3);
  else if (e3 instanceof Dict) {
    if (isName(e3.get("S"), "JavaScript")) {
      const t4 = e3.get("JS");
      let a4;
      t4 instanceof BaseStream ? a4 = t4.getString() : "string" == typeof t4 && (a4 = t4), a4 && (a4 = stringToPDFString(a4).replaceAll("\0", "")), a4 && i3.push(a4);
    }
    _collectJS(e3.getRaw("Next"), t3, i3, a3);
  }
  s3 && a3.remove(s3);
}
function collectActions(e3, t3, i3) {
  const a3 = /* @__PURE__ */ Object.create(null), s3 = getInheritableProperty({ dict: t3, key: "AA", stopWhenFound: false });
  if (s3) for (let t4 = s3.length - 1; t4 >= 0; t4--) {
    const n3 = s3[t4];
    if (n3 instanceof Dict) for (const t5 of n3.getKeys()) {
      const s4 = i3[t5];
      if (!s4) continue;
      const r3 = [];
      _collectJS(n3.getRaw(t5), e3, r3, new RefSet()), r3.length > 0 && (a3[s4] = r3);
    }
  }
  if (t3.has("A")) {
    const i4 = [];
    _collectJS(t3.get("A"), e3, i4, new RefSet()), i4.length > 0 && (a3.Action = i4);
  }
  return objectSize(a3) > 0 ? a3 : null;
}
function* codePointIter(e3) {
  for (let t3 = 0, i3 = e3.length; t3 < i3; t3++) {
    const i4 = e3.codePointAt(t3);
    i4 > 55295 && (i4 < 57344 || i4 > 65533) && t3++, yield i4;
  }
}
function encodeToXmlString(e3) {
  const t3 = [];
  let i3 = 0;
  for (let a3 = 0, s3 = e3.length; a3 < s3; a3++) {
    const s4 = e3.codePointAt(a3);
    if (32 <= s4 && s4 <= 126) {
      const n3 = tn[s4];
      n3 && (i3 < a3 && t3.push(e3.substring(i3, a3)), t3.push(n3), i3 = a3 + 1);
    } else i3 < a3 && t3.push(e3.substring(i3, a3)), t3.push(`&#x${s4.toString(16).toUpperCase()};`), s4 > 55295 && (s4 < 57344 || s4 > 65533) && a3++, i3 = a3 + 1;
  }
  return 0 === t3.length ? e3 : (i3 < e3.length && t3.push(e3.substring(i3, e3.length)), t3.join(""));
}
function validateFontName(e3, t3 = false) {
  const i3 = /^("|').*("|')$/.exec(e3);
  if (i3 && i3[1] === i3[2]) {
    if (new RegExp(`[^\\\\]${i3[1]}`).test(e3.slice(1, -1))) return t3 && warn(`FontFamily contains unescaped ${i3[1]}: ${e3}.`), false;
  } else for (const i4 of e3.split(/[ \t]+/)) if (/^(\d|(-(\d|-)))/.test(i4) || !/^[\w-\\]+$/.test(i4)) return t3 && warn(`FontFamily contains invalid <custom-ident>: ${e3}.`), false;
  return true;
}
function validateCSSFont(e3) {
  const t3 = /* @__PURE__ */ new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900", "1000", "normal", "bold", "bolder", "lighter"]), { fontFamily: i3, fontWeight: a3, italicAngle: s3 } = e3;
  if (!validateFontName(i3, true)) return false;
  const n3 = a3 ? a3.toString() : "";
  e3.fontWeight = t3.has(n3) ? n3 : "400";
  const r3 = parseFloat(s3);
  return e3.italicAngle = isNaN(r3) || r3 < -90 || r3 > 90 ? "14" : s3.toString(), true;
}
function recoverJsURL(e3) {
  const t3 = new RegExp("^\\s*(" + ["app.launchURL", "window.open", "xfa.host.gotoURL"].join("|").replaceAll(".", "\\.") + `)\\((?:'|")([^'"]*)(?:'|")(?:,\\s*(\\w+)\\)|\\))`, "i").exec(e3);
  if (t3?.[2]) {
    const e4 = t3[2];
    let i3 = false;
    return "true" === t3[3] && "app.launchURL" === t3[1] && (i3 = true), { url: e4, newWindow: i3 };
  }
  return null;
}
function numberToString(e3) {
  if (Number.isInteger(e3)) return e3.toString();
  const t3 = Math.round(100 * e3);
  return t3 % 100 == 0 ? (t3 / 100).toString() : t3 % 10 == 0 ? e3.toFixed(1) : e3.toFixed(2);
}
function getNewAnnotationsMap(e3) {
  if (!e3) return null;
  const t3 = /* @__PURE__ */ new Map();
  for (const [i3, a3] of e3) {
    if (!i3.startsWith(TA)) continue;
    let e4 = t3.get(a3.pageIndex);
    e4 || (e4 = [], t3.set(a3.pageIndex, e4)), e4.push(a3);
  }
  return t3.size > 0 ? t3 : null;
}
function stringToAsciiOrUTF16BE(e3) {
  return function(e4) {
    return /^[\x00-\x7F]*$/.test(e4);
  }(e3) ? e3 : stringToUTF16String(e3, true);
}
function stringToUTF16HexString(e3) {
  const t3 = [];
  for (let i3 = 0, a3 = e3.length; i3 < a3; i3++) {
    const a4 = e3.charCodeAt(i3);
    t3.push((a4 >> 8 & 255).toString(16).padStart(2, "0"), (255 & a4).toString(16).padStart(2, "0"));
  }
  return t3.join("");
}
function stringToUTF16String(e3, t3 = false) {
  const i3 = [];
  t3 && i3.push("\xFE\xFF");
  for (let t4 = 0, a3 = e3.length; t4 < a3; t4++) {
    const a4 = e3.charCodeAt(t4);
    i3.push(String.fromCharCode(a4 >> 8 & 255), String.fromCharCode(255 & a4));
  }
  return i3.join("");
}
function getRotationMatrix(e3, t3, i3) {
  switch (e3) {
    case 90:
      return [0, 1, -1, 0, t3, 0];
    case 180:
      return [-1, 0, 0, -1, t3, i3];
    case 270:
      return [0, -1, 1, 0, 0, i3];
    default:
      throw new Error("Invalid rotation");
  }
}
function getSizeInBytes(e3) {
  return Math.ceil(Math.ceil(Math.log2(1 + e3)) / 8);
}
function hexToInt(e3, t3) {
  let i3 = 0;
  for (let a3 = 0; a3 <= t3; a3++) i3 = i3 << 8 | e3[a3];
  return i3 >>> 0;
}
function hexToStr(e3, t3) {
  return 1 === t3 ? String.fromCharCode(e3[0], e3[1]) : 3 === t3 ? String.fromCharCode(e3[0], e3[1], e3[2], e3[3]) : String.fromCharCode(...e3.subarray(0, t3 + 1));
}
function addHex(e3, t3, i3) {
  let a3 = 0;
  for (let s3 = i3; s3 >= 0; s3--) a3 += e3[s3] + t3[s3], e3[s3] = 255 & a3, a3 >>= 8;
}
function incHex(e3, t3) {
  let i3 = 1;
  for (let a3 = t3; a3 >= 0 && i3 > 0; a3--) i3 += e3[a3], e3[a3] = 255 & i3, i3 >>= 8;
}
function decodeInteger(e3, t3, i3) {
  const a3 = e3.getContexts(t3);
  let s3 = 1;
  function readBits(e4) {
    let t4 = 0;
    for (let n4 = 0; n4 < e4; n4++) {
      const e5 = i3.readBit(a3, s3);
      s3 = s3 < 256 ? s3 << 1 | e5 : 511 & (s3 << 1 | e5) | 256, t4 = t4 << 1 | e5;
    }
    return t4 >>> 0;
  }
  const n3 = readBits(1), r3 = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);
  let o3;
  return 0 === n3 ? o3 = r3 : r3 > 0 && (o3 = -r3), o3 >= -2147483648 && o3 <= 2147483647 ? o3 : null;
}
function decodeIAID(e3, t3, i3) {
  const a3 = e3.getContexts("IAID");
  let s3 = 1;
  for (let e4 = 0; e4 < i3; e4++) {
    s3 = s3 << 1 | t3.readBit(a3, s3);
  }
  return i3 < 31 ? s3 & (1 << i3) - 1 : 2147483647 & s3;
}
function decodeBitmap(e3, t3, i3, a3, s3, n3, r3, o3) {
  if (e3) {
    return decodeMMRBitmap(new Reader(o3.data, o3.start, o3.end), t3, i3, false);
  }
  if (0 === a3 && !n3 && !s3 && 4 === r3.length && 3 === r3[0].x && -1 === r3[0].y && -3 === r3[1].x && -1 === r3[1].y && 2 === r3[2].x && -2 === r3[2].y && -2 === r3[3].x && -2 === r3[3].y) return function(e4, t4, i4) {
    const a4 = i4.decoder, s4 = i4.contextCache.getContexts("GB"), n4 = [];
    let r4, o4, g4, c4, h4, l4, C4;
    for (o4 = 0; o4 < t4; o4++) for (h4 = n4[o4] = new Uint8Array(e4), l4 = o4 < 1 ? h4 : n4[o4 - 1], C4 = o4 < 2 ? h4 : n4[o4 - 2], r4 = C4[0] << 13 | C4[1] << 12 | C4[2] << 11 | l4[0] << 7 | l4[1] << 6 | l4[2] << 5 | l4[3] << 4, g4 = 0; g4 < e4; g4++) h4[g4] = c4 = a4.readBit(s4, r4), r4 = (31735 & r4) << 1 | (g4 + 3 < e4 ? C4[g4 + 3] << 11 : 0) | (g4 + 4 < e4 ? l4[g4 + 4] << 4 : 0) | c4;
    return n4;
  }(t3, i3, o3);
  const g3 = En[a3].concat(r3);
  g3.sort(function(e4, t4) {
    return e4.y - t4.y || e4.x - t4.x;
  });
  const c3 = g3.length, h3 = new Int8Array(c3), l3 = new Int8Array(c3), C3 = [];
  let d3, u3, Q3 = 0, f3 = 0, p3 = 0, m3 = 0;
  for (u3 = 0; u3 < c3; u3++) h3[u3] = g3[u3].x, l3[u3] = g3[u3].y, f3 = Math.min(f3, g3[u3].x), p3 = Math.max(p3, g3[u3].x), m3 = Math.min(m3, g3[u3].y), u3 < c3 - 1 && g3[u3].y === g3[u3 + 1].y && g3[u3].x === g3[u3 + 1].x - 1 ? Q3 |= 1 << c3 - 1 - u3 : C3.push(u3);
  const y3 = C3.length, w3 = new Int8Array(y3), b3 = new Int8Array(y3), D3 = new Uint16Array(y3);
  for (d3 = 0; d3 < y3; d3++) u3 = C3[d3], w3[d3] = g3[u3].x, b3[d3] = g3[u3].y, D3[d3] = 1 << c3 - 1 - u3;
  const S3 = -f3, F3 = -m3, k3 = t3 - p3, R3 = mn[a3];
  let x3 = new Uint8Array(t3);
  const N3 = [], M3 = o3.decoder, G3 = o3.contextCache.getContexts("GB");
  let v3, L3, U3, H3, T3, J3 = 0, Y3 = 0;
  for (let e4 = 0; e4 < i3; e4++) {
    if (s3) {
      if (J3 ^= M3.readBit(G3, R3), J3) {
        N3.push(x3);
        continue;
      }
    }
    for (x3 = new Uint8Array(x3), N3.push(x3), v3 = 0; v3 < t3; v3++) {
      if (v3 >= S3 && v3 < k3 && e4 >= F3) for (Y3 = Y3 << 1 & Q3, u3 = 0; u3 < y3; u3++) L3 = e4 + b3[u3], U3 = v3 + w3[u3], H3 = N3[L3][U3], H3 && (H3 = D3[u3], Y3 |= H3);
      else for (Y3 = 0, T3 = c3 - 1, u3 = 0; u3 < c3; u3++, T3--) U3 = v3 + h3[u3], U3 >= 0 && U3 < t3 && (L3 = e4 + l3[u3], L3 >= 0 && (H3 = N3[L3][U3], H3 && (Y3 |= H3 << T3)));
      const i4 = M3.readBit(G3, Y3);
      x3[v3] = i4;
    }
  }
  return N3;
}
function decodeRefinement(e3, t3, i3, a3, s3, n3, r3, o3, g3) {
  let c3 = pn[i3].coding;
  0 === i3 && (c3 = c3.concat([o3[0]]));
  const h3 = c3.length, l3 = new Int32Array(h3), C3 = new Int32Array(h3);
  let d3;
  for (d3 = 0; d3 < h3; d3++) l3[d3] = c3[d3].x, C3[d3] = c3[d3].y;
  let u3 = pn[i3].reference;
  0 === i3 && (u3 = u3.concat([o3[1]]));
  const Q3 = u3.length, f3 = new Int32Array(Q3), p3 = new Int32Array(Q3);
  for (d3 = 0; d3 < Q3; d3++) f3[d3] = u3[d3].x, p3[d3] = u3[d3].y;
  const m3 = a3[0].length, y3 = a3.length, w3 = [], b3 = g3.decoder, D3 = g3.contextCache.getContexts("GR");
  for (let i4 = 0; i4 < t3; i4++) {
    const t4 = new Uint8Array(e3);
    w3.push(t4);
    for (let r4 = 0; r4 < e3; r4++) {
      let o4, g4, c4 = 0;
      for (d3 = 0; d3 < h3; d3++) o4 = i4 + C3[d3], g4 = r4 + l3[d3], o4 < 0 || g4 < 0 || g4 >= e3 ? c4 <<= 1 : c4 = c4 << 1 | w3[o4][g4];
      for (d3 = 0; d3 < Q3; d3++) o4 = i4 + p3[d3] - n3, g4 = r4 + f3[d3] - s3, o4 < 0 || o4 >= y3 || g4 < 0 || g4 >= m3 ? c4 <<= 1 : c4 = c4 << 1 | a3[o4][g4];
      const u4 = b3.readBit(D3, c4);
      t4[r4] = u4;
    }
  }
  return w3;
}
function decodeTextRegion(e3, t3, i3, a3, s3, n3, r3, o3, g3, c3, h3, l3, C3, d3, u3, Q3, f3, p3, m3) {
  if (e3 && t3) throw new Jbig2Error("refinement with Huffman is not supported");
  const y3 = [];
  let w3, b3;
  for (w3 = 0; w3 < a3; w3++) {
    if (b3 = new Uint8Array(i3), s3) for (let e4 = 0; e4 < i3; e4++) b3[e4] = s3;
    y3.push(b3);
  }
  const D3 = f3.decoder, S3 = f3.contextCache;
  let F3 = e3 ? -d3.tableDeltaT.decode(m3) : -decodeInteger(S3, "IADT", D3), k3 = 0;
  for (w3 = 0; w3 < n3; ) {
    F3 += e3 ? d3.tableDeltaT.decode(m3) : decodeInteger(S3, "IADT", D3);
    k3 += e3 ? d3.tableFirstS.decode(m3) : decodeInteger(S3, "IAFS", D3);
    let a4 = k3;
    for (; ; ) {
      let s4 = 0;
      r3 > 1 && (s4 = e3 ? m3.readBits(p3) : decodeInteger(S3, "IAIT", D3));
      const n4 = r3 * F3 + s4, k4 = e3 ? d3.symbolIDTable.decode(m3) : decodeIAID(S3, D3, g3), R3 = t3 && (e3 ? m3.readBit() : decodeInteger(S3, "IARI", D3));
      let x3 = o3[k4], N3 = x3[0].length, M3 = x3.length;
      if (R3) {
        const e4 = decodeInteger(S3, "IARDW", D3), t4 = decodeInteger(S3, "IARDH", D3);
        N3 += e4, M3 += t4, x3 = decodeRefinement(N3, M3, u3, x3, (e4 >> 1) + decodeInteger(S3, "IARDX", D3), (t4 >> 1) + decodeInteger(S3, "IARDY", D3), 0, Q3, f3);
      }
      let G3 = 0;
      c3 ? 1 & l3 ? G3 = M3 - 1 : a4 += M3 - 1 : l3 > 1 ? a4 += N3 - 1 : G3 = N3 - 1;
      const v3 = n4 - (1 & l3 ? 0 : M3 - 1), L3 = a4 - (2 & l3 ? N3 - 1 : 0);
      let U3, H3, T3;
      if (c3) for (U3 = 0; U3 < M3; U3++) {
        if (b3 = y3[L3 + U3], !b3) continue;
        T3 = x3[U3];
        const e4 = Math.min(i3 - v3, N3);
        switch (C3) {
          case 0:
            for (H3 = 0; H3 < e4; H3++) b3[v3 + H3] |= T3[H3];
            break;
          case 2:
            for (H3 = 0; H3 < e4; H3++) b3[v3 + H3] ^= T3[H3];
            break;
          default:
            throw new Jbig2Error(`operator ${C3} is not supported`);
        }
      }
      else for (H3 = 0; H3 < M3; H3++) if (b3 = y3[v3 + H3], b3) switch (T3 = x3[H3], C3) {
        case 0:
          for (U3 = 0; U3 < N3; U3++) b3[L3 + U3] |= T3[U3];
          break;
        case 2:
          for (U3 = 0; U3 < N3; U3++) b3[L3 + U3] ^= T3[U3];
          break;
        default:
          throw new Jbig2Error(`operator ${C3} is not supported`);
      }
      w3++;
      const J3 = e3 ? d3.tableDeltaS.decode(m3) : decodeInteger(S3, "IADS", D3);
      if (null === J3) break;
      a4 += G3 + J3 + h3;
    }
  }
  return y3;
}
function readSegmentHeader(e3, t3) {
  const i3 = {};
  i3.number = readUint32(e3, t3);
  const a3 = e3[t3 + 4], s3 = 63 & a3;
  if (!Qn[s3]) throw new Jbig2Error("invalid segment type: " + s3);
  i3.type = s3, i3.typeName = Qn[s3], i3.deferredNonRetain = !!(128 & a3);
  const n3 = !!(64 & a3), r3 = e3[t3 + 5];
  let o3 = r3 >> 5 & 7;
  const g3 = [31 & r3];
  let c3 = t3 + 6;
  if (7 === r3) {
    o3 = 536870911 & readUint32(e3, c3 - 1), c3 += 3;
    let t4 = o3 + 7 >> 3;
    for (g3[0] = e3[c3++]; --t4 > 0; ) g3.push(e3[c3++]);
  } else if (5 === r3 || 6 === r3) throw new Jbig2Error("invalid referred-to flags");
  i3.retainBits = g3;
  let h3 = 4;
  i3.number <= 256 ? h3 = 1 : i3.number <= 65536 && (h3 = 2);
  const l3 = [];
  let C3, d3;
  for (C3 = 0; C3 < o3; C3++) {
    let t4;
    t4 = 1 === h3 ? e3[c3] : 2 === h3 ? readUint16(e3, c3) : readUint32(e3, c3), l3.push(t4), c3 += h3;
  }
  if (i3.referredTo = l3, n3 ? (i3.pageAssociation = readUint32(e3, c3), c3 += 4) : i3.pageAssociation = e3[c3++], i3.length = readUint32(e3, c3), c3 += 4, 4294967295 === i3.length) {
    if (38 !== s3) throw new Jbig2Error("invalid unknown segment length");
    {
      const t4 = readRegionSegmentInformation(e3, c3), a4 = !!(1 & e3[c3 + yn]), s4 = 6, n4 = new Uint8Array(s4);
      for (a4 || (n4[0] = 255, n4[1] = 172), n4[2] = t4.height >>> 24 & 255, n4[3] = t4.height >> 16 & 255, n4[4] = t4.height >> 8 & 255, n4[5] = 255 & t4.height, C3 = c3, d3 = e3.length; C3 < d3; C3++) {
        let t5 = 0;
        for (; t5 < s4 && n4[t5] === e3[C3 + t5]; ) t5++;
        if (t5 === s4) {
          i3.length = C3 + s4;
          break;
        }
      }
      if (4294967295 === i3.length) throw new Jbig2Error("segment end was not found");
    }
  }
  return i3.headerEnd = c3, i3;
}
function readSegments(e3, t3, i3, a3) {
  const s3 = [];
  let n3 = i3;
  for (; n3 < a3; ) {
    const i4 = readSegmentHeader(t3, n3);
    n3 = i4.headerEnd;
    const a4 = { header: i4, data: t3 };
    if (e3.randomAccess || (a4.start = n3, n3 += i4.length, a4.end = n3), s3.push(a4), 51 === i4.type) break;
  }
  if (e3.randomAccess) for (let e4 = 0, t4 = s3.length; e4 < t4; e4++) s3[e4].start = n3, n3 += s3[e4].header.length, s3[e4].end = n3;
  return s3;
}
function readRegionSegmentInformation(e3, t3) {
  return { width: readUint32(e3, t3), height: readUint32(e3, t3 + 4), x: readUint32(e3, t3 + 8), y: readUint32(e3, t3 + 12), combinationOperator: 7 & e3[t3 + 16] };
}
function processSegment(e3, t3) {
  const i3 = e3.header, a3 = e3.data, s3 = e3.end;
  let n3, r3, o3, g3, c3 = e3.start;
  switch (i3.type) {
    case 0:
      const e4 = {}, t4 = readUint16(a3, c3);
      if (e4.huffman = !!(1 & t4), e4.refinement = !!(2 & t4), e4.huffmanDHSelector = t4 >> 2 & 3, e4.huffmanDWSelector = t4 >> 4 & 3, e4.bitmapSizeSelector = t4 >> 6 & 1, e4.aggregationInstancesSelector = t4 >> 7 & 1, e4.bitmapCodingContextUsed = !!(256 & t4), e4.bitmapCodingContextRetained = !!(512 & t4), e4.template = t4 >> 10 & 3, e4.refinementTemplate = t4 >> 12 & 1, c3 += 2, !e4.huffman) {
        for (g3 = 0 === e4.template ? 4 : 1, r3 = [], o3 = 0; o3 < g3; o3++) r3.push({ x: readInt8(a3, c3), y: readInt8(a3, c3 + 1) }), c3 += 2;
        e4.at = r3;
      }
      if (e4.refinement && !e4.refinementTemplate) {
        for (r3 = [], o3 = 0; o3 < 2; o3++) r3.push({ x: readInt8(a3, c3), y: readInt8(a3, c3 + 1) }), c3 += 2;
        e4.refinementAt = r3;
      }
      e4.numberOfExportedSymbols = readUint32(a3, c3), c3 += 4, e4.numberOfNewSymbols = readUint32(a3, c3), c3 += 4, n3 = [e4, i3.number, i3.referredTo, a3, c3, s3];
      break;
    case 6:
    case 7:
      const h4 = {};
      h4.info = readRegionSegmentInformation(a3, c3), c3 += yn;
      const l3 = readUint16(a3, c3);
      if (c3 += 2, h4.huffman = !!(1 & l3), h4.refinement = !!(2 & l3), h4.logStripSize = l3 >> 2 & 3, h4.stripSize = 1 << h4.logStripSize, h4.referenceCorner = l3 >> 4 & 3, h4.transposed = !!(64 & l3), h4.combinationOperator = l3 >> 7 & 3, h4.defaultPixelValue = l3 >> 9 & 1, h4.dsOffset = l3 << 17 >> 27, h4.refinementTemplate = l3 >> 15 & 1, h4.huffman) {
        const e5 = readUint16(a3, c3);
        c3 += 2, h4.huffmanFS = 3 & e5, h4.huffmanDS = e5 >> 2 & 3, h4.huffmanDT = e5 >> 4 & 3, h4.huffmanRefinementDW = e5 >> 6 & 3, h4.huffmanRefinementDH = e5 >> 8 & 3, h4.huffmanRefinementDX = e5 >> 10 & 3, h4.huffmanRefinementDY = e5 >> 12 & 3, h4.huffmanRefinementSizeSelector = !!(16384 & e5);
      }
      if (h4.refinement && !h4.refinementTemplate) {
        for (r3 = [], o3 = 0; o3 < 2; o3++) r3.push({ x: readInt8(a3, c3), y: readInt8(a3, c3 + 1) }), c3 += 2;
        h4.refinementAt = r3;
      }
      h4.numberOfSymbolInstances = readUint32(a3, c3), c3 += 4, n3 = [h4, i3.referredTo, a3, c3, s3];
      break;
    case 16:
      const C3 = {}, d3 = a3[c3++];
      C3.mmr = !!(1 & d3), C3.template = d3 >> 1 & 3, C3.patternWidth = a3[c3++], C3.patternHeight = a3[c3++], C3.maxPatternIndex = readUint32(a3, c3), c3 += 4, n3 = [C3, i3.number, a3, c3, s3];
      break;
    case 22:
    case 23:
      const u3 = {};
      u3.info = readRegionSegmentInformation(a3, c3), c3 += yn;
      const Q3 = a3[c3++];
      u3.mmr = !!(1 & Q3), u3.template = Q3 >> 1 & 3, u3.enableSkip = !!(8 & Q3), u3.combinationOperator = Q3 >> 4 & 7, u3.defaultPixelValue = Q3 >> 7 & 1, u3.gridWidth = readUint32(a3, c3), c3 += 4, u3.gridHeight = readUint32(a3, c3), c3 += 4, u3.gridOffsetX = 4294967295 & readUint32(a3, c3), c3 += 4, u3.gridOffsetY = 4294967295 & readUint32(a3, c3), c3 += 4, u3.gridVectorX = readUint16(a3, c3), c3 += 2, u3.gridVectorY = readUint16(a3, c3), c3 += 2, n3 = [u3, i3.referredTo, a3, c3, s3];
      break;
    case 38:
    case 39:
      const f3 = {};
      f3.info = readRegionSegmentInformation(a3, c3), c3 += yn;
      const p3 = a3[c3++];
      if (f3.mmr = !!(1 & p3), f3.template = p3 >> 1 & 3, f3.prediction = !!(8 & p3), !f3.mmr) {
        for (g3 = 0 === f3.template ? 4 : 1, r3 = [], o3 = 0; o3 < g3; o3++) r3.push({ x: readInt8(a3, c3), y: readInt8(a3, c3 + 1) }), c3 += 2;
        f3.at = r3;
      }
      n3 = [f3, a3, c3, s3];
      break;
    case 48:
      const m3 = { width: readUint32(a3, c3), height: readUint32(a3, c3 + 4), resolutionX: readUint32(a3, c3 + 8), resolutionY: readUint32(a3, c3 + 12) };
      4294967295 === m3.height && delete m3.height;
      const y3 = a3[c3 + 16];
      readUint16(a3, c3 + 17), m3.lossless = !!(1 & y3), m3.refinement = !!(2 & y3), m3.defaultPixelValue = y3 >> 2 & 1, m3.combinationOperator = y3 >> 3 & 3, m3.requiresBuffer = !!(32 & y3), m3.combinationOperatorOverride = !!(64 & y3), n3 = [m3];
      break;
    case 49:
    case 50:
    case 51:
    case 62:
      break;
    case 53:
      n3 = [i3.number, a3, c3, s3];
      break;
    default:
      throw new Jbig2Error(`segment type ${i3.typeName}(${i3.type}) is not implemented`);
  }
  const h3 = "on" + i3.typeName;
  h3 in t3 && t3[h3].apply(t3, n3);
}
function processSegments(e3, t3) {
  for (let i3 = 0, a3 = e3.length; i3 < a3; i3++) processSegment(e3[i3], t3);
}
function getStandardTable(e3) {
  let t3, i3 = wn[e3];
  if (i3) return i3;
  switch (e3) {
    case 1:
      t3 = [[0, 1, 4, 0], [16, 2, 8, 2], [272, 3, 16, 6], [65808, 3, 32, 7]];
      break;
    case 2:
      t3 = [[0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [75, 6, 32, 62], [6, 63]];
      break;
    case 3:
      t3 = [[-256, 8, 8, 254], [0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [-257, 8, 32, 255, "lower"], [75, 7, 32, 126], [6, 62]];
      break;
    case 4:
      t3 = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [76, 5, 32, 31]];
      break;
    case 5:
      t3 = [[-255, 7, 8, 126], [1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [-256, 7, 32, 127, "lower"], [76, 6, 32, 62]];
      break;
    case 6:
      t3 = [[-2048, 5, 10, 28], [-1024, 4, 9, 8], [-512, 4, 8, 9], [-256, 4, 7, 10], [-128, 5, 6, 29], [-64, 5, 5, 30], [-32, 4, 5, 11], [0, 2, 7, 0], [128, 3, 7, 2], [256, 3, 8, 3], [512, 4, 9, 12], [1024, 4, 10, 13], [-2049, 6, 32, 62, "lower"], [2048, 6, 32, 63]];
      break;
    case 7:
      t3 = [[-1024, 4, 9, 8], [-512, 3, 8, 0], [-256, 4, 7, 9], [-128, 5, 6, 26], [-64, 5, 5, 27], [-32, 4, 5, 10], [0, 4, 5, 11], [32, 5, 5, 28], [64, 5, 6, 29], [128, 4, 7, 12], [256, 3, 8, 1], [512, 3, 9, 2], [1024, 3, 10, 3], [-1025, 5, 32, 30, "lower"], [2048, 5, 32, 31]];
      break;
    case 8:
      t3 = [[-15, 8, 3, 252], [-7, 9, 1, 508], [-5, 8, 1, 253], [-3, 9, 0, 509], [-2, 7, 0, 124], [-1, 4, 0, 10], [0, 2, 1, 0], [2, 5, 0, 26], [3, 6, 0, 58], [4, 3, 4, 4], [20, 6, 1, 59], [22, 4, 4, 11], [38, 4, 5, 12], [70, 5, 6, 27], [134, 5, 7, 28], [262, 6, 7, 60], [390, 7, 8, 125], [646, 6, 10, 61], [-16, 9, 32, 510, "lower"], [1670, 9, 32, 511], [2, 1]];
      break;
    case 9:
      t3 = [[-31, 8, 4, 252], [-15, 9, 2, 508], [-11, 8, 2, 253], [-7, 9, 1, 509], [-5, 7, 1, 124], [-3, 4, 1, 10], [-1, 3, 1, 2], [1, 3, 1, 3], [3, 5, 1, 26], [5, 6, 1, 58], [7, 3, 5, 4], [39, 6, 2, 59], [43, 4, 5, 11], [75, 4, 6, 12], [139, 5, 7, 27], [267, 5, 8, 28], [523, 6, 8, 60], [779, 7, 9, 125], [1291, 6, 11, 61], [-32, 9, 32, 510, "lower"], [3339, 9, 32, 511], [2, 0]];
      break;
    case 10:
      t3 = [[-21, 7, 4, 122], [-5, 8, 0, 252], [-4, 7, 0, 123], [-3, 5, 0, 24], [-2, 2, 2, 0], [2, 5, 0, 25], [3, 6, 0, 54], [4, 7, 0, 124], [5, 8, 0, 253], [6, 2, 6, 1], [70, 5, 5, 26], [102, 6, 5, 55], [134, 6, 6, 56], [198, 6, 7, 57], [326, 6, 8, 58], [582, 6, 9, 59], [1094, 6, 10, 60], [2118, 7, 11, 125], [-22, 8, 32, 254, "lower"], [4166, 8, 32, 255], [2, 2]];
      break;
    case 11:
      t3 = [[1, 1, 0, 0], [2, 2, 1, 2], [4, 4, 0, 12], [5, 4, 1, 13], [7, 5, 1, 28], [9, 5, 2, 29], [13, 6, 2, 60], [17, 7, 2, 122], [21, 7, 3, 123], [29, 7, 4, 124], [45, 7, 5, 125], [77, 7, 6, 126], [141, 7, 32, 127]];
      break;
    case 12:
      t3 = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 1, 6], [5, 5, 0, 28], [6, 5, 1, 29], [8, 6, 1, 60], [10, 7, 0, 122], [11, 7, 1, 123], [13, 7, 2, 124], [17, 7, 3, 125], [25, 7, 4, 126], [41, 8, 5, 254], [73, 8, 32, 255]];
      break;
    case 13:
      t3 = [[1, 1, 0, 0], [2, 3, 0, 4], [3, 4, 0, 12], [4, 5, 0, 28], [5, 4, 1, 13], [7, 3, 3, 5], [15, 6, 1, 58], [17, 6, 2, 59], [21, 6, 3, 60], [29, 6, 4, 61], [45, 6, 5, 62], [77, 7, 6, 126], [141, 7, 32, 127]];
      break;
    case 14:
      t3 = [[-2, 3, 0, 4], [-1, 3, 0, 5], [0, 1, 0, 0], [1, 3, 0, 6], [2, 3, 0, 7]];
      break;
    case 15:
      t3 = [[-24, 7, 4, 124], [-8, 6, 2, 60], [-4, 5, 1, 28], [-2, 4, 0, 12], [-1, 3, 0, 4], [0, 1, 0, 0], [1, 3, 0, 5], [2, 4, 0, 13], [3, 5, 1, 29], [5, 6, 2, 61], [9, 7, 4, 125], [-25, 7, 32, 126, "lower"], [25, 7, 32, 127]];
      break;
    default:
      throw new Jbig2Error(`standard table B.${e3} does not exist`);
  }
  for (let e4 = 0, i4 = t3.length; e4 < i4; e4++) t3[e4] = new HuffmanLine(t3[e4]);
  return i3 = new HuffmanTable(t3, true), wn[e3] = i3, i3;
}
function getCustomHuffmanTable(e3, t3, i3) {
  let a3 = 0;
  for (let s3 = 0, n3 = t3.length; s3 < n3; s3++) {
    const n4 = i3[t3[s3]];
    if (n4) {
      if (e3 === a3) return n4;
      a3++;
    }
  }
  throw new Jbig2Error("can't find custom Huffman table");
}
function readUncompressedBitmap(e3, t3, i3) {
  const a3 = [];
  for (let s3 = 0; s3 < i3; s3++) {
    const i4 = new Uint8Array(t3);
    a3.push(i4);
    for (let a4 = 0; a4 < t3; a4++) i4[a4] = e3.readBit();
    e3.byteAlign();
  }
  return a3;
}
function decodeMMRBitmap(e3, t3, i3, a3) {
  const s3 = new CCITTFaxDecoder(e3, { K: -1, Columns: t3, Rows: i3, BlackIs1: true, EndOfBlock: a3 }), n3 = [];
  let r3, o3 = false;
  for (let e4 = 0; e4 < i3; e4++) {
    const e5 = new Uint8Array(t3);
    n3.push(e5);
    let i4 = -1;
    for (let a4 = 0; a4 < t3; a4++) i4 < 0 && (r3 = s3.readNextChar(), -1 === r3 && (r3 = 0, o3 = true), i4 = 7), e5[a4] = r3 >> i4 & 1, i4--;
  }
  if (a3 && !o3) {
    const e4 = 5;
    for (let t4 = 0; t4 < e4 && -1 !== s3.readNextChar(); t4++) ;
  }
  return n3;
}
function convertToRGBA(e3) {
  switch (e3.kind) {
    case WA:
      return convertBlackAndWhiteToRGBA(e3);
    case jA:
      return function({ src: e4, srcPos: t3 = 0, dest: i3, destPos: a3 = 0, width: s3, height: n3 }) {
        let r3 = 0;
        const o3 = e4.length >> 2, g3 = new Uint32Array(e4.buffer, t3, o3);
        if (FeatureTest.isLittleEndian) {
          for (; r3 < o3 - 2; r3 += 3, a3 += 4) {
            const e5 = g3[r3], t4 = g3[r3 + 1], s4 = g3[r3 + 2];
            i3[a3] = 4278190080 | e5, i3[a3 + 1] = e5 >>> 24 | t4 << 8 | 4278190080, i3[a3 + 2] = t4 >>> 16 | s4 << 16 | 4278190080, i3[a3 + 3] = s4 >>> 8 | 4278190080;
          }
          for (let t4 = 4 * r3, s4 = e4.length; t4 < s4; t4 += 3) i3[a3++] = e4[t4] | e4[t4 + 1] << 8 | e4[t4 + 2] << 16 | 4278190080;
        } else {
          for (; r3 < o3 - 2; r3 += 3, a3 += 4) {
            const e5 = g3[r3], t4 = g3[r3 + 1], s4 = g3[r3 + 2];
            i3[a3] = 255 | e5, i3[a3 + 1] = e5 << 24 | t4 >>> 8 | 255, i3[a3 + 2] = t4 << 16 | s4 >>> 16 | 255, i3[a3 + 3] = s4 << 8 | 255;
          }
          for (let t4 = 4 * r3, s4 = e4.length; t4 < s4; t4 += 3) i3[a3++] = e4[t4] << 24 | e4[t4 + 1] << 16 | e4[t4 + 2] << 8 | 255;
        }
        return { srcPos: t3, destPos: a3 };
      }(e3);
  }
  return null;
}
function convertBlackAndWhiteToRGBA({ src: e3, srcPos: t3 = 0, dest: i3, width: a3, height: s3, nonBlackColor: n3 = 4294967295, inverseDecode: r3 = false }) {
  const o3 = FeatureTest.isLittleEndian ? 4278190080 : 255, [g3, c3] = r3 ? [n3, o3] : [o3, n3], h3 = a3 >> 3, l3 = 7 & a3, C3 = e3.length;
  i3 = new Uint32Array(i3.buffer);
  let d3 = 0;
  for (let a4 = 0; a4 < s3; a4++) {
    for (const a6 = t3 + h3; t3 < a6; t3++) {
      const a7 = t3 < C3 ? e3[t3] : 255;
      i3[d3++] = 128 & a7 ? c3 : g3, i3[d3++] = 64 & a7 ? c3 : g3, i3[d3++] = 32 & a7 ? c3 : g3, i3[d3++] = 16 & a7 ? c3 : g3, i3[d3++] = 8 & a7 ? c3 : g3, i3[d3++] = 4 & a7 ? c3 : g3, i3[d3++] = 2 & a7 ? c3 : g3, i3[d3++] = 1 & a7 ? c3 : g3;
    }
    if (0 === l3) continue;
    const a5 = t3 < C3 ? e3[t3++] : 255;
    for (let e4 = 0; e4 < l3; e4++) i3[d3++] = a5 & 1 << 7 - e4 ? c3 : g3;
  }
  return { srcPos: t3, destPos: d3 };
}
function buildHuffmanTable(e3, t3) {
  let i3, a3, s3 = 0, n3 = 16;
  for (; n3 > 0 && !e3[n3 - 1]; ) n3--;
  const r3 = [{ children: [], index: 0 }];
  let o3, g3 = r3[0];
  for (i3 = 0; i3 < n3; i3++) {
    for (a3 = 0; a3 < e3[i3]; a3++) {
      for (g3 = r3.pop(), g3.children[g3.index] = t3[s3]; g3.index > 0; ) g3 = r3.pop();
      for (g3.index++, r3.push(g3); r3.length <= i3; ) r3.push(o3 = { children: [], index: 0 }), g3.children[g3.index] = o3.children, g3 = o3;
      s3++;
    }
    i3 + 1 < n3 && (r3.push(o3 = { children: [], index: 0 }), g3.children[g3.index] = o3.children, g3 = o3);
  }
  return r3[0].children;
}
function getBlockBufferOffset(e3, t3, i3) {
  return 64 * ((e3.blocksPerLine + 1) * t3 + i3);
}
function decodeScan(e3, t3, i3, a3, s3, n3, r3, o3, g3, c3 = false) {
  const h3 = i3.mcusPerLine, l3 = i3.progressive, C3 = t3;
  let d3 = 0, u3 = 0;
  function readBit() {
    if (u3 > 0) return u3--, d3 >> u3 & 1;
    if (d3 = e3[t3++], 255 === d3) {
      const a4 = e3[t3++];
      if (a4) {
        if (220 === a4 && c3) {
          const a5 = readUint16(e3, t3 += 2);
          if (t3 += 2, a5 > 0 && a5 !== i3.scanLines) throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", a5);
        } else if (217 === a4) {
          if (c3) {
            const e4 = m3 * (8 === i3.precision ? 8 : 0);
            if (e4 > 0 && Math.round(i3.scanLines / e4) >= 5) throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", e4);
          }
          throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
        }
        throw new JpegError(`unexpected marker ${(d3 << 8 | a4).toString(16)}`);
      }
    }
    return u3 = 7, d3 >>> 7;
  }
  function decodeHuffman(e4) {
    let t4 = e4;
    for (; ; ) {
      switch (t4 = t4[readBit()], typeof t4) {
        case "number":
          return t4;
        case "object":
          continue;
      }
      throw new JpegError("invalid huffman sequence");
    }
  }
  function receive(e4) {
    let t4 = 0;
    for (; e4 > 0; ) t4 = t4 << 1 | readBit(), e4--;
    return t4;
  }
  function receiveAndExtend(e4) {
    if (1 === e4) return 1 === readBit() ? 1 : -1;
    const t4 = receive(e4);
    return t4 >= 1 << e4 - 1 ? t4 : t4 + (-1 << e4) + 1;
  }
  let Q3 = 0;
  let f3, p3 = 0;
  let m3 = 0;
  function decodeMcu(e4, t4, i4, a4, s4) {
    const n4 = i4 % h3;
    m3 = (i4 / h3 | 0) * e4.v + a4;
    const r4 = n4 * e4.h + s4;
    t4(e4, getBlockBufferOffset(e4, m3, r4));
  }
  function decodeBlock(e4, t4, i4) {
    m3 = i4 / e4.blocksPerLine | 0;
    const a4 = i4 % e4.blocksPerLine;
    t4(e4, getBlockBufferOffset(e4, m3, a4));
  }
  const y3 = a3.length;
  let w3, b3, D3, S3, F3, k3;
  k3 = l3 ? 0 === n3 ? 0 === o3 ? function(e4, t4) {
    const i4 = decodeHuffman(e4.huffmanTableDC), a4 = 0 === i4 ? 0 : receiveAndExtend(i4) << g3;
    e4.blockData[t4] = e4.pred += a4;
  } : function(e4, t4) {
    e4.blockData[t4] |= readBit() << g3;
  } : 0 === o3 ? function(e4, t4) {
    if (Q3 > 0) return void Q3--;
    let i4 = n3;
    const a4 = r3;
    for (; i4 <= a4; ) {
      const a5 = decodeHuffman(e4.huffmanTableAC), s4 = 15 & a5, n4 = a5 >> 4;
      if (0 === s4) {
        if (n4 < 15) {
          Q3 = receive(n4) + (1 << n4) - 1;
          break;
        }
        i4 += 16;
        continue;
      }
      i4 += n4;
      const r4 = bn[i4];
      e4.blockData[t4 + r4] = receiveAndExtend(s4) * (1 << g3), i4++;
    }
  } : function(e4, t4) {
    let i4 = n3;
    const a4 = r3;
    let s4, o4, c4 = 0;
    for (; i4 <= a4; ) {
      const a5 = t4 + bn[i4], n4 = e4.blockData[a5] < 0 ? -1 : 1;
      switch (p3) {
        case 0:
          if (o4 = decodeHuffman(e4.huffmanTableAC), s4 = 15 & o4, c4 = o4 >> 4, 0 === s4) c4 < 15 ? (Q3 = receive(c4) + (1 << c4), p3 = 4) : (c4 = 16, p3 = 1);
          else {
            if (1 !== s4) throw new JpegError("invalid ACn encoding");
            f3 = receiveAndExtend(s4), p3 = c4 ? 2 : 3;
          }
          continue;
        case 1:
        case 2:
          e4.blockData[a5] ? e4.blockData[a5] += n4 * (readBit() << g3) : (c4--, 0 === c4 && (p3 = 2 === p3 ? 3 : 0));
          break;
        case 3:
          e4.blockData[a5] ? e4.blockData[a5] += n4 * (readBit() << g3) : (e4.blockData[a5] = f3 << g3, p3 = 0);
          break;
        case 4:
          e4.blockData[a5] && (e4.blockData[a5] += n4 * (readBit() << g3));
      }
      i4++;
    }
    4 === p3 && (Q3--, 0 === Q3 && (p3 = 0));
  } : function(e4, t4) {
    const i4 = decodeHuffman(e4.huffmanTableDC), a4 = 0 === i4 ? 0 : receiveAndExtend(i4);
    e4.blockData[t4] = e4.pred += a4;
    let s4 = 1;
    for (; s4 < 64; ) {
      const i5 = decodeHuffman(e4.huffmanTableAC), a5 = 15 & i5, n4 = i5 >> 4;
      if (0 === a5) {
        if (n4 < 15) break;
        s4 += 16;
        continue;
      }
      s4 += n4;
      const r4 = bn[s4];
      e4.blockData[t4 + r4] = receiveAndExtend(a5), s4++;
    }
  };
  let R3, x3 = 0;
  const N3 = 1 === y3 ? a3[0].blocksPerLine * a3[0].blocksPerColumn : h3 * i3.mcusPerColumn;
  let M3, G3;
  for (; x3 <= N3; ) {
    const i4 = s3 ? Math.min(N3 - x3, s3) : N3;
    if (i4 > 0) {
      for (b3 = 0; b3 < y3; b3++) a3[b3].pred = 0;
      if (Q3 = 0, 1 === y3) for (w3 = a3[0], F3 = 0; F3 < i4; F3++) decodeBlock(w3, k3, x3), x3++;
      else for (F3 = 0; F3 < i4; F3++) {
        for (b3 = 0; b3 < y3; b3++) for (w3 = a3[b3], M3 = w3.h, G3 = w3.v, D3 = 0; D3 < G3; D3++) for (S3 = 0; S3 < M3; S3++) decodeMcu(w3, k3, x3, D3, S3);
        x3++;
      }
    }
    if (u3 = 0, R3 = findNextFileMarker(e3, t3), !R3) break;
    if (R3.invalid) {
      warn(`decodeScan - ${i4 > 0 ? "unexpected" : "excessive"} MCU data, current marker is: ${R3.invalid}`), t3 = R3.offset;
    }
    if (!(R3.marker >= 65488 && R3.marker <= 65495)) break;
    t3 += 2;
  }
  return t3 - C3;
}
function quantizeAndInverse(e3, t3, i3) {
  const a3 = e3.quantizationTable, s3 = e3.blockData;
  let n3, r3, o3, g3, c3, h3, l3, C3, d3, u3, Q3, f3, p3, m3, y3, w3, b3;
  if (!a3) throw new JpegError("missing required Quantization Table.");
  for (let e4 = 0; e4 < 64; e4 += 8) d3 = s3[t3 + e4], u3 = s3[t3 + e4 + 1], Q3 = s3[t3 + e4 + 2], f3 = s3[t3 + e4 + 3], p3 = s3[t3 + e4 + 4], m3 = s3[t3 + e4 + 5], y3 = s3[t3 + e4 + 6], w3 = s3[t3 + e4 + 7], d3 *= a3[e4], u3 | Q3 | f3 | p3 | m3 | y3 | w3 ? (u3 *= a3[e4 + 1], Q3 *= a3[e4 + 2], f3 *= a3[e4 + 3], p3 *= a3[e4 + 4], m3 *= a3[e4 + 5], y3 *= a3[e4 + 6], w3 *= a3[e4 + 7], n3 = Nn * d3 + 128 >> 8, r3 = Nn * p3 + 128 >> 8, o3 = Q3, g3 = y3, c3 = Mn * (u3 - w3) + 128 >> 8, C3 = Mn * (u3 + w3) + 128 >> 8, h3 = f3 << 4, l3 = m3 << 4, n3 = n3 + r3 + 1 >> 1, r3 = n3 - r3, b3 = o3 * xn + g3 * Rn + 128 >> 8, o3 = o3 * Rn - g3 * xn + 128 >> 8, g3 = b3, c3 = c3 + l3 + 1 >> 1, l3 = c3 - l3, C3 = C3 + h3 + 1 >> 1, h3 = C3 - h3, n3 = n3 + g3 + 1 >> 1, g3 = n3 - g3, r3 = r3 + o3 + 1 >> 1, o3 = r3 - o3, b3 = c3 * kn + C3 * Fn + 2048 >> 12, c3 = c3 * Fn - C3 * kn + 2048 >> 12, C3 = b3, b3 = h3 * Sn + l3 * Dn + 2048 >> 12, h3 = h3 * Dn - l3 * Sn + 2048 >> 12, l3 = b3, i3[e4] = n3 + C3, i3[e4 + 7] = n3 - C3, i3[e4 + 1] = r3 + l3, i3[e4 + 6] = r3 - l3, i3[e4 + 2] = o3 + h3, i3[e4 + 5] = o3 - h3, i3[e4 + 3] = g3 + c3, i3[e4 + 4] = g3 - c3) : (b3 = Nn * d3 + 512 >> 10, i3[e4] = b3, i3[e4 + 1] = b3, i3[e4 + 2] = b3, i3[e4 + 3] = b3, i3[e4 + 4] = b3, i3[e4 + 5] = b3, i3[e4 + 6] = b3, i3[e4 + 7] = b3);
  for (let e4 = 0; e4 < 8; ++e4) d3 = i3[e4], u3 = i3[e4 + 8], Q3 = i3[e4 + 16], f3 = i3[e4 + 24], p3 = i3[e4 + 32], m3 = i3[e4 + 40], y3 = i3[e4 + 48], w3 = i3[e4 + 56], u3 | Q3 | f3 | p3 | m3 | y3 | w3 ? (n3 = Nn * d3 + 2048 >> 12, r3 = Nn * p3 + 2048 >> 12, o3 = Q3, g3 = y3, c3 = Mn * (u3 - w3) + 2048 >> 12, C3 = Mn * (u3 + w3) + 2048 >> 12, h3 = f3, l3 = m3, n3 = 4112 + (n3 + r3 + 1 >> 1), r3 = n3 - r3, b3 = o3 * xn + g3 * Rn + 2048 >> 12, o3 = o3 * Rn - g3 * xn + 2048 >> 12, g3 = b3, c3 = c3 + l3 + 1 >> 1, l3 = c3 - l3, C3 = C3 + h3 + 1 >> 1, h3 = C3 - h3, n3 = n3 + g3 + 1 >> 1, g3 = n3 - g3, r3 = r3 + o3 + 1 >> 1, o3 = r3 - o3, b3 = c3 * kn + C3 * Fn + 2048 >> 12, c3 = c3 * Fn - C3 * kn + 2048 >> 12, C3 = b3, b3 = h3 * Sn + l3 * Dn + 2048 >> 12, h3 = h3 * Dn - l3 * Sn + 2048 >> 12, l3 = b3, d3 = n3 + C3, w3 = n3 - C3, u3 = r3 + l3, y3 = r3 - l3, Q3 = o3 + h3, m3 = o3 - h3, f3 = g3 + c3, p3 = g3 - c3, d3 < 16 ? d3 = 0 : d3 >= 4080 ? d3 = 255 : d3 >>= 4, u3 < 16 ? u3 = 0 : u3 >= 4080 ? u3 = 255 : u3 >>= 4, Q3 < 16 ? Q3 = 0 : Q3 >= 4080 ? Q3 = 255 : Q3 >>= 4, f3 < 16 ? f3 = 0 : f3 >= 4080 ? f3 = 255 : f3 >>= 4, p3 < 16 ? p3 = 0 : p3 >= 4080 ? p3 = 255 : p3 >>= 4, m3 < 16 ? m3 = 0 : m3 >= 4080 ? m3 = 255 : m3 >>= 4, y3 < 16 ? y3 = 0 : y3 >= 4080 ? y3 = 255 : y3 >>= 4, w3 < 16 ? w3 = 0 : w3 >= 4080 ? w3 = 255 : w3 >>= 4, s3[t3 + e4] = d3, s3[t3 + e4 + 8] = u3, s3[t3 + e4 + 16] = Q3, s3[t3 + e4 + 24] = f3, s3[t3 + e4 + 32] = p3, s3[t3 + e4 + 40] = m3, s3[t3 + e4 + 48] = y3, s3[t3 + e4 + 56] = w3) : (b3 = Nn * d3 + 8192 >> 14, b3 = b3 < -2040 ? 0 : b3 >= 2024 ? 255 : b3 + 2056 >> 4, s3[t3 + e4] = b3, s3[t3 + e4 + 8] = b3, s3[t3 + e4 + 16] = b3, s3[t3 + e4 + 24] = b3, s3[t3 + e4 + 32] = b3, s3[t3 + e4 + 40] = b3, s3[t3 + e4 + 48] = b3, s3[t3 + e4 + 56] = b3);
}
function buildComponentData(e3, t3) {
  const i3 = t3.blocksPerLine, a3 = t3.blocksPerColumn, s3 = new Int16Array(64);
  for (let e4 = 0; e4 < a3; e4++) for (let a4 = 0; a4 < i3; a4++) {
    quantizeAndInverse(t3, getBlockBufferOffset(t3, e4, a4), s3);
  }
  return t3.blockData;
}
function findNextFileMarker(e3, t3, i3 = t3) {
  const a3 = e3.length - 1;
  let s3 = i3 < t3 ? i3 : t3;
  if (t3 >= a3) return null;
  const n3 = readUint16(e3, t3);
  if (n3 >= 65472 && n3 <= 65534) return { invalid: null, marker: n3, offset: t3 };
  let r3 = readUint16(e3, s3);
  for (; !(r3 >= 65472 && r3 <= 65534); ) {
    if (++s3 >= a3) return null;
    r3 = readUint16(e3, s3);
  }
  return { invalid: n3.toString(16), marker: r3, offset: s3 };
}
function toHexDigit(e3) {
  return e3 >= 48 && e3 <= 57 ? 15 & e3 : e3 >= 65 && e3 <= 70 || e3 >= 97 && e3 <= 102 ? 9 + (15 & e3) : -1;
}
function strToInt(e3) {
  let t3 = 0;
  for (let i3 = 0; i3 < e3.length; i3++) t3 = t3 << 8 | e3.charCodeAt(i3);
  return t3 >>> 0;
}
function expectString(e3) {
  if ("string" != typeof e3) throw new FormatError("Malformed CMap: expected string.");
}
function expectInt(e3) {
  if (!Number.isInteger(e3)) throw new FormatError("Malformed CMap: expected int.");
}
function parseBfChar(e3, t3) {
  for (; ; ) {
    let i3 = t3.getObj();
    if (i3 === Xs) break;
    if (isCmd(i3, "endbfchar")) return;
    expectString(i3);
    const a3 = strToInt(i3);
    i3 = t3.getObj(), expectString(i3);
    const s3 = i3;
    e3.mapOne(a3, s3);
  }
}
function parseBfRange(e3, t3) {
  for (; ; ) {
    let i3 = t3.getObj();
    if (i3 === Xs) break;
    if (isCmd(i3, "endbfrange")) return;
    expectString(i3);
    const a3 = strToInt(i3);
    i3 = t3.getObj(), expectString(i3);
    const s3 = strToInt(i3);
    if (i3 = t3.getObj(), Number.isInteger(i3) || "string" == typeof i3) {
      const t4 = Number.isInteger(i3) ? String.fromCharCode(i3) : i3;
      e3.mapBfRange(a3, s3, t4);
    } else {
      if (!isCmd(i3, "[")) break;
      {
        i3 = t3.getObj();
        const n3 = [];
        for (; !isCmd(i3, "]") && i3 !== Xs; ) n3.push(i3), i3 = t3.getObj();
        e3.mapBfRangeToArray(a3, s3, n3);
      }
    }
  }
  throw new FormatError("Invalid bf range.");
}
function parseCidChar(e3, t3) {
  for (; ; ) {
    let i3 = t3.getObj();
    if (i3 === Xs) break;
    if (isCmd(i3, "endcidchar")) return;
    expectString(i3);
    const a3 = strToInt(i3);
    i3 = t3.getObj(), expectInt(i3);
    const s3 = i3;
    e3.mapOne(a3, s3);
  }
}
function parseCidRange(e3, t3) {
  for (; ; ) {
    let i3 = t3.getObj();
    if (i3 === Xs) break;
    if (isCmd(i3, "endcidrange")) return;
    expectString(i3);
    const a3 = strToInt(i3);
    i3 = t3.getObj(), expectString(i3);
    const s3 = strToInt(i3);
    i3 = t3.getObj(), expectInt(i3);
    const n3 = i3;
    e3.mapCidRange(a3, s3, n3);
  }
}
function parseCodespaceRange(e3, t3) {
  for (; ; ) {
    let i3 = t3.getObj();
    if (i3 === Xs) break;
    if (isCmd(i3, "endcodespacerange")) return;
    if ("string" != typeof i3) break;
    const a3 = strToInt(i3);
    if (i3 = t3.getObj(), "string" != typeof i3) break;
    const s3 = strToInt(i3);
    e3.addCodespaceRange(i3.length, a3, s3);
  }
  throw new FormatError("Invalid codespace range.");
}
function parseWMode(e3, t3) {
  const i3 = t3.getObj();
  Number.isInteger(i3) && (e3.vertical = !!i3);
}
function parseCMapName(e3, t3) {
  const i3 = t3.getObj();
  i3 instanceof Name && (e3.name = i3.name);
}
async function parseCMap(e3, t3, i3, a3) {
  let s3, n3;
  e: for (; ; ) try {
    const i4 = t3.getObj();
    if (i4 === Xs) break;
    if (i4 instanceof Name) "WMode" === i4.name ? parseWMode(e3, t3) : "CMapName" === i4.name && parseCMapName(e3, t3), s3 = i4;
    else if (i4 instanceof Cmd) switch (i4.cmd) {
      case "endcmap":
        break e;
      case "usecmap":
        s3 instanceof Name && (n3 = s3.name);
        break;
      case "begincodespacerange":
        parseCodespaceRange(e3, t3);
        break;
      case "beginbfchar":
        parseBfChar(e3, t3);
        break;
      case "begincidchar":
        parseCidChar(e3, t3);
        break;
      case "beginbfrange":
        parseBfRange(e3, t3);
        break;
      case "begincidrange":
        parseCidRange(e3, t3);
    }
  } catch (e4) {
    if (e4 instanceof MissingDataException) throw e4;
    warn("Invalid cMap data: " + e4);
    continue;
  }
  return !a3 && n3 && (a3 = n3), a3 ? extendCMap(e3, i3, a3) : e3;
}
async function extendCMap(e3, t3, i3) {
  if (e3.useCMap = await createBuiltInCMap(i3, t3), 0 === e3.numCodespaceRanges) {
    const t4 = e3.useCMap.codespaceRanges;
    for (let i4 = 0; i4 < t4.length; i4++) e3.codespaceRanges[i4] = t4[i4].slice();
    e3.numCodespaceRanges = e3.useCMap.numCodespaceRanges;
  }
  return e3.useCMap.forEach(function(t4, i4) {
    e3.contains(t4) || e3.mapOne(t4, e3.useCMap.lookup(t4));
  }), e3;
}
async function createBuiltInCMap(e3, t3) {
  if ("Identity-H" === e3) return new IdentityCMap(false, 2);
  if ("Identity-V" === e3) return new IdentityCMap(true, 2);
  if (!Hn.includes(e3)) throw new Error("Unknown CMap name: " + e3);
  if (!t3) throw new Error("Built-in CMap parameters are not provided.");
  const { cMapData: i3, compressionType: a3 } = await t3(e3), s3 = new CMap(true);
  if (a3 === Wi) return new BinaryCMapReader().process(i3, s3, (e4) => extendCMap(s3, t3, e4));
  if (a3 === _i) {
    const e4 = new Lexer(new Stream(i3));
    return parseCMap(s3, e4, t3, null);
  }
  throw new Error(`Invalid CMap "compressionType" value: ${a3}`);
}
function getEncoding(e3) {
  switch (e3) {
    case "WinAnsiEncoding":
      return Wn;
    case "StandardEncoding":
      return _n2;
    case "MacRomanEncoding":
      return qn;
    case "SymbolSetEncoding":
      return jn;
    case "ZapfDingbatsEncoding":
      return Xn;
    case "ExpertEncoding":
      return On;
    case "MacExpertEncoding":
      return Kn;
    default:
      return null;
  }
}
function getUnicodeForGlyph(e3, t3) {
  let i3 = t3[e3];
  if (void 0 !== i3) return i3;
  if (!e3) return -1;
  if ("u" === e3[0]) {
    const t4 = e3.length;
    let a3;
    if (7 === t4 && "n" === e3[1] && "i" === e3[2]) a3 = e3.substring(3);
    else {
      if (!(t4 >= 5 && t4 <= 7)) return -1;
      a3 = e3.substring(1);
    }
    if (a3 === a3.toUpperCase() && (i3 = parseInt(a3, 16), i3 >= 0)) return i3;
  }
  return -1;
}
function getUnicodeRangeFor(e3, t3 = -1) {
  if (-1 !== t3) {
    const i3 = nr[t3];
    for (let a3 = 0, s3 = i3.length; a3 < s3; a3 += 2) if (e3 >= i3[a3] && e3 <= i3[a3 + 1]) return t3;
  }
  for (let t4 = 0, i3 = nr.length; t4 < i3; t4++) {
    const i4 = nr[t4];
    for (let a3 = 0, s3 = i4.length; a3 < s3; a3 += 2) if (e3 >= i4[a3] && e3 <= i4[a3 + 1]) return t4;
  }
  return -1;
}
function recoverGlyphName(e3, t3) {
  if (void 0 !== t3[e3]) return e3;
  const i3 = getUnicodeForGlyph(e3, t3);
  if (-1 !== i3) {
    for (const e4 in t3) if (t3[e4] === i3) return e4;
  }
  return info("Unable to recover a standard glyph name for: " + e3), e3;
}
function type1FontGlyphMapping(e3, t3, i3) {
  const a3 = /* @__PURE__ */ Object.create(null);
  let s3, n3, r3;
  const o3 = !!(e3.flags & lr);
  if (e3.isInternalFont) for (r3 = t3, n3 = 0; n3 < r3.length; n3++) s3 = i3.indexOf(r3[n3]), a3[n3] = s3 >= 0 ? s3 : 0;
  else if (e3.baseEncodingName) for (r3 = getEncoding(e3.baseEncodingName), n3 = 0; n3 < r3.length; n3++) s3 = i3.indexOf(r3[n3]), a3[n3] = s3 >= 0 ? s3 : 0;
  else if (o3) for (n3 in t3) a3[n3] = t3[n3];
  else for (r3 = _n2, n3 = 0; n3 < r3.length; n3++) s3 = i3.indexOf(r3[n3]), a3[n3] = s3 >= 0 ? s3 : 0;
  const g3 = e3.differences;
  let c3;
  if (g3) for (n3 in g3) {
    const e4 = g3[n3];
    if (s3 = i3.indexOf(e4), -1 === s3) {
      c3 || (c3 = ir());
      const t4 = recoverGlyphName(e4, c3);
      t4 !== e4 && (s3 = i3.indexOf(t4));
    }
    a3[n3] = s3 >= 0 ? s3 : 0;
  }
  return a3;
}
function normalizeFontName(e3) {
  return e3.replaceAll(/[,_]/g, "-").replaceAll(/\s/g, "");
}
function getStandardFontName(e3) {
  const t3 = normalizeFontName(e3);
  return ur()[t3];
}
function isKnownFontName(e3) {
  const t3 = normalizeFontName(e3);
  return !!(ur()[t3] || Er()[t3] || fr()[t3] || pr()[t3]);
}
function getUint32(e3, t3) {
  return (e3[t3] << 24 | e3[t3 + 1] << 16 | e3[t3 + 2] << 8 | e3[t3 + 3]) >>> 0;
}
function getUint16(e3, t3) {
  return e3[t3] << 8 | e3[t3 + 1];
}
function getInt16(e3, t3) {
  return (e3[t3] << 24 | e3[t3 + 1] << 16) >> 16;
}
function getInt8(e3, t3) {
  return e3[t3] << 24 >> 24;
}
function getFloat214(e3, t3) {
  return getInt16(e3, t3) / 16384;
}
function getSubroutineBias(e3) {
  const t3 = e3.length;
  let i3 = 32768;
  return t3 < 1240 ? i3 = 107 : t3 < 33900 && (i3 = 1131), i3;
}
function parseCmap(e3, t3, i3) {
  const a3 = 1 === getUint16(e3, t3 + 2) ? getUint32(e3, t3 + 8) : getUint32(e3, t3 + 16), s3 = getUint16(e3, t3 + a3);
  let n3, r3, o3;
  if (4 === s3) {
    getUint16(e3, t3 + a3 + 2);
    const i4 = getUint16(e3, t3 + a3 + 6) >> 1;
    for (r3 = t3 + a3 + 14, n3 = [], o3 = 0; o3 < i4; o3++, r3 += 2) n3[o3] = { end: getUint16(e3, r3) };
    for (r3 += 2, o3 = 0; o3 < i4; o3++, r3 += 2) n3[o3].start = getUint16(e3, r3);
    for (o3 = 0; o3 < i4; o3++, r3 += 2) n3[o3].idDelta = getUint16(e3, r3);
    for (o3 = 0; o3 < i4; o3++, r3 += 2) {
      let t4 = getUint16(e3, r3);
      if (0 !== t4) {
        n3[o3].ids = [];
        for (let i5 = 0, a4 = n3[o3].end - n3[o3].start + 1; i5 < a4; i5++) n3[o3].ids[i5] = getUint16(e3, r3 + t4), t4 += 2;
      }
    }
    return n3;
  }
  if (12 === s3) {
    const i4 = getUint32(e3, t3 + a3 + 12);
    for (r3 = t3 + a3 + 16, n3 = [], o3 = 0; o3 < i4; o3++) t3 = getUint32(e3, r3), n3.push({ start: t3, end: getUint32(e3, r3 + 4), idDelta: getUint32(e3, r3 + 8) - t3 }), r3 += 12;
    return n3;
  }
  throw new FormatError(`unsupported cmap: ${s3}`);
}
function parseCff(e3, t3, i3, a3) {
  const s3 = new CFFParser(new Stream(e3, t3, i3 - t3), {}, a3).parse();
  return { glyphs: s3.charStrings.objects, subrs: s3.topDict.privateDict?.subrsIndex?.objects, gsubrs: s3.globalSubrIndex?.objects, isCFFCIDFont: s3.isCIDFont, fdSelect: s3.fdSelect, fdArray: s3.fdArray };
}
function lookupCmap(e3, t3) {
  const i3 = t3.codePointAt(0);
  let a3 = 0, s3 = 0, n3 = e3.length - 1;
  for (; s3 < n3; ) {
    const t4 = s3 + n3 + 1 >> 1;
    i3 < e3[t4].start ? n3 = t4 - 1 : s3 = t4;
  }
  return e3[s3].start <= i3 && i3 <= e3[s3].end && (a3 = e3[s3].idDelta + (e3[s3].ids ? e3[s3].ids[i3 - e3[s3].start] : i3) & 65535), { charCode: i3, glyphId: a3 };
}
function compileGlyf(e3, t3, i3) {
  function moveTo(e4, i4) {
    t3.add(Ts, [e4, i4]);
  }
  function lineTo(e4, i4) {
    t3.add(Js, [e4, i4]);
  }
  function quadraticCurveTo(e4, i4, a4, s4) {
    t3.add(Ys, [e4, i4, a4, s4]);
  }
  let a3 = 0;
  const s3 = getInt16(e3, a3);
  let n3, r3 = 0, o3 = 0;
  if (a3 += 10, s3 < 0) do {
    n3 = getUint16(e3, a3);
    const s4 = getUint16(e3, a3 + 2);
    let g3, c3;
    a3 += 4, 1 & n3 ? (2 & n3 ? (g3 = getInt16(e3, a3), c3 = getInt16(e3, a3 + 2)) : (g3 = getUint16(e3, a3), c3 = getUint16(e3, a3 + 2)), a3 += 4) : 2 & n3 ? (g3 = getInt8(e3, a3++), c3 = getInt8(e3, a3++)) : (g3 = e3[a3++], c3 = e3[a3++]), 2 & n3 ? (r3 = g3, o3 = c3) : (r3 = 0, o3 = 0);
    let h3 = 1, l3 = 1, C3 = 0, d3 = 0;
    8 & n3 ? (h3 = l3 = getFloat214(e3, a3), a3 += 2) : 64 & n3 ? (h3 = getFloat214(e3, a3), l3 = getFloat214(e3, a3 + 2), a3 += 4) : 128 & n3 && (h3 = getFloat214(e3, a3), C3 = getFloat214(e3, a3 + 2), d3 = getFloat214(e3, a3 + 4), l3 = getFloat214(e3, a3 + 6), a3 += 8);
    const u3 = i3.glyphs[s4];
    u3 && (t3.add(Ks), t3.add(_s, [h3, C3, d3, l3, r3, o3]), compileGlyf(u3, t3, i3), t3.add(Os));
  } while (32 & n3);
  else {
    const t4 = [];
    let i4, g3;
    for (i4 = 0; i4 < s3; i4++) t4.push(getUint16(e3, a3)), a3 += 2;
    a3 += 2 + getUint16(e3, a3);
    const c3 = t4.at(-1) + 1, h3 = [];
    for (; h3.length < c3; ) {
      n3 = e3[a3++];
      let t5 = 1;
      for (8 & n3 && (t5 += e3[a3++]); t5-- > 0; ) h3.push({ flags: n3 });
    }
    for (i4 = 0; i4 < c3; i4++) {
      switch (18 & h3[i4].flags) {
        case 0:
          r3 += getInt16(e3, a3), a3 += 2;
          break;
        case 2:
          r3 -= e3[a3++];
          break;
        case 18:
          r3 += e3[a3++];
      }
      h3[i4].x = r3;
    }
    for (i4 = 0; i4 < c3; i4++) {
      switch (36 & h3[i4].flags) {
        case 0:
          o3 += getInt16(e3, a3), a3 += 2;
          break;
        case 4:
          o3 -= e3[a3++];
          break;
        case 36:
          o3 += e3[a3++];
      }
      h3[i4].y = o3;
    }
    let l3 = 0;
    for (a3 = 0; a3 < s3; a3++) {
      const e4 = t4[a3], s4 = h3.slice(l3, e4 + 1);
      if (1 & s4[0].flags) s4.push(s4[0]);
      else if (1 & s4.at(-1).flags) s4.unshift(s4.at(-1));
      else {
        const e5 = { flags: 1, x: (s4[0].x + s4.at(-1).x) / 2, y: (s4[0].y + s4.at(-1).y) / 2 };
        s4.unshift(e5), s4.push(e5);
      }
      for (moveTo(s4[0].x, s4[0].y), i4 = 1, g3 = s4.length; i4 < g3; i4++) 1 & s4[i4].flags ? lineTo(s4[i4].x, s4[i4].y) : 1 & s4[i4 + 1].flags ? (quadraticCurveTo(s4[i4].x, s4[i4].y, s4[i4 + 1].x, s4[i4 + 1].y), i4++) : quadraticCurveTo(s4[i4].x, s4[i4].y, (s4[i4].x + s4[i4 + 1].x) / 2, (s4[i4].y + s4[i4 + 1].y) / 2);
      l3 = e4 + 1;
    }
  }
}
function compileCharString(e3, t3, i3, a3) {
  function moveTo(e4, i4) {
    t3.add(Ts, [e4, i4]);
  }
  function lineTo(e4, i4) {
    t3.add(Js, [e4, i4]);
  }
  function bezierCurveTo(e4, i4, a4, s4, n4, r4) {
    t3.add(Hs, [e4, i4, a4, s4, n4, r4]);
  }
  const s3 = [];
  let n3 = 0, r3 = 0, o3 = 0;
  !function parse3(e4) {
    let g3 = 0;
    for (; g3 < e4.length; ) {
      let c3, h3, l3, C3, d3, u3, Q3, f3, p3, m3 = false, y3 = e4[g3++];
      switch (y3) {
        case 1:
        case 3:
        case 18:
        case 23:
          o3 += s3.length >> 1, m3 = true;
          break;
        case 4:
          r3 += s3.pop(), moveTo(n3, r3), m3 = true;
          break;
        case 5:
          for (; s3.length > 0; ) n3 += s3.shift(), r3 += s3.shift(), lineTo(n3, r3);
          break;
        case 6:
          for (; s3.length > 0 && (n3 += s3.shift(), lineTo(n3, r3), 0 !== s3.length); ) r3 += s3.shift(), lineTo(n3, r3);
          break;
        case 7:
          for (; s3.length > 0 && (r3 += s3.shift(), lineTo(n3, r3), 0 !== s3.length); ) n3 += s3.shift(), lineTo(n3, r3);
          break;
        case 8:
          for (; s3.length > 0; ) c3 = n3 + s3.shift(), l3 = r3 + s3.shift(), h3 = c3 + s3.shift(), C3 = l3 + s3.shift(), n3 = h3 + s3.shift(), r3 = C3 + s3.shift(), bezierCurveTo(c3, l3, h3, C3, n3, r3);
          break;
        case 10:
          if (f3 = s3.pop(), p3 = null, i3.isCFFCIDFont) {
            const e5 = i3.fdSelect.getFDIndex(a3);
            if (e5 >= 0 && e5 < i3.fdArray.length) {
              const t4 = i3.fdArray[e5];
              let a4;
              t4.privateDict?.subrsIndex && (a4 = t4.privateDict.subrsIndex.objects), a4 && (f3 += getSubroutineBias(a4), p3 = a4[f3]);
            } else warn("Invalid fd index for glyph index.");
          } else p3 = i3.subrs[f3 + i3.subrsBias];
          p3 && parse3(p3);
          break;
        case 11:
          return;
        case 12:
          switch (y3 = e4[g3++], y3) {
            case 34:
              c3 = n3 + s3.shift(), h3 = c3 + s3.shift(), d3 = r3 + s3.shift(), n3 = h3 + s3.shift(), bezierCurveTo(c3, r3, h3, d3, n3, d3), c3 = n3 + s3.shift(), h3 = c3 + s3.shift(), n3 = h3 + s3.shift(), bezierCurveTo(c3, d3, h3, r3, n3, r3);
              break;
            case 35:
              c3 = n3 + s3.shift(), l3 = r3 + s3.shift(), h3 = c3 + s3.shift(), C3 = l3 + s3.shift(), n3 = h3 + s3.shift(), r3 = C3 + s3.shift(), bezierCurveTo(c3, l3, h3, C3, n3, r3), c3 = n3 + s3.shift(), l3 = r3 + s3.shift(), h3 = c3 + s3.shift(), C3 = l3 + s3.shift(), n3 = h3 + s3.shift(), r3 = C3 + s3.shift(), bezierCurveTo(c3, l3, h3, C3, n3, r3), s3.pop();
              break;
            case 36:
              c3 = n3 + s3.shift(), d3 = r3 + s3.shift(), h3 = c3 + s3.shift(), u3 = d3 + s3.shift(), n3 = h3 + s3.shift(), bezierCurveTo(c3, d3, h3, u3, n3, u3), c3 = n3 + s3.shift(), h3 = c3 + s3.shift(), Q3 = u3 + s3.shift(), n3 = h3 + s3.shift(), bezierCurveTo(c3, u3, h3, Q3, n3, r3);
              break;
            case 37:
              const e5 = n3, t4 = r3;
              c3 = n3 + s3.shift(), l3 = r3 + s3.shift(), h3 = c3 + s3.shift(), C3 = l3 + s3.shift(), n3 = h3 + s3.shift(), r3 = C3 + s3.shift(), bezierCurveTo(c3, l3, h3, C3, n3, r3), c3 = n3 + s3.shift(), l3 = r3 + s3.shift(), h3 = c3 + s3.shift(), C3 = l3 + s3.shift(), n3 = h3, r3 = C3, Math.abs(n3 - e5) > Math.abs(r3 - t4) ? n3 += s3.shift() : r3 += s3.shift(), bezierCurveTo(c3, l3, h3, C3, n3, r3);
              break;
            default:
              throw new FormatError(`unknown operator: 12 ${y3}`);
          }
          break;
        case 14:
          if (s3.length >= 4) {
            const e5 = s3.pop(), a4 = s3.pop();
            r3 = s3.pop(), n3 = s3.pop(), t3.add(Ks), t3.add(Ws, [n3, r3]);
            let o4 = lookupCmap(i3.cmap, String.fromCharCode(i3.glyphNameMap[_n2[e5]]));
            compileCharString(i3.glyphs[o4.glyphId], t3, i3, o4.glyphId), t3.add(Os), o4 = lookupCmap(i3.cmap, String.fromCharCode(i3.glyphNameMap[_n2[a4]])), compileCharString(i3.glyphs[o4.glyphId], t3, i3, o4.glyphId);
          }
          return;
        case 19:
        case 20:
          o3 += s3.length >> 1, g3 += o3 + 7 >> 3, m3 = true;
          break;
        case 21:
          r3 += s3.pop(), n3 += s3.pop(), moveTo(n3, r3), m3 = true;
          break;
        case 22:
          n3 += s3.pop(), moveTo(n3, r3), m3 = true;
          break;
        case 24:
          for (; s3.length > 2; ) c3 = n3 + s3.shift(), l3 = r3 + s3.shift(), h3 = c3 + s3.shift(), C3 = l3 + s3.shift(), n3 = h3 + s3.shift(), r3 = C3 + s3.shift(), bezierCurveTo(c3, l3, h3, C3, n3, r3);
          n3 += s3.shift(), r3 += s3.shift(), lineTo(n3, r3);
          break;
        case 25:
          for (; s3.length > 6; ) n3 += s3.shift(), r3 += s3.shift(), lineTo(n3, r3);
          c3 = n3 + s3.shift(), l3 = r3 + s3.shift(), h3 = c3 + s3.shift(), C3 = l3 + s3.shift(), n3 = h3 + s3.shift(), r3 = C3 + s3.shift(), bezierCurveTo(c3, l3, h3, C3, n3, r3);
          break;
        case 26:
          for (s3.length % 2 && (n3 += s3.shift()); s3.length > 0; ) c3 = n3, l3 = r3 + s3.shift(), h3 = c3 + s3.shift(), C3 = l3 + s3.shift(), n3 = h3, r3 = C3 + s3.shift(), bezierCurveTo(c3, l3, h3, C3, n3, r3);
          break;
        case 27:
          for (s3.length % 2 && (r3 += s3.shift()); s3.length > 0; ) c3 = n3 + s3.shift(), l3 = r3, h3 = c3 + s3.shift(), C3 = l3 + s3.shift(), n3 = h3 + s3.shift(), r3 = C3, bezierCurveTo(c3, l3, h3, C3, n3, r3);
          break;
        case 28:
          s3.push((e4[g3] << 24 | e4[g3 + 1] << 16) >> 16), g3 += 2;
          break;
        case 29:
          f3 = s3.pop() + i3.gsubrsBias, p3 = i3.gsubrs[f3], p3 && parse3(p3);
          break;
        case 30:
          for (; s3.length > 0 && (c3 = n3, l3 = r3 + s3.shift(), h3 = c3 + s3.shift(), C3 = l3 + s3.shift(), n3 = h3 + s3.shift(), r3 = C3 + (1 === s3.length ? s3.shift() : 0), bezierCurveTo(c3, l3, h3, C3, n3, r3), 0 !== s3.length); ) c3 = n3 + s3.shift(), l3 = r3, h3 = c3 + s3.shift(), C3 = l3 + s3.shift(), r3 = C3 + s3.shift(), n3 = h3 + (1 === s3.length ? s3.shift() : 0), bezierCurveTo(c3, l3, h3, C3, n3, r3);
          break;
        case 31:
          for (; s3.length > 0 && (c3 = n3 + s3.shift(), l3 = r3, h3 = c3 + s3.shift(), C3 = l3 + s3.shift(), r3 = C3 + s3.shift(), n3 = h3 + (1 === s3.length ? s3.shift() : 0), bezierCurveTo(c3, l3, h3, C3, n3, r3), 0 !== s3.length); ) c3 = n3, l3 = r3 + s3.shift(), h3 = c3 + s3.shift(), C3 = l3 + s3.shift(), n3 = h3 + s3.shift(), r3 = C3 + (1 === s3.length ? s3.shift() : 0), bezierCurveTo(c3, l3, h3, C3, n3, r3);
          break;
        default:
          if (y3 < 32) throw new FormatError(`unknown operator: ${y3}`);
          y3 < 247 ? s3.push(y3 - 139) : y3 < 251 ? s3.push(256 * (y3 - 247) + e4[g3++] + 108) : y3 < 255 ? s3.push(256 * -(y3 - 251) - e4[g3++] - 108) : (s3.push((e4[g3] << 24 | e4[g3 + 1] << 16 | e4[g3 + 2] << 8 | e4[g3 + 3]) / 65536), g3 += 4);
      }
      m3 && (s3.length = 0);
    }
  }(e3);
}
function writeInt16(e3, t3, i3) {
  e3[t3] = i3 >> 8 & 255, e3[t3 + 1] = 255 & i3;
}
function writeInt32(e3, t3, i3) {
  e3[t3] = i3 >> 24 & 255, e3[t3 + 1] = i3 >> 16 & 255, e3[t3 + 2] = i3 >> 8 & 255, e3[t3 + 3] = 255 & i3;
}
function writeData(e3, t3, i3) {
  if (i3 instanceof Uint8Array) e3.set(i3, t3);
  else if ("string" == typeof i3) for (let a3 = 0, s3 = i3.length; a3 < s3; a3++) e3[t3++] = 255 & i3.charCodeAt(a3);
  else for (const a3 of i3) e3[t3++] = 255 & a3;
}
function isHexDigit(e3) {
  return e3 >= 48 && e3 <= 57 || e3 >= 65 && e3 <= 70 || e3 >= 97 && e3 <= 102;
}
function decrypt(e3, t3, i3) {
  if (i3 >= e3.length) return new Uint8Array(0);
  let a3, s3, n3 = 0 | t3;
  for (a3 = 0; a3 < i3; a3++) n3 = 52845 * (e3[a3] + n3) + 22719 & 65535;
  const r3 = e3.length - i3, o3 = new Uint8Array(r3);
  for (a3 = i3, s3 = 0; s3 < r3; a3++, s3++) {
    const t4 = e3[a3];
    o3[s3] = t4 ^ n3 >> 8, n3 = 52845 * (t4 + n3) + 22719 & 65535;
  }
  return o3;
}
function isSpecial(e3) {
  return 47 === e3 || 91 === e3 || 93 === e3 || 123 === e3 || 125 === e3 || 40 === e3 || 41 === e3;
}
function findBlock(e3, t3, i3) {
  const a3 = e3.length, s3 = t3.length, n3 = a3 - s3;
  let r3 = i3, o3 = false;
  for (; r3 < n3; ) {
    let i4 = 0;
    for (; i4 < s3 && e3[r3 + i4] === t3[i4]; ) i4++;
    if (i4 >= s3) {
      for (r3 += i4; r3 < a3 && isWhiteSpace(e3[r3]); ) r3++;
      o3 = true;
      break;
    }
    r3++;
  }
  return { found: o3, length: r3 };
}
function adjustWidths(e3) {
  if (!e3.fontMatrix) return;
  if (e3.fontMatrix[0] === SA[0]) return;
  const t3 = 1e-3 / e3.fontMatrix[0], i3 = e3.widths;
  for (const e4 in i3) i3[e4] *= t3;
  e3.defaultWidth *= t3;
}
function amendFallbackToUnicode(e3) {
  if (!e3.fallbackToUnicode) return;
  if (e3.toUnicode instanceof IdentityToUnicodeMap) return;
  const t3 = [];
  for (const i3 in e3.fallbackToUnicode) e3.toUnicode.has(i3) || (t3[i3] = e3.fallbackToUnicode[i3]);
  t3.length > 0 && e3.toUnicode.amend(t3);
}
function int16(e3, t3) {
  return (e3 << 8) + t3;
}
function writeSignedInt16(e3, t3, i3) {
  e3[t3 + 1] = i3, e3[t3] = i3 >>> 8;
}
function signedInt16(e3, t3) {
  const i3 = (e3 << 8) + t3;
  return 32768 & i3 ? i3 - 65536 : i3;
}
function string16(e3) {
  return String.fromCharCode(e3 >> 8 & 255, 255 & e3);
}
function safeString16(e3) {
  return e3 > 32767 ? e3 = 32767 : e3 < -32768 && (e3 = -32768), String.fromCharCode(e3 >> 8 & 255, 255 & e3);
}
function isTrueTypeCollectionFile(e3) {
  return "ttcf" === bytesToString(e3.peekBytes(4));
}
function getFontFileType(e3, { type: t3, subtype: i3, composite: a3 }) {
  let s3, n3;
  return function(e4) {
    const t4 = e4.peekBytes(4);
    return 65536 === readUint32(t4, 0) || "true" === bytesToString(t4);
  }(e3) || isTrueTypeCollectionFile(e3) ? s3 = a3 ? "CIDFontType2" : "TrueType" : !function(e4) {
    return "OTTO" === bytesToString(e4.peekBytes(4));
  }(e3) ? !function(e4) {
    const t4 = e4.peekBytes(2);
    return 37 === t4[0] && 33 === t4[1] || 128 === t4[0] && 1 === t4[1];
  }(e3) ? !function(e4) {
    const t4 = e4.peekBytes(4);
    return t4[0] >= 1 && t4[3] >= 1 && t4[3] <= 4;
  }(e3) ? (warn("getFontFileType: Unable to detect correct font file Type/Subtype."), s3 = t3, n3 = i3) : a3 ? (s3 = "CIDFontType0", n3 = "CIDFontType0C") : (s3 = "MMType1" === t3 ? "MMType1" : "Type1", n3 = "Type1C") : s3 = a3 ? "CIDFontType0" : "MMType1" === t3 ? "MMType1" : "Type1" : s3 = a3 ? "CIDFontType2" : "OpenType", [s3, n3];
}
function applyStandardFontGlyphMap(e3, t3) {
  for (const i3 in t3) e3[+i3] = t3[i3];
}
function buildToFontChar(e3, t3, i3) {
  const a3 = [];
  let s3;
  for (let i4 = 0, n3 = e3.length; i4 < n3; i4++) s3 = getUnicodeForGlyph(e3[i4], t3), -1 !== s3 && (a3[i4] = s3);
  for (const e4 in i3) s3 = getUnicodeForGlyph(i3[e4], t3), -1 !== s3 && (a3[+e4] = s3);
  return a3;
}
function isMacNameRecord(e3) {
  return 1 === e3.platform && 0 === e3.encoding && 0 === e3.language;
}
function isWinNameRecord(e3) {
  return 3 === e3.platform && 1 === e3.encoding && 1033 === e3.language;
}
function convertCidString(e3, t3, i3 = false) {
  switch (t3.length) {
    case 1:
      return t3.charCodeAt(0);
    case 2:
      return t3.charCodeAt(0) << 8 | t3.charCodeAt(1);
  }
  const a3 = `Unsupported CID string (charCode ${e3}): "${t3}".`;
  if (i3) throw new FormatError(a3);
  return warn(a3), t3;
}
function adjustMapping(e3, t3, i3, a3) {
  const s3 = /* @__PURE__ */ Object.create(null), n3 = /* @__PURE__ */ new Map(), r3 = [], o3 = /* @__PURE__ */ new Set();
  let g3 = 0;
  let c3 = Tr[g3][0], h3 = Tr[g3][1];
  const isInPrivateArea = (e4) => Tr[0][0] <= e4 && e4 <= Tr[0][1] || Tr[1][0] <= e4 && e4 <= Tr[1][1];
  for (const l3 in e3) {
    let C3 = e3[l3];
    if (!t3(C3)) continue;
    if (c3 > h3) {
      if (g3++, g3 >= Tr.length) {
        warn("Ran out of space in font private use area.");
        break;
      }
      c3 = Tr[g3][0], h3 = Tr[g3][1];
    }
    const d3 = c3++;
    0 === C3 && (C3 = i3);
    let u3 = a3.get(l3);
    "string" == typeof u3 && (u3 = u3.codePointAt(0)), !u3 || isInPrivateArea(u3) || o3.has(C3) || (n3.set(u3, C3), o3.add(C3)), s3[d3] = C3, r3[l3] = d3;
  }
  return { toFontChar: r3, charCodeToGlyphId: s3, toUnicodeExtraMap: n3, nextAvailableFontCharCode: c3 };
}
function createCmapTable(e3, t3, i3) {
  const a3 = function(e4, t4, i4) {
    const a4 = [];
    for (const t5 in e4) e4[t5] >= i4 || a4.push({ fontCharCode: 0 | t5, glyphId: e4[t5] });
    if (t4) for (const [e5, s5] of t4) s5 >= i4 || a4.push({ fontCharCode: e5, glyphId: s5 });
    0 === a4.length && a4.push({ fontCharCode: 0, glyphId: 0 }), a4.sort(function(e5, t5) {
      return e5.fontCharCode - t5.fontCharCode;
    });
    const s4 = [], n4 = a4.length;
    for (let e5 = 0; e5 < n4; ) {
      const t5 = a4[e5].fontCharCode, i5 = [a4[e5].glyphId];
      ++e5;
      let r4 = t5;
      for (; e5 < n4 && r4 + 1 === a4[e5].fontCharCode && (i5.push(a4[e5].glyphId), ++r4, ++e5, 65535 !== r4); ) ;
      s4.push([t5, r4, i5]);
    }
    return s4;
  }(e3, t3, i3), s3 = a3.at(-1)[1] > 65535 ? 2 : 1;
  let n3, r3, o3, g3, c3 = "\0\0" + string16(s3) + "\0\0" + string32(4 + 8 * s3);
  for (n3 = a3.length - 1; n3 >= 0 && !(a3[n3][0] <= 65535); --n3) ;
  const h3 = n3 + 1;
  a3[n3][0] < 65535 && 65535 === a3[n3][1] && (a3[n3][1] = 65534);
  const l3 = a3[n3][1] < 65535 ? 1 : 0, C3 = h3 + l3, d3 = OpenTypeFileBuilder.getSearchParams(C3, 2);
  let u3, Q3, f3, p3, m3 = "", y3 = "", w3 = "", b3 = "", D3 = "", S3 = 0;
  for (n3 = 0, r3 = h3; n3 < r3; n3++) {
    u3 = a3[n3], Q3 = u3[0], f3 = u3[1], m3 += string16(Q3), y3 += string16(f3), p3 = u3[2];
    let e4 = true;
    for (o3 = 1, g3 = p3.length; o3 < g3; ++o3) if (p3[o3] !== p3[o3 - 1] + 1) {
      e4 = false;
      break;
    }
    if (e4) {
      w3 += string16(p3[0] - Q3 & 65535), b3 += string16(0);
    } else {
      const e5 = 2 * (C3 - n3) + 2 * S3;
      for (S3 += f3 - Q3 + 1, w3 += string16(0), b3 += string16(e5), o3 = 0, g3 = p3.length; o3 < g3; ++o3) D3 += string16(p3[o3]);
    }
  }
  l3 > 0 && (y3 += "\xFF\xFF", m3 += "\xFF\xFF", w3 += "\0", b3 += "\0\0");
  const F3 = "\0\0" + string16(2 * C3) + string16(d3.range) + string16(d3.entry) + string16(d3.rangeShift) + y3 + "\0\0" + m3 + w3 + b3 + D3;
  let k3 = "", R3 = "";
  if (s3 > 1) {
    for (c3 += "\0\0\n" + string32(4 + 8 * s3 + 4 + F3.length), k3 = "", n3 = 0, r3 = a3.length; n3 < r3; n3++) {
      u3 = a3[n3], Q3 = u3[0], p3 = u3[2];
      let e4 = p3[0];
      for (o3 = 1, g3 = p3.length; o3 < g3; ++o3) p3[o3] !== p3[o3 - 1] + 1 && (f3 = u3[0] + o3 - 1, k3 += string32(Q3) + string32(f3) + string32(e4), Q3 = f3 + 1, e4 = p3[o3]);
      k3 += string32(Q3) + string32(u3[1]) + string32(e4);
    }
    R3 = "\0\f\0\0" + string32(k3.length + 16) + "\0\0\0\0" + string32(k3.length / 12);
  }
  return c3 + "\0" + string16(F3.length + 4) + F3 + R3 + k3;
}
function createOS2Table(e3, t3, i3) {
  i3 || (i3 = { unitsPerEm: 0, yMax: 0, yMin: 0, ascent: 0, descent: 0 });
  let a3 = 0, s3 = 0, n3 = 0, r3 = 0, o3 = null, g3 = 0, c3 = -1;
  if (t3) {
    for (let e4 in t3) if (e4 |= 0, (o3 > e4 || !o3) && (o3 = e4), g3 < e4 && (g3 = e4), c3 = getUnicodeRangeFor(e4, c3), c3 < 32) a3 |= 1 << c3;
    else if (c3 < 64) s3 |= 1 << c3 - 32;
    else if (c3 < 96) n3 |= 1 << c3 - 64;
    else {
      if (!(c3 < 123)) throw new FormatError("Unicode ranges Bits > 123 are reserved for internal usage");
      r3 |= 1 << c3 - 96;
    }
    g3 > 65535 && (g3 = 65535);
  } else o3 = 0, g3 = 255;
  const h3 = e3.bbox || [0, 0, 0, 0], l3 = i3.unitsPerEm || (e3.fontMatrix ? 1 / Math.max(...e3.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3), C3 = e3.ascentScaled ? 1 : l3 / Jr, d3 = i3.ascent || Math.round(C3 * (e3.ascent || h3[3]));
  let u3 = i3.descent || Math.round(C3 * (e3.descent || h3[1]));
  u3 > 0 && e3.descent > 0 && h3[1] < 0 && (u3 = -u3);
  const Q3 = i3.yMax || d3, f3 = -i3.yMin || -u3;
  return "\0$\xF4\0\0\0\x8A\xBB\0\0\0\x8C\x8A\xBB\0\0\xDF\x001\0\0\0\0" + String.fromCharCode(e3.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + string32(a3) + string32(s3) + string32(n3) + string32(r3) + "*21*" + string16(e3.italicAngle ? 1 : 0) + string16(o3 || e3.firstChar) + string16(g3 || e3.lastChar) + string16(d3) + string16(u3) + "\0d" + string16(Q3) + string16(f3) + "\0\0\0\0\0\0\0\0" + string16(e3.xHeight) + string16(e3.capHeight) + string16(0) + string16(o3 || e3.firstChar) + "\0";
}
function createPostTable(e3) {
  return "\0\0\0" + string32(Math.floor(65536 * e3.italicAngle)) + "\0\0\0\0" + string32(e3.fixedPitch ? 1 : 0) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
}
function createPostscriptName(e3) {
  return e3.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
}
function createNameTable(e3, t3) {
  t3 || (t3 = [[], []]);
  const i3 = [t3[0][0] || "Original licence", t3[0][1] || e3, t3[0][2] || "Unknown", t3[0][3] || "uniqueID", t3[0][4] || e3, t3[0][5] || "Version 0.11", t3[0][6] || createPostscriptName(e3), t3[0][7] || "Unknown", t3[0][8] || "Unknown", t3[0][9] || "Unknown"], a3 = [];
  let s3, n3, r3, o3, g3;
  for (s3 = 0, n3 = i3.length; s3 < n3; s3++) {
    g3 = t3[1][s3] || i3[s3];
    const e4 = [];
    for (r3 = 0, o3 = g3.length; r3 < o3; r3++) e4.push(string16(g3.charCodeAt(r3)));
    a3.push(e4.join(""));
  }
  const c3 = [i3, a3], h3 = ["\0", "\0"], l3 = ["\0\0", "\0"], C3 = ["\0\0", "	"], d3 = i3.length * h3.length;
  let u3 = "\0\0" + string16(d3) + string16(12 * d3 + 6), Q3 = 0;
  for (s3 = 0, n3 = h3.length; s3 < n3; s3++) {
    const e4 = c3[s3];
    for (r3 = 0, o3 = e4.length; r3 < o3; r3++) {
      g3 = e4[r3];
      u3 += h3[s3] + l3[s3] + C3[s3] + string16(r3) + string16(g3.length) + string16(Q3), Q3 += g3.length;
    }
  }
  return u3 += i3.join("") + a3.join(""), u3;
}
function getB(e3) {
  return Xr[e3] || (Xr[e3] = function(e4) {
    const t3 = [];
    for (let i3 = 0; i3 <= e4; i3++) {
      const a3 = i3 / e4, s3 = 1 - a3;
      t3.push(new Float32Array([s3 ** 3, 3 * a3 * s3 ** 2, 3 * a3 ** 2 * s3, a3 ** 3]));
    }
    return t3;
  }(e3));
}
function getTilingPatternIR(e3, t3, i3) {
  const a3 = lookupMatrix(t3.getArray("Matrix"), DA), s3 = lookupNormalRect(t3.getArray("BBox"), null);
  if (!s3 || s3[2] - s3[0] == 0 || s3[3] - s3[1] == 0) throw new FormatError("Invalid getTilingPatternIR /BBox array.");
  const n3 = t3.get("XStep");
  if ("number" != typeof n3) throw new FormatError("Invalid getTilingPatternIR /XStep value.");
  const r3 = t3.get("YStep");
  if ("number" != typeof r3) throw new FormatError("Invalid getTilingPatternIR /YStep value.");
  const o3 = t3.get("PaintType");
  if (!Number.isInteger(o3)) throw new FormatError("Invalid getTilingPatternIR /PaintType value.");
  const g3 = t3.get("TilingType");
  if (!Number.isInteger(g3)) throw new FormatError("Invalid getTilingPatternIR /TilingType value.");
  return ["TilingPattern", i3, e3, a3, s3, n3, r3, o3, g3];
}
function getXfaFontName(e3) {
  const t3 = normalizeFontName(e3);
  return Uo()[t3];
}
function getXfaFontDict(e3) {
  const t3 = function(e4) {
    const t4 = getXfaFontName(e4);
    if (!t4) return null;
    const { baseWidths: i4, baseMapping: a4, factors: s4 } = t4, n3 = s4 ? i4.map((e5, t5) => e5 * s4[t5]) : i4;
    let r3, o3 = -2;
    const g3 = [];
    for (const [e5, t5] of a4.map((e6, t6) => [e6, t6]).sort(([e6], [t6]) => e6 - t6)) -1 !== e5 && (e5 === o3 + 1 ? (r3.push(n3[t5]), o3 += 1) : (o3 = e5, r3 = [n3[t5]], g3.push(e5, r3)));
    return g3;
  }(e3), i3 = new Dict(null);
  i3.set("BaseFont", Name.get(e3)), i3.set("Type", Name.get("Font")), i3.set("Subtype", Name.get("CIDFontType2")), i3.set("Encoding", Name.get("Identity-H")), i3.set("CIDToGIDMap", Name.get("Identity")), i3.set("W", t3), i3.set("FirstChar", t3[0]), i3.set("LastChar", t3.at(-2) + t3.at(-1).length - 1);
  const a3 = new Dict(null);
  i3.set("FontDescriptor", a3);
  const s3 = new Dict(null);
  return s3.set("Ordering", "Identity"), s3.set("Registry", "Adobe"), s3.set("Supplement", 0), i3.set("CIDSystemInfo", s3), i3;
}
function toNumberArray(e3) {
  return Array.isArray(e3) ? isNumberArray(e3, null) ? e3 : e3.map((e4) => +e4) : null;
}
function isPDFFunction(e3) {
  let t3;
  if (e3 instanceof Dict) t3 = e3;
  else {
    if (!(e3 instanceof BaseStream)) return false;
    t3 = e3.dict;
  }
  return t3.has("FunctionType");
}
function buildAddOperation(e3, t3) {
  return "literal" === t3.type && 0 === t3.number ? e3 : "literal" === e3.type && 0 === e3.number ? t3 : "literal" === t3.type && "literal" === e3.type ? new AstLiteral(e3.number + t3.number) : new AstBinaryOperation("+", e3, t3, e3.min + t3.min, e3.max + t3.max);
}
function buildMulOperation(e3, t3) {
  if ("literal" === t3.type) {
    if (0 === t3.number) return new AstLiteral(0);
    if (1 === t3.number) return e3;
    if ("literal" === e3.type) return new AstLiteral(e3.number * t3.number);
  }
  if ("literal" === e3.type) {
    if (0 === e3.number) return new AstLiteral(0);
    if (1 === e3.number) return t3;
  }
  const i3 = Math.min(e3.min * t3.min, e3.min * t3.max, e3.max * t3.min, e3.max * t3.max), a3 = Math.max(e3.min * t3.min, e3.min * t3.max, e3.max * t3.min, e3.max * t3.max);
  return new AstBinaryOperation("*", e3, t3, i3, a3);
}
function buildSubOperation(e3, t3) {
  if ("literal" === t3.type) {
    if (0 === t3.number) return e3;
    if ("literal" === e3.type) return new AstLiteral(e3.number - t3.number);
  }
  return "binary" === t3.type && "-" === t3.op && "literal" === e3.type && 1 === e3.number && "literal" === t3.arg1.type && 1 === t3.arg1.number ? t3.arg2 : new AstBinaryOperation("-", e3, t3, e3.min - t3.max, e3.max - t3.min);
}
function buildMinOperation(e3, t3) {
  return e3.min >= t3 ? new AstLiteral(t3) : e3.max <= t3 ? e3 : new AstMin(e3, t3);
}
function isOdd(e3) {
  return !!(1 & e3);
}
function isEven(e3) {
  return !(1 & e3);
}
function findUnequal(e3, t3, i3) {
  let a3, s3;
  for (a3 = t3, s3 = e3.length; a3 < s3; ++a3) if (e3[a3] !== i3) return a3;
  return a3;
}
function setValues(e3, t3, i3, a3) {
  for (let s3 = t3; s3 < i3; ++s3) e3[s3] = a3;
}
function reverseValues(e3, t3, i3) {
  for (let a3 = t3, s3 = i3 - 1; a3 < s3; ++a3, --s3) {
    const t4 = e3[a3];
    e3[a3] = e3[s3], e3[s3] = t4;
  }
}
function createBidiText(e3, t3, i3 = false) {
  let a3 = "ltr";
  return i3 ? a3 = "ttb" : t3 || (a3 = "rtl"), { str: e3, dir: a3 };
}
function bidi(e3, t3 = -1, i3 = false) {
  let a3 = true;
  const s3 = e3.length;
  if (0 === s3 || i3) return createBidiText(e3, a3, i3);
  Po.length = s3, Oo.length = s3;
  let n3, r3, o3 = 0;
  for (n3 = 0; n3 < s3; ++n3) {
    Po[n3] = e3.charAt(n3);
    const t4 = e3.charCodeAt(n3);
    let i4 = "L";
    t4 <= 255 ? i4 = Jo[t4] : 1424 <= t4 && t4 <= 1524 ? i4 = "R" : 1536 <= t4 && t4 <= 1791 ? (i4 = Yo[255 & t4], i4 || warn("Bidi: invalid Unicode character " + t4.toString(16))) : (1792 <= t4 && t4 <= 2220 || 64336 <= t4 && t4 <= 65023 || 65136 <= t4 && t4 <= 65279) && (i4 = "AL"), "R" !== i4 && "AL" !== i4 && "AN" !== i4 || o3++, Oo[n3] = i4;
  }
  if (0 === o3) return a3 = true, createBidiText(e3, a3);
  -1 === t3 && (o3 / s3 < 0.3 && s3 > 4 ? (a3 = true, t3 = 0) : (a3 = false, t3 = 1));
  const g3 = [];
  for (n3 = 0; n3 < s3; ++n3) g3[n3] = t3;
  const c3 = isOdd(t3) ? "R" : "L", h3 = c3, l3 = h3;
  let C3, d3 = h3;
  for (n3 = 0; n3 < s3; ++n3) "NSM" === Oo[n3] ? Oo[n3] = d3 : d3 = Oo[n3];
  for (d3 = h3, n3 = 0; n3 < s3; ++n3) C3 = Oo[n3], "EN" === C3 ? Oo[n3] = "AL" === d3 ? "AN" : "EN" : "R" !== C3 && "L" !== C3 && "AL" !== C3 || (d3 = C3);
  for (n3 = 0; n3 < s3; ++n3) C3 = Oo[n3], "AL" === C3 && (Oo[n3] = "R");
  for (n3 = 1; n3 < s3 - 1; ++n3) "ES" === Oo[n3] && "EN" === Oo[n3 - 1] && "EN" === Oo[n3 + 1] && (Oo[n3] = "EN"), "CS" !== Oo[n3] || "EN" !== Oo[n3 - 1] && "AN" !== Oo[n3 - 1] || Oo[n3 + 1] !== Oo[n3 - 1] || (Oo[n3] = Oo[n3 - 1]);
  for (n3 = 0; n3 < s3; ++n3) if ("EN" === Oo[n3]) {
    for (let e4 = n3 - 1; e4 >= 0 && "ET" === Oo[e4]; --e4) Oo[e4] = "EN";
    for (let e4 = n3 + 1; e4 < s3 && "ET" === Oo[e4]; ++e4) Oo[e4] = "EN";
  }
  for (n3 = 0; n3 < s3; ++n3) C3 = Oo[n3], "WS" !== C3 && "ES" !== C3 && "ET" !== C3 && "CS" !== C3 || (Oo[n3] = "ON");
  for (d3 = h3, n3 = 0; n3 < s3; ++n3) C3 = Oo[n3], "EN" === C3 ? Oo[n3] = "L" === d3 ? "L" : "EN" : "R" !== C3 && "L" !== C3 || (d3 = C3);
  for (n3 = 0; n3 < s3; ++n3) if ("ON" === Oo[n3]) {
    const e4 = findUnequal(Oo, n3 + 1, "ON");
    let t4 = h3;
    n3 > 0 && (t4 = Oo[n3 - 1]);
    let i4 = l3;
    e4 + 1 < s3 && (i4 = Oo[e4 + 1]), "L" !== t4 && (t4 = "R"), "L" !== i4 && (i4 = "R"), t4 === i4 && setValues(Oo, n3, e4, t4), n3 = e4 - 1;
  }
  for (n3 = 0; n3 < s3; ++n3) "ON" === Oo[n3] && (Oo[n3] = c3);
  for (n3 = 0; n3 < s3; ++n3) C3 = Oo[n3], isEven(g3[n3]) ? "R" === C3 ? g3[n3] += 1 : "AN" !== C3 && "EN" !== C3 || (g3[n3] += 2) : "L" !== C3 && "AN" !== C3 && "EN" !== C3 || (g3[n3] += 1);
  let u3, Q3 = -1, f3 = 99;
  for (n3 = 0, r3 = g3.length; n3 < r3; ++n3) u3 = g3[n3], Q3 < u3 && (Q3 = u3), f3 > u3 && isOdd(u3) && (f3 = u3);
  for (u3 = Q3; u3 >= f3; --u3) {
    let e4 = -1;
    for (n3 = 0, r3 = g3.length; n3 < r3; ++n3) g3[n3] < u3 ? e4 >= 0 && (reverseValues(Po, e4, n3), e4 = -1) : e4 < 0 && (e4 = n3);
    e4 >= 0 && reverseValues(Po, e4, g3.length);
  }
  for (n3 = 0, r3 = Po.length; n3 < r3; ++n3) {
    const e4 = Po[n3];
    "<" !== e4 && ">" !== e4 || (Po[n3] = "");
  }
  return createBidiText(Po.join(""), a3);
}
function getFamilyName(e3) {
  const t3 = /* @__PURE__ */ new Set(["thin", "extralight", "ultralight", "demilight", "semilight", "light", "book", "regular", "normal", "medium", "demibold", "semibold", "bold", "extrabold", "ultrabold", "black", "heavy", "extrablack", "ultrablack", "roman", "italic", "oblique", "ultracondensed", "extracondensed", "condensed", "semicondensed", "normal", "semiexpanded", "expanded", "extraexpanded", "ultraexpanded", "bolditalic"]);
  return e3.split(/[- ,+]+/g).filter((e4) => !t3.has(e4.toLowerCase())).join(" ");
}
function generateFont({ alias: e3, local: t3, path: i3, fallback: a3, style: s3, ultimate: n3 }, r3, o3, g3 = true, c3 = true, h3 = "") {
  const l3 = { style: null, ultimate: null };
  if (t3) {
    const e4 = h3 ? ` ${h3}` : "";
    for (const i4 of t3) r3.push(`local(${i4}${e4})`);
  }
  if (e3) {
    const t4 = jo.get(e3), n4 = h3 || function(e4) {
      switch (e4) {
        case qo:
          return "Bold";
        case _o2:
          return "Italic";
        case Wo:
          return "Bold Italic";
        default:
          if ("bold" === e4?.weight) return "Bold";
          if ("italic" === e4?.style) return "Italic";
      }
      return "";
    }(s3);
    Object.assign(l3, generateFont(t4, r3, o3, g3 && !a3, c3 && !i3, n4));
  }
  if (s3 && (l3.style = s3), n3 && (l3.ultimate = n3), g3 && a3) {
    const e4 = jo.get(a3), { ultimate: t4 } = generateFont(e4, r3, o3, g3, c3 && !i3, h3);
    l3.ultimate || (l3.ultimate = t4);
  }
  return c3 && i3 && o3 && r3.push(`url(${o3}${i3})`), l3;
}
function getFontSubstitution(e3, t3, i3, a3, s3, n3) {
  if (a3.startsWith("InvalidPDFjsFont_")) return null;
  "TrueType" !== n3 && "Type1" !== n3 || !/^[A-Z]{6}\+/.test(a3) || (a3 = a3.slice(7));
  const r3 = a3 = normalizeFontName(a3);
  let o3 = e3.get(r3);
  if (o3) return o3;
  let g3 = jo.get(a3);
  if (!g3) {
    for (const [e4, t4] of Xo) if (a3.startsWith(e4)) {
      a3 = `${t4}${a3.substring(e4.length)}`, g3 = jo.get(a3);
      break;
    }
  }
  let c3 = false;
  g3 || (g3 = jo.get(s3), c3 = true);
  const h3 = `${t3.getDocId()}_s${t3.createFontId()}`;
  if (!g3) {
    if (!validateFontName(a3)) return warn(`Cannot substitute the font because of its name: ${a3}`), e3.set(r3, null), null;
    const t4 = /bold/gi.test(a3), i4 = /oblique|italic/gi.test(a3), s4 = t4 && i4 && Wo || t4 && qo || i4 && _o2 || Ko;
    return o3 = { css: `"${getFamilyName(a3)}",${h3}`, guessFallback: true, loadedName: h3, baseFontName: a3, src: `local(${a3})`, style: s4 }, e3.set(r3, o3), o3;
  }
  const l3 = [];
  c3 && validateFontName(a3) && l3.push(`local(${a3})`);
  const { style: C3, ultimate: d3 } = generateFont(g3, l3, i3), u3 = null === d3, Q3 = u3 ? "" : `,${d3}`;
  return o3 = { css: `"${getFamilyName(a3)}",${h3}${Q3}`, guessFallback: u3, loadedName: h3, baseFontName: a3, src: l3.join(","), style: C3 }, e3.set(r3, o3), o3;
}
function addState(e3, t3, i3, a3, s3) {
  let n3 = e3;
  for (let e4 = 0, i4 = t3.length - 1; e4 < i4; e4++) {
    const i5 = t3[e4];
    n3 = n3[i5] || (n3[i5] = []);
  }
  n3[t3.at(-1)] = { checkFn: i3, iterateFn: a3, processFn: s3 };
}
function decodeAndClamp(e3, t3, i3, a3) {
  return (e3 = t3 + e3 * i3) < 0 ? e3 = 0 : e3 > a3 && (e3 = a3), e3;
}
function resizeImageMask(e3, t3, i3, a3, s3, n3) {
  const r3 = s3 * n3;
  let o3;
  o3 = t3 <= 8 ? new Uint8Array(r3) : t3 <= 16 ? new Uint16Array(r3) : new Uint32Array(r3);
  const g3 = i3 / s3, c3 = a3 / n3;
  let h3, l3, C3, d3, u3 = 0;
  const Q3 = new Uint16Array(s3), f3 = i3;
  for (h3 = 0; h3 < s3; h3++) Q3[h3] = Math.floor(h3 * g3);
  for (h3 = 0; h3 < n3; h3++) for (C3 = Math.floor(h3 * c3) * f3, l3 = 0; l3 < s3; l3++) d3 = C3 + Q3[l3], o3[u3++] = e3[d3];
  return o3;
}
function normalizeBlendMode(e3, t3 = false) {
  if (Array.isArray(e3)) {
    for (const t4 of e3) {
      const e4 = normalizeBlendMode(t4, true);
      if (e4) return e4;
    }
    return warn(`Unsupported blend mode Array: ${e3}`), "source-over";
  }
  if (!(e3 instanceof Name)) return t3 ? null : "source-over";
  switch (e3.name) {
    case "Normal":
    case "Compatible":
      return "source-over";
    case "Multiply":
      return "multiply";
    case "Screen":
      return "screen";
    case "Overlay":
      return "overlay";
    case "Darken":
      return "darken";
    case "Lighten":
      return "lighten";
    case "ColorDodge":
      return "color-dodge";
    case "ColorBurn":
      return "color-burn";
    case "HardLight":
      return "hard-light";
    case "SoftLight":
      return "soft-light";
    case "Difference":
      return "difference";
    case "Exclusion":
      return "exclusion";
    case "Hue":
      return "hue";
    case "Saturation":
      return "saturation";
    case "Color":
      return "color";
    case "Luminosity":
      return "luminosity";
  }
  return t3 ? null : (warn(`Unsupported blend mode: ${e3.name}`), "source-over");
}
function addLocallyCachedImageOps(e3, t3) {
  t3.objId && e3.addDependency(t3.objId), e3.addImageOps(t3.fn, t3.args, t3.optionalContent), t3.fn === Es && t3.args[0]?.count > 0 && t3.args[0].count++;
}
function parseDefaultAppearance(e3) {
  return new DefaultAppearanceEvaluator(e3).parse();
}
function getPdfColor(e3, t3) {
  if (e3[0] === e3[1] && e3[1] === e3[2]) {
    return `${numberToString(e3[0] / 255)} ${t3 ? "g" : "G"}`;
  }
  return Array.from(e3, (e4) => numberToString(e4 / 255)).join(" ") + " " + (t3 ? "rg" : "RG");
}
function clearGlobalCaches() {
  Xr = /* @__PURE__ */ Object.create(null), Vs = /* @__PURE__ */ Object.create(null), Zs = /* @__PURE__ */ Object.create(null), zs = /* @__PURE__ */ Object.create(null), or.clear(), JpxImage.cleanup();
}
function pickPlatformItem(e3) {
  return e3 instanceof Dict ? e3.has("UF") ? e3.get("UF") : e3.has("F") ? e3.get("F") : e3.has("Unix") ? e3.get("Unix") : e3.has("Mac") ? e3.get("Mac") : e3.has("DOS") ? e3.get("DOS") : null : null;
}
function isWhitespace(e3, t3) {
  const i3 = e3[t3];
  return " " === i3 || "\n" === i3 || "\r" === i3 || "	" === i3;
}
async function writeObject(e3, t3, i3, { encrypt: a3 = null }) {
  const s3 = a3?.createCipherTransform(e3.num, e3.gen);
  i3.push(`${e3.num} ${e3.gen} obj
`), t3 instanceof Dict ? await writeDict(t3, i3, s3) : t3 instanceof BaseStream ? await writeStream(t3, i3, s3) : (Array.isArray(t3) || ArrayBuffer.isView(t3)) && await writeArray(t3, i3, s3), i3.push("\nendobj\n");
}
async function writeDict(e3, t3, i3) {
  t3.push("<<");
  for (const a3 of e3.getKeys()) t3.push(` /${escapePDFName(a3)} `), await writeValue(e3.getRaw(a3), t3, i3);
  t3.push(">>");
}
async function writeStream(e3, t3, i3) {
  let a3 = e3.getBytes();
  const { dict: s3 } = e3, [n3, r3] = await Promise.all([s3.getAsync("Filter"), s3.getAsync("DecodeParms")]), o3 = isName(Array.isArray(n3) ? await s3.xref.fetchIfRefAsync(n3[0]) : n3, "FlateDecode");
  if (a3.length >= 256 || o3) try {
    const e4 = new CompressionStream("deflate"), t4 = e4.writable.getWriter();
    t4.write(a3), t4.close();
    const i4 = await new Response(e4.readable).arrayBuffer();
    let g4, c3;
    a3 = new Uint8Array(i4), n3 ? o3 || (g4 = Array.isArray(n3) ? [Name.get("FlateDecode"), ...n3] : [Name.get("FlateDecode"), n3], r3 && (c3 = Array.isArray(r3) ? [null, ...r3] : [null, r3])) : g4 = Name.get("FlateDecode"), g4 && s3.set("Filter", g4), c3 && s3.set("DecodeParms", c3);
  } catch (e4) {
    info(`writeStream - cannot compress data: "${e4}".`);
  }
  let g3 = bytesToString(a3);
  i3 && (g3 = i3.encryptString(g3)), s3.set("Length", g3.length), await writeDict(s3, t3, i3), t3.push(" stream\n", g3, "\nendstream");
}
async function writeArray(e3, t3, i3) {
  t3.push("[");
  let a3 = true;
  for (const s3 of e3) a3 ? a3 = false : t3.push(" "), await writeValue(s3, t3, i3);
  t3.push("]");
}
async function writeValue(e3, t3, i3) {
  e3 instanceof Name ? t3.push(`/${escapePDFName(e3.name)}`) : e3 instanceof Ref ? t3.push(`${e3.num} ${e3.gen} R`) : Array.isArray(e3) || ArrayBuffer.isView(e3) ? await writeArray(e3, t3, i3) : "string" == typeof e3 ? (i3 && (e3 = i3.encryptString(e3)), t3.push(`(${escapeString(e3)})`)) : "number" == typeof e3 ? t3.push(numberToString(e3)) : "boolean" == typeof e3 ? t3.push(e3.toString()) : e3 instanceof Dict ? await writeDict(e3, t3, i3) : e3 instanceof BaseStream ? await writeStream(e3, t3, i3) : null === e3 ? t3.push("null") : warn(`Unhandled value in writer: ${typeof e3}, please file a bug.`);
}
function writeInt(e3, t3, i3, a3) {
  for (let s3 = t3 + i3 - 1; s3 > i3 - 1; s3--) a3[s3] = 255 & e3, e3 >>= 8;
  return i3 + t3;
}
function writeString(e3, t3, i3) {
  for (let a3 = 0, s3 = e3.length; a3 < s3; a3++) i3[t3 + a3] = 255 & e3.charCodeAt(a3);
}
function updateXFA({ xfaData: e3, xfaDatasetsRef: t3, newRefs: i3, xref: a3 }) {
  if (null === e3) {
    e3 = function(e4, t4) {
      const i4 = new SimpleXMLParser({ hasAttributes: true }).parseFromString(e4);
      for (const { xfa: e5 } of t4) {
        if (!e5) continue;
        const { path: t5, value: a5 } = e5;
        if (!t5) continue;
        const s4 = parseXFAPath(t5);
        let n4 = i4.documentElement.searchNode(s4, 0);
        !n4 && s4.length > 1 && (n4 = i4.documentElement.searchNode([s4.at(-1)], 0)), n4 ? n4.childNodes = Array.isArray(a5) ? a5.map((e6) => new SimpleDOMNode("value", e6)) : [new SimpleDOMNode("#text", a5)] : warn(`Node not found for path: ${t5}`);
      }
      const a4 = [];
      return i4.documentElement.dump(a4), a4.join("");
    }(a3.fetchIfRef(t3).getString(), i3);
  }
  const s3 = a3.encrypt;
  if (s3) {
    e3 = s3.createCipherTransform(t3.num, t3.gen).encryptString(e3);
  }
  const n3 = `${t3.num} ${t3.gen} obj
<< /Type /EmbeddedFile /Length ${e3.length}>>
stream
` + e3 + "\nendstream\nendobj\n";
  i3.push({ ref: t3, data: n3 });
}
function getIndexes(e3) {
  const t3 = [];
  for (const { ref: i3 } of e3) i3.num === t3.at(-2) + t3.at(-1) ? t3[t3.length - 1] += 1 : t3.push(i3.num, 1);
  return t3;
}
function computeIDs(e3, t3, i3) {
  if (Array.isArray(t3.fileIds) && t3.fileIds.length > 0) {
    const a3 = function(e4, t4) {
      const i4 = Math.floor(Date.now() / 1e3), a4 = t4.filename || "", s3 = [i4.toString(), a4, e4.toString()];
      let n3 = s3.reduce((e5, t5) => e5 + t5.length, 0);
      for (const e5 of Object.values(t4.info)) s3.push(e5), n3 += e5.length;
      const r3 = new Uint8Array(n3);
      let o3 = 0;
      for (const e5 of s3) writeString(e5, o3, r3), o3 += e5.length;
      return bytesToString(hg(r3));
    }(e3, t3);
    i3.set("ID", [t3.fileIds[0], a3]);
  }
}
async function incrementalUpdate({ originalData: e3, xrefInfo: t3, newRefs: i3, xref: a3 = null, hasXfa: s3 = false, xfaDatasetsRef: n3 = null, hasXfaDatasetsEntry: r3 = false, needAppearances: o3, acroFormRef: g3 = null, acroForm: c3 = null, xfaData: h3 = null, useXrefStream: l3 = false }) {
  await async function({ xref: e4, acroForm: t4, acroFormRef: i4, hasXfa: a4, hasXfaDatasetsEntry: s4, xfaDatasetsRef: n4, needAppearances: r4, newRefs: o4 }) {
    if (!a4 || s4 || n4 || warn("XFA - Cannot save it"), !r4 && (!a4 || !n4 || s4)) return;
    const g4 = t4.clone();
    if (a4 && !s4) {
      const e5 = t4.get("XFA").slice();
      e5.splice(2, 0, "datasets"), e5.splice(3, 0, n4), g4.set("XFA", e5);
    }
    r4 && g4.set("NeedAppearances", true);
    const c4 = [];
    await writeObject(i4, g4, c4, e4), o4.push({ ref: i4, data: c4.join("") });
  }({ xref: a3, acroForm: c3, acroFormRef: g3, hasXfa: s3, hasXfaDatasetsEntry: r3, xfaDatasetsRef: n3, needAppearances: o3, newRefs: i3 }), s3 && updateXFA({ xfaData: h3, xfaDatasetsRef: n3, newRefs: i3, xref: a3 });
  const C3 = [];
  let d3 = e3.length;
  const u3 = e3.at(-1);
  10 !== u3 && 13 !== u3 && (C3.push("\n"), d3 += 1);
  const Q3 = function(e4, t4, i4) {
    const a4 = new Dict(null);
    a4.set("Prev", e4.startXRef);
    const s4 = e4.newRef;
    return i4 ? (t4.push({ ref: s4, data: "" }), a4.set("Size", s4.num + 1), a4.set("Type", Name.get("XRef"))) : a4.set("Size", s4.num), null !== e4.rootRef && a4.set("Root", e4.rootRef), null !== e4.infoRef && a4.set("Info", e4.infoRef), null !== e4.encryptRef && a4.set("Encrypt", e4.encryptRef), a4;
  }(t3, i3, l3);
  i3 = i3.sort((e4, t4) => e4.ref.num - t4.ref.num);
  for (const { data: e4 } of i3) null !== e4 && C3.push(e4);
  await (l3 ? async function(e4, t4, i4, a4, s4) {
    const n4 = [];
    let r4 = 0, o4 = 0;
    for (const { ref: e5, data: a5 } of i4) {
      let i5;
      r4 = Math.max(r4, t4), null !== a5 ? (i5 = Math.min(e5.gen, 65535), n4.push([1, t4, i5]), t4 += a5.length) : (i5 = Math.min(e5.gen + 1, 65535), n4.push([0, 0, i5])), o4 = Math.max(o4, i5);
    }
    a4.set("Index", getIndexes(i4));
    const g4 = [1, getSizeInBytes(r4), getSizeInBytes(o4)];
    a4.set("W", g4), computeIDs(t4, e4, a4);
    const c4 = g4.reduce((e5, t5) => e5 + t5, 0), h4 = new Uint8Array(c4 * n4.length), l4 = new Stream(h4);
    l4.dict = a4;
    let C4 = 0;
    for (const [e5, t5, i5] of n4) C4 = writeInt(e5, g4[0], C4, h4), C4 = writeInt(t5, g4[1], C4, h4), C4 = writeInt(i5, g4[2], C4, h4);
    await writeObject(e4.newRef, l4, s4, {}), s4.push("startxref\n", t4.toString(), "\n%%EOF\n");
  }(t3, d3, i3, Q3, C3) : async function(e4, t4, i4, a4, s4) {
    s4.push("xref\n");
    const n4 = getIndexes(i4);
    let r4 = 0;
    for (const { ref: e5, data: a5 } of i4) e5.num === n4[r4] && (s4.push(`${n4[r4]} ${n4[r4 + 1]}
`), r4 += 2), null !== a5 ? (s4.push(`${t4.toString().padStart(10, "0")} ${Math.min(e5.gen, 65535).toString().padStart(5, "0")} n\r
`), t4 += a5.length) : s4.push(`0000000000 ${Math.min(e5.gen + 1, 65535).toString().padStart(5, "0")} f\r
`);
    computeIDs(t4, e4, a4), s4.push("trailer\n"), await writeDict(a4, s4), s4.push("\nstartxref\n", t4.toString(), "\n%%EOF\n");
  }(t3, d3, i3, Q3, C3));
  const f3 = C3.reduce((e4, t4) => e4 + t4.length, e3.length), p3 = new Uint8Array(f3);
  p3.set(e3);
  let m3 = e3.length;
  for (const e4 of C3) writeString(e4, m3, p3), m3 += e4.length;
  return p3;
}
function isValidExplicitDest(e3) {
  if (!Array.isArray(e3) || e3.length < 2) return false;
  const [t3, i3, ...a3] = e3;
  if (!(t3 instanceof Ref || Number.isInteger(t3))) return false;
  if (!(i3 instanceof Name)) return false;
  const s3 = a3.length;
  let n3 = true;
  switch (i3.name) {
    case "XYZ":
      if (s3 < 2 || s3 > 3) return false;
      break;
    case "Fit":
    case "FitB":
      return 0 === s3;
    case "FitH":
    case "FitBH":
    case "FitV":
    case "FitBV":
      if (s3 > 1) return false;
      break;
    case "FitR":
      if (4 !== s3) return false;
      n3 = false;
      break;
    default:
      return false;
  }
  for (const e4 of a3) if (!("number" == typeof e4 || n3 && null === e4)) return false;
  return true;
}
function fetchDest(e3) {
  return e3 instanceof Dict && (e3 = e3.get("D")), isValidExplicitDest(e3) ? e3 : null;
}
function fetchRemoteDest(e3) {
  let t3 = e3.get("D");
  if (t3) {
    if (t3 instanceof Name && (t3 = t3.name), "string" == typeof t3) return stringToPDFString(t3);
    if (isValidExplicitDest(t3)) return JSON.stringify(t3);
  }
  return null;
}
function addChildren(e3, t3) {
  if (e3 instanceof Dict) e3 = e3.getRawValues();
  else if (e3 instanceof BaseStream) e3 = e3.dict.getRawValues();
  else if (!Array.isArray(e3)) return;
  for (const a3 of e3) ((i3 = a3) instanceof Ref || i3 instanceof Dict || i3 instanceof BaseStream || Array.isArray(i3)) && t3.push(a3);
  var i3;
}
function stripQuotes(e3) {
  return e3.startsWith("'") || e3.startsWith('"') ? e3.slice(1, -1) : e3;
}
function getInteger({ data: e3, defaultValue: t3, validate: i3 }) {
  if (!e3) return t3;
  e3 = e3.trim();
  const a3 = parseInt(e3, 10);
  return !isNaN(a3) && i3(a3) ? a3 : t3;
}
function getFloat({ data: e3, defaultValue: t3, validate: i3 }) {
  if (!e3) return t3;
  e3 = e3.trim();
  const a3 = parseFloat(e3);
  return !isNaN(a3) && i3(a3) ? a3 : t3;
}
function getKeyword({ data: e3, defaultValue: t3, validate: i3 }) {
  return e3 && i3(e3 = e3.trim()) ? e3 : t3;
}
function getStringOption(e3, t3) {
  return getKeyword({ data: e3, defaultValue: t3[0], validate: (e4) => t3.includes(e4) });
}
function getMeasurement(e3, t3 = "0") {
  if (t3 || (t3 = "0"), !e3) return getMeasurement(t3);
  const i3 = e3.trim().match(Lc);
  if (!i3) return getMeasurement(t3);
  const [, a3, s3] = i3, n3 = parseFloat(a3);
  if (isNaN(n3)) return getMeasurement(t3);
  if (0 === n3) return 0;
  const r3 = vc[s3];
  return r3 ? r3(n3) : n3;
}
function getRatio(e3) {
  if (!e3) return { num: 1, den: 1 };
  const t3 = e3.trim().split(/\s*:\s*/).map((e4) => parseFloat(e4)).filter((e4) => !isNaN(e4));
  if (1 === t3.length && t3.push(1), 0 === t3.length) return { num: 1, den: 1 };
  const [i3, a3] = t3;
  return { num: i3, den: a3 };
}
function getRelevant(e3) {
  return e3 ? e3.trim().split(/\s+/).map((e4) => ({ excluded: "-" === e4[0], viewname: e4.substring(1) })) : [];
}
function selectFont(e3, t3) {
  return "italic" === e3.posture ? "bold" === e3.weight ? t3.bolditalic : t3.italic : "bold" === e3.weight ? t3.bold : t3.regular;
}
function parseIndex(e3) {
  return "*" === (e3 = e3.trim()) ? 1 / 0 : parseInt(e3, 10) || 0;
}
function parseExpression(e3, t3, i3 = true) {
  let a3 = e3.match(Uc);
  if (!a3) return null;
  let [s3] = a3;
  const n3 = [{ name: s3, cacheName: "." + s3, index: 0, js: null, formCalc: null, operator: Tc }];
  let r3 = s3.length;
  for (; r3 < e3.length; ) {
    const o3 = r3;
    if ("[" === e3.charAt(r3++)) {
      if (a3 = e3.slice(r3).match(Hc), !a3) return warn("XFA - Invalid index in SOM expression"), null;
      n3.at(-1).index = parseIndex(a3[0]), r3 += a3[0].length + 1;
      continue;
    }
    let g3;
    switch (e3.charAt(r3)) {
      case ".":
        if (!t3) return null;
        r3++, g3 = Jc;
        break;
      case "#":
        r3++, g3 = Yc;
        break;
      case "[":
        if (i3) return warn("XFA - SOM expression contains a FormCalc subexpression which is not supported for now."), null;
        g3 = Pc;
        break;
      case "(":
        if (i3) return warn("XFA - SOM expression contains a JavaScript subexpression which is not supported for now."), null;
        g3 = Oc;
        break;
      default:
        g3 = Tc;
    }
    if (a3 = e3.slice(r3).match(Uc), !a3) break;
    [s3] = a3, r3 += s3.length, n3.push({ name: s3, cacheName: e3.slice(o3, r3), operator: g3, index: 0, js: null, formCalc: null });
  }
  return n3;
}
function searchNode(e3, t3, i3, a3 = true, s3 = true) {
  const n3 = parseExpression(i3, a3);
  if (!n3) return null;
  const r3 = Kc.get(n3[0].name);
  let o3, g3 = 0;
  r3 ? (o3 = true, e3 = [r3(e3, t3)], g3 = 1) : (o3 = null === t3, e3 = [t3 || e3]);
  for (let i4 = n3.length; g3 < i4; g3++) {
    const { name: i5, cacheName: a4, operator: r4, index: c3 } = n3[g3], h3 = [];
    for (const t4 of e3) {
      if (!t4.isXFAObject) continue;
      let e4, n4;
      if (s3 && (n4 = qc.get(t4), n4 || (n4 = /* @__PURE__ */ new Map(), qc.set(t4, n4)), e4 = n4.get(a4)), !e4) {
        switch (r4) {
          case Tc:
            e4 = t4[Hg](i5, false);
            break;
          case Jc:
            e4 = t4[Hg](i5, true);
            break;
          case Yc:
            e4 = t4[Ug](i5), e4 = e4.isXFAObjectArray ? e4.children : [e4];
        }
        s3 && n4.set(a4, e4);
      }
      e4.length > 0 && h3.push(e4);
    }
    if (0 !== h3.length || o3 || 0 !== g3) e3 = isFinite(c3) ? h3.filter((e4) => c3 < e4.length).map((e4) => e4[c3]) : h3.flat();
    else {
      const i6 = t3[Wg]();
      if (!(t3 = i6)) return null;
      g3 = -1, e3 = [t3];
    }
  }
  return 0 === e3.length ? null : e3;
}
function createDataNode(e3, t3, i3) {
  const a3 = parseExpression(i3);
  if (!a3) return null;
  if (a3.some((e4) => e4.operator === Jc)) return null;
  const s3 = Kc.get(a3[0].name);
  let n3 = 0;
  s3 ? (e3 = s3(e3, t3), n3 = 1) : e3 = t3 || e3;
  for (let t4 = a3.length; n3 < t4; n3++) {
    const { name: t5, operator: i4, index: s4 } = a3[n3];
    if (!isFinite(s4)) return a3[n3].index = 0, e3.createNodes(a3.slice(n3));
    let r3;
    switch (i4) {
      case Tc:
        r3 = e3[Hg](t5, false);
        break;
      case Jc:
        r3 = e3[Hg](t5, true);
        break;
      case Yc:
        r3 = e3[Ug](t5), r3 = r3.isXFAObjectArray ? r3.children : [r3];
    }
    if (0 === r3.length) return e3.createNodes(a3.slice(n3));
    if (!(s4 < r3.length)) return a3[n3].index = s4 - r3.length, e3.createNodes(a3.slice(n3));
    {
      const t6 = r3[s4];
      if (!t6.isXFAObject) return warn("XFA - Cannot create a node."), null;
      e3 = t6;
    }
  }
  return null;
}
function measureToString(e3) {
  return "string" == typeof e3 ? "0px" : Number.isInteger(e3) ? `${e3}px` : `${e3.toFixed(2)}px`;
}
function setMinMaxDimensions(e3, t3) {
  "position" === e3[_g2]().layout && (e3.minW > 0 && (t3.minWidth = measureToString(e3.minW)), e3.maxW > 0 && (t3.maxWidth = measureToString(e3.maxW)), e3.minH > 0 && (t3.minHeight = measureToString(e3.minH)), e3.maxH > 0 && (t3.maxHeight = measureToString(e3.maxH)));
}
function layoutText(e3, t3, i3, a3, s3, n3) {
  const r3 = new TextMeasure(t3, i3, a3, s3);
  return "string" == typeof e3 ? r3.addString(e3) : e3[Bc](r3), r3.compute(n3);
}
function layoutNode(e3, t3) {
  let i3 = null, a3 = null, s3 = false;
  if ((!e3.w || !e3.h) && e3.value) {
    let n3 = 0, r3 = 0;
    e3.margin && (n3 = e3.margin.leftInset + e3.margin.rightInset, r3 = e3.margin.topInset + e3.margin.bottomInset);
    let o3 = null, g3 = null;
    e3.para && (g3 = /* @__PURE__ */ Object.create(null), o3 = "" === e3.para.lineHeight ? null : e3.para.lineHeight, g3.top = "" === e3.para.spaceAbove ? 0 : e3.para.spaceAbove, g3.bottom = "" === e3.para.spaceBelow ? 0 : e3.para.spaceBelow, g3.left = "" === e3.para.marginLeft ? 0 : e3.para.marginLeft, g3.right = "" === e3.para.marginRight ? 0 : e3.para.marginRight);
    let c3 = e3.font;
    if (!c3) {
      const t4 = e3[jg]();
      let i4 = e3[Wg]();
      for (; i4 && i4 !== t4; ) {
        if (i4.font) {
          c3 = i4.font;
          break;
        }
        i4 = i4[Wg]();
      }
    }
    const h3 = (e3.w || t3.width) - n3, l3 = e3[Xg].fontFinder;
    if (e3.value.exData && e3.value.exData[Fg] && "text/html" === e3.value.exData.contentType) {
      const t4 = layoutText(e3.value.exData[Fg], c3, g3, o3, l3, h3);
      a3 = t4.width, i3 = t4.height, s3 = t4.isBroken;
    } else {
      const t4 = e3.value[Sc]();
      if (t4) {
        const e4 = layoutText(t4, c3, g3, o3, l3, h3);
        a3 = e4.width, i3 = e4.height, s3 = e4.isBroken;
      }
    }
    null === a3 || e3.w || (a3 += n3), null === i3 || e3.h || (i3 += r3);
  }
  return { w: a3, h: i3, isBroken: s3 };
}
function computeBbox(e3, t3, i3) {
  let a3;
  if ("" !== e3.w && "" !== e3.h) a3 = [e3.x, e3.y, e3.w, e3.h];
  else {
    if (!i3) return null;
    let s3 = e3.w;
    if ("" === s3) {
      if (0 === e3.maxW) {
        const t4 = e3[_g2]();
        s3 = "position" === t4.layout && "" !== t4.w ? 0 : e3.minW;
      } else s3 = Math.min(e3.maxW, i3.width);
      t3.attributes.style.width = measureToString(s3);
    }
    let n3 = e3.h;
    if ("" === n3) {
      if (0 === e3.maxH) {
        const t4 = e3[_g2]();
        n3 = "position" === t4.layout && "" !== t4.h ? 0 : e3.minH;
      } else n3 = Math.min(e3.maxH, i3.height);
      t3.attributes.style.height = measureToString(n3);
    }
    a3 = [e3.x, e3.y, s3, n3];
  }
  return a3;
}
function fixDimensions(e3) {
  const t3 = e3[_g2]();
  if (t3.layout?.includes("row")) {
    const i3 = t3[xg], a3 = e3.colSpan;
    let s3;
    s3 = -1 === a3 ? i3.columnWidths.slice(i3.currentColumn).reduce((e4, t4) => e4 + t4, 0) : i3.columnWidths.slice(i3.currentColumn, i3.currentColumn + a3).reduce((e4, t4) => e4 + t4, 0), isNaN(s3) || (e3.w = s3);
  }
  t3.layout && "position" !== t3.layout && (e3.x = e3.y = 0), "table" === e3.layout && "" === e3.w && Array.isArray(e3.columnWidths) && (e3.w = e3.columnWidths.reduce((e4, t4) => e4 + t4, 0));
}
function layoutClass(e3) {
  switch (e3.layout) {
    case "position":
    default:
      return "xfaPosition";
    case "lr-tb":
      return "xfaLrTb";
    case "rl-row":
      return "xfaRlRow";
    case "rl-tb":
      return "xfaRlTb";
    case "row":
      return "xfaRow";
    case "table":
      return "xfaTable";
    case "tb":
      return "xfaTb";
  }
}
function toStyle(e3, ...t3) {
  const i3 = /* @__PURE__ */ Object.create(null);
  for (const a3 of t3) {
    const t4 = e3[a3];
    if (null !== t4) {
      if (lh.hasOwnProperty(a3)) lh[a3](e3, i3);
      else if (t4 instanceof XFAObject) {
        const e4 = t4[xc]();
        e4 ? Object.assign(i3, e4) : warn(`(DEBUG) - XFA - style for ${a3} not implemented yet`);
      }
    }
  }
  return i3;
}
function createWrapper(e3, t3) {
  const { attributes: i3 } = t3, { style: a3 } = i3, s3 = { name: "div", attributes: { class: ["xfaWrapper"], style: /* @__PURE__ */ Object.create(null) }, children: [] };
  if (i3.class.push("xfaWrapped"), e3.border) {
    const { widths: i4, insets: n3 } = e3.border[xg];
    let r3, o3, g3 = n3[0], c3 = n3[3];
    const h3 = n3[0] + n3[2], l3 = n3[1] + n3[3];
    switch (e3.border.hand) {
      case "even":
        g3 -= i4[0] / 2, c3 -= i4[3] / 2, r3 = `calc(100% + ${(i4[1] + i4[3]) / 2 - l3}px)`, o3 = `calc(100% + ${(i4[0] + i4[2]) / 2 - h3}px)`;
        break;
      case "left":
        g3 -= i4[0], c3 -= i4[3], r3 = `calc(100% + ${i4[1] + i4[3] - l3}px)`, o3 = `calc(100% + ${i4[0] + i4[2] - h3}px)`;
        break;
      case "right":
        r3 = l3 ? `calc(100% - ${l3}px)` : "100%", o3 = h3 ? `calc(100% - ${h3}px)` : "100%";
    }
    const C3 = ["xfaBorder"];
    isPrintOnly(e3.border) && C3.push("xfaPrintOnly");
    const d3 = { name: "div", attributes: { class: C3, style: { top: `${g3}px`, left: `${c3}px`, width: r3, height: o3 } }, children: [] };
    for (const e4 of ["border", "borderWidth", "borderColor", "borderRadius", "borderStyle"]) void 0 !== a3[e4] && (d3.attributes.style[e4] = a3[e4], delete a3[e4]);
    s3.children.push(d3, t3);
  } else s3.children.push(t3);
  for (const e4 of ["background", "backgroundClip", "top", "left", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "transform", "transformOrigin", "visibility"]) void 0 !== a3[e4] && (s3.attributes.style[e4] = a3[e4], delete a3[e4]);
  return s3.attributes.style.position = "absolute" === a3.position ? "absolute" : "relative", delete a3.position, a3.alignSelf && (s3.attributes.style.alignSelf = a3.alignSelf, delete a3.alignSelf), s3;
}
function fixTextIndent(e3) {
  const t3 = getMeasurement(e3.textIndent, "0px");
  if (t3 >= 0) return;
  const i3 = "padding" + ("left" === ("right" === e3.textAlign ? "right" : "left") ? "Left" : "Right"), a3 = getMeasurement(e3[i3], "0px");
  e3[i3] = a3 - t3 + "px";
}
function setAccess(e3, t3) {
  switch (e3.access) {
    case "nonInteractive":
      t3.push("xfaNonInteractive");
      break;
    case "readOnly":
      t3.push("xfaReadOnly");
      break;
    case "protected":
      t3.push("xfaDisabled");
  }
}
function isPrintOnly(e3) {
  return e3.relevant.length > 0 && !e3.relevant[0].excluded && "print" === e3.relevant[0].viewname;
}
function getCurrentPara(e3) {
  const t3 = e3[jg]()[xg].paraStack;
  return t3.length ? t3.at(-1) : null;
}
function setPara(e3, t3, i3) {
  if (i3.attributes.class?.includes("xfaRich")) {
    t3 && ("" === e3.h && (t3.height = "auto"), "" === e3.w && (t3.width = "auto"));
    const a3 = getCurrentPara(e3);
    if (a3) {
      const e4 = i3.attributes.style;
      switch (e4.display = "flex", e4.flexDirection = "column", a3.vAlign) {
        case "top":
          e4.justifyContent = "start";
          break;
        case "bottom":
          e4.justifyContent = "end";
          break;
        case "middle":
          e4.justifyContent = "center";
      }
      const t4 = a3[xc]();
      for (const [i4, a4] of Object.entries(t4)) i4 in e4 || (e4[i4] = a4);
    }
  }
}
function setFontFamily(e3, t3, i3, a3) {
  if (!i3) return void delete a3.fontFamily;
  const s3 = stripQuotes(e3.typeface);
  a3.fontFamily = `"${s3}"`;
  const n3 = i3.find(s3);
  if (n3) {
    const { fontFamily: i4 } = n3.regular.cssFontInfo;
    i4 !== s3 && (a3.fontFamily = `"${i4}"`);
    const r3 = getCurrentPara(t3);
    if (r3 && "" !== r3.lineHeight) return;
    if (a3.lineHeight) return;
    const o3 = selectFont(e3, n3);
    o3 && (a3.lineHeight = Math.max(1.2, o3.lineHeight));
  }
}
function fixURL(e3) {
  const t3 = createValidAbsoluteUrl(e3, null, { addDefaultProtocol: true, tryConvertEncoding: true });
  return t3 ? t3.href : null;
}
function createLine(e3, t3) {
  return { name: "div", attributes: { class: ["lr-tb" === e3.layout ? "xfaLr" : "xfaRl"] }, children: t3 };
}
function flushHTML(e3) {
  if (!e3[xg]) return null;
  const t3 = { name: "div", attributes: e3[xg].attributes, children: e3[xg].children };
  if (e3[xg].failingNode) {
    const i3 = e3[xg].failingNode[Mg]();
    i3 && (e3.layout.endsWith("-tb") ? t3.children.push(createLine(e3, [i3])) : t3.children.push(i3));
  }
  return 0 === t3.children.length ? null : t3;
}
function addHTML(e3, t3, i3) {
  const a3 = e3[xg], s3 = a3.availableSpace, [n3, r3, o3, g3] = i3;
  switch (e3.layout) {
    case "position":
      a3.width = Math.max(a3.width, n3 + o3), a3.height = Math.max(a3.height, r3 + g3), a3.children.push(t3);
      break;
    case "lr-tb":
    case "rl-tb":
      a3.line && 1 !== a3.attempt || (a3.line = createLine(e3, []), a3.children.push(a3.line), a3.numberInLine = 0), a3.numberInLine += 1, a3.line.children.push(t3), 0 === a3.attempt ? (a3.currentWidth += o3, a3.height = Math.max(a3.height, a3.prevHeight + g3)) : (a3.currentWidth = o3, a3.prevHeight = a3.height, a3.height += g3, a3.attempt = 0), a3.width = Math.max(a3.width, a3.currentWidth);
      break;
    case "rl-row":
    case "row": {
      a3.children.push(t3), a3.width += o3, a3.height = Math.max(a3.height, g3);
      const e4 = measureToString(a3.height);
      for (const t4 of a3.children) t4.attributes.style.height = e4;
      break;
    }
    case "table":
    case "tb":
      a3.width = Math.min(s3.width, Math.max(a3.width, o3)), a3.height += g3, a3.children.push(t3);
  }
}
function getAvailableSpace(e3) {
  const t3 = e3[xg].availableSpace, i3 = e3.margin ? e3.margin.topInset + e3.margin.bottomInset : 0, a3 = e3.margin ? e3.margin.leftInset + e3.margin.rightInset : 0;
  switch (e3.layout) {
    case "lr-tb":
    case "rl-tb":
      return 0 === e3[xg].attempt ? { width: t3.width - a3 - e3[xg].currentWidth, height: t3.height - i3 - e3[xg].prevHeight } : { width: t3.width - a3, height: t3.height - i3 - e3[xg].height };
    case "rl-row":
    case "row":
      return { width: e3[xg].columnWidths.slice(e3[xg].currentColumn).reduce((e4, t4) => e4 + t4), height: t3.height - a3 };
    case "table":
    case "tb":
      return { width: t3.width - a3, height: t3.height - i3 - e3[xg].height };
    default:
      return t3;
  }
}
function checkDimensions(e3, t3) {
  if (null === e3[jg]()[xg].firstUnsplittable) return true;
  if (0 === e3.w || 0 === e3.h) return true;
  const i3 = e3[_g2](), a3 = i3[xg]?.attempt || 0, [, s3, n3, r3] = function(e4) {
    let t4, i4, a4 = "" === e4.w ? NaN : e4.w, s4 = "" === e4.h ? NaN : e4.h, [n4, r4] = [0, 0];
    switch (e4.anchorType || "") {
      case "bottomCenter":
        [n4, r4] = [a4 / 2, s4];
        break;
      case "bottomLeft":
        [n4, r4] = [0, s4];
        break;
      case "bottomRight":
        [n4, r4] = [a4, s4];
        break;
      case "middleCenter":
        [n4, r4] = [a4 / 2, s4 / 2];
        break;
      case "middleLeft":
        [n4, r4] = [0, s4 / 2];
        break;
      case "middleRight":
        [n4, r4] = [a4, s4 / 2];
        break;
      case "topCenter":
        [n4, r4] = [a4 / 2, 0];
        break;
      case "topRight":
        [n4, r4] = [a4, 0];
    }
    switch (e4.rotate || 0) {
      case 0:
        [t4, i4] = [-n4, -r4];
        break;
      case 90:
        [t4, i4] = [-r4, n4], [a4, s4] = [s4, -a4];
        break;
      case 180:
        [t4, i4] = [n4, r4], [a4, s4] = [-a4, -s4];
        break;
      case 270:
        [t4, i4] = [r4, -n4], [a4, s4] = [-s4, a4];
    }
    return [e4.x + t4 + Math.min(0, a4), e4.y + i4 + Math.min(0, s4), Math.abs(a4), Math.abs(s4)];
  }(e3);
  switch (i3.layout) {
    case "lr-tb":
    case "rl-tb":
      return 0 === a3 ? e3[jg]()[xg].noLayoutFailure ? "" !== e3.w ? Math.round(n3 - t3.width) <= 2 : t3.width > 2 : !("" !== e3.h && Math.round(r3 - t3.height) > 2) && ("" !== e3.w ? Math.round(n3 - t3.width) <= 2 || 0 === i3[xg].numberInLine && t3.height > 2 : t3.width > 2) : !!e3[jg]()[xg].noLayoutFailure || !("" !== e3.h && Math.round(r3 - t3.height) > 2) && (("" === e3.w || Math.round(n3 - t3.width) <= 2 || !i3[nc]()) && t3.height > 2);
    case "table":
    case "tb":
      return !!e3[jg]()[xg].noLayoutFailure || ("" === e3.h || e3[sc]() ? ("" === e3.w || Math.round(n3 - t3.width) <= 2 || !i3[nc]()) && t3.height > 2 : Math.round(r3 - t3.height) <= 2);
    case "position":
      if (e3[jg]()[xg].noLayoutFailure) return true;
      if ("" === e3.h || Math.round(r3 + s3 - t3.height) <= 2) return true;
      return r3 + s3 > e3[jg]()[xg].currentContentArea.h;
    case "rl-row":
    case "row":
      return !!e3[jg]()[xg].noLayoutFailure || ("" === e3.h || Math.round(r3 - t3.height) <= 2);
    default:
      return true;
  }
}
function getBorderDims(e3) {
  if (!e3 || !e3.border) return { w: 0, h: 0 };
  const t3 = e3.border[Yg]();
  return t3 ? { w: t3.widths[0] + t3.widths[2] + t3.insets[0] + t3.insets[2], h: t3.widths[1] + t3.widths[3] + t3.insets[1] + t3.insets[3] } : { w: 0, h: 0 };
}
function hasMargin(e3) {
  return e3.margin && (e3.margin.topInset || e3.margin.rightInset || e3.margin.bottomInset || e3.margin.leftInset);
}
function _setValue(e3, t3) {
  if (!e3.value) {
    const t4 = new Value({});
    e3[pg](t4), e3.value = t4;
  }
  e3.value[bc](t3);
}
function* getContainedChildren(e3) {
  for (const t3 of e3[Og]()) t3 instanceof SubformSet ? yield* t3[Kg]() : yield t3;
}
function isRequired(e3) {
  return "error" === e3.validate?.nullTest;
}
function setTabIndex(e3) {
  for (; e3; ) {
    if (!e3.traversal) return void (e3[Dc] = e3[Wg]()[Dc]);
    if (e3[Dc]) return;
    let t3 = null;
    for (const i4 of e3.traversal[Og]()) if ("next" === i4.operation) {
      t3 = i4;
      break;
    }
    if (!t3 || !t3.ref) return void (e3[Dc] = e3[Wg]()[Dc]);
    const i3 = e3[jg]();
    e3[Dc] = ++i3[Dc];
    const a3 = i3[mc](t3.ref, e3);
    if (!a3) return;
    e3 = a3[0];
  }
}
function applyAssist(e3, t3) {
  const i3 = e3.assist;
  if (i3) {
    const e4 = i3[kc]();
    e4 && (t3.title = e4);
    const a3 = i3.role.match(dh);
    if (a3) {
      const e5 = "heading", i4 = a3[1];
      t3.role = e5, t3["aria-level"] = i4;
    }
  }
  if ("table" === e3.layout) t3.role = "table";
  else if ("row" === e3.layout) t3.role = "row";
  else {
    const i4 = e3[Wg]();
    "row" === i4.layout && (t3.role = "TH" === i4.assist?.role ? "columnheader" : "cell");
  }
}
function ariaLabel(e3) {
  if (!e3.assist) return null;
  const t3 = e3.assist;
  return t3.speak && "" !== t3.speak[Fg] ? t3.speak[Fg] : t3.toolTip ? t3.toolTip[Fg] : null;
}
function valueToHtml(e3) {
  return HTMLResult.success({ name: "div", attributes: { class: ["xfaRich"], style: /* @__PURE__ */ Object.create(null) }, children: [{ name: "span", attributes: { style: /* @__PURE__ */ Object.create(null) }, value: e3 }] });
}
function setFirstUnsplittable(e3) {
  const t3 = e3[jg]();
  null === t3[xg].firstUnsplittable && (t3[xg].firstUnsplittable = e3, t3[xg].noLayoutFailure = true);
}
function unsetFirstUnsplittable(e3) {
  const t3 = e3[jg]();
  t3[xg].firstUnsplittable === e3 && (t3[xg].noLayoutFailure = false);
}
function handleBreak(e3) {
  if (e3[xg]) return false;
  if (e3[xg] = /* @__PURE__ */ Object.create(null), "auto" === e3.targetType) return false;
  const t3 = e3[jg]();
  let i3 = null;
  if (e3.target) {
    if (i3 = t3[mc](e3.target, e3[Wg]()), !i3) return false;
    i3 = i3[0];
  }
  const { currentPageArea: a3, currentContentArea: s3 } = t3[xg];
  if ("pageArea" === e3.targetType) return i3 instanceof PageArea || (i3 = null), e3.startNew ? (e3[xg].target = i3 || a3, true) : !(!i3 || i3 === a3) && (e3[xg].target = i3, true);
  i3 instanceof ContentArea || (i3 = null);
  const n3 = i3 && i3[Wg]();
  let r3, o3 = n3;
  if (e3.startNew) if (i3) {
    const e4 = n3.contentArea.children, t4 = e4.indexOf(s3), a4 = e4.indexOf(i3);
    -1 !== t4 && t4 < a4 && (o3 = null), r3 = a4 - 1;
  } else r3 = a3.contentArea.children.indexOf(s3);
  else {
    if (!i3 || i3 === s3) return false;
    r3 = n3.contentArea.children.indexOf(i3) - 1, o3 = n3 === a3 ? null : n3;
  }
  return e3[xg].target = o3, e3[xg].index = r3, true;
}
function handleOverflow(e3, t3, i3) {
  const a3 = e3[jg](), s3 = a3[xg].noLayoutFailure, n3 = t3[_g2];
  t3[_g2] = () => e3, a3[xg].noLayoutFailure = true;
  const r3 = t3[kc](i3);
  e3[fg](r3.html, r3.bbox), a3[xg].noLayoutFailure = s3, t3[_g2] = n3;
}
function createText(e3) {
  const t3 = new Text({});
  return t3[Fg] = e3, t3;
}
function mapStyle(e3, t3, i3) {
  const a3 = /* @__PURE__ */ Object.create(null);
  if (!e3) return a3;
  const s3 = /* @__PURE__ */ Object.create(null);
  for (const [t4, i4] of e3.split(";").map((e4) => e4.split(":", 2))) {
    const e4 = Nh.get(t4);
    if ("" === e4) continue;
    let n3 = i4;
    e4 && (n3 = "string" == typeof e4 ? e4 : e4(i4, s3)), t4.endsWith("scale") ? a3.transform = a3.transform ? `${a3[t4]} ${n3}` : n3 : a3[t4.replaceAll(/-([a-zA-Z])/g, (e5, t5) => t5.toUpperCase())] = n3;
  }
  if (a3.fontFamily && setFontFamily({ typeface: a3.fontFamily, weight: a3.fontWeight || "normal", posture: a3.fontStyle || "normal", size: s3.fontSize || 0 }, t3, t3[Xg].fontFinder, a3), i3 && a3.verticalAlign && "0px" !== a3.verticalAlign && a3.fontSize) {
    const e4 = 0.583, t4 = 0.333, i4 = getMeasurement(a3.fontSize);
    a3.fontSize = measureToString(i4 * e4), a3.verticalAlign = measureToString(Math.sign(getMeasurement(a3.verticalAlign)) * i4 * t4);
  }
  return i3 && a3.fontSize && (a3.fontSize = `calc(${a3.fontSize} * var(--scale-factor))`), fixTextIndent(a3), a3;
}
function getRgbColor(e3, t3 = new Uint8ClampedArray(3)) {
  if (!Array.isArray(e3)) return t3;
  const i3 = t3 || new Uint8ClampedArray(3);
  switch (e3.length) {
    case 0:
      return null;
    case 1:
      return ColorSpace.singletons.gray.getRgbItem(e3, 0, i3, 0), i3;
    case 3:
      return ColorSpace.singletons.rgb.getRgbItem(e3, 0, i3, 0), i3;
    case 4:
      return ColorSpace.singletons.cmyk.getRgbItem(e3, 0, i3, 0), i3;
    default:
      return t3;
  }
}
function getPdfColorArray(e3) {
  return Array.from(e3, (e4) => e4 / 255);
}
function getQuadPoints(e3, t3) {
  const i3 = e3.getArray("QuadPoints");
  if (!isNumberArray(i3, null) || 0 === i3.length || i3.length % 8 > 0) return null;
  const a3 = new Float32Array(i3.length);
  for (let e4 = 0, s3 = i3.length; e4 < s3; e4 += 8) {
    const [s4, n3, r3, o3, g3, c3, h3, l3] = i3.slice(e4, e4 + 8), C3 = Math.min(s4, r3, g3, h3), d3 = Math.max(s4, r3, g3, h3), u3 = Math.min(n3, o3, c3, l3), Q3 = Math.max(n3, o3, c3, l3);
    if (null !== t3 && (C3 < t3[0] || d3 > t3[2] || u3 < t3[1] || Q3 > t3[3])) return null;
    a3.set([C3, Q3, d3, Q3, C3, u3, d3, u3], e4);
  }
  return a3;
}
function getTransformMatrix(e3, t3, i3) {
  const [a3, s3, n3, r3] = Util.getAxialAlignedBoundingBox(t3, i3);
  if (a3 === n3 || s3 === r3) return [1, 0, 0, 1, e3[0], e3[1]];
  const o3 = (e3[2] - e3[0]) / (n3 - a3), g3 = (e3[3] - e3[1]) / (r3 - s3);
  return [o3, 0, 0, g3, e3[0] - a3 * o3, e3[1] - s3 * g3];
}
function decodeString(e3) {
  try {
    return stringToUTF8String(e3);
  } catch (t3) {
    return warn(`UTF-8 decoding failed: "${t3}".`), e3;
  }
}
function find(e3, t3, i3 = 1024, a3 = false) {
  const s3 = t3.length, n3 = e3.peekBytes(i3), r3 = n3.length - s3;
  if (r3 <= 0) return false;
  if (a3) {
    const i4 = s3 - 1;
    let a4 = n3.length - 1;
    for (; a4 >= i4; ) {
      let r4 = 0;
      for (; r4 < s3 && n3[a4 - r4] === t3[i4 - r4]; ) r4++;
      if (r4 >= s3) return e3.pos += a4 - i4, true;
      a4--;
    }
  } else {
    let i4 = 0;
    for (; i4 <= r3; ) {
      let a4 = 0;
      for (; a4 < s3 && n3[i4 + a4] === t3[a4]; ) a4++;
      if (a4 >= s3) return e3.pos += i4, true;
      i4++;
    }
  }
  return false;
}
function wrapReason(e3) {
  switch (e3 instanceof Error || "object" == typeof e3 && null !== e3 || unreachable('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), e3.name) {
    case "AbortException":
      return new AbortException(e3.message);
    case "MissingPDFException":
      return new MissingPDFException(e3.message);
    case "PasswordException":
      return new PasswordException(e3.message, e3.code);
    case "UnexpectedResponseException":
      return new UnexpectedResponseException(e3.message, e3.status);
    case "UnknownErrorException":
      return new UnknownErrorException(e3.message, e3.details);
    default:
      return new UnknownErrorException(e3.message, e3.toString());
  }
}
async function __main__() {
  var _Util_static2, e_fn2, t_fn2, _W, _j, _X, _V, _Z, _z, _$, _EditorToolbar_static, ee_fn, _EditorToolbar_instances, Ae_fn, ie_fn, ae_fn, te_fn, se_get, _Z2, _j2, _ne, _HighlightToolbar_instances, re_fn, ge_fn, oe_fn, _ce, _he, _ce2, _le, _ImageManager_instances, Ie_fn, _Ce, _de, _Be, _ue, _KeyboardManager_instances, Qe_fn, _Ee, _fe, _pe, _me, _ye, _we, _be, _De, _Se, _Fe, _ke, _Re, _xe, _Ne, _Me, _Ge, _ve, _Le, _Ue, _He, _Te, _Je, _Ye, _Pe, _Oe, _Ke, _qe, __e, _We, _je, _Xe, _Ve, _Ze, _ze, _$e, _et, _tt, _At, _it, _at, _AnnotationEditorUIManager_instances, ot_fn, gt_fn, ct_fn, ht_fn, It_fn, st_fn, Ct_fn, dt_fn, rt_fn, Bt_fn, ut_fn, Qt_fn, nt_fn, lt_fn, pt_fn, wt_fn, yt_fn, Et_fn, bt_get, mt_fn, ft_fn, _z2, _Dt, _St, _Ft, _kt, _Rt, _xt, _V2, _Nt, _Mt, _Gt, _AltText_instances, vt_get, Lt_fn, _Ut, _Ht, _z3, _Tt, _Jt, _Yt, _Pt, _Ot, _Kt, _qt, __t, _Wt, _jt, _Xt, _Vt, _Zt, _zt, _$t, _eA, _tA, _AnnotationEditor_instances, iA_fn, _AnnotationEditor_static, aA_fn, sA_fn, nA_fn, rA_fn, gA_fn, oA_fn, lA_fn, hA_fn, cA_fn, IA_fn, CA_fn, dA_fn, BA_fn, AA_fn, _uA, _QA, _EA, _AnnotationStorage_instances, fA_fn, _pA, _mA, _CanvasGraphics_instances, yA_fn, wA_fn, _bA, _DA, _MessageHandler_instances2, q_fn2, K_fn2, __fn2, _SA, _FA, _kA, _RA, _xA, _NA, _MA, _GA, _vA, _LA, _OptionalContentConfig_instances, UA_fn, _HA, _it2, _TA, _JA, _YA, _PA, _OA, _KA, _qA, __A, _WA, _jA, _XA, _VA, _ZA, _zA, _$A, _ei, _ti, _Ai, _ii, _ai, _TextLayer_instances, ni_fn, gi_fn, oi_fn, _TextLayer_static, ri_fn, si_fn, ci_fn, _hi, _li, _Ii, _Ci, _di, _Bi, _ce3, _instances, le_get, ui_get, Qi_get, Ei_fn, fi_fn, Di_fn, wi_fn, pi_fn, Si_fn, mi_fn, bi_fn, yi_fn, _a4, _Ci2, _Fi, _ki, _PDFPageProxy_instances, xi_fn, Ri_fn, _Ni, _Mi, _Gi, _vi, _Li, _PDFWorker_instances, Ui_fn, _PDFWorker_static, Hi_get, _Ti, _Ji, _Yi, _Pi, _Oi, _WorkerTransport_instances, Ki_fn, _qi, _PDFObjects_instances, _i_fn, _Wi, _ji, _Xi, _Vi, _Zi, _zi, _AnnotationElement_instances, $i_fn, _LinkAnnotationElement_instances, Aa_fn, ea_fn, ta_fn, _ia, _sa, _ra, _ga, _ha, _it3, _la, _Ia, _Ca, _da, _Ba, _ua, _Qa, _ue2, _Ea, _fa, _pa, _Vi2, _ma, _PopupElement_instances, ya_get, wa_get, ba_get, Da_fn, aa_fn, Sa_fn, ca_fn, oa_fn, na_fn, _Fa, _ka, _Ra, _xa, _Na, _Ma, _FileAttachmentAnnotationElement_instances, Ga_fn, _va, _La, _Ua, _AnnotationLayer_instances, Ha_fn, Ta_fn, _ha2, _Ja, _Ya, _Pa, _wa, _Oa, _FreeTextEditor_instances, Ka_fn, qa_fn, Wa_fn, _a_fn, _FreeTextEditor_static, ja_fn, Xa_fn, Za_fn, Va_fn, za_fn, _$a, _es, _ts, _Outliner_instances, ss_fn, ns_fn, is_fn, as_fn, As_fn, _$a2, _rs, _$a3, _os, _gs, _cs, _hs, _ls, _Is, _Cs, _ds, _Bs, _us, _Qs, _Es, _fs, _ps, _ms, _FreeOutliner_instances, ys_fn, _$a4, _ws, _gs2, _cs2, _Es2, _us2, _bs, _FreeHighlightOutline_instances, Ss_fn, Fs_fn, Ds_fn, _ia2, _ks, _Rs, _xs, _Ns, _Ms, _Gs, _vs, _V3, _Ls, _ne2, _Us, _ColorPicker_instances, Ts_fn, Js_fn, aa_fn2, Hs_fn, ee_fn2, Ys_get, _Ps, _Os, _Ks, _qs, _X2, __s, _Ws, _js, _Xs, _Vs, _ce4, _Zs, _zs, _$s, _en, _tn, _Qs2, _An, _HighlightEditor_instances, sn_fn, in_fn, qa_fn2, rn_fn, on_fn, cn_fn, an_fn, _HighlightEditor_static, nn_fn, hn_fn, ln_fn, gn_fn, In_fn, Cn_fn, Bn_fn, dn_fn, _un, _Qn, _En, _fn, _pn, _mn, _yn, _wn, _bn, _Dn, _Sn, _Fn, _kn, _InkEditor_instances, rn_fn2, qa_fn3, Rn_fn, Hn_fn, Tn_fn, Jn_fn, Pn_fn, Kn_fn, qn_fn, Yn_fn, On_fn, _n_fn, Nn_fn, Ln_fn, Un_fn, jn_fn, Mn_fn, Gn_fn, vn_fn, Xn_fn, Wn_fn, _InkEditor_static, Zn_fn, zn_fn, $n_fn, er_fn, tr_fn, Vn_fn, xn_fn, _Ar, _ir, _ar, _sr, _nr, _rr, _or, _bn2, _gr, _cr, _hr, _StampEditor_instances, lr_fn, Ir_fn, Cr_fn, Mn_fn2, ur_fn, Br_fn, dr_fn, Qr_fn, Gn_fn2, _va2, _Er, _fr, _pr, _mr, _yr, _wr, _br, _Dr, _Sr, _Fr, _ne3, _xe2, _AnnotationEditorLayer_instances, Rr_fn, xr_get, Nr_fn, Mr_fn, kr_fn, _da2, _ce5, _Gr, _vr, _DrawLayer_static, Lr_fn, _DrawLayer_instances, Ur_fn, Hr_fn;
  var e3 = { d: (t4, i4) => {
    for (var a4 in i4) e3.o(i4, a4) && !e3.o(t4, a4) && Object.defineProperty(t4, a4, { enumerable: true, get: i4[a4] });
  }, o: (e4, t4) => Object.prototype.hasOwnProperty.call(e4, t4) }, t3 = globalThis.pdfjsLib = {};
  e3.d(t3, { AbortException: () => AbortException2, AnnotationEditorLayer: () => AnnotationEditorLayer, AnnotationEditorParamsType: () => f3, AnnotationEditorType: () => Q3, AnnotationEditorUIManager: () => AnnotationEditorUIManager, AnnotationLayer: () => AnnotationLayer, AnnotationMode: () => u3, CMapCompressionType: () => ee3, ColorPicker: () => ColorPicker, DOMSVGFactory: () => DOMSVGFactory, DrawLayer: () => DrawLayer, FeatureTest: () => util_FeatureTest, GlobalWorkerOptions: () => GlobalWorkerOptions, ImageKind: () => F3, InvalidPDFException: () => InvalidPDFException2, MissingPDFException: () => MissingPDFException2, OPS: () => te3, PDFDataRangeTransport: () => PDFDataRangeTransport, PDFDateString: () => PDFDateString, PDFWorker: () => PDFWorker, PasswordResponses: () => Ae3, PermissionFlag: () => p3, PixelsPerInch: () => PixelsPerInch, RenderingCancelledException: () => RenderingCancelledException, TextLayer: () => TextLayer, UnexpectedResponseException: () => UnexpectedResponseException2, Util: () => Util2, VerbosityLevel: () => $3, XfaLayer: () => XfaLayer, build: () => At3, createValidAbsoluteUrl: () => createValidAbsoluteUrl2, fetchData: () => fetchData, getDocument: () => getDocument, getFilenameFromUrl: () => getFilenameFromUrl, getPdfFilenameFromUrl: () => getPdfFilenameFromUrl, getXfaPageViewport: () => getXfaPageViewport, isDataScheme: () => isDataScheme, isPdfFile: () => isPdfFile, noContextMenu: () => noContextMenu, normalizeUnicode: () => normalizeUnicode, setLayerDimensions: () => setLayerDimensions, shadow: () => shadow2, version: () => tt3 });
  const i3 = "undefined" == typeof document, a3 = [1, 0, 0, 1, 0, 0], s3 = [1e-3, 0, 0, 1e-3, 0, 0], n3 = 1.35, r3 = 1, o3 = 2, g3 = 4, c3 = 16, h3 = 32, l3 = 64, C3 = 128, d3 = 256, u3 = { DISABLE: 0, ENABLE: 1, ENABLE_FORMS: 2, ENABLE_STORAGE: 3 }, Q3 = { DISABLE: -1, NONE: 0, FREETEXT: 3, HIGHLIGHT: 9, STAMP: 13, INK: 15 }, f3 = { RESIZE: 1, CREATE: 2, FREETEXT_SIZE: 11, FREETEXT_COLOR: 12, FREETEXT_OPACITY: 13, INK_COLOR: 21, INK_THICKNESS: 22, INK_OPACITY: 23, HIGHLIGHT_COLOR: 31, HIGHLIGHT_DEFAULT_COLOR: 32, HIGHLIGHT_THICKNESS: 33, HIGHLIGHT_FREE: 34, HIGHLIGHT_SHOW_ALL: 35 }, p3 = { PRINT: 4, MODIFY_CONTENTS: 8, COPY: 16, MODIFY_ANNOTATIONS: 32, FILL_INTERACTIVE_FORMS: 256, COPY_FOR_ACCESSIBILITY: 512, ASSEMBLE: 1024, PRINT_HIGH_QUALITY: 2048 }, m3 = 0, y3 = 1, w3 = 2, b3 = 3, D3 = 3, S3 = 4, F3 = { GRAYSCALE_1BPP: 1, RGB_24BPP: 2, RGBA_32BPP: 3 }, k3 = 1, R3 = 2, x3 = 3, N3 = 4, M3 = 5, G3 = 6, v3 = 7, L3 = 8, U3 = 9, H3 = 10, T3 = 11, J3 = 12, Y3 = 13, O3 = 14, K3 = 15, q3 = 16, _3 = 17, W3 = 20, j3 = 1, X3 = 2, V3 = 3, Z3 = 4, z3 = 5, $3 = { ERRORS: 0, WARNINGS: 1, INFOS: 5 }, ee3 = { NONE: 0, BINARY: 1 }, te3 = { dependency: 1, setLineWidth: 2, setLineCap: 3, setLineJoin: 4, setMiterLimit: 5, setDash: 6, setRenderingIntent: 7, setFlatness: 8, setGState: 9, save: 10, restore: 11, transform: 12, moveTo: 13, lineTo: 14, curveTo: 15, curveTo2: 16, curveTo3: 17, closePath: 18, rectangle: 19, stroke: 20, closeStroke: 21, fill: 22, eoFill: 23, fillStroke: 24, eoFillStroke: 25, closeFillStroke: 26, closeEOFillStroke: 27, endPath: 28, clip: 29, eoClip: 30, beginText: 31, endText: 32, setCharSpacing: 33, setWordSpacing: 34, setHScale: 35, setLeading: 36, setFont: 37, setTextRenderingMode: 38, setTextRise: 39, moveText: 40, setLeadingMoveText: 41, setTextMatrix: 42, nextLine: 43, showText: 44, showSpacedText: 45, nextLineShowText: 46, nextLineSetSpacingShowText: 47, setCharWidth: 48, setCharWidthAndBounds: 49, setStrokeColorSpace: 50, setFillColorSpace: 51, setStrokeColor: 52, setStrokeColorN: 53, setFillColor: 54, setFillColorN: 55, setStrokeGray: 56, setFillGray: 57, setStrokeRGBColor: 58, setFillRGBColor: 59, setStrokeCMYKColor: 60, setFillCMYKColor: 61, shadingFill: 62, beginInlineImage: 63, beginImageData: 64, endInlineImage: 65, paintXObject: 66, markPoint: 67, markPointProps: 68, beginMarkedContent: 69, beginMarkedContentProps: 70, endMarkedContent: 71, beginCompat: 72, endCompat: 73, paintFormXObjectBegin: 74, paintFormXObjectEnd: 75, beginGroup: 76, endGroup: 77, beginAnnotation: 80, endAnnotation: 81, paintImageMaskXObject: 83, paintImageMaskXObjectGroup: 84, paintImageXObject: 85, paintInlineImageXObject: 86, paintInlineImageXObjectGroup: 87, paintImageXObjectRepeat: 88, paintImageMaskXObjectRepeat: 89, paintSolidColorImageMask: 90, constructPath: 91, setStrokeTransparent: 92, setFillTransparent: 93 }, Ae3 = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 };
  let ie3 = $3.WARNINGS;
  function setVerbosityLevel(e4) {
    Number.isInteger(e4) && (ie3 = e4);
  }
  function getVerbosityLevel2() {
    return ie3;
  }
  function info2(e4) {
    ie3 >= $3.INFOS && console.log(`Info: ${e4}`);
  }
  function warn2(e4) {
    ie3 >= $3.WARNINGS && console.log(`Warning: ${e4}`);
  }
  function unreachable2(e4) {
    throw new Error(e4);
  }
  function assert2(e4, t4) {
    e4 || unreachable2(t4);
  }
  function createValidAbsoluteUrl2(e4, t4 = null, i4 = null) {
    if (!e4) return null;
    try {
      if (i4 && "string" == typeof e4) {
        if (i4.addDefaultProtocol && e4.startsWith("www.")) {
          const t5 = e4.match(/\./g);
          t5?.length >= 2 && (e4 = `http://${e4}`);
        }
        if (i4.tryConvertEncoding) try {
          e4 = decodeURIComponent(escape(e4));
        } catch {
        }
      }
      const a4 = t4 ? new URL(e4, t4) : new URL(e4);
      if (function(e5) {
        switch (e5?.protocol) {
          case "http:":
          case "https:":
          case "ftp:":
          case "mailto:":
          case "tel:":
            return true;
          default:
            return false;
        }
      }(a4)) return a4;
    } catch {
    }
    return null;
  }
  function shadow2(e4, t4, i4, a4 = false) {
    return Object.defineProperty(e4, t4, { value: i4, enumerable: !a4, configurable: true, writable: false }), i4;
  }
  const ae3 = function() {
    function BaseException(e4, t4) {
      this.message = e4, this.name = t4;
    }
    return BaseException.prototype = new Error(), BaseException.constructor = BaseException, BaseException;
  }();
  class PasswordException2 extends ae3 {
    constructor(e4, t4) {
      super(e4, "PasswordException"), this.code = t4;
    }
  }
  class UnknownErrorException2 extends ae3 {
    constructor(e4, t4) {
      super(e4, "UnknownErrorException"), this.details = t4;
    }
  }
  class InvalidPDFException2 extends ae3 {
    constructor(e4) {
      super(e4, "InvalidPDFException");
    }
  }
  class MissingPDFException2 extends ae3 {
    constructor(e4) {
      super(e4, "MissingPDFException");
    }
  }
  class UnexpectedResponseException2 extends ae3 {
    constructor(e4, t4) {
      super(e4, "UnexpectedResponseException"), this.status = t4;
    }
  }
  class FormatError2 extends ae3 {
    constructor(e4) {
      super(e4, "FormatError");
    }
  }
  class AbortException2 extends ae3 {
    constructor(e4) {
      super(e4, "AbortException");
    }
  }
  function bytesToString2(e4) {
    "object" == typeof e4 && void 0 !== e4?.length || unreachable2("Invalid argument for bytesToString");
    const t4 = e4.length, i4 = 8192;
    if (t4 < i4) return String.fromCharCode.apply(null, e4);
    const a4 = [];
    for (let s4 = 0; s4 < t4; s4 += i4) {
      const n4 = Math.min(s4 + i4, t4), r4 = e4.subarray(s4, n4);
      a4.push(String.fromCharCode.apply(null, r4));
    }
    return a4.join("");
  }
  function stringToBytes2(e4) {
    "string" != typeof e4 && unreachable2("Invalid argument for stringToBytes");
    const t4 = e4.length, i4 = new Uint8Array(t4);
    for (let a4 = 0; a4 < t4; ++a4) i4[a4] = 255 & e4.charCodeAt(a4);
    return i4;
  }
  function objectFromMap(e4) {
    const t4 = /* @__PURE__ */ Object.create(null);
    for (const [i4, a4] of e4) t4[i4] = a4;
    return t4;
  }
  class util_FeatureTest {
    static get isLittleEndian() {
      return shadow2(this, "isLittleEndian", function() {
        const e4 = new Uint8Array(4);
        return e4[0] = 1, 1 === new Uint32Array(e4.buffer, 0, 1)[0];
      }());
    }
    static get isEvalSupported() {
      return shadow2(this, "isEvalSupported", function() {
        try {
          return new Function(""), true;
        } catch {
          return false;
        }
      }());
    }
    static get isOffscreenCanvasSupported() {
      return shadow2(this, "isOffscreenCanvasSupported", "undefined" != typeof OffscreenCanvas);
    }
    static get platform() {
      return "undefined" != typeof navigator && "string" == typeof navigator?.platform ? shadow2(this, "platform", { isMac: navigator.platform.includes("Mac") }) : shadow2(this, "platform", { isMac: false });
    }
    static get isCSSRoundSupported() {
      return shadow2(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
    }
  }
  const se3 = Array.from(Array(256).keys(), (e4) => e4.toString(16).padStart(2, "0"));
  class Util2 {
    static makeHexColor(e4, t4, i4) {
      return `#${se3[e4]}${se3[t4]}${se3[i4]}`;
    }
    static scaleMinMax(e4, t4) {
      let i4;
      e4[0] ? (e4[0] < 0 && (i4 = t4[0], t4[0] = t4[2], t4[2] = i4), t4[0] *= e4[0], t4[2] *= e4[0], e4[3] < 0 && (i4 = t4[1], t4[1] = t4[3], t4[3] = i4), t4[1] *= e4[3], t4[3] *= e4[3]) : (i4 = t4[0], t4[0] = t4[1], t4[1] = i4, i4 = t4[2], t4[2] = t4[3], t4[3] = i4, e4[1] < 0 && (i4 = t4[1], t4[1] = t4[3], t4[3] = i4), t4[1] *= e4[1], t4[3] *= e4[1], e4[2] < 0 && (i4 = t4[0], t4[0] = t4[2], t4[2] = i4), t4[0] *= e4[2], t4[2] *= e4[2]), t4[0] += e4[4], t4[1] += e4[5], t4[2] += e4[4], t4[3] += e4[5];
    }
    static transform(e4, t4) {
      return [e4[0] * t4[0] + e4[2] * t4[1], e4[1] * t4[0] + e4[3] * t4[1], e4[0] * t4[2] + e4[2] * t4[3], e4[1] * t4[2] + e4[3] * t4[3], e4[0] * t4[4] + e4[2] * t4[5] + e4[4], e4[1] * t4[4] + e4[3] * t4[5] + e4[5]];
    }
    static applyTransform(e4, t4) {
      return [e4[0] * t4[0] + e4[1] * t4[2] + t4[4], e4[0] * t4[1] + e4[1] * t4[3] + t4[5]];
    }
    static applyInverseTransform(e4, t4) {
      const i4 = t4[0] * t4[3] - t4[1] * t4[2];
      return [(e4[0] * t4[3] - e4[1] * t4[2] + t4[2] * t4[5] - t4[4] * t4[3]) / i4, (-e4[0] * t4[1] + e4[1] * t4[0] + t4[4] * t4[1] - t4[5] * t4[0]) / i4];
    }
    static getAxialAlignedBoundingBox(e4, t4) {
      const i4 = this.applyTransform(e4, t4), a4 = this.applyTransform(e4.slice(2, 4), t4), s4 = this.applyTransform([e4[0], e4[3]], t4), n4 = this.applyTransform([e4[2], e4[1]], t4);
      return [Math.min(i4[0], a4[0], s4[0], n4[0]), Math.min(i4[1], a4[1], s4[1], n4[1]), Math.max(i4[0], a4[0], s4[0], n4[0]), Math.max(i4[1], a4[1], s4[1], n4[1])];
    }
    static inverseTransform(e4) {
      const t4 = e4[0] * e4[3] - e4[1] * e4[2];
      return [e4[3] / t4, -e4[1] / t4, -e4[2] / t4, e4[0] / t4, (e4[2] * e4[5] - e4[4] * e4[3]) / t4, (e4[4] * e4[1] - e4[5] * e4[0]) / t4];
    }
    static singularValueDecompose2dScale(e4) {
      const t4 = [e4[0], e4[2], e4[1], e4[3]], i4 = e4[0] * t4[0] + e4[1] * t4[2], a4 = e4[0] * t4[1] + e4[1] * t4[3], s4 = e4[2] * t4[0] + e4[3] * t4[2], n4 = e4[2] * t4[1] + e4[3] * t4[3], r4 = (i4 + n4) / 2, o4 = Math.sqrt((i4 + n4) ** 2 - 4 * (i4 * n4 - s4 * a4)) / 2, g4 = r4 + o4 || 1, c4 = r4 - o4 || 1;
      return [Math.sqrt(g4), Math.sqrt(c4)];
    }
    static normalizeRect(e4) {
      const t4 = e4.slice(0);
      return e4[0] > e4[2] && (t4[0] = e4[2], t4[2] = e4[0]), e4[1] > e4[3] && (t4[1] = e4[3], t4[3] = e4[1]), t4;
    }
    static intersect(e4, t4) {
      const i4 = Math.max(Math.min(e4[0], e4[2]), Math.min(t4[0], t4[2])), a4 = Math.min(Math.max(e4[0], e4[2]), Math.max(t4[0], t4[2]));
      if (i4 > a4) return null;
      const s4 = Math.max(Math.min(e4[1], e4[3]), Math.min(t4[1], t4[3])), n4 = Math.min(Math.max(e4[1], e4[3]), Math.max(t4[1], t4[3]));
      return s4 > n4 ? null : [i4, s4, a4, n4];
    }
    static bezierBoundingBox(e4, t4, i4, a4, s4, n4, r4, o4, g4) {
      return g4 ? (g4[0] = Math.min(g4[0], e4, r4), g4[1] = Math.min(g4[1], t4, o4), g4[2] = Math.max(g4[2], e4, r4), g4[3] = Math.max(g4[3], t4, o4)) : g4 = [Math.min(e4, r4), Math.min(t4, o4), Math.max(e4, r4), Math.max(t4, o4)], __privateMethod(this, _Util_static2, t_fn2).call(this, e4, i4, s4, r4, t4, a4, n4, o4, 3 * (3 * (i4 - s4) - e4 + r4), 6 * (e4 - 2 * i4 + s4), 3 * (i4 - e4), g4), __privateMethod(this, _Util_static2, t_fn2).call(this, e4, i4, s4, r4, t4, a4, n4, o4, 3 * (3 * (a4 - n4) - t4 + o4), 6 * (t4 - 2 * a4 + n4), 3 * (a4 - t4), g4), g4;
    }
  }
  _Util_static2 = new WeakSet();
  e_fn2 = function(e4, t4, i4, a4, s4, n4, r4, o4, g4, c4) {
    if (g4 <= 0 || g4 >= 1) return;
    const h4 = 1 - g4, l4 = g4 * g4, C4 = l4 * g4, d4 = h4 * (h4 * (h4 * e4 + 3 * g4 * t4) + 3 * l4 * i4) + C4 * a4, u4 = h4 * (h4 * (h4 * s4 + 3 * g4 * n4) + 3 * l4 * r4) + C4 * o4;
    c4[0] = Math.min(c4[0], d4), c4[1] = Math.min(c4[1], u4), c4[2] = Math.max(c4[2], d4), c4[3] = Math.max(c4[3], u4);
  };
  t_fn2 = function(e4, t4, i4, a4, s4, n4, r4, o4, g4, c4, h4, l4) {
    if (Math.abs(g4) < 1e-12) return void (Math.abs(c4) >= 1e-12 && __privateMethod(this, _Util_static2, e_fn2).call(this, e4, t4, i4, a4, s4, n4, r4, o4, -h4 / c4, l4));
    const C4 = c4 ** 2 - 4 * h4 * g4;
    if (C4 < 0) return;
    const d4 = Math.sqrt(C4), u4 = 2 * g4;
    __privateMethod(this, _Util_static2, e_fn2).call(this, e4, t4, i4, a4, s4, n4, r4, o4, (-c4 + d4) / u4, l4), __privateMethod(this, _Util_static2, e_fn2).call(this, e4, t4, i4, a4, s4, n4, r4, o4, (-c4 - d4) / u4, l4);
  };
  __privateAdd(Util2, _Util_static2);
  let ne3 = null, re3 = null;
  function normalizeUnicode(e4) {
    return ne3 || (ne3 = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, re3 = /* @__PURE__ */ new Map([["\uFB05", "\u017Ft"]])), e4.replaceAll(ne3, (e5, t4, i4) => t4 ? t4.normalize("NFKC") : re3.get(i4));
  }
  const oe3 = "pdfjs_internal_id_", ge3 = 0, ce3 = 1, he3 = 2, le3 = 3, Ie3 = 4, Ce3 = 5, de3 = 6, Be3 = 7, ue3 = 8;
  class BaseFilterFactory {
    addFilter(e4) {
      return "none";
    }
    addHCMFilter(e4, t4) {
      return "none";
    }
    addAlphaFilter(e4) {
      return "none";
    }
    addLuminosityFilter(e4) {
      return "none";
    }
    addHighlightHCMFilter(e4, t4, i4, a4, s4) {
      return "none";
    }
    destroy(e4 = false) {
    }
  }
  class BaseCanvasFactory {
    constructor({ enableHWA: e4 = false } = {}) {
      __privateAdd(this, _W, false);
      __privateSet(this, _W, e4);
    }
    create(e4, t4) {
      if (e4 <= 0 || t4 <= 0) throw new Error("Invalid canvas size");
      const i4 = this._createCanvas(e4, t4);
      return { canvas: i4, context: i4.getContext("2d", { willReadFrequently: !__privateGet(this, _W) }) };
    }
    reset(e4, t4, i4) {
      if (!e4.canvas) throw new Error("Canvas is not specified");
      if (t4 <= 0 || i4 <= 0) throw new Error("Invalid canvas size");
      e4.canvas.width = t4, e4.canvas.height = i4;
    }
    destroy(e4) {
      if (!e4.canvas) throw new Error("Canvas is not specified");
      e4.canvas.width = 0, e4.canvas.height = 0, e4.canvas = null, e4.context = null;
    }
    _createCanvas(e4, t4) {
      unreachable2("Abstract method `_createCanvas` called.");
    }
  }
  _W = new WeakMap();
  class BaseCMapReaderFactory {
    constructor({ baseUrl: e4 = null, isCompressed: t4 = true }) {
      this.baseUrl = e4, this.isCompressed = t4;
    }
    async fetch({ name: e4 }) {
      if (!this.baseUrl) throw new Error("Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.");
      if (!e4) throw new Error("CMap name must be specified.");
      const t4 = this.baseUrl + e4 + (this.isCompressed ? ".bcmap" : ""), i4 = this.isCompressed ? ee3.BINARY : ee3.NONE;
      return this._fetchData(t4, i4).catch((e5) => {
        throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${t4}`);
      });
    }
    _fetchData(e4, t4) {
      unreachable2("Abstract method `_fetchData` called.");
    }
  }
  class BaseStandardFontDataFactory {
    constructor({ baseUrl: e4 = null }) {
      this.baseUrl = e4;
    }
    async fetch({ filename: e4 }) {
      if (!this.baseUrl) throw new Error("Ensure that the `standardFontDataUrl` API parameter is provided.");
      if (!e4) throw new Error("Font filename must be specified.");
      const t4 = `${this.baseUrl}${e4}`;
      return this._fetchData(t4).catch((e5) => {
        throw new Error(`Unable to load font data at: ${t4}`);
      });
    }
    _fetchData(e4) {
      unreachable2("Abstract method `_fetchData` called.");
    }
  }
  class BaseSVGFactory {
    create(e4, t4, i4 = false) {
      if (e4 <= 0 || t4 <= 0) throw new Error("Invalid SVG dimensions");
      const a4 = this._createSVG("svg:svg");
      return a4.setAttribute("version", "1.1"), i4 || (a4.setAttribute("width", `${e4}px`), a4.setAttribute("height", `${t4}px`)), a4.setAttribute("preserveAspectRatio", "none"), a4.setAttribute("viewBox", `0 0 ${e4} ${t4}`), a4;
    }
    createElement(e4) {
      if ("string" != typeof e4) throw new Error("Invalid SVG element type");
      return this._createSVG(e4);
    }
    _createSVG(e4) {
      unreachable2("Abstract method `_createSVG` called.");
    }
  }
  const Qe3 = "http://www.w3.org/2000/svg";
  const _PixelsPerInch = class _PixelsPerInch {
  };
  __publicField(_PixelsPerInch, "CSS", 96);
  __publicField(_PixelsPerInch, "PDF", 72);
  __publicField(_PixelsPerInch, "PDF_TO_CSS_UNITS", _PixelsPerInch.CSS / _PixelsPerInch.PDF);
  let PixelsPerInch = _PixelsPerInch;
  async function fetchData(e4, t4 = "text") {
    if (isValidFetchUrl(e4, document.baseURI)) {
      const i4 = await fetch(e4);
      if (!i4.ok) throw new Error(i4.statusText);
      switch (t4) {
        case "arraybuffer":
          return i4.arrayBuffer();
        case "blob":
          return i4.blob();
        case "json":
          return i4.json();
      }
      return i4.text();
    }
    return new Promise((i4, a4) => {
      const s4 = new XMLHttpRequest();
      s4.open("GET", e4, true), s4.responseType = t4, s4.onreadystatechange = () => {
        if (s4.readyState === XMLHttpRequest.DONE) if (200 !== s4.status && 0 !== s4.status) a4(new Error(s4.statusText));
        else {
          switch (t4) {
            case "arraybuffer":
            case "blob":
            case "json":
              return void i4(s4.response);
          }
          i4(s4.responseText);
        }
      }, s4.send(null);
    });
  }
  class DOMCMapReaderFactory extends BaseCMapReaderFactory {
    _fetchData(e4, t4) {
      return fetchData(e4, this.isCompressed ? "arraybuffer" : "text").then((e5) => ({ cMapData: e5 instanceof ArrayBuffer ? new Uint8Array(e5) : stringToBytes2(e5), compressionType: t4 }));
    }
  }
  class DOMStandardFontDataFactory extends BaseStandardFontDataFactory {
    _fetchData(e4) {
      return fetchData(e4, "arraybuffer").then((e5) => new Uint8Array(e5));
    }
  }
  class DOMSVGFactory extends BaseSVGFactory {
    _createSVG(e4) {
      return document.createElementNS(Qe3, e4);
    }
  }
  class PageViewport {
    constructor({ viewBox: e4, scale: t4, rotation: i4, offsetX: a4 = 0, offsetY: s4 = 0, dontFlip: n4 = false }) {
      this.viewBox = e4, this.scale = t4, this.rotation = i4, this.offsetX = a4, this.offsetY = s4;
      const r4 = (e4[2] + e4[0]) / 2, o4 = (e4[3] + e4[1]) / 2;
      let g4, c4, h4, l4, C4, d4, u4, Q4;
      switch ((i4 %= 360) < 0 && (i4 += 360), i4) {
        case 180:
          g4 = -1, c4 = 0, h4 = 0, l4 = 1;
          break;
        case 90:
          g4 = 0, c4 = 1, h4 = 1, l4 = 0;
          break;
        case 270:
          g4 = 0, c4 = -1, h4 = -1, l4 = 0;
          break;
        case 0:
          g4 = 1, c4 = 0, h4 = 0, l4 = -1;
          break;
        default:
          throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
      }
      n4 && (h4 = -h4, l4 = -l4), 0 === g4 ? (C4 = Math.abs(o4 - e4[1]) * t4 + a4, d4 = Math.abs(r4 - e4[0]) * t4 + s4, u4 = (e4[3] - e4[1]) * t4, Q4 = (e4[2] - e4[0]) * t4) : (C4 = Math.abs(r4 - e4[0]) * t4 + a4, d4 = Math.abs(o4 - e4[1]) * t4 + s4, u4 = (e4[2] - e4[0]) * t4, Q4 = (e4[3] - e4[1]) * t4), this.transform = [g4 * t4, c4 * t4, h4 * t4, l4 * t4, C4 - g4 * t4 * r4 - h4 * t4 * o4, d4 - c4 * t4 * r4 - l4 * t4 * o4], this.width = u4, this.height = Q4;
    }
    get rawDims() {
      const { viewBox: e4 } = this;
      return shadow2(this, "rawDims", { pageWidth: e4[2] - e4[0], pageHeight: e4[3] - e4[1], pageX: e4[0], pageY: e4[1] });
    }
    clone({ scale: e4 = this.scale, rotation: t4 = this.rotation, offsetX: i4 = this.offsetX, offsetY: a4 = this.offsetY, dontFlip: s4 = false } = {}) {
      return new PageViewport({ viewBox: this.viewBox.slice(), scale: e4, rotation: t4, offsetX: i4, offsetY: a4, dontFlip: s4 });
    }
    convertToViewportPoint(e4, t4) {
      return Util2.applyTransform([e4, t4], this.transform);
    }
    convertToViewportRectangle(e4) {
      const t4 = Util2.applyTransform([e4[0], e4[1]], this.transform), i4 = Util2.applyTransform([e4[2], e4[3]], this.transform);
      return [t4[0], t4[1], i4[0], i4[1]];
    }
    convertToPdfPoint(e4, t4) {
      return Util2.applyInverseTransform([e4, t4], this.transform);
    }
  }
  class RenderingCancelledException extends ae3 {
    constructor(e4, t4 = 0) {
      super(e4, "RenderingCancelledException"), this.extraDelay = t4;
    }
  }
  function isDataScheme(e4) {
    const t4 = e4.length;
    let i4 = 0;
    for (; i4 < t4 && "" === e4[i4].trim(); ) i4++;
    return "data:" === e4.substring(i4, i4 + 5).toLowerCase();
  }
  function isPdfFile(e4) {
    return "string" == typeof e4 && /\.pdf$/i.test(e4);
  }
  function getFilenameFromUrl(e4) {
    return [e4] = e4.split(/[#?]/, 1), e4.substring(e4.lastIndexOf("/") + 1);
  }
  function getPdfFilenameFromUrl(e4, t4 = "document.pdf") {
    if ("string" != typeof e4) return t4;
    if (isDataScheme(e4)) return warn2('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), t4;
    const i4 = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, a4 = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/.exec(e4);
    let s4 = i4.exec(a4[1]) || i4.exec(a4[2]) || i4.exec(a4[3]);
    if (s4 && (s4 = s4[0], s4.includes("%"))) try {
      s4 = i4.exec(decodeURIComponent(s4))[0];
    } catch {
    }
    return s4 || t4;
  }
  class StatTimer {
    constructor() {
      __publicField(this, "started", /* @__PURE__ */ Object.create(null));
      __publicField(this, "times", []);
    }
    time(e4) {
      e4 in this.started && warn2(`Timer is already running for ${e4}`), this.started[e4] = Date.now();
    }
    timeEnd(e4) {
      e4 in this.started || warn2(`Timer has not been started for ${e4}`), this.times.push({ name: e4, start: this.started[e4], end: Date.now() }), delete this.started[e4];
    }
    toString() {
      const e4 = [];
      let t4 = 0;
      for (const { name: e5 } of this.times) t4 = Math.max(e5.length, t4);
      for (const { name: i4, start: a4, end: s4 } of this.times) e4.push(`${i4.padEnd(t4)} ${s4 - a4}ms
`);
      return e4.join("");
    }
  }
  function isValidFetchUrl(e4, t4) {
    try {
      const { protocol: i4 } = t4 ? new URL(e4, t4) : new URL(e4);
      return "http:" === i4 || "https:" === i4;
    } catch {
      return false;
    }
  }
  function noContextMenu(e4) {
    e4.preventDefault();
  }
  let Ee3;
  class PDFDateString {
    static toDateObject(e4) {
      if (!e4 || "string" != typeof e4) return null;
      Ee3 || (Ee3 = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
      const t4 = Ee3.exec(e4);
      if (!t4) return null;
      const i4 = parseInt(t4[1], 10);
      let a4 = parseInt(t4[2], 10);
      a4 = a4 >= 1 && a4 <= 12 ? a4 - 1 : 0;
      let s4 = parseInt(t4[3], 10);
      s4 = s4 >= 1 && s4 <= 31 ? s4 : 1;
      let n4 = parseInt(t4[4], 10);
      n4 = n4 >= 0 && n4 <= 23 ? n4 : 0;
      let r4 = parseInt(t4[5], 10);
      r4 = r4 >= 0 && r4 <= 59 ? r4 : 0;
      let o4 = parseInt(t4[6], 10);
      o4 = o4 >= 0 && o4 <= 59 ? o4 : 0;
      const g4 = t4[7] || "Z";
      let c4 = parseInt(t4[8], 10);
      c4 = c4 >= 0 && c4 <= 23 ? c4 : 0;
      let h4 = parseInt(t4[9], 10) || 0;
      return h4 = h4 >= 0 && h4 <= 59 ? h4 : 0, "-" === g4 ? (n4 += c4, r4 += h4) : "+" === g4 && (n4 -= c4, r4 -= h4), new Date(Date.UTC(i4, a4, s4, n4, r4, o4));
    }
  }
  function getXfaPageViewport(e4, { scale: t4 = 1, rotation: i4 = 0 }) {
    const { width: a4, height: s4 } = e4.attributes.style, n4 = [0, 0, parseInt(a4), parseInt(s4)];
    return new PageViewport({ viewBox: n4, scale: t4, rotation: i4 });
  }
  function getRGB(e4) {
    if (e4.startsWith("#")) {
      const t4 = parseInt(e4.slice(1), 16);
      return [(16711680 & t4) >> 16, (65280 & t4) >> 8, 255 & t4];
    }
    return e4.startsWith("rgb(") ? e4.slice(4, -1).split(",").map((e5) => parseInt(e5)) : e4.startsWith("rgba(") ? e4.slice(5, -1).split(",").map((e5) => parseInt(e5)).slice(0, 3) : (warn2(`Not a valid color format: "${e4}"`), [0, 0, 0]);
  }
  function getCurrentTransform(e4) {
    const { a: t4, b: i4, c: a4, d: s4, e: n4, f: r4 } = e4.getTransform();
    return [t4, i4, a4, s4, n4, r4];
  }
  function getCurrentTransformInverse(e4) {
    const { a: t4, b: i4, c: a4, d: s4, e: n4, f: r4 } = e4.getTransform().invertSelf();
    return [t4, i4, a4, s4, n4, r4];
  }
  function setLayerDimensions(e4, t4, i4 = false, a4 = true) {
    if (t4 instanceof PageViewport) {
      const { pageWidth: a5, pageHeight: s4 } = t4.rawDims, { style: n4 } = e4, r4 = util_FeatureTest.isCSSRoundSupported, o4 = `var(--scale-factor) * ${a5}px`, g4 = `var(--scale-factor) * ${s4}px`, c4 = r4 ? `round(${o4}, 1px)` : `calc(${o4})`, h4 = r4 ? `round(${g4}, 1px)` : `calc(${g4})`;
      i4 && t4.rotation % 180 != 0 ? (n4.width = h4, n4.height = c4) : (n4.width = c4, n4.height = h4);
    }
    a4 && e4.setAttribute("data-main-rotation", t4.rotation);
  }
  const _EditorToolbar = class _EditorToolbar {
    constructor(e4) {
      __privateAdd(this, _EditorToolbar_instances);
      __privateAdd(this, _j, null);
      __privateAdd(this, _X, null);
      __privateAdd(this, _V);
      __privateAdd(this, _Z, null);
      __privateAdd(this, _z, null);
      __privateSet(this, _V, e4), __privateGet(_EditorToolbar, _$) || __privateSet(_EditorToolbar, _$, Object.freeze({ freetext: "pdfjs-editor-remove-freetext-button", highlight: "pdfjs-editor-remove-highlight-button", ink: "pdfjs-editor-remove-ink-button", stamp: "pdfjs-editor-remove-stamp-button" }));
    }
    render() {
      const e4 = __privateSet(this, _j, document.createElement("div"));
      e4.className = "editToolbar", e4.setAttribute("role", "toolbar");
      const t4 = __privateGet(this, _V)._uiManager._signal;
      e4.addEventListener("contextmenu", noContextMenu, { signal: t4 }), e4.addEventListener("pointerdown", __privateMethod(_EditorToolbar, _EditorToolbar_static, ee_fn), { signal: t4 });
      const i4 = __privateSet(this, _Z, document.createElement("div"));
      i4.className = "buttons", e4.append(i4);
      const a4 = __privateGet(this, _V).toolbarPosition;
      if (a4) {
        const { style: t5 } = e4, i5 = "ltr" === __privateGet(this, _V)._uiManager.direction ? 1 - a4[0] : a4[0];
        t5.insetInlineEnd = 100 * i5 + "%", t5.top = `calc(${100 * a4[1]}% + var(--editor-toolbar-vert-offset))`;
      }
      return __privateMethod(this, _EditorToolbar_instances, te_fn).call(this), e4;
    }
    hide() {
      __privateGet(this, _j).classList.add("hidden"), __privateGet(this, _X)?.hideDropdown();
    }
    show() {
      __privateGet(this, _j).classList.remove("hidden"), __privateGet(this, _z)?.shown();
    }
    async addAltText(e4) {
      const t4 = await e4.render();
      __privateMethod(this, _EditorToolbar_instances, ae_fn).call(this, t4), __privateGet(this, _Z).prepend(t4, __privateGet(this, _EditorToolbar_instances, se_get)), __privateSet(this, _z, e4);
    }
    addColorPicker(e4) {
      __privateSet(this, _X, e4);
      const t4 = e4.renderButton();
      __privateMethod(this, _EditorToolbar_instances, ae_fn).call(this, t4), __privateGet(this, _Z).prepend(t4, __privateGet(this, _EditorToolbar_instances, se_get));
    }
    remove() {
      __privateGet(this, _j).remove(), __privateGet(this, _X)?.destroy(), __privateSet(this, _X, null);
    }
  };
  _j = new WeakMap();
  _X = new WeakMap();
  _V = new WeakMap();
  _Z = new WeakMap();
  _z = new WeakMap();
  _$ = new WeakMap();
  _EditorToolbar_static = new WeakSet();
  ee_fn = function(e4) {
    e4.stopPropagation();
  };
  _EditorToolbar_instances = new WeakSet();
  Ae_fn = function(e4) {
    __privateGet(this, _V)._focusEventsAllowed = false, e4.preventDefault(), e4.stopPropagation();
  };
  ie_fn = function(e4) {
    __privateGet(this, _V)._focusEventsAllowed = true, e4.preventDefault(), e4.stopPropagation();
  };
  ae_fn = function(e4) {
    const t4 = __privateGet(this, _V)._uiManager._signal;
    e4.addEventListener("focusin", __privateMethod(this, _EditorToolbar_instances, Ae_fn).bind(this), { capture: true, signal: t4 }), e4.addEventListener("focusout", __privateMethod(this, _EditorToolbar_instances, ie_fn).bind(this), { capture: true, signal: t4 }), e4.addEventListener("contextmenu", noContextMenu, { signal: t4 });
  };
  te_fn = function() {
    const { editorType: e4, _uiManager: t4 } = __privateGet(this, _V), i4 = document.createElement("button");
    i4.className = "delete", i4.tabIndex = 0, i4.setAttribute("data-l10n-id", __privateGet(_EditorToolbar, _$)[e4]), __privateMethod(this, _EditorToolbar_instances, ae_fn).call(this, i4), i4.addEventListener("click", (e5) => {
      t4.delete();
    }, { signal: t4._signal }), __privateGet(this, _Z).append(i4);
  };
  se_get = function() {
    const e4 = document.createElement("div");
    return e4.className = "divider", e4;
  };
  __privateAdd(_EditorToolbar, _EditorToolbar_static);
  __privateAdd(_EditorToolbar, _$, null);
  let EditorToolbar = _EditorToolbar;
  class HighlightToolbar {
    constructor(e4) {
      __privateAdd(this, _HighlightToolbar_instances);
      __privateAdd(this, _Z2, null);
      __privateAdd(this, _j2, null);
      __privateAdd(this, _ne);
      __privateSet(this, _ne, e4);
    }
    show(e4, t4, i4) {
      const [a4, s4] = __privateMethod(this, _HighlightToolbar_instances, ge_fn).call(this, t4, i4), { style: n4 } = __privateGet(this, _j2) || __privateSet(this, _j2, __privateMethod(this, _HighlightToolbar_instances, re_fn).call(this));
      e4.append(__privateGet(this, _j2)), n4.insetInlineEnd = 100 * a4 + "%", n4.top = `calc(${100 * s4}% + var(--editor-toolbar-vert-offset))`;
    }
    hide() {
      __privateGet(this, _j2).remove();
    }
  }
  _Z2 = new WeakMap();
  _j2 = new WeakMap();
  _ne = new WeakMap();
  _HighlightToolbar_instances = new WeakSet();
  re_fn = function() {
    const e4 = __privateSet(this, _j2, document.createElement("div"));
    e4.className = "editToolbar", e4.setAttribute("role", "toolbar"), e4.addEventListener("contextmenu", noContextMenu, { signal: __privateGet(this, _ne)._signal });
    const t4 = __privateSet(this, _Z2, document.createElement("div"));
    return t4.className = "buttons", e4.append(t4), __privateMethod(this, _HighlightToolbar_instances, oe_fn).call(this), e4;
  };
  ge_fn = function(e4, t4) {
    let i4 = 0, a4 = 0;
    for (const s4 of e4) {
      const e5 = s4.y + s4.height;
      if (e5 < i4) continue;
      const n4 = s4.x + (t4 ? s4.width : 0);
      e5 > i4 ? (a4 = n4, i4 = e5) : t4 ? n4 > a4 && (a4 = n4) : n4 < a4 && (a4 = n4);
    }
    return [t4 ? 1 - a4 : a4, i4];
  };
  oe_fn = function() {
    const e4 = document.createElement("button");
    e4.className = "highlightButton", e4.tabIndex = 0, e4.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button1");
    const t4 = document.createElement("span");
    e4.append(t4), t4.className = "visuallyHidden", t4.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button-label");
    const i4 = __privateGet(this, _ne)._signal;
    e4.addEventListener("contextmenu", noContextMenu, { signal: i4 }), e4.addEventListener("click", () => {
      __privateGet(this, _ne).highlightSelection("floating_button");
    }, { signal: i4 }), __privateGet(this, _Z2).append(e4);
  };
  function bindEvents(e4, t4, i4) {
    for (const a4 of i4) t4.addEventListener(a4, e4[a4].bind(e4));
  }
  class IdManager {
    constructor() {
      __privateAdd(this, _ce, 0);
    }
    get id() {
      return "pdfjs_internal_editor_" + __privateWrapper(this, _ce)._++;
    }
  }
  _ce = new WeakMap();
  const _ImageManager = class _ImageManager {
    constructor() {
      __privateAdd(this, _ImageManager_instances);
      __privateAdd(this, _he, function() {
        if ("undefined" != typeof crypto && "function" == typeof crypto?.randomUUID) return crypto.randomUUID();
        const e4 = new Uint8Array(32);
        if ("undefined" != typeof crypto && "function" == typeof crypto?.getRandomValues) crypto.getRandomValues(e4);
        else for (let t4 = 0; t4 < 32; t4++) e4[t4] = Math.floor(255 * Math.random());
        return bytesToString2(e4);
      }());
      __privateAdd(this, _ce2, 0);
      __privateAdd(this, _le, null);
    }
    static get _isSVGFittingCanvas() {
      const e4 = new OffscreenCanvas(1, 3).getContext("2d", { willReadFrequently: true }), t4 = new Image();
      t4.src = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>';
      return shadow2(this, "_isSVGFittingCanvas", t4.decode().then(() => (e4.drawImage(t4, 0, 0, 1, 1, 0, 0, 1, 3), 0 === new Uint32Array(e4.getImageData(0, 0, 1, 1).data.buffer)[0])));
    }
    async getFromFile(e4) {
      const { lastModified: t4, name: i4, size: a4, type: s4 } = e4;
      return __privateMethod(this, _ImageManager_instances, Ie_fn).call(this, `${t4}_${i4}_${a4}_${s4}`, e4);
    }
    async getFromUrl(e4) {
      return __privateMethod(this, _ImageManager_instances, Ie_fn).call(this, e4, e4);
    }
    async getFromId(e4) {
      __privateGet(this, _le) || __privateSet(this, _le, /* @__PURE__ */ new Map());
      const t4 = __privateGet(this, _le).get(e4);
      return t4 ? t4.bitmap ? (t4.refCounter += 1, t4) : t4.file ? this.getFromFile(t4.file) : this.getFromUrl(t4.url) : null;
    }
    getSvgUrl(e4) {
      const t4 = __privateGet(this, _le).get(e4);
      return t4?.isSvg ? t4.svgUrl : null;
    }
    deleteId(e4) {
      __privateGet(this, _le) || __privateSet(this, _le, /* @__PURE__ */ new Map());
      const t4 = __privateGet(this, _le).get(e4);
      t4 && (t4.refCounter -= 1, 0 === t4.refCounter && (t4.bitmap = null));
    }
    isValidId(e4) {
      return e4.startsWith(`image_${__privateGet(this, _he)}_`);
    }
  };
  _he = new WeakMap();
  _ce2 = new WeakMap();
  _le = new WeakMap();
  _ImageManager_instances = new WeakSet();
  Ie_fn = async function(e4, t4) {
    __privateGet(this, _le) || __privateSet(this, _le, /* @__PURE__ */ new Map());
    let i4 = __privateGet(this, _le).get(e4);
    if (null === i4) return null;
    if (i4?.bitmap) return i4.refCounter += 1, i4;
    try {
      let e5;
      if (i4 || (i4 = { bitmap: null, id: `image_${__privateGet(this, _he)}_${__privateWrapper(this, _ce2)._++}`, refCounter: 0, isSvg: false }), "string" == typeof t4 ? (i4.url = t4, e5 = await fetchData(t4, "blob")) : e5 = i4.file = t4, "image/svg+xml" === e5.type) {
        const t5 = _ImageManager._isSVGFittingCanvas, a4 = new FileReader(), s4 = new Image(), n4 = new Promise((e6, n5) => {
          s4.onload = () => {
            i4.bitmap = s4, i4.isSvg = true, e6();
          }, a4.onload = async () => {
            const e7 = i4.svgUrl = a4.result;
            s4.src = await t5 ? `${e7}#svgView(preserveAspectRatio(none))` : e7;
          }, s4.onerror = a4.onerror = n5;
        });
        a4.readAsDataURL(e5), await n4;
      } else i4.bitmap = await createImageBitmap(e5);
      i4.refCounter = 1;
    } catch (e5) {
      console.error(e5), i4 = null;
    }
    return __privateGet(this, _le).set(e4, i4), i4 && __privateGet(this, _le).set(i4.id, i4), i4;
  };
  let ImageManager = _ImageManager;
  class CommandManager {
    constructor(e4 = 128) {
      __privateAdd(this, _Ce, []);
      __privateAdd(this, _de, false);
      __privateAdd(this, _Be);
      __privateAdd(this, _ue, -1);
      __privateSet(this, _Be, e4);
    }
    add({ cmd: e4, undo: t4, post: i4, mustExec: a4, type: s4 = NaN, overwriteIfSameType: n4 = false, keepUndo: r4 = false }) {
      if (a4 && e4(), __privateGet(this, _de)) return;
      const o4 = { cmd: e4, undo: t4, post: i4, type: s4 };
      if (-1 === __privateGet(this, _ue)) return __privateGet(this, _Ce).length > 0 && (__privateGet(this, _Ce).length = 0), __privateSet(this, _ue, 0), void __privateGet(this, _Ce).push(o4);
      if (n4 && __privateGet(this, _Ce)[__privateGet(this, _ue)].type === s4) return r4 && (o4.undo = __privateGet(this, _Ce)[__privateGet(this, _ue)].undo), void (__privateGet(this, _Ce)[__privateGet(this, _ue)] = o4);
      const g4 = __privateGet(this, _ue) + 1;
      g4 === __privateGet(this, _Be) ? __privateGet(this, _Ce).splice(0, 1) : (__privateSet(this, _ue, g4), g4 < __privateGet(this, _Ce).length && __privateGet(this, _Ce).splice(g4)), __privateGet(this, _Ce).push(o4);
    }
    undo() {
      if (-1 === __privateGet(this, _ue)) return;
      __privateSet(this, _de, true);
      const { undo: e4, post: t4 } = __privateGet(this, _Ce)[__privateGet(this, _ue)];
      e4(), t4?.(), __privateSet(this, _de, false), __privateSet(this, _ue, __privateGet(this, _ue) - 1);
    }
    redo() {
      if (__privateGet(this, _ue) < __privateGet(this, _Ce).length - 1) {
        __privateSet(this, _ue, __privateGet(this, _ue) + 1), __privateSet(this, _de, true);
        const { cmd: e4, post: t4 } = __privateGet(this, _Ce)[__privateGet(this, _ue)];
        e4(), t4?.(), __privateSet(this, _de, false);
      }
    }
    hasSomethingToUndo() {
      return -1 !== __privateGet(this, _ue);
    }
    hasSomethingToRedo() {
      return __privateGet(this, _ue) < __privateGet(this, _Ce).length - 1;
    }
    destroy() {
      __privateSet(this, _Ce, null);
    }
  }
  _Ce = new WeakMap();
  _de = new WeakMap();
  _Be = new WeakMap();
  _ue = new WeakMap();
  class KeyboardManager {
    constructor(e4) {
      __privateAdd(this, _KeyboardManager_instances);
      this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
      const { isMac: t4 } = util_FeatureTest.platform;
      for (const [i4, a4, s4 = {}] of e4) for (const e5 of i4) {
        const i5 = e5.startsWith("mac+");
        t4 && i5 ? (this.callbacks.set(e5.slice(4), { callback: a4, options: s4 }), this.allKeys.add(e5.split("+").at(-1))) : t4 || i5 || (this.callbacks.set(e5, { callback: a4, options: s4 }), this.allKeys.add(e5.split("+").at(-1)));
      }
    }
    exec(e4, t4) {
      if (!this.allKeys.has(t4.key)) return;
      const i4 = this.callbacks.get(__privateMethod(this, _KeyboardManager_instances, Qe_fn).call(this, t4));
      if (!i4) return;
      const { callback: a4, options: { bubbles: s4 = false, args: n4 = [], checker: r4 = null } } = i4;
      r4 && !r4(e4, t4) || (a4.bind(e4, ...n4, t4)(), s4 || (t4.stopPropagation(), t4.preventDefault()));
    }
  }
  _KeyboardManager_instances = new WeakSet();
  Qe_fn = function(e4) {
    e4.altKey && this.buffer.push("alt"), e4.ctrlKey && this.buffer.push("ctrl"), e4.metaKey && this.buffer.push("meta"), e4.shiftKey && this.buffer.push("shift"), this.buffer.push(e4.key);
    const t4 = this.buffer.join("+");
    return this.buffer.length = 0, t4;
  };
  const _ColorManager = class _ColorManager {
    get _colors() {
      const e4 = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
      return function(e5) {
        const t4 = document.createElement("span");
        t4.style.visibility = "hidden", document.body.append(t4);
        for (const i4 of e5.keys()) {
          t4.style.color = i4;
          const a4 = window.getComputedStyle(t4).color;
          e5.set(i4, getRGB(a4));
        }
        t4.remove();
      }(e4), shadow2(this, "_colors", e4);
    }
    convert(e4) {
      const t4 = getRGB(e4);
      if (!window.matchMedia("(forced-colors: active)").matches) return t4;
      for (const [e5, i4] of this._colors) if (i4.every((e6, i5) => e6 === t4[i5])) return _ColorManager._colorsMapping.get(e5);
      return t4;
    }
    getHexCode(e4) {
      const t4 = this._colors.get(e4);
      return t4 ? Util2.makeHexColor(...t4) : e4;
    }
  };
  __publicField(_ColorManager, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
  let ColorManager = _ColorManager;
  const _AnnotationEditorUIManager = class _AnnotationEditorUIManager {
    constructor(e4, t4, i4, a4, s4, n4, r4, o4, g4, c4, h4) {
      __privateAdd(this, _AnnotationEditorUIManager_instances);
      __privateAdd(this, _Ee, new AbortController());
      __privateAdd(this, _fe, null);
      __privateAdd(this, _pe, /* @__PURE__ */ new Map());
      __privateAdd(this, _me, /* @__PURE__ */ new Map());
      __privateAdd(this, _ye, null);
      __privateAdd(this, _we, null);
      __privateAdd(this, _be, null);
      __privateAdd(this, _De, new CommandManager());
      __privateAdd(this, _Se, null);
      __privateAdd(this, _Fe, 0);
      __privateAdd(this, _ke, /* @__PURE__ */ new Set());
      __privateAdd(this, _Re, null);
      __privateAdd(this, _xe, null);
      __privateAdd(this, _Ne, /* @__PURE__ */ new Set());
      __privateAdd(this, _Me, false);
      __privateAdd(this, _Ge, false);
      __privateAdd(this, _ve, false);
      __privateAdd(this, _Le, null);
      __privateAdd(this, _Ue, null);
      __privateAdd(this, _He, null);
      __privateAdd(this, _Te, null);
      __privateAdd(this, _Je, false);
      __privateAdd(this, _Ye, null);
      __privateAdd(this, _Pe, new IdManager());
      __privateAdd(this, _Oe, false);
      __privateAdd(this, _Ke, false);
      __privateAdd(this, _qe, null);
      __privateAdd(this, __e, null);
      __privateAdd(this, _We, null);
      __privateAdd(this, _je, null);
      __privateAdd(this, _Xe, Q3.NONE);
      __privateAdd(this, _Ve, /* @__PURE__ */ new Set());
      __privateAdd(this, _Ze, null);
      __privateAdd(this, _ze, null);
      __privateAdd(this, _$e, null);
      __privateAdd(this, _et, { isEditing: false, isEmpty: true, hasSomethingToUndo: false, hasSomethingToRedo: false, hasSelectedEditor: false, hasSelectedText: false });
      __privateAdd(this, _tt, [0, 0]);
      __privateAdd(this, _At, null);
      __privateAdd(this, _it, null);
      __privateAdd(this, _at, null);
      const l4 = this._signal = __privateGet(this, _Ee).signal;
      __privateSet(this, _it, e4), __privateSet(this, _at, t4), __privateSet(this, _ye, i4), this._eventBus = a4, a4._on("editingaction", this.onEditingAction.bind(this), { signal: l4 }), a4._on("pagechanging", this.onPageChanging.bind(this), { signal: l4 }), a4._on("scalechanging", this.onScaleChanging.bind(this), { signal: l4 }), a4._on("rotationchanging", this.onRotationChanging.bind(this), { signal: l4 }), a4._on("setpreference", this.onSetPreference.bind(this), { signal: l4 }), a4._on("switchannotationeditorparams", (e5) => this.updateParams(e5.type, e5.value), { signal: l4 }), __privateMethod(this, _AnnotationEditorUIManager_instances, st_fn).call(this), __privateMethod(this, _AnnotationEditorUIManager_instances, nt_fn).call(this), __privateMethod(this, _AnnotationEditorUIManager_instances, rt_fn).call(this), __privateSet(this, _we, s4.annotationStorage), __privateSet(this, _Le, s4.filterFactory), __privateSet(this, _ze, n4), __privateSet(this, _Te, r4 || null), __privateSet(this, _Me, o4), __privateSet(this, _Ge, g4), __privateSet(this, _ve, c4), __privateSet(this, _je, h4 || null), this.viewParameters = { realScale: PixelsPerInch.PDF_TO_CSS_UNITS, rotation: 0 }, this.isShiftKeyDown = false;
    }
    static get _keyboardManager() {
      const e4 = _AnnotationEditorUIManager.prototype, arrowChecker = (e5) => __privateGet(e5, _it).contains(document.activeElement) && "BUTTON" !== document.activeElement.tagName && e5.hasSomethingToControl(), textInputChecker = (e5, { target: t5 }) => {
        if (t5 instanceof HTMLInputElement) {
          const { type: e6 } = t5;
          return "text" !== e6 && "number" !== e6;
        }
        return true;
      }, t4 = this.TRANSLATE_SMALL, i4 = this.TRANSLATE_BIG;
      return shadow2(this, "_keyboardManager", new KeyboardManager([[["ctrl+a", "mac+meta+a"], e4.selectAll, { checker: textInputChecker }], [["ctrl+z", "mac+meta+z"], e4.undo, { checker: textInputChecker }], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], e4.redo, { checker: textInputChecker }], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], e4.delete, { checker: textInputChecker }], [["Enter", "mac+Enter"], e4.addNewEditorFromKeyboard, { checker: (e5, { target: t5 }) => !(t5 instanceof HTMLButtonElement) && __privateGet(e5, _it).contains(t5) && !e5.isEnterHandled }], [[" ", "mac+ "], e4.addNewEditorFromKeyboard, { checker: (e5, { target: t5 }) => !(t5 instanceof HTMLButtonElement) && __privateGet(e5, _it).contains(document.activeElement) }], [["Escape", "mac+Escape"], e4.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], e4.translateSelectedEditors, { args: [-t4, 0], checker: arrowChecker }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], e4.translateSelectedEditors, { args: [-i4, 0], checker: arrowChecker }], [["ArrowRight", "mac+ArrowRight"], e4.translateSelectedEditors, { args: [t4, 0], checker: arrowChecker }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], e4.translateSelectedEditors, { args: [i4, 0], checker: arrowChecker }], [["ArrowUp", "mac+ArrowUp"], e4.translateSelectedEditors, { args: [0, -t4], checker: arrowChecker }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], e4.translateSelectedEditors, { args: [0, -i4], checker: arrowChecker }], [["ArrowDown", "mac+ArrowDown"], e4.translateSelectedEditors, { args: [0, t4], checker: arrowChecker }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], e4.translateSelectedEditors, { args: [0, i4], checker: arrowChecker }]]));
    }
    destroy() {
      __privateGet(this, _Ee)?.abort(), __privateSet(this, _Ee, null), this._signal = null;
      for (const e4 of __privateGet(this, _me).values()) e4.destroy();
      __privateGet(this, _me).clear(), __privateGet(this, _pe).clear(), __privateGet(this, _Ne).clear(), __privateSet(this, _fe, null), __privateGet(this, _Ve).clear(), __privateGet(this, _De).destroy(), __privateGet(this, _ye)?.destroy(), __privateGet(this, _Ye)?.hide(), __privateSet(this, _Ye, null), __privateGet(this, _Ue) && (clearTimeout(__privateGet(this, _Ue)), __privateSet(this, _Ue, null)), __privateGet(this, _At) && (clearTimeout(__privateGet(this, _At)), __privateSet(this, _At, null));
    }
    combinedSignal(e4) {
      return AbortSignal.any([this._signal, e4.signal]);
    }
    get mlManager() {
      return __privateGet(this, _je);
    }
    get useNewAltTextFlow() {
      return __privateGet(this, _Ge);
    }
    get useNewAltTextWhenAddingImage() {
      return __privateGet(this, _ve);
    }
    get hcmFilter() {
      return shadow2(this, "hcmFilter", __privateGet(this, _ze) ? __privateGet(this, _Le).addHCMFilter(__privateGet(this, _ze).foreground, __privateGet(this, _ze).background) : "none");
    }
    get direction() {
      return shadow2(this, "direction", getComputedStyle(__privateGet(this, _it)).direction);
    }
    get highlightColors() {
      return shadow2(this, "highlightColors", __privateGet(this, _Te) ? new Map(__privateGet(this, _Te).split(",").map((e4) => e4.split("=").map((e5) => e5.trim()))) : null);
    }
    get highlightColorNames() {
      return shadow2(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, (e4) => e4.reverse())) : null);
    }
    setMainHighlightColorPicker(e4) {
      __privateSet(this, _We, e4);
    }
    editAltText(e4, t4 = false) {
      __privateGet(this, _ye)?.editAltText(this, e4, t4);
    }
    switchToMode(e4, t4) {
      this._eventBus.on("annotationeditormodechanged", t4, { once: true, signal: this._signal }), this._eventBus.dispatch("showannotationeditorui", { source: this, mode: e4 });
    }
    setPreference(e4, t4) {
      this._eventBus.dispatch("setpreference", { source: this, name: e4, value: t4 });
    }
    onSetPreference({ name: e4, value: t4 }) {
      if ("enableNewAltTextWhenAddingImage" === e4) __privateSet(this, _ve, t4);
    }
    onPageChanging({ pageNumber: e4 }) {
      __privateSet(this, _Fe, e4 - 1);
    }
    focusMainContainer() {
      __privateGet(this, _it).focus();
    }
    findParent(e4, t4) {
      for (const i4 of __privateGet(this, _me).values()) {
        const { x: a4, y: s4, width: n4, height: r4 } = i4.div.getBoundingClientRect();
        if (e4 >= a4 && e4 <= a4 + n4 && t4 >= s4 && t4 <= s4 + r4) return i4;
      }
      return null;
    }
    disableUserSelect(e4 = false) {
      __privateGet(this, _at).classList.toggle("noUserSelect", e4);
    }
    addShouldRescale(e4) {
      __privateGet(this, _Ne).add(e4);
    }
    removeShouldRescale(e4) {
      __privateGet(this, _Ne).delete(e4);
    }
    onScaleChanging({ scale: e4 }) {
      this.commitOrRemove(), this.viewParameters.realScale = e4 * PixelsPerInch.PDF_TO_CSS_UNITS;
      for (const e5 of __privateGet(this, _Ne)) e5.onScaleChanging();
    }
    onRotationChanging({ pagesRotation: e4 }) {
      this.commitOrRemove(), this.viewParameters.rotation = e4;
    }
    highlightSelection(e4 = "") {
      const t4 = document.getSelection();
      if (!t4 || t4.isCollapsed) return;
      const { anchorNode: i4, anchorOffset: a4, focusNode: s4, focusOffset: n4 } = t4, r4 = t4.toString(), o4 = __privateMethod(this, _AnnotationEditorUIManager_instances, ot_fn).call(this, t4).closest(".textLayer"), g4 = this.getSelectionBoxes(o4);
      if (!g4) return;
      t4.empty();
      const c4 = __privateMethod(this, _AnnotationEditorUIManager_instances, gt_fn).call(this, o4), h4 = __privateGet(this, _Xe) === Q3.NONE, callback = () => {
        c4?.createAndAddNewEditor({ x: 0, y: 0 }, false, { methodOfCreation: e4, boxes: g4, anchorNode: i4, anchorOffset: a4, focusNode: s4, focusOffset: n4, text: r4 }), h4 && this.showAllEditors("highlight", true, true);
      };
      h4 ? this.switchToMode(Q3.HIGHLIGHT, callback) : callback();
    }
    addToAnnotationStorage(e4) {
      e4.isEmpty() || !__privateGet(this, _we) || __privateGet(this, _we).has(e4.id) || __privateGet(this, _we).setValue(e4.id, e4);
    }
    blur() {
      if (this.isShiftKeyDown = false, __privateGet(this, _Je) && (__privateSet(this, _Je, false), __privateMethod(this, _AnnotationEditorUIManager_instances, It_fn).call(this, "main_toolbar")), !this.hasSelection) return;
      const { activeElement: e4 } = document;
      for (const t4 of __privateGet(this, _Ve)) if (t4.div.contains(e4)) {
        __privateSet(this, __e, [t4, e4]), t4._focusEventsAllowed = false;
        break;
      }
    }
    focus() {
      if (!__privateGet(this, __e)) return;
      const [e4, t4] = __privateGet(this, __e);
      __privateSet(this, __e, null), t4.addEventListener("focusin", () => {
        e4._focusEventsAllowed = true;
      }, { once: true, signal: this._signal }), t4.focus();
    }
    addEditListeners() {
      __privateMethod(this, _AnnotationEditorUIManager_instances, rt_fn).call(this), __privateMethod(this, _AnnotationEditorUIManager_instances, ut_fn).call(this);
    }
    removeEditListeners() {
      __privateMethod(this, _AnnotationEditorUIManager_instances, Bt_fn).call(this), __privateMethod(this, _AnnotationEditorUIManager_instances, Qt_fn).call(this);
    }
    dragOver(e4) {
      for (const { type: t4 } of e4.dataTransfer.items) for (const i4 of __privateGet(this, _xe)) if (i4.isHandlingMimeForPasting(t4)) return e4.dataTransfer.dropEffect = "copy", void e4.preventDefault();
    }
    drop(e4) {
      for (const t4 of e4.dataTransfer.items) for (const i4 of __privateGet(this, _xe)) if (i4.isHandlingMimeForPasting(t4.type)) return i4.paste(t4, this.currentLayer), void e4.preventDefault();
    }
    copy(e4) {
      if (e4.preventDefault(), __privateGet(this, _fe)?.commitOrRemove(), !this.hasSelection) return;
      const t4 = [];
      for (const e5 of __privateGet(this, _Ve)) {
        const i4 = e5.serialize(true);
        i4 && t4.push(i4);
      }
      0 !== t4.length && e4.clipboardData.setData("application/pdfjs", JSON.stringify(t4));
    }
    cut(e4) {
      this.copy(e4), this.delete();
    }
    paste(e4) {
      e4.preventDefault();
      const { clipboardData: t4 } = e4;
      for (const e5 of t4.items) for (const t5 of __privateGet(this, _xe)) if (t5.isHandlingMimeForPasting(e5.type)) return void t5.paste(e5, this.currentLayer);
      let i4 = t4.getData("application/pdfjs");
      if (!i4) return;
      try {
        i4 = JSON.parse(i4);
      } catch (e5) {
        return void warn2(`paste: "${e5.message}".`);
      }
      if (!Array.isArray(i4)) return;
      this.unselectAll();
      const a4 = this.currentLayer;
      try {
        const e5 = [];
        for (const t5 of i4) {
          const i5 = a4.deserialize(t5);
          if (!i5) return;
          e5.push(i5);
        }
        const cmd = () => {
          for (const t5 of e5) __privateMethod(this, _AnnotationEditorUIManager_instances, Et_fn).call(this, t5);
          __privateMethod(this, _AnnotationEditorUIManager_instances, ft_fn).call(this, e5);
        }, undo = () => {
          for (const t5 of e5) t5.remove();
        };
        this.addCommands({ cmd, undo, mustExec: true });
      } catch (e5) {
        warn2(`paste: "${e5.message}".`);
      }
    }
    keydown(e4) {
      this.isShiftKeyDown || "Shift" !== e4.key || (this.isShiftKeyDown = true), __privateGet(this, _Xe) === Q3.NONE || this.isEditorHandlingKeyboard || _AnnotationEditorUIManager._keyboardManager.exec(this, e4);
    }
    keyup(e4) {
      this.isShiftKeyDown && "Shift" === e4.key && (this.isShiftKeyDown = false, __privateGet(this, _Je) && (__privateSet(this, _Je, false), __privateMethod(this, _AnnotationEditorUIManager_instances, It_fn).call(this, "main_toolbar")));
    }
    onEditingAction({ name: e4 }) {
      switch (e4) {
        case "undo":
        case "redo":
        case "delete":
        case "selectAll":
          this[e4]();
          break;
        case "highlightSelection":
          this.highlightSelection("context_menu");
      }
    }
    setEditingState(e4) {
      e4 ? (__privateMethod(this, _AnnotationEditorUIManager_instances, Ct_fn).call(this), __privateMethod(this, _AnnotationEditorUIManager_instances, ut_fn).call(this), __privateMethod(this, _AnnotationEditorUIManager_instances, lt_fn).call(this, { isEditing: __privateGet(this, _Xe) !== Q3.NONE, isEmpty: __privateMethod(this, _AnnotationEditorUIManager_instances, mt_fn).call(this), hasSomethingToUndo: __privateGet(this, _De).hasSomethingToUndo(), hasSomethingToRedo: __privateGet(this, _De).hasSomethingToRedo(), hasSelectedEditor: false })) : (__privateMethod(this, _AnnotationEditorUIManager_instances, dt_fn).call(this), __privateMethod(this, _AnnotationEditorUIManager_instances, Qt_fn).call(this), __privateMethod(this, _AnnotationEditorUIManager_instances, lt_fn).call(this, { isEditing: false }), this.disableUserSelect(false));
    }
    registerEditorTypes(e4) {
      if (!__privateGet(this, _xe)) {
        __privateSet(this, _xe, e4);
        for (const e5 of __privateGet(this, _xe)) __privateMethod(this, _AnnotationEditorUIManager_instances, pt_fn).call(this, e5.defaultPropertiesToUpdate);
      }
    }
    getId() {
      return __privateGet(this, _Pe).id;
    }
    get currentLayer() {
      return __privateGet(this, _me).get(__privateGet(this, _Fe));
    }
    getLayer(e4) {
      return __privateGet(this, _me).get(e4);
    }
    get currentPageIndex() {
      return __privateGet(this, _Fe);
    }
    addLayer(e4) {
      __privateGet(this, _me).set(e4.pageIndex, e4), __privateGet(this, _Oe) ? e4.enable() : e4.disable();
    }
    removeLayer(e4) {
      __privateGet(this, _me).delete(e4.pageIndex);
    }
    updateMode(e4, t4 = null, i4 = false) {
      if (__privateGet(this, _Xe) !== e4) {
        if (__privateSet(this, _Xe, e4), e4 === Q3.NONE) return this.setEditingState(false), void __privateMethod(this, _AnnotationEditorUIManager_instances, yt_fn).call(this);
        this.setEditingState(true), __privateMethod(this, _AnnotationEditorUIManager_instances, wt_fn).call(this), this.unselectAll();
        for (const t5 of __privateGet(this, _me).values()) t5.updateMode(e4);
        if (t4 || !i4) {
          if (t4) {
            for (const e5 of __privateGet(this, _pe).values()) if (e5.annotationElementId === t4) {
              this.setSelected(e5), e5.enterInEditMode();
              break;
            }
          }
        } else this.addNewEditorFromKeyboard();
      }
    }
    addNewEditorFromKeyboard() {
      this.currentLayer.canCreateNewEmptyEditor() && this.currentLayer.addNewEditor();
    }
    updateToolbar(e4) {
      e4 !== __privateGet(this, _Xe) && this._eventBus.dispatch("switchannotationeditormode", { source: this, mode: e4 });
    }
    updateParams(e4, t4) {
      if (__privateGet(this, _xe)) {
        switch (e4) {
          case f3.CREATE:
            return void this.currentLayer.addNewEditor();
          case f3.HIGHLIGHT_DEFAULT_COLOR:
            __privateGet(this, _We)?.updateColor(t4);
            break;
          case f3.HIGHLIGHT_SHOW_ALL:
            this._eventBus.dispatch("reporttelemetry", { source: this, details: { type: "editing", data: { type: "highlight", action: "toggle_visibility" } } }), (__privateGet(this, _$e) || __privateSet(this, _$e, /* @__PURE__ */ new Map())).set(e4, t4), this.showAllEditors("highlight", t4);
        }
        for (const i4 of __privateGet(this, _Ve)) i4.updateParams(e4, t4);
        for (const i4 of __privateGet(this, _xe)) i4.updateDefaultParams(e4, t4);
      }
    }
    showAllEditors(e4, t4, i4 = false) {
      for (const i5 of __privateGet(this, _pe).values()) i5.editorType === e4 && i5.show(t4);
      (__privateGet(this, _$e)?.get(f3.HIGHLIGHT_SHOW_ALL) ?? true) !== t4 && __privateMethod(this, _AnnotationEditorUIManager_instances, pt_fn).call(this, [[f3.HIGHLIGHT_SHOW_ALL, t4]]);
    }
    enableWaiting(e4 = false) {
      if (__privateGet(this, _Ke) !== e4) {
        __privateSet(this, _Ke, e4);
        for (const t4 of __privateGet(this, _me).values()) e4 ? t4.disableClick() : t4.enableClick(), t4.div.classList.toggle("waiting", e4);
      }
    }
    getEditors(e4) {
      const t4 = [];
      for (const i4 of __privateGet(this, _pe).values()) i4.pageIndex === e4 && t4.push(i4);
      return t4;
    }
    getEditor(e4) {
      return __privateGet(this, _pe).get(e4);
    }
    addEditor(e4) {
      __privateGet(this, _pe).set(e4.id, e4);
    }
    removeEditor(e4) {
      e4.div.contains(document.activeElement) && (__privateGet(this, _Ue) && clearTimeout(__privateGet(this, _Ue)), __privateSet(this, _Ue, setTimeout(() => {
        this.focusMainContainer(), __privateSet(this, _Ue, null);
      }, 0))), __privateGet(this, _pe).delete(e4.id), this.unselect(e4), e4.annotationElementId && __privateGet(this, _ke).has(e4.annotationElementId) || __privateGet(this, _we)?.remove(e4.id);
    }
    addDeletedAnnotationElement(e4) {
      __privateGet(this, _ke).add(e4.annotationElementId), this.addChangedExistingAnnotation(e4), e4.deleted = true;
    }
    isDeletedAnnotationElement(e4) {
      return __privateGet(this, _ke).has(e4);
    }
    removeDeletedAnnotationElement(e4) {
      __privateGet(this, _ke).delete(e4.annotationElementId), this.removeChangedExistingAnnotation(e4), e4.deleted = false;
    }
    setActiveEditor(e4) {
      __privateGet(this, _fe) !== e4 && (__privateSet(this, _fe, e4), e4 && __privateMethod(this, _AnnotationEditorUIManager_instances, pt_fn).call(this, e4.propertiesToUpdate));
    }
    updateUI(e4) {
      __privateGet(this, _AnnotationEditorUIManager_instances, bt_get) === e4 && __privateMethod(this, _AnnotationEditorUIManager_instances, pt_fn).call(this, e4.propertiesToUpdate);
    }
    toggleSelected(e4) {
      if (__privateGet(this, _Ve).has(e4)) return __privateGet(this, _Ve).delete(e4), e4.unselect(), void __privateMethod(this, _AnnotationEditorUIManager_instances, lt_fn).call(this, { hasSelectedEditor: this.hasSelection });
      __privateGet(this, _Ve).add(e4), e4.select(), __privateMethod(this, _AnnotationEditorUIManager_instances, pt_fn).call(this, e4.propertiesToUpdate), __privateMethod(this, _AnnotationEditorUIManager_instances, lt_fn).call(this, { hasSelectedEditor: true });
    }
    setSelected(e4) {
      for (const t4 of __privateGet(this, _Ve)) t4 !== e4 && t4.unselect();
      __privateGet(this, _Ve).clear(), __privateGet(this, _Ve).add(e4), e4.select(), __privateMethod(this, _AnnotationEditorUIManager_instances, pt_fn).call(this, e4.propertiesToUpdate), __privateMethod(this, _AnnotationEditorUIManager_instances, lt_fn).call(this, { hasSelectedEditor: true });
    }
    isSelected(e4) {
      return __privateGet(this, _Ve).has(e4);
    }
    get firstSelectedEditor() {
      return __privateGet(this, _Ve).values().next().value;
    }
    unselect(e4) {
      e4.unselect(), __privateGet(this, _Ve).delete(e4), __privateMethod(this, _AnnotationEditorUIManager_instances, lt_fn).call(this, { hasSelectedEditor: this.hasSelection });
    }
    get hasSelection() {
      return 0 !== __privateGet(this, _Ve).size;
    }
    get isEnterHandled() {
      return 1 === __privateGet(this, _Ve).size && this.firstSelectedEditor.isEnterHandled;
    }
    undo() {
      __privateGet(this, _De).undo(), __privateMethod(this, _AnnotationEditorUIManager_instances, lt_fn).call(this, { hasSomethingToUndo: __privateGet(this, _De).hasSomethingToUndo(), hasSomethingToRedo: true, isEmpty: __privateMethod(this, _AnnotationEditorUIManager_instances, mt_fn).call(this) });
    }
    redo() {
      __privateGet(this, _De).redo(), __privateMethod(this, _AnnotationEditorUIManager_instances, lt_fn).call(this, { hasSomethingToUndo: true, hasSomethingToRedo: __privateGet(this, _De).hasSomethingToRedo(), isEmpty: __privateMethod(this, _AnnotationEditorUIManager_instances, mt_fn).call(this) });
    }
    addCommands(e4) {
      __privateGet(this, _De).add(e4), __privateMethod(this, _AnnotationEditorUIManager_instances, lt_fn).call(this, { hasSomethingToUndo: true, hasSomethingToRedo: false, isEmpty: __privateMethod(this, _AnnotationEditorUIManager_instances, mt_fn).call(this) });
    }
    delete() {
      if (this.commitOrRemove(), !this.hasSelection) return;
      const e4 = [...__privateGet(this, _Ve)];
      this.addCommands({ cmd: () => {
        for (const t4 of e4) t4.remove();
      }, undo: () => {
        for (const t4 of e4) __privateMethod(this, _AnnotationEditorUIManager_instances, Et_fn).call(this, t4);
      }, mustExec: true });
    }
    commitOrRemove() {
      __privateGet(this, _fe)?.commitOrRemove();
    }
    hasSomethingToControl() {
      return __privateGet(this, _fe) || this.hasSelection;
    }
    selectAll() {
      for (const e4 of __privateGet(this, _Ve)) e4.commit();
      __privateMethod(this, _AnnotationEditorUIManager_instances, ft_fn).call(this, __privateGet(this, _pe).values());
    }
    unselectAll() {
      if ((!__privateGet(this, _fe) || (__privateGet(this, _fe).commitOrRemove(), __privateGet(this, _Xe) === Q3.NONE)) && this.hasSelection) {
        for (const e4 of __privateGet(this, _Ve)) e4.unselect();
        __privateGet(this, _Ve).clear(), __privateMethod(this, _AnnotationEditorUIManager_instances, lt_fn).call(this, { hasSelectedEditor: false });
      }
    }
    translateSelectedEditors(e4, t4, i4 = false) {
      if (i4 || this.commitOrRemove(), !this.hasSelection) return;
      __privateGet(this, _tt)[0] += e4, __privateGet(this, _tt)[1] += t4;
      const [a4, s4] = __privateGet(this, _tt), n4 = [...__privateGet(this, _Ve)];
      __privateGet(this, _At) && clearTimeout(__privateGet(this, _At)), __privateSet(this, _At, setTimeout(() => {
        __privateSet(this, _At, null), __privateGet(this, _tt)[0] = __privateGet(this, _tt)[1] = 0, this.addCommands({ cmd: () => {
          for (const e5 of n4) __privateGet(this, _pe).has(e5.id) && e5.translateInPage(a4, s4);
        }, undo: () => {
          for (const e5 of n4) __privateGet(this, _pe).has(e5.id) && e5.translateInPage(-a4, -s4);
        }, mustExec: false });
      }, 1e3));
      for (const i5 of n4) i5.translateInPage(e4, t4);
    }
    setUpDragSession() {
      if (this.hasSelection) {
        this.disableUserSelect(true), __privateSet(this, _Re, /* @__PURE__ */ new Map());
        for (const e4 of __privateGet(this, _Ve)) __privateGet(this, _Re).set(e4, { savedX: e4.x, savedY: e4.y, savedPageIndex: e4.pageIndex, newX: 0, newY: 0, newPageIndex: -1 });
      }
    }
    endDragSession() {
      if (!__privateGet(this, _Re)) return false;
      this.disableUserSelect(false);
      const e4 = __privateGet(this, _Re);
      __privateSet(this, _Re, null);
      let t4 = false;
      for (const [{ x: i4, y: a4, pageIndex: s4 }, n4] of e4) n4.newX = i4, n4.newY = a4, n4.newPageIndex = s4, t4 || (t4 = i4 !== n4.savedX || a4 !== n4.savedY || s4 !== n4.savedPageIndex);
      if (!t4) return false;
      const move = (e5, t5, i4, a4) => {
        if (__privateGet(this, _pe).has(e5.id)) {
          const s4 = __privateGet(this, _me).get(a4);
          s4 ? e5._setParentAndPosition(s4, t5, i4) : (e5.pageIndex = a4, e5.x = t5, e5.y = i4);
        }
      };
      return this.addCommands({ cmd: () => {
        for (const [t5, { newX: i4, newY: a4, newPageIndex: s4 }] of e4) move(t5, i4, a4, s4);
      }, undo: () => {
        for (const [t5, { savedX: i4, savedY: a4, savedPageIndex: s4 }] of e4) move(t5, i4, a4, s4);
      }, mustExec: true }), true;
    }
    dragSelectedEditors(e4, t4) {
      if (__privateGet(this, _Re)) for (const i4 of __privateGet(this, _Re).keys()) i4.drag(e4, t4);
    }
    rebuild(e4) {
      if (null === e4.parent) {
        const t4 = this.getLayer(e4.pageIndex);
        t4 ? (t4.changeParent(e4), t4.addOrRebuild(e4)) : (this.addEditor(e4), this.addToAnnotationStorage(e4), e4.rebuild());
      } else e4.parent.addOrRebuild(e4);
    }
    get isEditorHandlingKeyboard() {
      return this.getActive()?.shouldGetKeyboardEvents() || 1 === __privateGet(this, _Ve).size && this.firstSelectedEditor.shouldGetKeyboardEvents();
    }
    isActive(e4) {
      return __privateGet(this, _fe) === e4;
    }
    getActive() {
      return __privateGet(this, _fe);
    }
    getMode() {
      return __privateGet(this, _Xe);
    }
    get imageManager() {
      return shadow2(this, "imageManager", new ImageManager());
    }
    getSelectionBoxes(e4) {
      if (!e4) return null;
      const t4 = document.getSelection();
      for (let i5 = 0, a5 = t4.rangeCount; i5 < a5; i5++) if (!e4.contains(t4.getRangeAt(i5).commonAncestorContainer)) return null;
      const { x: i4, y: a4, width: s4, height: n4 } = e4.getBoundingClientRect();
      let r4;
      switch (e4.getAttribute("data-main-rotation")) {
        case "90":
          r4 = (e5, t5, r5, o5) => ({ x: (t5 - a4) / n4, y: 1 - (e5 + r5 - i4) / s4, width: o5 / n4, height: r5 / s4 });
          break;
        case "180":
          r4 = (e5, t5, r5, o5) => ({ x: 1 - (e5 + r5 - i4) / s4, y: 1 - (t5 + o5 - a4) / n4, width: r5 / s4, height: o5 / n4 });
          break;
        case "270":
          r4 = (e5, t5, r5, o5) => ({ x: 1 - (t5 + o5 - a4) / n4, y: (e5 - i4) / s4, width: o5 / n4, height: r5 / s4 });
          break;
        default:
          r4 = (e5, t5, r5, o5) => ({ x: (e5 - i4) / s4, y: (t5 - a4) / n4, width: r5 / s4, height: o5 / n4 });
      }
      const o4 = [];
      for (let e5 = 0, i5 = t4.rangeCount; e5 < i5; e5++) {
        const i6 = t4.getRangeAt(e5);
        if (!i6.collapsed) for (const { x: e6, y: t5, width: a5, height: s5 } of i6.getClientRects()) 0 !== a5 && 0 !== s5 && o4.push(r4(e6, t5, a5, s5));
      }
      return 0 === o4.length ? null : o4;
    }
    addChangedExistingAnnotation({ annotationElementId: e4, id: t4 }) {
      (__privateGet(this, _be) || __privateSet(this, _be, /* @__PURE__ */ new Map())).set(e4, t4);
    }
    removeChangedExistingAnnotation({ annotationElementId: e4 }) {
      __privateGet(this, _be)?.delete(e4);
    }
    renderAnnotationElement(e4) {
      const t4 = __privateGet(this, _be)?.get(e4.data.id);
      if (!t4) return;
      const i4 = __privateGet(this, _we).getRawValue(t4);
      i4 && (__privateGet(this, _Xe) !== Q3.NONE || i4.hasBeenModified) && i4.renderAnnotationElement(e4);
    }
  };
  _Ee = new WeakMap();
  _fe = new WeakMap();
  _pe = new WeakMap();
  _me = new WeakMap();
  _ye = new WeakMap();
  _we = new WeakMap();
  _be = new WeakMap();
  _De = new WeakMap();
  _Se = new WeakMap();
  _Fe = new WeakMap();
  _ke = new WeakMap();
  _Re = new WeakMap();
  _xe = new WeakMap();
  _Ne = new WeakMap();
  _Me = new WeakMap();
  _Ge = new WeakMap();
  _ve = new WeakMap();
  _Le = new WeakMap();
  _Ue = new WeakMap();
  _He = new WeakMap();
  _Te = new WeakMap();
  _Je = new WeakMap();
  _Ye = new WeakMap();
  _Pe = new WeakMap();
  _Oe = new WeakMap();
  _Ke = new WeakMap();
  _qe = new WeakMap();
  __e = new WeakMap();
  _We = new WeakMap();
  _je = new WeakMap();
  _Xe = new WeakMap();
  _Ve = new WeakMap();
  _Ze = new WeakMap();
  _ze = new WeakMap();
  _$e = new WeakMap();
  _et = new WeakMap();
  _tt = new WeakMap();
  _At = new WeakMap();
  _it = new WeakMap();
  _at = new WeakMap();
  _AnnotationEditorUIManager_instances = new WeakSet();
  ot_fn = function({ anchorNode: e4 }) {
    return e4.nodeType === Node.TEXT_NODE ? e4.parentElement : e4;
  };
  gt_fn = function(e4) {
    const { currentLayer: t4 } = this;
    if (t4.hasTextLayer(e4)) return t4;
    for (const t5 of __privateGet(this, _me).values()) if (t5.hasTextLayer(e4)) return t5;
    return null;
  };
  ct_fn = function() {
    const e4 = document.getSelection();
    if (!e4 || e4.isCollapsed) return;
    const t4 = __privateMethod(this, _AnnotationEditorUIManager_instances, ot_fn).call(this, e4).closest(".textLayer"), i4 = this.getSelectionBoxes(t4);
    i4 && (__privateGet(this, _Ye) || __privateSet(this, _Ye, new HighlightToolbar(this)), __privateGet(this, _Ye).show(t4, i4, "ltr" === this.direction));
  };
  ht_fn = function() {
    const e4 = document.getSelection();
    if (!e4 || e4.isCollapsed) return void (__privateGet(this, _Ze) && (__privateGet(this, _Ye)?.hide(), __privateSet(this, _Ze, null), __privateMethod(this, _AnnotationEditorUIManager_instances, lt_fn).call(this, { hasSelectedText: false })));
    const { anchorNode: t4 } = e4;
    if (t4 === __privateGet(this, _Ze)) return;
    const i4 = __privateMethod(this, _AnnotationEditorUIManager_instances, ot_fn).call(this, e4).closest(".textLayer");
    if (i4) {
      if (__privateGet(this, _Ye)?.hide(), __privateSet(this, _Ze, t4), __privateMethod(this, _AnnotationEditorUIManager_instances, lt_fn).call(this, { hasSelectedText: true }), (__privateGet(this, _Xe) === Q3.HIGHLIGHT || __privateGet(this, _Xe) === Q3.NONE) && (__privateGet(this, _Xe) === Q3.HIGHLIGHT && this.showAllEditors("highlight", true, true), __privateSet(this, _Je, this.isShiftKeyDown), !this.isShiftKeyDown)) {
        const e5 = __privateGet(this, _Xe) === Q3.HIGHLIGHT ? __privateMethod(this, _AnnotationEditorUIManager_instances, gt_fn).call(this, i4) : null;
        e5?.toggleDrawing();
        const t5 = new AbortController(), a4 = this.combinedSignal(t5), pointerup = (i5) => {
          "pointerup" === i5.type && 0 !== i5.button || (t5.abort(), e5?.toggleDrawing(true), "pointerup" === i5.type && __privateMethod(this, _AnnotationEditorUIManager_instances, It_fn).call(this, "main_toolbar"));
        };
        window.addEventListener("pointerup", pointerup, { signal: a4 }), window.addEventListener("blur", pointerup, { signal: a4 });
      }
    } else __privateGet(this, _Ze) && (__privateGet(this, _Ye)?.hide(), __privateSet(this, _Ze, null), __privateMethod(this, _AnnotationEditorUIManager_instances, lt_fn).call(this, { hasSelectedText: false }));
  };
  It_fn = function(e4 = "") {
    __privateGet(this, _Xe) === Q3.HIGHLIGHT ? this.highlightSelection(e4) : __privateGet(this, _Me) && __privateMethod(this, _AnnotationEditorUIManager_instances, ct_fn).call(this);
  };
  st_fn = function() {
    document.addEventListener("selectionchange", __privateMethod(this, _AnnotationEditorUIManager_instances, ht_fn).bind(this), { signal: this._signal });
  };
  Ct_fn = function() {
    if (__privateGet(this, _He)) return;
    __privateSet(this, _He, new AbortController());
    const e4 = this.combinedSignal(__privateGet(this, _He));
    window.addEventListener("focus", this.focus.bind(this), { signal: e4 }), window.addEventListener("blur", this.blur.bind(this), { signal: e4 });
  };
  dt_fn = function() {
    __privateGet(this, _He)?.abort(), __privateSet(this, _He, null);
  };
  rt_fn = function() {
    if (__privateGet(this, _qe)) return;
    __privateSet(this, _qe, new AbortController());
    const e4 = this.combinedSignal(__privateGet(this, _qe));
    window.addEventListener("keydown", this.keydown.bind(this), { signal: e4 }), window.addEventListener("keyup", this.keyup.bind(this), { signal: e4 });
  };
  Bt_fn = function() {
    __privateGet(this, _qe)?.abort(), __privateSet(this, _qe, null);
  };
  ut_fn = function() {
    if (__privateGet(this, _Se)) return;
    __privateSet(this, _Se, new AbortController());
    const e4 = this.combinedSignal(__privateGet(this, _Se));
    document.addEventListener("copy", this.copy.bind(this), { signal: e4 }), document.addEventListener("cut", this.cut.bind(this), { signal: e4 }), document.addEventListener("paste", this.paste.bind(this), { signal: e4 });
  };
  Qt_fn = function() {
    __privateGet(this, _Se)?.abort(), __privateSet(this, _Se, null);
  };
  nt_fn = function() {
    const e4 = this._signal;
    document.addEventListener("dragover", this.dragOver.bind(this), { signal: e4 }), document.addEventListener("drop", this.drop.bind(this), { signal: e4 });
  };
  lt_fn = function(e4) {
    Object.entries(e4).some(([e5, t4]) => __privateGet(this, _et)[e5] !== t4) && (this._eventBus.dispatch("annotationeditorstateschanged", { source: this, details: Object.assign(__privateGet(this, _et), e4) }), __privateGet(this, _Xe) === Q3.HIGHLIGHT && false === e4.hasSelectedEditor && __privateMethod(this, _AnnotationEditorUIManager_instances, pt_fn).call(this, [[f3.HIGHLIGHT_FREE, true]]));
  };
  pt_fn = function(e4) {
    this._eventBus.dispatch("annotationeditorparamschanged", { source: this, details: e4 });
  };
  wt_fn = function() {
    if (!__privateGet(this, _Oe)) {
      __privateSet(this, _Oe, true);
      for (const e4 of __privateGet(this, _me).values()) e4.enable();
      for (const e4 of __privateGet(this, _pe).values()) e4.enable();
    }
  };
  yt_fn = function() {
    if (this.unselectAll(), __privateGet(this, _Oe)) {
      __privateSet(this, _Oe, false);
      for (const e4 of __privateGet(this, _me).values()) e4.disable();
      for (const e4 of __privateGet(this, _pe).values()) e4.disable();
    }
  };
  Et_fn = function(e4) {
    const t4 = __privateGet(this, _me).get(e4.pageIndex);
    t4 ? t4.addOrRebuild(e4) : (this.addEditor(e4), this.addToAnnotationStorage(e4));
  };
  bt_get = function() {
    let e4 = null;
    for (e4 of __privateGet(this, _Ve)) ;
    return e4;
  };
  mt_fn = function() {
    if (0 === __privateGet(this, _pe).size) return true;
    if (1 === __privateGet(this, _pe).size) for (const e4 of __privateGet(this, _pe).values()) return e4.isEmpty();
    return false;
  };
  ft_fn = function(e4) {
    for (const e5 of __privateGet(this, _Ve)) e5.unselect();
    __privateGet(this, _Ve).clear();
    for (const t4 of e4) t4.isEmpty() || (__privateGet(this, _Ve).add(t4), t4.select());
    __privateMethod(this, _AnnotationEditorUIManager_instances, lt_fn).call(this, { hasSelectedEditor: this.hasSelection });
  };
  __publicField(_AnnotationEditorUIManager, "TRANSLATE_SMALL", 1);
  __publicField(_AnnotationEditorUIManager, "TRANSLATE_BIG", 10);
  let AnnotationEditorUIManager = _AnnotationEditorUIManager;
  const _AltText = class _AltText {
    constructor(e4) {
      __privateAdd(this, _AltText_instances);
      __privateAdd(this, _z2, null);
      __privateAdd(this, _Dt, false);
      __privateAdd(this, _St, null);
      __privateAdd(this, _Ft, null);
      __privateAdd(this, _kt, null);
      __privateAdd(this, _Rt, false);
      __privateAdd(this, _xt, null);
      __privateAdd(this, _V2, null);
      __privateAdd(this, _Nt, null);
      __privateAdd(this, _Mt, null);
      __privateAdd(this, _Gt, false);
      __privateSet(this, _V2, e4), __privateSet(this, _Gt, e4._uiManager.useNewAltTextFlow);
    }
    static initialize(e4) {
      _AltText._l10nPromise || (_AltText._l10nPromise = e4);
    }
    async render() {
      const e4 = __privateSet(this, _St, document.createElement("button"));
      let t4;
      e4.className = "altText", __privateGet(this, _Gt) ? (e4.classList.add("new"), t4 = await _AltText._l10nPromise.get("pdfjs-editor-new-alt-text-missing-button-label")) : t4 = await _AltText._l10nPromise.get("pdfjs-editor-alt-text-button-label"), e4.textContent = t4, e4.setAttribute("aria-label", t4), e4.tabIndex = "0";
      const i4 = __privateGet(this, _V2)._uiManager._signal;
      e4.addEventListener("contextmenu", noContextMenu, { signal: i4 }), e4.addEventListener("pointerdown", (e5) => e5.stopPropagation(), { signal: i4 });
      const onClick = (e5) => {
        e5.preventDefault(), __privateGet(this, _V2)._uiManager.editAltText(__privateGet(this, _V2)), __privateGet(this, _Gt) && __privateGet(this, _V2)._reportTelemetry({ action: "pdfjs.image.alt_text.image_status_label_clicked", data: { label: __privateGet(this, _AltText_instances, vt_get) } });
      };
      return e4.addEventListener("click", onClick, { capture: true, signal: i4 }), e4.addEventListener("keydown", (t5) => {
        t5.target === e4 && "Enter" === t5.key && (__privateSet(this, _Rt, true), onClick(t5));
      }, { signal: i4 }), await __privateMethod(this, _AltText_instances, Lt_fn).call(this), e4;
    }
    finish() {
      __privateGet(this, _St) && (__privateGet(this, _St).focus({ focusVisible: __privateGet(this, _Rt) }), __privateSet(this, _Rt, false));
    }
    isEmpty() {
      return __privateGet(this, _Gt) ? null === __privateGet(this, _z2) : !__privateGet(this, _z2) && !__privateGet(this, _Dt);
    }
    hasData() {
      return __privateGet(this, _Gt) ? null !== __privateGet(this, _z2) || !!__privateGet(this, _Nt) : this.isEmpty();
    }
    get guessedText() {
      return __privateGet(this, _Nt);
    }
    async setGuessedText(e4) {
      null === __privateGet(this, _z2) && (__privateSet(this, _Nt, e4), __privateSet(this, _Mt, await _AltText._l10nPromise.get("pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer")({ generatedAltText: e4 })), __privateMethod(this, _AltText_instances, Lt_fn).call(this));
    }
    toggleAltTextBadge(e4 = false) {
      if (!__privateGet(this, _Gt) || __privateGet(this, _z2)) return __privateGet(this, _xt)?.remove(), void __privateSet(this, _xt, null);
      if (!__privateGet(this, _xt)) {
        const e5 = __privateSet(this, _xt, document.createElement("div"));
        e5.className = "noAltTextBadge", __privateGet(this, _V2).div.append(e5);
      }
      __privateGet(this, _xt).classList.toggle("hidden", !e4);
    }
    serialize(e4) {
      let t4 = __privateGet(this, _z2);
      return e4 || __privateGet(this, _Nt) !== t4 || (t4 = __privateGet(this, _Mt)), { altText: t4, decorative: __privateGet(this, _Dt), guessedText: __privateGet(this, _Nt), textWithDisclaimer: __privateGet(this, _Mt) };
    }
    get data() {
      return { altText: __privateGet(this, _z2), decorative: __privateGet(this, _Dt) };
    }
    set data({ altText: e4, decorative: t4, guessedText: i4, textWithDisclaimer: a4, cancel: s4 = false }) {
      i4 && (__privateSet(this, _Nt, i4), __privateSet(this, _Mt, a4)), __privateGet(this, _z2) === e4 && __privateGet(this, _Dt) === t4 || (s4 || (__privateSet(this, _z2, e4), __privateSet(this, _Dt, t4)), __privateMethod(this, _AltText_instances, Lt_fn).call(this));
    }
    toggle(e4 = false) {
      __privateGet(this, _St) && (!e4 && __privateGet(this, _kt) && (clearTimeout(__privateGet(this, _kt)), __privateSet(this, _kt, null)), __privateGet(this, _St).disabled = !e4);
    }
    shown() {
      __privateGet(this, _V2)._reportTelemetry({ action: "pdfjs.image.alt_text.image_status_label_displayed", data: { label: __privateGet(this, _AltText_instances, vt_get) } });
    }
    destroy() {
      __privateGet(this, _St)?.remove(), __privateSet(this, _St, null), __privateSet(this, _Ft, null), __privateGet(this, _xt)?.remove(), __privateSet(this, _xt, null);
    }
  };
  _z2 = new WeakMap();
  _Dt = new WeakMap();
  _St = new WeakMap();
  _Ft = new WeakMap();
  _kt = new WeakMap();
  _Rt = new WeakMap();
  _xt = new WeakMap();
  _V2 = new WeakMap();
  _Nt = new WeakMap();
  _Mt = new WeakMap();
  _Gt = new WeakMap();
  _AltText_instances = new WeakSet();
  vt_get = function() {
    return (__privateGet(this, _z2) ? "added" : null === __privateGet(this, _z2) && this.guessedText && "review") || "missing";
  };
  Lt_fn = async function() {
    const e4 = __privateGet(this, _St);
    if (!e4) return;
    if (__privateGet(this, _Gt)) {
      const t5 = __privateGet(this, _AltText_instances, vt_get), i5 = "review" === t5 ? "to-review" : t5;
      if (e4.classList.toggle("done", !!__privateGet(this, _z2)), _AltText._l10nPromise.get(`pdfjs-editor-new-alt-text-${i5}-button-label`).then((t6) => {
        e4.setAttribute("aria-label", t6);
        for (const i6 of e4.childNodes) if (i6.nodeType === Node.TEXT_NODE) {
          i6.textContent = t6;
          break;
        }
      }), !__privateGet(this, _z2)) return void __privateGet(this, _Ft)?.remove();
    } else {
      if (!__privateGet(this, _z2) && !__privateGet(this, _Dt)) return e4.classList.remove("done"), void __privateGet(this, _Ft)?.remove();
      e4.classList.add("done"), _AltText._l10nPromise.get("pdfjs-editor-alt-text-edit-button-label").then((t5) => {
        e4.setAttribute("aria-label", t5);
      });
    }
    let t4 = __privateGet(this, _Ft);
    if (!t4) {
      __privateSet(this, _Ft, t4 = document.createElement("span")), t4.className = "tooltip", t4.setAttribute("role", "tooltip");
      const i5 = t4.id = `alt-text-tooltip-${__privateGet(this, _V2).id}`;
      e4.setAttribute("aria-describedby", i5);
      const a4 = 100, s4 = __privateGet(this, _V2)._uiManager._signal;
      s4.addEventListener("abort", () => {
        clearTimeout(__privateGet(this, _kt)), __privateSet(this, _kt, null);
      }, { once: true }), e4.addEventListener("mouseenter", () => {
        __privateSet(this, _kt, setTimeout(() => {
          __privateSet(this, _kt, null), __privateGet(this, _Ft).classList.add("show"), __privateGet(this, _V2)._reportTelemetry({ action: "alt_text_tooltip" });
        }, a4));
      }, { signal: s4 }), e4.addEventListener("mouseleave", () => {
        __privateGet(this, _kt) && (clearTimeout(__privateGet(this, _kt)), __privateSet(this, _kt, null)), __privateGet(this, _Ft)?.classList.remove("show");
      }, { signal: s4 });
    }
    t4.innerText = __privateGet(this, _Dt) ? await _AltText._l10nPromise.get("pdfjs-editor-alt-text-decorative-tooltip") : __privateGet(this, _z2), t4.parentNode || e4.append(t4);
    const i4 = __privateGet(this, _V2).getImageForAltText();
    i4?.setAttribute("aria-describedby", t4.id);
  };
  __publicField(_AltText, "_l10nPromise", null);
  let AltText = _AltText;
  const _AnnotationEditor = class _AnnotationEditor {
    constructor(e4) {
      __privateAdd(this, _AnnotationEditor_instances);
      __privateAdd(this, _Ut, null);
      __privateAdd(this, _Ht, null);
      __privateAdd(this, _z3, null);
      __privateAdd(this, _Tt, false);
      __privateAdd(this, _Jt, false);
      __privateAdd(this, _Yt, null);
      __privateAdd(this, _Pt, null);
      __privateAdd(this, _Ot, null);
      __privateAdd(this, _Kt, "");
      __privateAdd(this, _qt, false);
      __privateAdd(this, __t, null);
      __privateAdd(this, _Wt, false);
      __privateAdd(this, _jt, false);
      __privateAdd(this, _Xt, false);
      __privateAdd(this, _Vt, null);
      __privateAdd(this, _Zt, 0);
      __privateAdd(this, _zt, 0);
      __privateAdd(this, _$t, null);
      __publicField(this, "_editToolbar", null);
      __publicField(this, "_initialOptions", /* @__PURE__ */ Object.create(null));
      __publicField(this, "_isVisible", true);
      __publicField(this, "_uiManager", null);
      __publicField(this, "_focusEventsAllowed", true);
      __privateAdd(this, _eA, false);
      __privateAdd(this, _tA, _AnnotationEditor._zIndex++);
      this.parent = e4.parent, this.id = e4.id, this.width = this.height = null, this.pageIndex = e4.parent.pageIndex, this.name = e4.name, this.div = null, this._uiManager = e4.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = false, this._initialOptions.isCentered = e4.isCentered, this._structTreeParentId = null;
      const { rotation: t4, rawDims: { pageWidth: i4, pageHeight: a4, pageX: s4, pageY: n4 } } = this.parent.viewport;
      this.rotation = t4, this.pageRotation = (360 + t4 - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [i4, a4], this.pageTranslation = [s4, n4];
      const [r4, o4] = this.parentDimensions;
      this.x = e4.x / r4, this.y = e4.y / o4, this.isAttachedToDOM = false, this.deleted = false;
    }
    static get _resizerKeyboardManager() {
      const e4 = _AnnotationEditor.prototype._resizeWithKeyboard, t4 = AnnotationEditorUIManager.TRANSLATE_SMALL, i4 = AnnotationEditorUIManager.TRANSLATE_BIG;
      return shadow2(this, "_resizerKeyboardManager", new KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], e4, { args: [-t4, 0] }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], e4, { args: [-i4, 0] }], [["ArrowRight", "mac+ArrowRight"], e4, { args: [t4, 0] }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], e4, { args: [i4, 0] }], [["ArrowUp", "mac+ArrowUp"], e4, { args: [0, -t4] }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], e4, { args: [0, -i4] }], [["ArrowDown", "mac+ArrowDown"], e4, { args: [0, t4] }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], e4, { args: [0, i4] }], [["Escape", "mac+Escape"], _AnnotationEditor.prototype._stopResizingWithKeyboard]]));
    }
    get editorType() {
      return Object.getPrototypeOf(this).constructor._type;
    }
    static get _defaultLineColor() {
      return shadow2(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
    }
    static deleteAnnotationElement(e4) {
      const t4 = new FakeEditor({ id: e4.parent.getNextId(), parent: e4.parent, uiManager: e4._uiManager });
      t4.annotationElementId = e4.annotationElementId, t4.deleted = true, t4._uiManager.addToAnnotationStorage(t4);
    }
    static initialize(e4, t4, i4) {
      if (_AnnotationEditor._l10nResizer || (_AnnotationEditor._l10nResizer = Object.freeze({ topLeft: "pdfjs-editor-resizer-top-left", topMiddle: "pdfjs-editor-resizer-top-middle", topRight: "pdfjs-editor-resizer-top-right", middleRight: "pdfjs-editor-resizer-middle-right", bottomRight: "pdfjs-editor-resizer-bottom-right", bottomMiddle: "pdfjs-editor-resizer-bottom-middle", bottomLeft: "pdfjs-editor-resizer-bottom-left", middleLeft: "pdfjs-editor-resizer-middle-left" })), _AnnotationEditor._l10nPromise || (_AnnotationEditor._l10nPromise = new Map([...["pdfjs-editor-alt-text-button-label", "pdfjs-editor-alt-text-edit-button-label", "pdfjs-editor-alt-text-decorative-tooltip", "pdfjs-editor-new-alt-text-added-button-label", "pdfjs-editor-new-alt-text-missing-button-label", "pdfjs-editor-new-alt-text-to-review-button-label"].map((t5) => [t5, e4.get(t5)]), ...["pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer"].map((t5) => [t5, e4.get.bind(e4, t5)])])), i4?.strings) for (const t5 of i4.strings) _AnnotationEditor._l10nPromise.set(t5, e4.get(t5));
      if (-1 !== _AnnotationEditor._borderLineWidth) return;
      const a4 = getComputedStyle(document.documentElement);
      _AnnotationEditor._borderLineWidth = parseFloat(a4.getPropertyValue("--outline-width")) || 0;
    }
    static updateDefaultParams(e4, t4) {
    }
    static get defaultPropertiesToUpdate() {
      return [];
    }
    static isHandlingMimeForPasting(e4) {
      return false;
    }
    static paste(e4, t4) {
      unreachable2("Not implemented");
    }
    get propertiesToUpdate() {
      return [];
    }
    get _isDraggable() {
      return __privateGet(this, _eA);
    }
    set _isDraggable(e4) {
      __privateSet(this, _eA, e4), this.div?.classList.toggle("draggable", e4);
    }
    get isEnterHandled() {
      return true;
    }
    center() {
      const [e4, t4] = this.pageDimensions;
      switch (this.parentRotation) {
        case 90:
          this.x -= this.height * t4 / (2 * e4), this.y += this.width * e4 / (2 * t4);
          break;
        case 180:
          this.x += this.width / 2, this.y += this.height / 2;
          break;
        case 270:
          this.x += this.height * t4 / (2 * e4), this.y -= this.width * e4 / (2 * t4);
          break;
        default:
          this.x -= this.width / 2, this.y -= this.height / 2;
      }
      this.fixAndSetPosition();
    }
    addCommands(e4) {
      this._uiManager.addCommands(e4);
    }
    get currentLayer() {
      return this._uiManager.currentLayer;
    }
    setInBackground() {
      this.div.style.zIndex = 0;
    }
    setInForeground() {
      this.div.style.zIndex = __privateGet(this, _tA);
    }
    setParent(e4) {
      null !== e4 ? (this.pageIndex = e4.pageIndex, this.pageDimensions = e4.pageDimensions) : __privateMethod(this, _AnnotationEditor_instances, AA_fn).call(this), this.parent = e4;
    }
    focusin(e4) {
      this._focusEventsAllowed && (__privateGet(this, _qt) ? __privateSet(this, _qt, false) : this.parent.setSelected(this));
    }
    focusout(e4) {
      if (!this._focusEventsAllowed) return;
      if (!this.isAttachedToDOM) return;
      const t4 = e4.relatedTarget;
      t4?.closest(`#${this.id}`) || (e4.preventDefault(), this.parent?.isMultipleSelection || this.commitOrRemove());
    }
    commitOrRemove() {
      this.isEmpty() ? this.remove() : this.commit();
    }
    commit() {
      this.addToAnnotationStorage();
    }
    addToAnnotationStorage() {
      this._uiManager.addToAnnotationStorage(this);
    }
    setAt(e4, t4, i4, a4) {
      const [s4, n4] = this.parentDimensions;
      [i4, a4] = this.screenToPageTranslation(i4, a4), this.x = (e4 + i4) / s4, this.y = (t4 + a4) / n4, this.fixAndSetPosition();
    }
    translate(e4, t4) {
      __privateMethod(this, _AnnotationEditor_instances, iA_fn).call(this, this.parentDimensions, e4, t4);
    }
    translateInPage(e4, t4) {
      __privateGet(this, __t) || __privateSet(this, __t, [this.x, this.y]), __privateMethod(this, _AnnotationEditor_instances, iA_fn).call(this, this.pageDimensions, e4, t4), this.div.scrollIntoView({ block: "nearest" });
    }
    drag(e4, t4) {
      __privateGet(this, __t) || __privateSet(this, __t, [this.x, this.y]);
      const [i4, a4] = this.parentDimensions;
      if (this.x += e4 / i4, this.y += t4 / a4, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
        const { x: e5, y: t5 } = this.div.getBoundingClientRect();
        this.parent.findNewParent(this, e5, t5) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y));
      }
      let { x: s4, y: n4 } = this;
      const [r4, o4] = this.getBaseTranslation();
      s4 += r4, n4 += o4, this.div.style.left = `${(100 * s4).toFixed(2)}%`, this.div.style.top = `${(100 * n4).toFixed(2)}%`, this.div.scrollIntoView({ block: "nearest" });
    }
    get _hasBeenMoved() {
      return !!__privateGet(this, __t) && (__privateGet(this, __t)[0] !== this.x || __privateGet(this, __t)[1] !== this.y);
    }
    getBaseTranslation() {
      const [e4, t4] = this.parentDimensions, { _borderLineWidth: i4 } = _AnnotationEditor, a4 = i4 / e4, s4 = i4 / t4;
      switch (this.rotation) {
        case 90:
          return [-a4, s4];
        case 180:
          return [a4, s4];
        case 270:
          return [a4, -s4];
        default:
          return [-a4, -s4];
      }
    }
    get _mustFixPosition() {
      return true;
    }
    fixAndSetPosition(e4 = this.rotation) {
      const [t4, i4] = this.pageDimensions;
      let { x: a4, y: s4, width: n4, height: r4 } = this;
      if (n4 *= t4, r4 *= i4, a4 *= t4, s4 *= i4, this._mustFixPosition) switch (e4) {
        case 0:
          a4 = Math.max(0, Math.min(t4 - n4, a4)), s4 = Math.max(0, Math.min(i4 - r4, s4));
          break;
        case 90:
          a4 = Math.max(0, Math.min(t4 - r4, a4)), s4 = Math.min(i4, Math.max(n4, s4));
          break;
        case 180:
          a4 = Math.min(t4, Math.max(n4, a4)), s4 = Math.min(i4, Math.max(r4, s4));
          break;
        case 270:
          a4 = Math.min(t4, Math.max(r4, a4)), s4 = Math.max(0, Math.min(i4 - n4, s4));
      }
      this.x = a4 /= t4, this.y = s4 /= i4;
      const [o4, g4] = this.getBaseTranslation();
      a4 += o4, s4 += g4;
      const { style: c4 } = this.div;
      c4.left = `${(100 * a4).toFixed(2)}%`, c4.top = `${(100 * s4).toFixed(2)}%`, this.moveInDOM();
    }
    screenToPageTranslation(e4, t4) {
      var _a5;
      return __privateMethod(_a5 = _AnnotationEditor, _AnnotationEditor_static, aA_fn).call(_a5, e4, t4, this.parentRotation);
    }
    pageTranslationToScreen(e4, t4) {
      var _a5;
      return __privateMethod(_a5 = _AnnotationEditor, _AnnotationEditor_static, aA_fn).call(_a5, e4, t4, 360 - this.parentRotation);
    }
    get parentScale() {
      return this._uiManager.viewParameters.realScale;
    }
    get parentRotation() {
      return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
    }
    get parentDimensions() {
      const { parentScale: e4, pageDimensions: [t4, i4] } = this, a4 = t4 * e4, s4 = i4 * e4;
      return util_FeatureTest.isCSSRoundSupported ? [Math.round(a4), Math.round(s4)] : [a4, s4];
    }
    setDims(e4, t4) {
      const [i4, a4] = this.parentDimensions;
      this.div.style.width = `${(100 * e4 / i4).toFixed(2)}%`, __privateGet(this, _Jt) || (this.div.style.height = `${(100 * t4 / a4).toFixed(2)}%`);
    }
    fixDims() {
      const { style: e4 } = this.div, { height: t4, width: i4 } = e4, a4 = i4.endsWith("%"), s4 = !__privateGet(this, _Jt) && t4.endsWith("%");
      if (a4 && s4) return;
      const [n4, r4] = this.parentDimensions;
      a4 || (e4.width = `${(100 * parseFloat(i4) / n4).toFixed(2)}%`), __privateGet(this, _Jt) || s4 || (e4.height = `${(100 * parseFloat(t4) / r4).toFixed(2)}%`);
    }
    getInitialTranslation() {
      return [0, 0];
    }
    altTextFinish() {
      __privateGet(this, _z3)?.finish();
    }
    async addEditToolbar() {
      return this._editToolbar || __privateGet(this, _jt) || (this._editToolbar = new EditorToolbar(this), this.div.append(this._editToolbar.render()), __privateGet(this, _z3) && await this._editToolbar.addAltText(__privateGet(this, _z3))), this._editToolbar;
    }
    removeEditToolbar() {
      this._editToolbar && (this._editToolbar.remove(), this._editToolbar = null, __privateGet(this, _z3)?.destroy());
    }
    getClientDimensions() {
      return this.div.getBoundingClientRect();
    }
    async addAltTextButton() {
      __privateGet(this, _z3) || (AltText.initialize(_AnnotationEditor._l10nPromise), __privateSet(this, _z3, new AltText(this)), __privateGet(this, _Ut) && (__privateGet(this, _z3).data = __privateGet(this, _Ut), __privateSet(this, _Ut, null)), await this.addEditToolbar());
    }
    get altTextData() {
      return __privateGet(this, _z3)?.data;
    }
    set altTextData(e4) {
      __privateGet(this, _z3) && (__privateGet(this, _z3).data = e4);
    }
    get guessedAltText() {
      return __privateGet(this, _z3)?.guessedText;
    }
    async setGuessedAltText(e4) {
      await __privateGet(this, _z3)?.setGuessedText(e4);
    }
    serializeAltText(e4) {
      return __privateGet(this, _z3)?.serialize(e4);
    }
    hasAltText() {
      return !!__privateGet(this, _z3) && !__privateGet(this, _z3).isEmpty();
    }
    hasAltTextData() {
      return __privateGet(this, _z3)?.hasData() ?? false;
    }
    render() {
      this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.tabIndex = __privateGet(this, _Tt) ? -1 : 0, this._isVisible || this.div.classList.add("hidden"), this.setInForeground(), __privateMethod(this, _AnnotationEditor_instances, cA_fn).call(this);
      const [e4, t4] = this.parentDimensions;
      this.parentRotation % 180 != 0 && (this.div.style.maxWidth = `${(100 * t4 / e4).toFixed(2)}%`, this.div.style.maxHeight = `${(100 * e4 / t4).toFixed(2)}%`);
      const [i4, a4] = this.getInitialTranslation();
      return this.translate(i4, a4), bindEvents(this, this.div, ["pointerdown"]), this.div;
    }
    pointerdown(e4) {
      const { isMac: t4 } = util_FeatureTest.platform;
      0 !== e4.button || e4.ctrlKey && t4 ? e4.preventDefault() : (__privateSet(this, _qt, true), this._isDraggable ? __privateMethod(this, _AnnotationEditor_instances, hA_fn).call(this, e4) : __privateMethod(this, _AnnotationEditor_instances, lA_fn).call(this, e4));
    }
    moveInDOM() {
      __privateGet(this, _Vt) && clearTimeout(__privateGet(this, _Vt)), __privateSet(this, _Vt, setTimeout(() => {
        __privateSet(this, _Vt, null), this.parent?.moveEditorInDOM(this);
      }, 0));
    }
    _setParentAndPosition(e4, t4, i4) {
      e4.changeParent(this), this.x = t4, this.y = i4, this.fixAndSetPosition();
    }
    getRect(e4, t4, i4 = this.rotation) {
      const a4 = this.parentScale, [s4, n4] = this.pageDimensions, [r4, o4] = this.pageTranslation, g4 = e4 / a4, c4 = t4 / a4, h4 = this.x * s4, l4 = this.y * n4, C4 = this.width * s4, d4 = this.height * n4;
      switch (i4) {
        case 0:
          return [h4 + g4 + r4, n4 - l4 - c4 - d4 + o4, h4 + g4 + C4 + r4, n4 - l4 - c4 + o4];
        case 90:
          return [h4 + c4 + r4, n4 - l4 + g4 + o4, h4 + c4 + d4 + r4, n4 - l4 + g4 + C4 + o4];
        case 180:
          return [h4 - g4 - C4 + r4, n4 - l4 + c4 + o4, h4 - g4 + r4, n4 - l4 + c4 + d4 + o4];
        case 270:
          return [h4 - c4 - d4 + r4, n4 - l4 - g4 - C4 + o4, h4 - c4 + r4, n4 - l4 - g4 + o4];
        default:
          throw new Error("Invalid rotation");
      }
    }
    getRectInCurrentCoords(e4, t4) {
      const [i4, a4, s4, n4] = e4, r4 = s4 - i4, o4 = n4 - a4;
      switch (this.rotation) {
        case 0:
          return [i4, t4 - n4, r4, o4];
        case 90:
          return [i4, t4 - a4, o4, r4];
        case 180:
          return [s4, t4 - a4, r4, o4];
        case 270:
          return [s4, t4 - n4, o4, r4];
        default:
          throw new Error("Invalid rotation");
      }
    }
    onceAdded() {
    }
    isEmpty() {
      return false;
    }
    enableEditMode() {
      __privateSet(this, _jt, true);
    }
    disableEditMode() {
      __privateSet(this, _jt, false);
    }
    isInEditMode() {
      return __privateGet(this, _jt);
    }
    shouldGetKeyboardEvents() {
      return __privateGet(this, _Xt);
    }
    needsToBeRebuilt() {
      return this.div && !this.isAttachedToDOM;
    }
    rebuild() {
      __privateMethod(this, _AnnotationEditor_instances, cA_fn).call(this);
    }
    rotate(e4) {
    }
    serialize(e4 = false, t4 = null) {
      unreachable2("An editor must be serializable");
    }
    static deserialize(e4, t4, i4) {
      const a4 = new this.prototype.constructor({ parent: t4, id: t4.getNextId(), uiManager: i4 });
      a4.rotation = e4.rotation, __privateSet(a4, _Ut, e4.accessibilityData);
      const [s4, n4] = a4.pageDimensions, [r4, o4, g4, c4] = a4.getRectInCurrentCoords(e4.rect, n4);
      return a4.x = r4 / s4, a4.y = o4 / n4, a4.width = g4 / s4, a4.height = c4 / n4, a4;
    }
    get hasBeenModified() {
      return !!this.annotationElementId && (this.deleted || null !== this.serialize());
    }
    remove() {
      if (__privateGet(this, _Ot)?.abort(), __privateSet(this, _Ot, null), this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), __privateGet(this, _Vt) && (clearTimeout(__privateGet(this, _Vt)), __privateSet(this, _Vt, null)), __privateMethod(this, _AnnotationEditor_instances, AA_fn).call(this), this.removeEditToolbar(), __privateGet(this, _$t)) {
        for (const e4 of __privateGet(this, _$t).values()) clearTimeout(e4);
        __privateSet(this, _$t, null);
      }
      this.parent = null;
    }
    get isResizable() {
      return false;
    }
    makeResizable() {
      this.isResizable && (__privateMethod(this, _AnnotationEditor_instances, nA_fn).call(this), __privateGet(this, _Yt).classList.remove("hidden"), bindEvents(this, this.div, ["keydown"]));
    }
    get toolbarPosition() {
      return null;
    }
    keydown(e4) {
      if (!this.isResizable || e4.target !== this.div || "Enter" !== e4.key) return;
      this._uiManager.setSelected(this), __privateSet(this, _Pt, { savedX: this.x, savedY: this.y, savedWidth: this.width, savedHeight: this.height });
      const t4 = __privateGet(this, _Yt).children;
      if (!__privateGet(this, _Ht)) {
        __privateSet(this, _Ht, Array.from(t4));
        const e5 = __privateMethod(this, _AnnotationEditor_instances, IA_fn).bind(this), i5 = __privateMethod(this, _AnnotationEditor_instances, CA_fn).bind(this), a5 = this._uiManager._signal;
        for (const t5 of __privateGet(this, _Ht)) {
          const s5 = t5.getAttribute("data-resizer-name");
          t5.setAttribute("role", "spinbutton"), t5.addEventListener("keydown", e5, { signal: a5 }), t5.addEventListener("blur", i5, { signal: a5 }), t5.addEventListener("focus", __privateMethod(this, _AnnotationEditor_instances, dA_fn).bind(this, s5), { signal: a5 }), t5.setAttribute("data-l10n-id", _AnnotationEditor._l10nResizer[s5]);
        }
      }
      const i4 = __privateGet(this, _Ht)[0];
      let a4 = 0;
      for (const e5 of t4) {
        if (e5 === i4) break;
        a4++;
      }
      const s4 = (360 - this.rotation + this.parentRotation) % 360 / 90 * (__privateGet(this, _Ht).length / 4);
      if (s4 !== a4) {
        if (s4 < a4) for (let e6 = 0; e6 < a4 - s4; e6++) __privateGet(this, _Yt).append(__privateGet(this, _Yt).firstChild);
        else if (s4 > a4) for (let e6 = 0; e6 < s4 - a4; e6++) __privateGet(this, _Yt).firstChild.before(__privateGet(this, _Yt).lastChild);
        let e5 = 0;
        for (const i5 of t4) {
          const t5 = __privateGet(this, _Ht)[e5++].getAttribute("data-resizer-name");
          i5.setAttribute("data-l10n-id", _AnnotationEditor._l10nResizer[t5]);
        }
      }
      __privateMethod(this, _AnnotationEditor_instances, BA_fn).call(this, 0), __privateSet(this, _Xt, true), __privateGet(this, _Yt).firstChild.focus({ focusVisible: true }), e4.preventDefault(), e4.stopImmediatePropagation();
    }
    _resizeWithKeyboard(e4, t4) {
      __privateGet(this, _Xt) && __privateMethod(this, _AnnotationEditor_instances, oA_fn).call(this, __privateGet(this, _Kt), { movementX: e4, movementY: t4 });
    }
    _stopResizingWithKeyboard() {
      __privateMethod(this, _AnnotationEditor_instances, AA_fn).call(this), this.div.focus();
    }
    select() {
      this.makeResizable(), this.div?.classList.add("selectedEditor"), this._editToolbar ? (this._editToolbar?.show(), __privateGet(this, _z3)?.toggleAltTextBadge(false)) : this.addEditToolbar().then(() => {
        this.div?.classList.contains("selectedEditor") && this._editToolbar?.show();
      });
    }
    unselect() {
      __privateGet(this, _Yt)?.classList.add("hidden"), this.div?.classList.remove("selectedEditor"), this.div?.contains(document.activeElement) && this._uiManager.currentLayer.div.focus({ preventScroll: true }), this._editToolbar?.hide(), __privateGet(this, _z3)?.toggleAltTextBadge(true);
    }
    updateParams(e4, t4) {
    }
    disableEditing() {
    }
    enableEditing() {
    }
    enterInEditMode() {
    }
    getImageForAltText() {
      return null;
    }
    get contentDiv() {
      return this.div;
    }
    get isEditing() {
      return __privateGet(this, _Wt);
    }
    set isEditing(e4) {
      __privateSet(this, _Wt, e4), this.parent && (e4 ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null));
    }
    setAspectRatio(e4, t4) {
      __privateSet(this, _Jt, true);
      const i4 = e4 / t4, { style: a4 } = this.div;
      a4.aspectRatio = i4, a4.height = "auto";
    }
    static get MIN_SIZE() {
      return 16;
    }
    static canCreateNewEmptyEditor() {
      return true;
    }
    get telemetryInitialData() {
      return { action: "added" };
    }
    get telemetryFinalData() {
      return null;
    }
    _reportTelemetry(e4, t4 = false) {
      if (t4) {
        __privateGet(this, _$t) || __privateSet(this, _$t, /* @__PURE__ */ new Map());
        const { action: t5 } = e4;
        let i4 = __privateGet(this, _$t).get(t5);
        return i4 && clearTimeout(i4), i4 = setTimeout(() => {
          this._reportTelemetry(e4), __privateGet(this, _$t).delete(t5), 0 === __privateGet(this, _$t).size && __privateSet(this, _$t, null);
        }, _AnnotationEditor._telemetryTimeout), void __privateGet(this, _$t).set(t5, i4);
      }
      e4.type || (e4.type = this.editorType), this._uiManager._eventBus.dispatch("reporttelemetry", { source: this, details: { type: "editing", data: e4 } });
    }
    show(e4 = this._isVisible) {
      this.div.classList.toggle("hidden", !e4), this._isVisible = e4;
    }
    enable() {
      this.div && (this.div.tabIndex = 0), __privateSet(this, _Tt, false);
    }
    disable() {
      this.div && (this.div.tabIndex = -1), __privateSet(this, _Tt, true);
    }
    renderAnnotationElement(e4) {
      let t4 = e4.container.querySelector(".annotationContent");
      if (t4) {
        if ("CANVAS" === t4.nodeName) {
          const e5 = t4;
          t4 = document.createElement("div"), t4.classList.add("annotationContent", this.editorType), e5.before(t4);
        }
      } else t4 = document.createElement("div"), t4.classList.add("annotationContent", this.editorType), e4.container.prepend(t4);
      return t4;
    }
    resetAnnotationElement(e4) {
      const { firstChild: t4 } = e4.container;
      "DIV" === t4.nodeName && t4.classList.contains("annotationContent") && t4.remove();
    }
  };
  _Ut = new WeakMap();
  _Ht = new WeakMap();
  _z3 = new WeakMap();
  _Tt = new WeakMap();
  _Jt = new WeakMap();
  _Yt = new WeakMap();
  _Pt = new WeakMap();
  _Ot = new WeakMap();
  _Kt = new WeakMap();
  _qt = new WeakMap();
  __t = new WeakMap();
  _Wt = new WeakMap();
  _jt = new WeakMap();
  _Xt = new WeakMap();
  _Vt = new WeakMap();
  _Zt = new WeakMap();
  _zt = new WeakMap();
  _$t = new WeakMap();
  _eA = new WeakMap();
  _tA = new WeakMap();
  _AnnotationEditor_instances = new WeakSet();
  iA_fn = function([e4, t4], i4, a4) {
    [i4, a4] = this.screenToPageTranslation(i4, a4), this.x += i4 / e4, this.y += a4 / t4, this.fixAndSetPosition();
  };
  _AnnotationEditor_static = new WeakSet();
  aA_fn = function(e4, t4, i4) {
    switch (i4) {
      case 90:
        return [t4, -e4];
      case 180:
        return [-e4, -t4];
      case 270:
        return [-t4, e4];
      default:
        return [e4, t4];
    }
  };
  sA_fn = function(e4) {
    switch (e4) {
      case 90: {
        const [e5, t4] = this.pageDimensions;
        return [0, -e5 / t4, t4 / e5, 0];
      }
      case 180:
        return [-1, 0, 0, -1];
      case 270: {
        const [e5, t4] = this.pageDimensions;
        return [0, e5 / t4, -t4 / e5, 0];
      }
      default:
        return [1, 0, 0, 1];
    }
  };
  nA_fn = function() {
    if (__privateGet(this, _Yt)) return;
    __privateSet(this, _Yt, document.createElement("div")), __privateGet(this, _Yt).classList.add("resizers");
    const e4 = this._willKeepAspectRatio ? ["topLeft", "topRight", "bottomRight", "bottomLeft"] : ["topLeft", "topMiddle", "topRight", "middleRight", "bottomRight", "bottomMiddle", "bottomLeft", "middleLeft"], t4 = this._uiManager._signal;
    for (const i4 of e4) {
      const e5 = document.createElement("div");
      __privateGet(this, _Yt).append(e5), e5.classList.add("resizer", i4), e5.setAttribute("data-resizer-name", i4), e5.addEventListener("pointerdown", __privateMethod(this, _AnnotationEditor_instances, rA_fn).bind(this, i4), { signal: t4 }), e5.addEventListener("contextmenu", noContextMenu, { signal: t4 }), e5.tabIndex = -1;
    }
    this.div.prepend(__privateGet(this, _Yt));
  };
  rA_fn = function(e4, t4) {
    t4.preventDefault();
    const { isMac: i4 } = util_FeatureTest.platform;
    if (0 !== t4.button || t4.ctrlKey && i4) return;
    __privateGet(this, _z3)?.toggle(false);
    const a4 = this._isDraggable;
    this._isDraggable = false;
    const s4 = new AbortController(), n4 = this._uiManager.combinedSignal(s4);
    this.parent.togglePointerEvents(false), window.addEventListener("pointermove", __privateMethod(this, _AnnotationEditor_instances, oA_fn).bind(this, e4), { passive: true, capture: true, signal: n4 }), window.addEventListener("contextmenu", noContextMenu, { signal: n4 });
    const r4 = this.x, o4 = this.y, g4 = this.width, c4 = this.height, h4 = this.parent.div.style.cursor, l4 = this.div.style.cursor;
    this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(t4.target).cursor;
    const pointerUpCallback = () => {
      s4.abort(), this.parent.togglePointerEvents(true), __privateGet(this, _z3)?.toggle(true), this._isDraggable = a4, this.parent.div.style.cursor = h4, this.div.style.cursor = l4, __privateMethod(this, _AnnotationEditor_instances, gA_fn).call(this, r4, o4, g4, c4);
    };
    window.addEventListener("pointerup", pointerUpCallback, { signal: n4 }), window.addEventListener("blur", pointerUpCallback, { signal: n4 });
  };
  gA_fn = function(e4, t4, i4, a4) {
    const s4 = this.x, n4 = this.y, r4 = this.width, o4 = this.height;
    s4 === e4 && n4 === t4 && r4 === i4 && o4 === a4 || this.addCommands({ cmd: () => {
      this.width = r4, this.height = o4, this.x = s4, this.y = n4;
      const [e5, t5] = this.parentDimensions;
      this.setDims(e5 * r4, t5 * o4), this.fixAndSetPosition();
    }, undo: () => {
      this.width = i4, this.height = a4, this.x = e4, this.y = t4;
      const [s5, n5] = this.parentDimensions;
      this.setDims(s5 * i4, n5 * a4), this.fixAndSetPosition();
    }, mustExec: true });
  };
  oA_fn = function(e4, t4) {
    const [i4, a4] = this.parentDimensions, s4 = this.x, n4 = this.y, r4 = this.width, o4 = this.height, g4 = _AnnotationEditor.MIN_SIZE / i4, c4 = _AnnotationEditor.MIN_SIZE / a4, round = (e5) => Math.round(1e4 * e5) / 1e4, h4 = __privateMethod(this, _AnnotationEditor_instances, sA_fn).call(this, this.rotation), transf = (e5, t5) => [h4[0] * e5 + h4[2] * t5, h4[1] * e5 + h4[3] * t5], l4 = __privateMethod(this, _AnnotationEditor_instances, sA_fn).call(this, 360 - this.rotation);
    let C4, d4, u4 = false, Q4 = false;
    switch (e4) {
      case "topLeft":
        u4 = true, C4 = (e5, t5) => [0, 0], d4 = (e5, t5) => [e5, t5];
        break;
      case "topMiddle":
        C4 = (e5, t5) => [e5 / 2, 0], d4 = (e5, t5) => [e5 / 2, t5];
        break;
      case "topRight":
        u4 = true, C4 = (e5, t5) => [e5, 0], d4 = (e5, t5) => [0, t5];
        break;
      case "middleRight":
        Q4 = true, C4 = (e5, t5) => [e5, t5 / 2], d4 = (e5, t5) => [0, t5 / 2];
        break;
      case "bottomRight":
        u4 = true, C4 = (e5, t5) => [e5, t5], d4 = (e5, t5) => [0, 0];
        break;
      case "bottomMiddle":
        C4 = (e5, t5) => [e5 / 2, t5], d4 = (e5, t5) => [e5 / 2, 0];
        break;
      case "bottomLeft":
        u4 = true, C4 = (e5, t5) => [0, t5], d4 = (e5, t5) => [e5, 0];
        break;
      case "middleLeft":
        Q4 = true, C4 = (e5, t5) => [0, t5 / 2], d4 = (e5, t5) => [e5, t5 / 2];
    }
    const f4 = C4(r4, o4), p4 = d4(r4, o4);
    let m4 = transf(...p4);
    const y4 = round(s4 + m4[0]), w4 = round(n4 + m4[1]);
    let b4 = 1, D4 = 1, [S4, F4] = this.screenToPageTranslation(t4.movementX, t4.movementY);
    var k4, R4;
    if ([S4, F4] = (k4 = S4 / i4, R4 = F4 / a4, [l4[0] * k4 + l4[2] * R4, l4[1] * k4 + l4[3] * R4]), u4) {
      const e5 = Math.hypot(r4, o4);
      b4 = D4 = Math.max(Math.min(Math.hypot(p4[0] - f4[0] - S4, p4[1] - f4[1] - F4) / e5, 1 / r4, 1 / o4), g4 / r4, c4 / o4);
    } else Q4 ? b4 = Math.max(g4, Math.min(1, Math.abs(p4[0] - f4[0] - S4))) / r4 : D4 = Math.max(c4, Math.min(1, Math.abs(p4[1] - f4[1] - F4))) / o4;
    const x4 = round(r4 * b4), N4 = round(o4 * D4);
    m4 = transf(...d4(x4, N4));
    const M4 = y4 - m4[0], G4 = w4 - m4[1];
    this.width = x4, this.height = N4, this.x = M4, this.y = G4, this.setDims(i4 * x4, a4 * N4), this.fixAndSetPosition();
  };
  lA_fn = function(e4) {
    const { isMac: t4 } = util_FeatureTest.platform;
    e4.ctrlKey && !t4 || e4.shiftKey || e4.metaKey && t4 ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
  };
  hA_fn = function(e4) {
    const t4 = this._uiManager.isSelected(this);
    this._uiManager.setUpDragSession();
    const i4 = new AbortController(), a4 = this._uiManager.combinedSignal(i4);
    if (t4) {
      this.div.classList.add("moving"), __privateSet(this, _Zt, e4.clientX), __privateSet(this, _zt, e4.clientY);
      const pointerMoveCallback = (e5) => {
        const { clientX: t5, clientY: i5 } = e5, [a5, s4] = this.screenToPageTranslation(t5 - __privateGet(this, _Zt), i5 - __privateGet(this, _zt));
        __privateSet(this, _Zt, t5), __privateSet(this, _zt, i5), this._uiManager.dragSelectedEditors(a5, s4);
      };
      window.addEventListener("pointermove", pointerMoveCallback, { passive: true, capture: true, signal: a4 });
    }
    const pointerUpCallback = () => {
      i4.abort(), t4 && this.div.classList.remove("moving"), __privateSet(this, _qt, false), this._uiManager.endDragSession() || __privateMethod(this, _AnnotationEditor_instances, lA_fn).call(this, e4);
    };
    window.addEventListener("pointerup", pointerUpCallback, { signal: a4 }), window.addEventListener("blur", pointerUpCallback, { signal: a4 });
  };
  cA_fn = function() {
    if (__privateGet(this, _Ot) || !this.div) return;
    __privateSet(this, _Ot, new AbortController());
    const e4 = this._uiManager.combinedSignal(__privateGet(this, _Ot));
    this.div.addEventListener("focusin", this.focusin.bind(this), { signal: e4 }), this.div.addEventListener("focusout", this.focusout.bind(this), { signal: e4 });
  };
  IA_fn = function(e4) {
    _AnnotationEditor._resizerKeyboardManager.exec(this, e4);
  };
  CA_fn = function(e4) {
    __privateGet(this, _Xt) && e4.relatedTarget?.parentNode !== __privateGet(this, _Yt) && __privateMethod(this, _AnnotationEditor_instances, AA_fn).call(this);
  };
  dA_fn = function(e4) {
    __privateSet(this, _Kt, __privateGet(this, _Xt) ? e4 : "");
  };
  BA_fn = function(e4) {
    if (__privateGet(this, _Ht)) for (const t4 of __privateGet(this, _Ht)) t4.tabIndex = e4;
  };
  AA_fn = function() {
    if (__privateSet(this, _Xt, false), __privateMethod(this, _AnnotationEditor_instances, BA_fn).call(this, -1), __privateGet(this, _Pt)) {
      const { savedX: e4, savedY: t4, savedWidth: i4, savedHeight: a4 } = __privateGet(this, _Pt);
      __privateMethod(this, _AnnotationEditor_instances, gA_fn).call(this, e4, t4, i4, a4), __privateSet(this, _Pt, null);
    }
  };
  __privateAdd(_AnnotationEditor, _AnnotationEditor_static);
  __publicField(_AnnotationEditor, "_l10nPromise", null);
  __publicField(_AnnotationEditor, "_l10nResizer", null);
  __publicField(_AnnotationEditor, "_borderLineWidth", -1);
  __publicField(_AnnotationEditor, "_colorManager", new ColorManager());
  __publicField(_AnnotationEditor, "_zIndex", 1);
  __publicField(_AnnotationEditor, "_telemetryTimeout", 1e3);
  let AnnotationEditor = _AnnotationEditor;
  class FakeEditor extends AnnotationEditor {
    constructor(e4) {
      super(e4), this.annotationElementId = e4.annotationElementId, this.deleted = true;
    }
    serialize() {
      return { id: this.annotationElementId, deleted: true, pageIndex: this.pageIndex };
    }
  }
  const fe3 = 3285377520, pe3 = 4294901760, me3 = 65535;
  class MurmurHash3_642 {
    constructor(e4) {
      this.h1 = e4 ? 4294967295 & e4 : fe3, this.h2 = e4 ? 4294967295 & e4 : fe3;
    }
    update(e4) {
      let t4, i4;
      if ("string" == typeof e4) {
        t4 = new Uint8Array(2 * e4.length), i4 = 0;
        for (let a5 = 0, s5 = e4.length; a5 < s5; a5++) {
          const s6 = e4.charCodeAt(a5);
          s6 <= 255 ? t4[i4++] = s6 : (t4[i4++] = s6 >>> 8, t4[i4++] = 255 & s6);
        }
      } else {
        if (!ArrayBuffer.isView(e4)) throw new Error("Invalid data format, must be a string or TypedArray.");
        t4 = e4.slice(), i4 = t4.byteLength;
      }
      const a4 = i4 >> 2, s4 = i4 - 4 * a4, n4 = new Uint32Array(t4.buffer, 0, a4);
      let r4 = 0, o4 = 0, g4 = this.h1, c4 = this.h2;
      const h4 = 3432918353, l4 = 461845907, C4 = 11601, d4 = 13715;
      for (let e5 = 0; e5 < a4; e5++) 1 & e5 ? (r4 = n4[e5], r4 = r4 * h4 & pe3 | r4 * C4 & me3, r4 = r4 << 15 | r4 >>> 17, r4 = r4 * l4 & pe3 | r4 * d4 & me3, g4 ^= r4, g4 = g4 << 13 | g4 >>> 19, g4 = 5 * g4 + 3864292196) : (o4 = n4[e5], o4 = o4 * h4 & pe3 | o4 * C4 & me3, o4 = o4 << 15 | o4 >>> 17, o4 = o4 * l4 & pe3 | o4 * d4 & me3, c4 ^= o4, c4 = c4 << 13 | c4 >>> 19, c4 = 5 * c4 + 3864292196);
      switch (r4 = 0, s4) {
        case 3:
          r4 ^= t4[4 * a4 + 2] << 16;
        case 2:
          r4 ^= t4[4 * a4 + 1] << 8;
        case 1:
          r4 ^= t4[4 * a4], r4 = r4 * h4 & pe3 | r4 * C4 & me3, r4 = r4 << 15 | r4 >>> 17, r4 = r4 * l4 & pe3 | r4 * d4 & me3, 1 & a4 ? g4 ^= r4 : c4 ^= r4;
      }
      this.h1 = g4, this.h2 = c4;
    }
    hexdigest() {
      let e4 = this.h1, t4 = this.h2;
      return e4 ^= t4 >>> 1, e4 = 3981806797 * e4 & pe3 | 36045 * e4 & me3, t4 = 4283543511 * t4 & pe3 | (2950163797 * (t4 << 16 | e4 >>> 16) & pe3) >>> 16, e4 ^= t4 >>> 1, e4 = 444984403 * e4 & pe3 | 60499 * e4 & me3, t4 = 3301882366 * t4 & pe3 | (3120437893 * (t4 << 16 | e4 >>> 16) & pe3) >>> 16, e4 ^= t4 >>> 1, (e4 >>> 0).toString(16).padStart(8, "0") + (t4 >>> 0).toString(16).padStart(8, "0");
    }
  }
  const ye3 = Object.freeze({ map: null, hash: "", transfer: void 0 });
  class AnnotationStorage {
    constructor() {
      __privateAdd(this, _AnnotationStorage_instances);
      __privateAdd(this, _uA, false);
      __privateAdd(this, _QA, null);
      __privateAdd(this, _EA, /* @__PURE__ */ new Map());
      this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
    }
    getValue(e4, t4) {
      const i4 = __privateGet(this, _EA).get(e4);
      return void 0 === i4 ? t4 : Object.assign(t4, i4);
    }
    getRawValue(e4) {
      return __privateGet(this, _EA).get(e4);
    }
    remove(e4) {
      if (__privateGet(this, _EA).delete(e4), 0 === __privateGet(this, _EA).size && this.resetModified(), "function" == typeof this.onAnnotationEditor) {
        for (const e5 of __privateGet(this, _EA).values()) if (e5 instanceof AnnotationEditor) return;
        this.onAnnotationEditor(null);
      }
    }
    setValue(e4, t4) {
      const i4 = __privateGet(this, _EA).get(e4);
      let a4 = false;
      if (void 0 !== i4) for (const [e5, s4] of Object.entries(t4)) i4[e5] !== s4 && (a4 = true, i4[e5] = s4);
      else a4 = true, __privateGet(this, _EA).set(e4, t4);
      a4 && __privateMethod(this, _AnnotationStorage_instances, fA_fn).call(this), t4 instanceof AnnotationEditor && "function" == typeof this.onAnnotationEditor && this.onAnnotationEditor(t4.constructor._type);
    }
    has(e4) {
      return __privateGet(this, _EA).has(e4);
    }
    getAll() {
      return __privateGet(this, _EA).size > 0 ? objectFromMap(__privateGet(this, _EA)) : null;
    }
    setAll(e4) {
      for (const [t4, i4] of Object.entries(e4)) this.setValue(t4, i4);
    }
    get size() {
      return __privateGet(this, _EA).size;
    }
    resetModified() {
      __privateGet(this, _uA) && (__privateSet(this, _uA, false), "function" == typeof this.onResetModified && this.onResetModified());
    }
    get print() {
      return new PrintAnnotationStorage(this);
    }
    get serializable() {
      if (0 === __privateGet(this, _EA).size) return ye3;
      const e4 = /* @__PURE__ */ new Map(), t4 = new MurmurHash3_642(), i4 = [], a4 = /* @__PURE__ */ Object.create(null);
      let s4 = false;
      for (const [i5, n4] of __privateGet(this, _EA)) {
        const r4 = n4 instanceof AnnotationEditor ? n4.serialize(false, a4) : n4;
        r4 && (e4.set(i5, r4), t4.update(`${i5}:${JSON.stringify(r4)}`), s4 || (s4 = !!r4.bitmap));
      }
      if (s4) for (const t5 of e4.values()) t5.bitmap && i4.push(t5.bitmap);
      return e4.size > 0 ? { map: e4, hash: t4.hexdigest(), transfer: i4 } : ye3;
    }
    get editorStats() {
      let e4 = null;
      const t4 = /* @__PURE__ */ new Map();
      for (const i4 of __privateGet(this, _EA).values()) {
        if (!(i4 instanceof AnnotationEditor)) continue;
        const a4 = i4.telemetryFinalData;
        if (!a4) continue;
        const { type: s4 } = a4;
        t4.has(s4) || t4.set(s4, Object.getPrototypeOf(i4).constructor), e4 || (e4 = /* @__PURE__ */ Object.create(null));
        const n4 = e4[s4] || (e4[s4] = /* @__PURE__ */ new Map());
        for (const [e5, t5] of Object.entries(a4)) {
          if ("type" === e5) continue;
          let i5 = n4.get(e5);
          i5 || (i5 = /* @__PURE__ */ new Map(), n4.set(e5, i5));
          const a5 = i5.get(t5) ?? 0;
          i5.set(t5, a5 + 1);
        }
      }
      for (const [i4, a4] of t4) e4[i4] = a4.computeTelemetryFinalData(e4[i4]);
      return e4;
    }
    resetModifiedIds() {
      __privateSet(this, _QA, null);
    }
    get modifiedIds() {
      if (__privateGet(this, _QA)) return __privateGet(this, _QA);
      const e4 = [];
      for (const t4 of __privateGet(this, _EA).values()) t4 instanceof AnnotationEditor && t4.annotationElementId && t4.serialize() && e4.push(t4.annotationElementId);
      return __privateSet(this, _QA, { ids: new Set(e4), hash: e4.join(",") });
    }
  }
  _uA = new WeakMap();
  _QA = new WeakMap();
  _EA = new WeakMap();
  _AnnotationStorage_instances = new WeakSet();
  fA_fn = function() {
    __privateGet(this, _uA) || (__privateSet(this, _uA, true), "function" == typeof this.onSetModified && this.onSetModified());
  };
  class PrintAnnotationStorage extends AnnotationStorage {
    constructor(e4) {
      super();
      __privateAdd(this, _pA);
      const { map: t4, hash: i4, transfer: a4 } = e4.serializable, s4 = structuredClone(t4, a4 ? { transfer: a4 } : null);
      __privateSet(this, _pA, { map: s4, hash: i4, transfer: a4 });
    }
    get print() {
      unreachable2("Should not call PrintAnnotationStorage.print");
    }
    get serializable() {
      return __privateGet(this, _pA);
    }
    get modifiedIds() {
      return shadow2(this, "modifiedIds", { ids: /* @__PURE__ */ new Set(), hash: "" });
    }
  }
  _pA = new WeakMap();
  class FontLoader {
    constructor({ ownerDocument: e4 = globalThis.document, styleElement: t4 = null }) {
      __privateAdd(this, _mA, /* @__PURE__ */ new Set());
      this._document = e4, this.nativeFontFaces = /* @__PURE__ */ new Set(), this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0;
    }
    addNativeFontFace(e4) {
      this.nativeFontFaces.add(e4), this._document.fonts.add(e4);
    }
    removeNativeFontFace(e4) {
      this.nativeFontFaces.delete(e4), this._document.fonts.delete(e4);
    }
    insertRule(e4) {
      this.styleElement || (this.styleElement = this._document.createElement("style"), this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement));
      const t4 = this.styleElement.sheet;
      t4.insertRule(e4, t4.cssRules.length);
    }
    clear() {
      for (const e4 of this.nativeFontFaces) this._document.fonts.delete(e4);
      this.nativeFontFaces.clear(), __privateGet(this, _mA).clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null);
    }
    async loadSystemFont({ systemFontInfo: e4, _inspectFont: t4 }) {
      if (e4 && !__privateGet(this, _mA).has(e4.loadedName)) if (assert2(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
        const { loadedName: i4, src: a4, style: s4 } = e4, n4 = new FontFace(i4, a4, s4);
        this.addNativeFontFace(n4);
        try {
          await n4.load(), __privateGet(this, _mA).add(i4), t4?.(e4);
        } catch {
          warn2(`Cannot load system font: ${e4.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(n4);
        }
      } else unreachable2("Not implemented: loadSystemFont without the Font Loading API.");
    }
    async bind(e4) {
      if (e4.attached || e4.missingFile && !e4.systemFontInfo) return;
      if (e4.attached = true, e4.systemFontInfo) return void await this.loadSystemFont(e4);
      if (this.isFontLoadingAPISupported) {
        const t5 = e4.createNativeFontFace();
        if (t5) {
          this.addNativeFontFace(t5);
          try {
            await t5.loaded;
          } catch (i4) {
            throw warn2(`Failed to load font '${t5.family}': '${i4}'.`), e4.disableFontFace = true, i4;
          }
        }
        return;
      }
      const t4 = e4.createFontFaceRule();
      if (t4) {
        if (this.insertRule(t4), this.isSyncFontLoadingSupported) return;
        await new Promise((t5) => {
          const i4 = this._queueLoadingCallback(t5);
          this._prepareFontLoadEvent(e4, i4);
        });
      }
    }
    get isFontLoadingAPISupported() {
      return shadow2(this, "isFontLoadingAPISupported", !!this._document?.fonts);
    }
    get isSyncFontLoadingSupported() {
      let e4 = false;
      return (i3 || "undefined" != typeof navigator && "string" == typeof navigator?.userAgent && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) && (e4 = true), shadow2(this, "isSyncFontLoadingSupported", e4);
    }
    _queueLoadingCallback(e4) {
      const { loadingRequests: t4 } = this, i4 = { done: false, complete: function() {
        for (assert2(!i4.done, "completeRequest() cannot be called twice."), i4.done = true; t4.length > 0 && t4[0].done; ) {
          const e5 = t4.shift();
          setTimeout(e5.callback, 0);
        }
      }, callback: e4 };
      return t4.push(i4), i4;
    }
    get _loadTestFont() {
      return shadow2(this, "_loadTestFont", atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA=="));
    }
    _prepareFontLoadEvent(e4, t4) {
      function int32(e5, t5) {
        return e5.charCodeAt(t5) << 24 | e5.charCodeAt(t5 + 1) << 16 | e5.charCodeAt(t5 + 2) << 8 | 255 & e5.charCodeAt(t5 + 3);
      }
      function spliceString(e5, t5, i5, a5) {
        return e5.substring(0, t5) + a5 + e5.substring(t5 + i5);
      }
      let i4, a4;
      const s4 = this._document.createElement("canvas");
      s4.width = 1, s4.height = 1;
      const n4 = s4.getContext("2d");
      let r4 = 0;
      const o4 = `lt${Date.now()}${this.loadTestFontId++}`;
      let g4 = this._loadTestFont;
      g4 = spliceString(g4, 976, o4.length, o4);
      const c4 = 1482184792;
      let h4 = int32(g4, 16);
      for (i4 = 0, a4 = o4.length - 3; i4 < a4; i4 += 4) h4 = h4 - c4 + int32(o4, i4) | 0;
      var l4;
      i4 < o4.length && (h4 = h4 - c4 + int32(o4 + "XXX", i4) | 0), g4 = spliceString(g4, 16, 4, (l4 = h4, String.fromCharCode(l4 >> 24 & 255, l4 >> 16 & 255, l4 >> 8 & 255, 255 & l4)));
      const C4 = `@font-face {font-family:"${o4}";src:${`url(data:font/opentype;base64,${btoa(g4)});`}}`;
      this.insertRule(C4);
      const d4 = this._document.createElement("div");
      d4.style.visibility = "hidden", d4.style.width = d4.style.height = "10px", d4.style.position = "absolute", d4.style.top = d4.style.left = "0px";
      for (const t5 of [e4.loadedName, o4]) {
        const e5 = this._document.createElement("span");
        e5.textContent = "Hi", e5.style.fontFamily = t5, d4.append(e5);
      }
      this._document.body.append(d4), function isFontReady(e5, t5) {
        if (++r4 > 30) return warn2("Load test font never loaded."), void t5();
        n4.font = "30px " + e5, n4.fillText(".", 0, 20), n4.getImageData(0, 0, 1, 1).data[3] > 0 ? t5() : setTimeout(isFontReady.bind(null, e5, t5));
      }(o4, () => {
        d4.remove(), t4.complete();
      });
    }
  }
  _mA = new WeakMap();
  class FontFaceObject {
    constructor(e4, { disableFontFace: t4 = false, inspectFont: i4 = null }) {
      this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
      for (const t5 in e4) this[t5] = e4[t5];
      this.disableFontFace = true === t4, this._inspectFont = i4;
    }
    createNativeFontFace() {
      if (!this.data || this.disableFontFace) return null;
      let e4;
      if (this.cssFontInfo) {
        const t4 = { weight: this.cssFontInfo.fontWeight };
        this.cssFontInfo.italicAngle && (t4.style = `oblique ${this.cssFontInfo.italicAngle}deg`), e4 = new FontFace(this.cssFontInfo.fontFamily, this.data, t4);
      } else e4 = new FontFace(this.loadedName, this.data, {});
      return this._inspectFont?.(this), e4;
    }
    createFontFaceRule() {
      if (!this.data || this.disableFontFace) return null;
      const e4 = bytesToString2(this.data), t4 = `url(data:${this.mimetype};base64,${btoa(e4)});`;
      let i4;
      if (this.cssFontInfo) {
        let e5 = `font-weight: ${this.cssFontInfo.fontWeight};`;
        this.cssFontInfo.italicAngle && (e5 += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), i4 = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${e5}src:${t4}}`;
      } else i4 = `@font-face {font-family:"${this.loadedName}";src:${t4}}`;
      return this._inspectFont?.(this, t4), i4;
    }
    getPathGenerator(e4, t4) {
      if (void 0 !== this.compiledGlyphs[t4]) return this.compiledGlyphs[t4];
      let i4;
      try {
        i4 = e4.get(this.loadedName + "_path_" + t4);
      } catch (e5) {
        warn2(`getPathGenerator - ignoring character: "${e5}".`);
      }
      if (!Array.isArray(i4) || 0 === i4.length) return this.compiledGlyphs[t4] = function(e5, t5) {
      };
      const a4 = [];
      for (let e5 = 0, t5 = i4.length; e5 < t5; ) switch (i4[e5++]) {
        case ge3:
          {
            const [t6, s4, n4, r4, o4, g4] = i4.slice(e5, e5 + 6);
            a4.push((e6) => e6.bezierCurveTo(t6, s4, n4, r4, o4, g4)), e5 += 6;
          }
          break;
        case ce3:
          {
            const [t6, s4] = i4.slice(e5, e5 + 2);
            a4.push((e6) => e6.moveTo(t6, s4)), e5 += 2;
          }
          break;
        case he3:
          {
            const [t6, s4] = i4.slice(e5, e5 + 2);
            a4.push((e6) => e6.lineTo(t6, s4)), e5 += 2;
          }
          break;
        case le3:
          {
            const [t6, s4, n4, r4] = i4.slice(e5, e5 + 4);
            a4.push((e6) => e6.quadraticCurveTo(t6, s4, n4, r4)), e5 += 4;
          }
          break;
        case Ie3:
          a4.push((e6) => e6.restore());
          break;
        case Ce3:
          a4.push((e6) => e6.save());
          break;
        case de3:
          assert2(2 === a4.length, "Scale command is only valid at the third position.");
          break;
        case Be3:
          {
            const [t6, s4, n4, r4, o4, g4] = i4.slice(e5, e5 + 6);
            a4.push((e6) => e6.transform(t6, s4, n4, r4, o4, g4)), e5 += 6;
          }
          break;
        case ue3: {
          const [t6, s4] = i4.slice(e5, e5 + 2);
          a4.push((e6) => e6.translate(t6, s4)), e5 += 2;
        }
      }
      return this.compiledGlyphs[t4] = function(e5, t5) {
        a4[0](e5), a4[1](e5), e5.scale(t5, -t5);
        for (let t6 = 2, i5 = a4.length; t6 < i5; t6++) a4[t6](e5);
      };
    }
  }
  if (i3) {
    var we3 = Promise.withResolvers(), be3 = null;
    (async () => {
      const e4 = await Promise.resolve().then(function() {
        return Nt;
      }), t4 = await Promise.resolve().then(function() {
        return IA;
      }), i4 = await Promise.resolve().then(function() {
        return QA;
      }), a4 = await Promise.resolve().then(function() {
        return mA;
      });
      return new Map(Object.entries({ fs: e4, http: t4, https: i4, url: a4, canvas: void 0, path2d: void 0 }));
    })().then((e4) => {
      be3 = e4, we3.resolve();
    }, (e4) => {
      warn2(`loadPackages: ${e4}`), be3 = /* @__PURE__ */ new Map(), we3.resolve();
    });
  }
  class NodePackages {
    static get promise() {
      return we3.promise;
    }
    static get(e4) {
      return be3?.get(e4);
    }
  }
  const node_utils_fetchData = function(e4) {
    return NodePackages.get("fs").promises.readFile(e4).then((e5) => new Uint8Array(e5));
  };
  const De3 = "Fill", Se3 = "Stroke", Fe3 = "Shading";
  function applyBoundingBox(e4, t4) {
    if (!t4) return;
    const i4 = t4[2] - t4[0], a4 = t4[3] - t4[1], s4 = new Path2D();
    s4.rect(t4[0], t4[1], i4, a4), e4.clip(s4);
  }
  class BaseShadingPattern {
    getPattern() {
      unreachable2("Abstract method `getPattern` called.");
    }
  }
  class RadialAxialShadingPattern extends BaseShadingPattern {
    constructor(e4) {
      super(), this._type = e4[1], this._bbox = e4[2], this._colorStops = e4[3], this._p0 = e4[4], this._p1 = e4[5], this._r0 = e4[6], this._r1 = e4[7], this.matrix = null;
    }
    _createGradient(e4) {
      let t4;
      "axial" === this._type ? t4 = e4.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : "radial" === this._type && (t4 = e4.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
      for (const e5 of this._colorStops) t4.addColorStop(e5[0], e5[1]);
      return t4;
    }
    getPattern(e4, t4, i4, a4) {
      let s4;
      if (a4 === Se3 || a4 === De3) {
        const n4 = t4.current.getClippedPathBoundingBox(a4, getCurrentTransform(e4)) || [0, 0, 0, 0], r4 = Math.ceil(n4[2] - n4[0]) || 1, o4 = Math.ceil(n4[3] - n4[1]) || 1, g4 = t4.cachedCanvases.getCanvas("pattern", r4, o4, true), c4 = g4.context;
        c4.clearRect(0, 0, c4.canvas.width, c4.canvas.height), c4.beginPath(), c4.rect(0, 0, c4.canvas.width, c4.canvas.height), c4.translate(-n4[0], -n4[1]), i4 = Util2.transform(i4, [1, 0, 0, 1, n4[0], n4[1]]), c4.transform(...t4.baseTransform), this.matrix && c4.transform(...this.matrix), applyBoundingBox(c4, this._bbox), c4.fillStyle = this._createGradient(c4), c4.fill(), s4 = e4.createPattern(g4.canvas, "no-repeat");
        const h4 = new DOMMatrix(i4);
        s4.setTransform(h4);
      } else applyBoundingBox(e4, this._bbox), s4 = this._createGradient(e4);
      return s4;
    }
  }
  function drawTriangle(e4, t4, i4, a4, s4, n4, r4, o4) {
    const g4 = t4.coords, c4 = t4.colors, h4 = e4.data, l4 = 4 * e4.width;
    let C4;
    g4[i4 + 1] > g4[a4 + 1] && (C4 = i4, i4 = a4, a4 = C4, C4 = n4, n4 = r4, r4 = C4), g4[a4 + 1] > g4[s4 + 1] && (C4 = a4, a4 = s4, s4 = C4, C4 = r4, r4 = o4, o4 = C4), g4[i4 + 1] > g4[a4 + 1] && (C4 = i4, i4 = a4, a4 = C4, C4 = n4, n4 = r4, r4 = C4);
    const d4 = (g4[i4] + t4.offsetX) * t4.scaleX, u4 = (g4[i4 + 1] + t4.offsetY) * t4.scaleY, Q4 = (g4[a4] + t4.offsetX) * t4.scaleX, f4 = (g4[a4 + 1] + t4.offsetY) * t4.scaleY, p4 = (g4[s4] + t4.offsetX) * t4.scaleX, m4 = (g4[s4 + 1] + t4.offsetY) * t4.scaleY;
    if (u4 >= m4) return;
    const y4 = c4[n4], w4 = c4[n4 + 1], b4 = c4[n4 + 2], D4 = c4[r4], S4 = c4[r4 + 1], F4 = c4[r4 + 2], k4 = c4[o4], R4 = c4[o4 + 1], x4 = c4[o4 + 2], N4 = Math.round(u4), M4 = Math.round(m4);
    let G4, v4, L4, U4, H4, T4, J4, Y4;
    for (let e5 = N4; e5 <= M4; e5++) {
      if (e5 < f4) {
        const t6 = e5 < u4 ? 0 : (u4 - e5) / (u4 - f4);
        G4 = d4 - (d4 - Q4) * t6, v4 = y4 - (y4 - D4) * t6, L4 = w4 - (w4 - S4) * t6, U4 = b4 - (b4 - F4) * t6;
      } else {
        let t6;
        t6 = e5 > m4 ? 1 : f4 === m4 ? 0 : (f4 - e5) / (f4 - m4), G4 = Q4 - (Q4 - p4) * t6, v4 = D4 - (D4 - k4) * t6, L4 = S4 - (S4 - R4) * t6, U4 = F4 - (F4 - x4) * t6;
      }
      let t5;
      t5 = e5 < u4 ? 0 : e5 > m4 ? 1 : (u4 - e5) / (u4 - m4), H4 = d4 - (d4 - p4) * t5, T4 = y4 - (y4 - k4) * t5, J4 = w4 - (w4 - R4) * t5, Y4 = b4 - (b4 - x4) * t5;
      const i5 = Math.round(Math.min(G4, H4)), a5 = Math.round(Math.max(G4, H4));
      let s5 = l4 * e5 + 4 * i5;
      for (let e6 = i5; e6 <= a5; e6++) t5 = (G4 - e6) / (G4 - H4), t5 < 0 ? t5 = 0 : t5 > 1 && (t5 = 1), h4[s5++] = v4 - (v4 - T4) * t5 | 0, h4[s5++] = L4 - (L4 - J4) * t5 | 0, h4[s5++] = U4 - (U4 - Y4) * t5 | 0, h4[s5++] = 255;
    }
  }
  function drawFigure(e4, t4, i4) {
    const a4 = t4.coords, s4 = t4.colors;
    let n4, r4;
    switch (t4.type) {
      case "lattice":
        const o4 = t4.verticesPerRow, g4 = Math.floor(a4.length / o4) - 1, c4 = o4 - 1;
        for (n4 = 0; n4 < g4; n4++) {
          let t5 = n4 * o4;
          for (let n5 = 0; n5 < c4; n5++, t5++) drawTriangle(e4, i4, a4[t5], a4[t5 + 1], a4[t5 + o4], s4[t5], s4[t5 + 1], s4[t5 + o4]), drawTriangle(e4, i4, a4[t5 + o4 + 1], a4[t5 + 1], a4[t5 + o4], s4[t5 + o4 + 1], s4[t5 + 1], s4[t5 + o4]);
        }
        break;
      case "triangles":
        for (n4 = 0, r4 = a4.length; n4 < r4; n4 += 3) drawTriangle(e4, i4, a4[n4], a4[n4 + 1], a4[n4 + 2], s4[n4], s4[n4 + 1], s4[n4 + 2]);
        break;
      default:
        throw new Error("illegal figure");
    }
  }
  class MeshShadingPattern extends BaseShadingPattern {
    constructor(e4) {
      super(), this._coords = e4[2], this._colors = e4[3], this._figures = e4[4], this._bounds = e4[5], this._bbox = e4[7], this._background = e4[8], this.matrix = null;
    }
    _createMeshCanvas(e4, t4, i4) {
      const a4 = Math.floor(this._bounds[0]), s4 = Math.floor(this._bounds[1]), n4 = Math.ceil(this._bounds[2]) - a4, r4 = Math.ceil(this._bounds[3]) - s4, o4 = Math.min(Math.ceil(Math.abs(n4 * e4[0] * 1.1)), 3e3), g4 = Math.min(Math.ceil(Math.abs(r4 * e4[1] * 1.1)), 3e3), c4 = n4 / o4, h4 = r4 / g4, l4 = { coords: this._coords, colors: this._colors, offsetX: -a4, offsetY: -s4, scaleX: 1 / c4, scaleY: 1 / h4 }, C4 = o4 + 4, d4 = g4 + 4, u4 = i4.getCanvas("mesh", C4, d4, false), Q4 = u4.context, f4 = Q4.createImageData(o4, g4);
      if (t4) {
        const e5 = f4.data;
        for (let i5 = 0, a5 = e5.length; i5 < a5; i5 += 4) e5[i5] = t4[0], e5[i5 + 1] = t4[1], e5[i5 + 2] = t4[2], e5[i5 + 3] = 255;
      }
      for (const e5 of this._figures) drawFigure(f4, e5, l4);
      Q4.putImageData(f4, 2, 2);
      return { canvas: u4.canvas, offsetX: a4 - 2 * c4, offsetY: s4 - 2 * h4, scaleX: c4, scaleY: h4 };
    }
    getPattern(e4, t4, i4, a4) {
      let s4;
      if (applyBoundingBox(e4, this._bbox), a4 === Fe3) s4 = Util2.singularValueDecompose2dScale(getCurrentTransform(e4));
      else if (s4 = Util2.singularValueDecompose2dScale(t4.baseTransform), this.matrix) {
        const e5 = Util2.singularValueDecompose2dScale(this.matrix);
        s4 = [s4[0] * e5[0], s4[1] * e5[1]];
      }
      const n4 = this._createMeshCanvas(s4, a4 === Fe3 ? null : this._background, t4.cachedCanvases);
      return a4 !== Fe3 && (e4.setTransform(...t4.baseTransform), this.matrix && e4.transform(...this.matrix)), e4.translate(n4.offsetX, n4.offsetY), e4.scale(n4.scaleX, n4.scaleY), e4.createPattern(n4.canvas, "no-repeat");
    }
  }
  class DummyShadingPattern extends BaseShadingPattern {
    getPattern() {
      return "hotpink";
    }
  }
  const ke3 = 1, Re3 = 2;
  const _TilingPattern = class _TilingPattern {
    constructor(e4, t4, i4, a4, s4) {
      this.operatorList = e4[2], this.matrix = e4[3], this.bbox = e4[4], this.xstep = e4[5], this.ystep = e4[6], this.paintType = e4[7], this.tilingType = e4[8], this.color = t4, this.ctx = i4, this.canvasGraphicsFactory = a4, this.baseTransform = s4;
    }
    createPatternCanvas(e4) {
      const t4 = this.operatorList, i4 = this.bbox, a4 = this.xstep, s4 = this.ystep, n4 = this.paintType, r4 = this.tilingType, o4 = this.color, g4 = this.canvasGraphicsFactory;
      info2("TilingType: " + r4);
      const c4 = i4[0], h4 = i4[1], l4 = i4[2], C4 = i4[3], d4 = Util2.singularValueDecompose2dScale(this.matrix), u4 = Util2.singularValueDecompose2dScale(this.baseTransform), Q4 = [d4[0] * u4[0], d4[1] * u4[1]], f4 = this.getSizeAndScale(a4, this.ctx.canvas.width, Q4[0]), p4 = this.getSizeAndScale(s4, this.ctx.canvas.height, Q4[1]), m4 = e4.cachedCanvases.getCanvas("pattern", f4.size, p4.size, true), y4 = m4.context, w4 = g4.createCanvasGraphics(y4);
      w4.groupLevel = e4.groupLevel, this.setFillAndStrokeStyleToContext(w4, n4, o4);
      let b4 = c4, D4 = h4, S4 = l4, F4 = C4;
      return c4 < 0 && (b4 = 0, S4 += Math.abs(c4)), h4 < 0 && (D4 = 0, F4 += Math.abs(h4)), y4.translate(-f4.scale * b4, -p4.scale * D4), w4.transform(f4.scale, 0, 0, p4.scale, 0, 0), y4.save(), this.clipBbox(w4, b4, D4, S4, F4), w4.baseTransform = getCurrentTransform(w4.ctx), w4.executeOperatorList(t4), w4.endDrawing(), { canvas: m4.canvas, scaleX: f4.scale, scaleY: p4.scale, offsetX: b4, offsetY: D4 };
    }
    getSizeAndScale(e4, t4, i4) {
      e4 = Math.abs(e4);
      const a4 = Math.max(_TilingPattern.MAX_PATTERN_SIZE, t4);
      let s4 = Math.ceil(e4 * i4);
      return s4 >= a4 ? s4 = a4 : i4 = s4 / e4, { scale: i4, size: s4 };
    }
    clipBbox(e4, t4, i4, a4, s4) {
      const n4 = a4 - t4, r4 = s4 - i4;
      e4.ctx.rect(t4, i4, n4, r4), e4.current.updateRectMinMax(getCurrentTransform(e4.ctx), [t4, i4, a4, s4]), e4.clip(), e4.endPath();
    }
    setFillAndStrokeStyleToContext(e4, t4, i4) {
      const a4 = e4.ctx, s4 = e4.current;
      switch (t4) {
        case ke3:
          const e5 = this.ctx;
          a4.fillStyle = e5.fillStyle, a4.strokeStyle = e5.strokeStyle, s4.fillColor = e5.fillStyle, s4.strokeColor = e5.strokeStyle;
          break;
        case Re3:
          const n4 = Util2.makeHexColor(i4[0], i4[1], i4[2]);
          a4.fillStyle = n4, a4.strokeStyle = n4, s4.fillColor = n4, s4.strokeColor = n4;
          break;
        default:
          throw new FormatError2(`Unsupported paint type: ${t4}`);
      }
    }
    getPattern(e4, t4, i4, a4) {
      let s4 = i4;
      a4 !== Fe3 && (s4 = Util2.transform(s4, t4.baseTransform), this.matrix && (s4 = Util2.transform(s4, this.matrix)));
      const n4 = this.createPatternCanvas(t4);
      let r4 = new DOMMatrix(s4);
      r4 = r4.translate(n4.offsetX, n4.offsetY), r4 = r4.scale(1 / n4.scaleX, 1 / n4.scaleY);
      const o4 = e4.createPattern(n4.canvas, "repeat");
      return o4.setTransform(r4), o4;
    }
  };
  __publicField(_TilingPattern, "MAX_PATTERN_SIZE", 3e3);
  let TilingPattern = _TilingPattern;
  function convertBlackAndWhiteToRGBA2({ src: e4, srcPos: t4 = 0, dest: i4, width: a4, height: s4, nonBlackColor: n4 = 4294967295, inverseDecode: r4 = false }) {
    const o4 = util_FeatureTest.isLittleEndian ? 4278190080 : 255, [g4, c4] = r4 ? [n4, o4] : [o4, n4], h4 = a4 >> 3, l4 = 7 & a4, C4 = e4.length;
    i4 = new Uint32Array(i4.buffer);
    let d4 = 0;
    for (let a5 = 0; a5 < s4; a5++) {
      for (const a7 = t4 + h4; t4 < a7; t4++) {
        const a8 = t4 < C4 ? e4[t4] : 255;
        i4[d4++] = 128 & a8 ? c4 : g4, i4[d4++] = 64 & a8 ? c4 : g4, i4[d4++] = 32 & a8 ? c4 : g4, i4[d4++] = 16 & a8 ? c4 : g4, i4[d4++] = 8 & a8 ? c4 : g4, i4[d4++] = 4 & a8 ? c4 : g4, i4[d4++] = 2 & a8 ? c4 : g4, i4[d4++] = 1 & a8 ? c4 : g4;
      }
      if (0 === l4) continue;
      const a6 = t4 < C4 ? e4[t4++] : 255;
      for (let e5 = 0; e5 < l4; e5++) i4[d4++] = a6 & 1 << 7 - e5 ? c4 : g4;
    }
    return { srcPos: t4, destPos: d4 };
  }
  const xe3 = 16;
  class CachedCanvases {
    constructor(e4) {
      this.canvasFactory = e4, this.cache = /* @__PURE__ */ Object.create(null);
    }
    getCanvas(e4, t4, i4) {
      let a4;
      return void 0 !== this.cache[e4] ? (a4 = this.cache[e4], this.canvasFactory.reset(a4, t4, i4)) : (a4 = this.canvasFactory.create(t4, i4), this.cache[e4] = a4), a4;
    }
    delete(e4) {
      delete this.cache[e4];
    }
    clear() {
      for (const e4 in this.cache) {
        const t4 = this.cache[e4];
        this.canvasFactory.destroy(t4), delete this.cache[e4];
      }
    }
  }
  function drawImageAtIntegerCoords(e4, t4, i4, a4, s4, n4, r4, o4, g4, c4) {
    const [h4, l4, C4, d4, u4, Q4] = getCurrentTransform(e4);
    if (0 === l4 && 0 === C4) {
      const f4 = r4 * h4 + u4, p4 = Math.round(f4), m4 = o4 * d4 + Q4, y4 = Math.round(m4), w4 = (r4 + g4) * h4 + u4, b4 = Math.abs(Math.round(w4) - p4) || 1, D4 = (o4 + c4) * d4 + Q4, S4 = Math.abs(Math.round(D4) - y4) || 1;
      return e4.setTransform(Math.sign(h4), 0, 0, Math.sign(d4), p4, y4), e4.drawImage(t4, i4, a4, s4, n4, 0, 0, b4, S4), e4.setTransform(h4, l4, C4, d4, u4, Q4), [b4, S4];
    }
    if (0 === h4 && 0 === d4) {
      const f4 = o4 * C4 + u4, p4 = Math.round(f4), m4 = r4 * l4 + Q4, y4 = Math.round(m4), w4 = (o4 + c4) * C4 + u4, b4 = Math.abs(Math.round(w4) - p4) || 1, D4 = (r4 + g4) * l4 + Q4, S4 = Math.abs(Math.round(D4) - y4) || 1;
      return e4.setTransform(0, Math.sign(l4), Math.sign(C4), 0, p4, y4), e4.drawImage(t4, i4, a4, s4, n4, 0, 0, S4, b4), e4.setTransform(h4, l4, C4, d4, u4, Q4), [S4, b4];
    }
    e4.drawImage(t4, i4, a4, s4, n4, r4, o4, g4, c4);
    return [Math.hypot(h4, l4) * g4, Math.hypot(C4, d4) * c4];
  }
  class CanvasExtraState {
    constructor(e4, t4) {
      this.alphaIsShape = false, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = a3, this.textMatrixScale = 1, this.fontMatrix = s3, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = m3, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = false, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = "none", this.startNewPathAndClipBox([0, 0, e4, t4]);
    }
    clone() {
      const e4 = Object.create(this);
      return e4.clipBox = this.clipBox.slice(), e4;
    }
    setCurrentPoint(e4, t4) {
      this.x = e4, this.y = t4;
    }
    updatePathMinMax(e4, t4, i4) {
      [t4, i4] = Util2.applyTransform([t4, i4], e4), this.minX = Math.min(this.minX, t4), this.minY = Math.min(this.minY, i4), this.maxX = Math.max(this.maxX, t4), this.maxY = Math.max(this.maxY, i4);
    }
    updateRectMinMax(e4, t4) {
      const i4 = Util2.applyTransform(t4, e4), a4 = Util2.applyTransform(t4.slice(2), e4), s4 = Util2.applyTransform([t4[0], t4[3]], e4), n4 = Util2.applyTransform([t4[2], t4[1]], e4);
      this.minX = Math.min(this.minX, i4[0], a4[0], s4[0], n4[0]), this.minY = Math.min(this.minY, i4[1], a4[1], s4[1], n4[1]), this.maxX = Math.max(this.maxX, i4[0], a4[0], s4[0], n4[0]), this.maxY = Math.max(this.maxY, i4[1], a4[1], s4[1], n4[1]);
    }
    updateScalingPathMinMax(e4, t4) {
      Util2.scaleMinMax(e4, t4), this.minX = Math.min(this.minX, t4[0]), this.minY = Math.min(this.minY, t4[1]), this.maxX = Math.max(this.maxX, t4[2]), this.maxY = Math.max(this.maxY, t4[3]);
    }
    updateCurvePathMinMax(e4, t4, i4, a4, s4, n4, r4, o4, g4, c4) {
      const h4 = Util2.bezierBoundingBox(t4, i4, a4, s4, n4, r4, o4, g4, c4);
      c4 || this.updateRectMinMax(e4, h4);
    }
    getPathBoundingBox(e4 = De3, t4 = null) {
      const i4 = [this.minX, this.minY, this.maxX, this.maxY];
      if (e4 === Se3) {
        t4 || unreachable2("Stroke bounding box must include transform.");
        const e5 = Util2.singularValueDecompose2dScale(t4), a4 = e5[0] * this.lineWidth / 2, s4 = e5[1] * this.lineWidth / 2;
        i4[0] -= a4, i4[1] -= s4, i4[2] += a4, i4[3] += s4;
      }
      return i4;
    }
    updateClipFromPath() {
      const e4 = Util2.intersect(this.clipBox, this.getPathBoundingBox());
      this.startNewPathAndClipBox(e4 || [0, 0, 0, 0]);
    }
    isEmptyClip() {
      return this.minX === 1 / 0;
    }
    startNewPathAndClipBox(e4) {
      this.clipBox = e4, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0;
    }
    getClippedPathBoundingBox(e4 = De3, t4 = null) {
      return Util2.intersect(this.clipBox, this.getPathBoundingBox(e4, t4));
    }
  }
  function putBinaryImageData(e4, t4) {
    if ("undefined" != typeof ImageData && t4 instanceof ImageData) return void e4.putImageData(t4, 0, 0);
    const i4 = t4.height, a4 = t4.width, s4 = i4 % xe3, n4 = (i4 - s4) / xe3, r4 = 0 === s4 ? n4 : n4 + 1, o4 = e4.createImageData(a4, xe3);
    let g4, c4 = 0;
    const h4 = t4.data, l4 = o4.data;
    let C4, d4, u4, Q4;
    if (t4.kind === F3.GRAYSCALE_1BPP) {
      const t5 = h4.byteLength, i5 = new Uint32Array(l4.buffer, 0, l4.byteLength >> 2), Q5 = i5.length, f4 = a4 + 7 >> 3, p4 = 4294967295, m4 = util_FeatureTest.isLittleEndian ? 4278190080 : 255;
      for (C4 = 0; C4 < r4; C4++) {
        for (u4 = C4 < n4 ? xe3 : s4, g4 = 0, d4 = 0; d4 < u4; d4++) {
          const e5 = t5 - c4;
          let s5 = 0;
          const n5 = e5 > f4 ? a4 : 8 * e5 - 7, r5 = -8 & n5;
          let o5 = 0, l5 = 0;
          for (; s5 < r5; s5 += 8) l5 = h4[c4++], i5[g4++] = 128 & l5 ? p4 : m4, i5[g4++] = 64 & l5 ? p4 : m4, i5[g4++] = 32 & l5 ? p4 : m4, i5[g4++] = 16 & l5 ? p4 : m4, i5[g4++] = 8 & l5 ? p4 : m4, i5[g4++] = 4 & l5 ? p4 : m4, i5[g4++] = 2 & l5 ? p4 : m4, i5[g4++] = 1 & l5 ? p4 : m4;
          for (; s5 < n5; s5++) 0 === o5 && (l5 = h4[c4++], o5 = 128), i5[g4++] = l5 & o5 ? p4 : m4, o5 >>= 1;
        }
        for (; g4 < Q5; ) i5[g4++] = 0;
        e4.putImageData(o4, 0, C4 * xe3);
      }
    } else if (t4.kind === F3.RGBA_32BPP) {
      for (d4 = 0, Q4 = a4 * xe3 * 4, C4 = 0; C4 < n4; C4++) l4.set(h4.subarray(c4, c4 + Q4)), c4 += Q4, e4.putImageData(o4, 0, d4), d4 += xe3;
      C4 < r4 && (Q4 = a4 * s4 * 4, l4.set(h4.subarray(c4, c4 + Q4)), e4.putImageData(o4, 0, d4));
    } else {
      if (t4.kind !== F3.RGB_24BPP) throw new Error(`bad image kind: ${t4.kind}`);
      for (u4 = xe3, Q4 = a4 * u4, C4 = 0; C4 < r4; C4++) {
        for (C4 >= n4 && (u4 = s4, Q4 = a4 * u4), g4 = 0, d4 = Q4; d4--; ) l4[g4++] = h4[c4++], l4[g4++] = h4[c4++], l4[g4++] = h4[c4++], l4[g4++] = 255;
        e4.putImageData(o4, 0, C4 * xe3);
      }
    }
  }
  function putBinaryImageMask(e4, t4) {
    if (t4.bitmap) return void e4.drawImage(t4.bitmap, 0, 0);
    const i4 = t4.height, a4 = t4.width, s4 = i4 % xe3, n4 = (i4 - s4) / xe3, r4 = 0 === s4 ? n4 : n4 + 1, o4 = e4.createImageData(a4, xe3);
    let g4 = 0;
    const c4 = t4.data, h4 = o4.data;
    for (let t5 = 0; t5 < r4; t5++) {
      const i5 = t5 < n4 ? xe3 : s4;
      ({ srcPos: g4 } = convertBlackAndWhiteToRGBA2({ src: c4, srcPos: g4, dest: h4, width: a4, height: i5, nonBlackColor: 0 })), e4.putImageData(o4, 0, t5 * xe3);
    }
  }
  function copyCtxState(e4, t4) {
    const i4 = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
    for (const a4 of i4) void 0 !== e4[a4] && (t4[a4] = e4[a4]);
    void 0 !== e4.setLineDash && (t4.setLineDash(e4.getLineDash()), t4.lineDashOffset = e4.lineDashOffset);
  }
  function resetCtxToDefault(e4) {
    if (e4.strokeStyle = e4.fillStyle = "#000000", e4.fillRule = "nonzero", e4.globalAlpha = 1, e4.lineWidth = 1, e4.lineCap = "butt", e4.lineJoin = "miter", e4.miterLimit = 10, e4.globalCompositeOperation = "source-over", e4.font = "10px sans-serif", void 0 !== e4.setLineDash && (e4.setLineDash([]), e4.lineDashOffset = 0), !i3) {
      const { filter: t4 } = e4;
      "none" !== t4 && "" !== t4 && (e4.filter = "none");
    }
  }
  function getImageSmoothingEnabled(e4, t4) {
    if (t4) return true;
    const i4 = Util2.singularValueDecompose2dScale(e4);
    i4[0] = Math.fround(i4[0]), i4[1] = Math.fround(i4[1]);
    const a4 = Math.fround((globalThis.devicePixelRatio || 1) * PixelsPerInch.PDF_TO_CSS_UNITS);
    return i4[0] <= a4 && i4[1] <= a4;
  }
  const Ne3 = ["butt", "round", "square"], Me3 = ["miter", "round", "bevel"], Ge3 = {}, ve3 = {};
  const _CanvasGraphics = class _CanvasGraphics {
    constructor(e4, t4, i4, a4, s4, { optionalContentConfig: n4, markedContentStack: r4 = null }, o4, g4) {
      __privateAdd(this, _CanvasGraphics_instances);
      this.ctx = e4, this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = false, this.res = null, this.xobjs = null, this.commonObjs = t4, this.objs = i4, this.canvasFactory = a4, this.filterFactory = s4, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = true, this.markedContentStack = r4 || [], this.optionalContentConfig = n4, this.cachedCanvases = new CachedCanvases(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = o4, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = g4, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
    }
    getObject(e4, t4 = null) {
      return "string" == typeof e4 ? e4.startsWith("g_") ? this.commonObjs.get(e4) : this.objs.get(e4) : t4;
    }
    beginDrawing({ transform: e4, viewport: t4, transparency: i4 = false, background: a4 = null }) {
      const s4 = this.ctx.canvas.width, n4 = this.ctx.canvas.height, r4 = this.ctx.fillStyle;
      if (this.ctx.fillStyle = a4 || "#ffffff", this.ctx.fillRect(0, 0, s4, n4), this.ctx.fillStyle = r4, i4) {
        const e5 = this.cachedCanvases.getCanvas("transparent", s4, n4);
        this.compositeCtx = this.ctx, this.transparentCanvas = e5.canvas, this.ctx = e5.context, this.ctx.save(), this.ctx.transform(...getCurrentTransform(this.compositeCtx));
      }
      this.ctx.save(), resetCtxToDefault(this.ctx), e4 && (this.ctx.transform(...e4), this.outputScaleX = e4[0], this.outputScaleY = e4[0]), this.ctx.transform(...t4.transform), this.viewportScale = t4.scale, this.baseTransform = getCurrentTransform(this.ctx);
    }
    executeOperatorList(e4, t4, i4, a4) {
      const s4 = e4.argsArray, n4 = e4.fnArray;
      let r4 = t4 || 0;
      const o4 = s4.length;
      if (o4 === r4) return r4;
      const g4 = o4 - r4 > 10 && "function" == typeof i4, c4 = g4 ? Date.now() + 15 : 0;
      let h4 = 0;
      const l4 = this.commonObjs, C4 = this.objs;
      let d4;
      for (; ; ) {
        if (void 0 !== a4 && r4 === a4.nextBreakPoint) return a4.breakIt(r4, i4), r4;
        if (d4 = n4[r4], d4 !== te3.dependency) this[d4].apply(this, s4[r4]);
        else for (const e5 of s4[r4]) {
          const t5 = e5.startsWith("g_") ? l4 : C4;
          if (!t5.has(e5)) return t5.get(e5, i4), r4;
        }
        if (r4++, r4 === o4) return r4;
        if (g4 && ++h4 > 10) {
          if (Date.now() > c4) return i4(), r4;
          h4 = 0;
        }
      }
    }
    endDrawing() {
      __privateMethod(this, _CanvasGraphics_instances, yA_fn).call(this), this.cachedCanvases.clear(), this.cachedPatterns.clear();
      for (const e4 of this._cachedBitmapsMap.values()) {
        for (const t4 of e4.values()) "undefined" != typeof HTMLCanvasElement && t4 instanceof HTMLCanvasElement && (t4.width = t4.height = 0);
        e4.clear();
      }
      this._cachedBitmapsMap.clear(), __privateMethod(this, _CanvasGraphics_instances, wA_fn).call(this);
    }
    _scaleImage(e4, t4) {
      const i4 = e4.width, a4 = e4.height;
      let s4, n4, r4 = Math.max(Math.hypot(t4[0], t4[1]), 1), o4 = Math.max(Math.hypot(t4[2], t4[3]), 1), g4 = i4, c4 = a4, h4 = "prescale1";
      for (; r4 > 2 && g4 > 1 || o4 > 2 && c4 > 1; ) {
        let t5 = g4, i5 = c4;
        r4 > 2 && g4 > 1 && (t5 = g4 >= 16384 ? Math.floor(g4 / 2) - 1 || 1 : Math.ceil(g4 / 2), r4 /= g4 / t5), o4 > 2 && c4 > 1 && (i5 = c4 >= 16384 ? Math.floor(c4 / 2) - 1 || 1 : Math.ceil(c4) / 2, o4 /= c4 / i5), s4 = this.cachedCanvases.getCanvas(h4, t5, i5), n4 = s4.context, n4.clearRect(0, 0, t5, i5), n4.drawImage(e4, 0, 0, g4, c4, 0, 0, t5, i5), e4 = s4.canvas, g4 = t5, c4 = i5, h4 = "prescale1" === h4 ? "prescale2" : "prescale1";
      }
      return { img: e4, paintWidth: g4, paintHeight: c4 };
    }
    _createMaskCanvas(e4) {
      const t4 = this.ctx, { width: i4, height: a4 } = e4, s4 = this.current.fillColor, n4 = this.current.patternFill, r4 = getCurrentTransform(t4);
      let o4, g4, c4, h4;
      if ((e4.bitmap || e4.data) && e4.count > 1) {
        const t5 = e4.bitmap || e4.data.buffer;
        g4 = JSON.stringify(n4 ? r4 : [r4.slice(0, 4), s4]), o4 = this._cachedBitmapsMap.get(t5), o4 || (o4 = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(t5, o4));
        const i5 = o4.get(g4);
        if (i5 && !n4) {
          return { canvas: i5, offsetX: Math.round(Math.min(r4[0], r4[2]) + r4[4]), offsetY: Math.round(Math.min(r4[1], r4[3]) + r4[5]) };
        }
        c4 = i5;
      }
      c4 || (h4 = this.cachedCanvases.getCanvas("maskCanvas", i4, a4), putBinaryImageMask(h4.context, e4));
      let l4 = Util2.transform(r4, [1 / i4, 0, 0, -1 / a4, 0, 0]);
      l4 = Util2.transform(l4, [1, 0, 0, 1, 0, -a4]);
      const [C4, d4, u4, Q4] = Util2.getAxialAlignedBoundingBox([0, 0, i4, a4], l4), f4 = Math.round(u4 - C4) || 1, p4 = Math.round(Q4 - d4) || 1, m4 = this.cachedCanvases.getCanvas("fillCanvas", f4, p4), y4 = m4.context, w4 = C4, b4 = d4;
      y4.translate(-w4, -b4), y4.transform(...l4), c4 || (c4 = this._scaleImage(h4.canvas, getCurrentTransformInverse(y4)), c4 = c4.img, o4 && n4 && o4.set(g4, c4)), y4.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(y4), e4.interpolate), drawImageAtIntegerCoords(y4, c4, 0, 0, c4.width, c4.height, 0, 0, i4, a4), y4.globalCompositeOperation = "source-in";
      const D4 = Util2.transform(getCurrentTransformInverse(y4), [1, 0, 0, 1, -w4, -b4]);
      return y4.fillStyle = n4 ? s4.getPattern(t4, this, D4, De3) : s4, y4.fillRect(0, 0, i4, a4), o4 && !n4 && (this.cachedCanvases.delete("fillCanvas"), o4.set(g4, m4.canvas)), { canvas: m4.canvas, offsetX: Math.round(w4), offsetY: Math.round(b4) };
    }
    setLineWidth(e4) {
      e4 !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = e4, this.ctx.lineWidth = e4;
    }
    setLineCap(e4) {
      this.ctx.lineCap = Ne3[e4];
    }
    setLineJoin(e4) {
      this.ctx.lineJoin = Me3[e4];
    }
    setMiterLimit(e4) {
      this.ctx.miterLimit = e4;
    }
    setDash(e4, t4) {
      const i4 = this.ctx;
      void 0 !== i4.setLineDash && (i4.setLineDash(e4), i4.lineDashOffset = t4);
    }
    setRenderingIntent(e4) {
    }
    setFlatness(e4) {
    }
    setGState(e4) {
      for (const [t4, i4] of e4) switch (t4) {
        case "LW":
          this.setLineWidth(i4);
          break;
        case "LC":
          this.setLineCap(i4);
          break;
        case "LJ":
          this.setLineJoin(i4);
          break;
        case "ML":
          this.setMiterLimit(i4);
          break;
        case "D":
          this.setDash(i4[0], i4[1]);
          break;
        case "RI":
          this.setRenderingIntent(i4);
          break;
        case "FL":
          this.setFlatness(i4);
          break;
        case "Font":
          this.setFont(i4[0], i4[1]);
          break;
        case "CA":
          this.current.strokeAlpha = i4;
          break;
        case "ca":
          this.current.fillAlpha = i4, this.ctx.globalAlpha = i4;
          break;
        case "BM":
          this.ctx.globalCompositeOperation = i4;
          break;
        case "SMask":
          this.current.activeSMask = i4 ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
          break;
        case "TR":
          this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(i4);
      }
    }
    get inSMaskMode() {
      return !!this.suspendedCtx;
    }
    checkSMaskState() {
      const e4 = this.inSMaskMode;
      this.current.activeSMask && !e4 ? this.beginSMaskMode() : !this.current.activeSMask && e4 && this.endSMaskMode();
    }
    beginSMaskMode() {
      if (this.inSMaskMode) throw new Error("beginSMaskMode called while already in smask mode");
      const e4 = this.ctx.canvas.width, t4 = this.ctx.canvas.height, i4 = "smaskGroupAt" + this.groupLevel, a4 = this.cachedCanvases.getCanvas(i4, e4, t4);
      this.suspendedCtx = this.ctx, this.ctx = a4.context;
      const s4 = this.ctx;
      s4.setTransform(...getCurrentTransform(this.suspendedCtx)), copyCtxState(this.suspendedCtx, s4), function(e5, t5) {
        if (e5._removeMirroring) throw new Error("Context is already forwarding operations.");
        e5.__originalSave = e5.save, e5.__originalRestore = e5.restore, e5.__originalRotate = e5.rotate, e5.__originalScale = e5.scale, e5.__originalTranslate = e5.translate, e5.__originalTransform = e5.transform, e5.__originalSetTransform = e5.setTransform, e5.__originalResetTransform = e5.resetTransform, e5.__originalClip = e5.clip, e5.__originalMoveTo = e5.moveTo, e5.__originalLineTo = e5.lineTo, e5.__originalBezierCurveTo = e5.bezierCurveTo, e5.__originalRect = e5.rect, e5.__originalClosePath = e5.closePath, e5.__originalBeginPath = e5.beginPath, e5._removeMirroring = () => {
          e5.save = e5.__originalSave, e5.restore = e5.__originalRestore, e5.rotate = e5.__originalRotate, e5.scale = e5.__originalScale, e5.translate = e5.__originalTranslate, e5.transform = e5.__originalTransform, e5.setTransform = e5.__originalSetTransform, e5.resetTransform = e5.__originalResetTransform, e5.clip = e5.__originalClip, e5.moveTo = e5.__originalMoveTo, e5.lineTo = e5.__originalLineTo, e5.bezierCurveTo = e5.__originalBezierCurveTo, e5.rect = e5.__originalRect, e5.closePath = e5.__originalClosePath, e5.beginPath = e5.__originalBeginPath, delete e5._removeMirroring;
        }, e5.save = function() {
          t5.save(), this.__originalSave();
        }, e5.restore = function() {
          t5.restore(), this.__originalRestore();
        }, e5.translate = function(e6, i5) {
          t5.translate(e6, i5), this.__originalTranslate(e6, i5);
        }, e5.scale = function(e6, i5) {
          t5.scale(e6, i5), this.__originalScale(e6, i5);
        }, e5.transform = function(e6, i5, a5, s5, n4, r4) {
          t5.transform(e6, i5, a5, s5, n4, r4), this.__originalTransform(e6, i5, a5, s5, n4, r4);
        }, e5.setTransform = function(e6, i5, a5, s5, n4, r4) {
          t5.setTransform(e6, i5, a5, s5, n4, r4), this.__originalSetTransform(e6, i5, a5, s5, n4, r4);
        }, e5.resetTransform = function() {
          t5.resetTransform(), this.__originalResetTransform();
        }, e5.rotate = function(e6) {
          t5.rotate(e6), this.__originalRotate(e6);
        }, e5.clip = function(e6) {
          t5.clip(e6), this.__originalClip(e6);
        }, e5.moveTo = function(e6, i5) {
          t5.moveTo(e6, i5), this.__originalMoveTo(e6, i5);
        }, e5.lineTo = function(e6, i5) {
          t5.lineTo(e6, i5), this.__originalLineTo(e6, i5);
        }, e5.bezierCurveTo = function(e6, i5, a5, s5, n4, r4) {
          t5.bezierCurveTo(e6, i5, a5, s5, n4, r4), this.__originalBezierCurveTo(e6, i5, a5, s5, n4, r4);
        }, e5.rect = function(e6, i5, a5, s5) {
          t5.rect(e6, i5, a5, s5), this.__originalRect(e6, i5, a5, s5);
        }, e5.closePath = function() {
          t5.closePath(), this.__originalClosePath();
        }, e5.beginPath = function() {
          t5.beginPath(), this.__originalBeginPath();
        };
      }(s4, this.suspendedCtx), this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
    }
    endSMaskMode() {
      if (!this.inSMaskMode) throw new Error("endSMaskMode called while not in smask mode");
      this.ctx._removeMirroring(), copyCtxState(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
    }
    compose(e4) {
      if (!this.current.activeSMask) return;
      e4 ? (e4[0] = Math.floor(e4[0]), e4[1] = Math.floor(e4[1]), e4[2] = Math.ceil(e4[2]), e4[3] = Math.ceil(e4[3])) : e4 = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
      const t4 = this.current.activeSMask, i4 = this.suspendedCtx;
      this.composeSMask(i4, t4, this.ctx, e4), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
    }
    composeSMask(e4, t4, i4, a4) {
      const s4 = a4[0], n4 = a4[1], r4 = a4[2] - s4, o4 = a4[3] - n4;
      0 !== r4 && 0 !== o4 && (this.genericComposeSMask(t4.context, i4, r4, o4, t4.subtype, t4.backdrop, t4.transferMap, s4, n4, t4.offsetX, t4.offsetY), e4.save(), e4.globalAlpha = 1, e4.globalCompositeOperation = "source-over", e4.setTransform(1, 0, 0, 1, 0, 0), e4.drawImage(i4.canvas, 0, 0), e4.restore());
    }
    genericComposeSMask(e4, t4, i4, a4, s4, n4, r4, o4, g4, c4, h4) {
      let l4 = e4.canvas, C4 = o4 - c4, d4 = g4 - h4;
      if (n4) {
        if (C4 < 0 || d4 < 0 || C4 + i4 > l4.width || d4 + a4 > l4.height) {
          const e5 = this.cachedCanvases.getCanvas("maskExtension", i4, a4), t5 = e5.context;
          t5.drawImage(l4, -C4, -d4), n4.some((e6) => 0 !== e6) && (t5.globalCompositeOperation = "destination-atop", t5.fillStyle = Util2.makeHexColor(...n4), t5.fillRect(0, 0, i4, a4), t5.globalCompositeOperation = "source-over"), l4 = e5.canvas, C4 = d4 = 0;
        } else if (n4.some((e5) => 0 !== e5)) {
          e4.save(), e4.globalAlpha = 1, e4.setTransform(1, 0, 0, 1, 0, 0);
          const t5 = new Path2D();
          t5.rect(C4, d4, i4, a4), e4.clip(t5), e4.globalCompositeOperation = "destination-atop", e4.fillStyle = Util2.makeHexColor(...n4), e4.fillRect(C4, d4, i4, a4), e4.restore();
        }
      }
      t4.save(), t4.globalAlpha = 1, t4.setTransform(1, 0, 0, 1, 0, 0), "Alpha" === s4 && r4 ? t4.filter = this.filterFactory.addAlphaFilter(r4) : "Luminosity" === s4 && (t4.filter = this.filterFactory.addLuminosityFilter(r4));
      const u4 = new Path2D();
      u4.rect(o4, g4, i4, a4), t4.clip(u4), t4.globalCompositeOperation = "destination-in", t4.drawImage(l4, C4, d4, i4, a4, o4, g4, i4, a4), t4.restore();
    }
    save() {
      this.inSMaskMode ? (copyCtxState(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save();
      const e4 = this.current;
      this.stateStack.push(e4), this.current = e4.clone();
    }
    restore() {
      0 === this.stateStack.length && this.inSMaskMode && this.endSMaskMode(), 0 !== this.stateStack.length && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), copyCtxState(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null);
    }
    transform(e4, t4, i4, a4, s4, n4) {
      this.ctx.transform(e4, t4, i4, a4, s4, n4), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
    }
    constructPath(e4, t4, i4) {
      const a4 = this.ctx, s4 = this.current;
      let n4, r4, o4 = s4.x, g4 = s4.y;
      const c4 = getCurrentTransform(a4), h4 = 0 === c4[0] && 0 === c4[3] || 0 === c4[1] && 0 === c4[2], l4 = h4 ? i4.slice(0) : null;
      for (let i5 = 0, C4 = 0, d4 = e4.length; i5 < d4; i5++) switch (0 | e4[i5]) {
        case te3.rectangle:
          o4 = t4[C4++], g4 = t4[C4++];
          const e5 = t4[C4++], i6 = t4[C4++], d5 = o4 + e5, u4 = g4 + i6;
          a4.moveTo(o4, g4), 0 === e5 || 0 === i6 ? a4.lineTo(d5, u4) : (a4.lineTo(d5, g4), a4.lineTo(d5, u4), a4.lineTo(o4, u4)), h4 || s4.updateRectMinMax(c4, [o4, g4, d5, u4]), a4.closePath();
          break;
        case te3.moveTo:
          o4 = t4[C4++], g4 = t4[C4++], a4.moveTo(o4, g4), h4 || s4.updatePathMinMax(c4, o4, g4);
          break;
        case te3.lineTo:
          o4 = t4[C4++], g4 = t4[C4++], a4.lineTo(o4, g4), h4 || s4.updatePathMinMax(c4, o4, g4);
          break;
        case te3.curveTo:
          n4 = o4, r4 = g4, o4 = t4[C4 + 4], g4 = t4[C4 + 5], a4.bezierCurveTo(t4[C4], t4[C4 + 1], t4[C4 + 2], t4[C4 + 3], o4, g4), s4.updateCurvePathMinMax(c4, n4, r4, t4[C4], t4[C4 + 1], t4[C4 + 2], t4[C4 + 3], o4, g4, l4), C4 += 6;
          break;
        case te3.curveTo2:
          n4 = o4, r4 = g4, a4.bezierCurveTo(o4, g4, t4[C4], t4[C4 + 1], t4[C4 + 2], t4[C4 + 3]), s4.updateCurvePathMinMax(c4, n4, r4, o4, g4, t4[C4], t4[C4 + 1], t4[C4 + 2], t4[C4 + 3], l4), o4 = t4[C4 + 2], g4 = t4[C4 + 3], C4 += 4;
          break;
        case te3.curveTo3:
          n4 = o4, r4 = g4, o4 = t4[C4 + 2], g4 = t4[C4 + 3], a4.bezierCurveTo(t4[C4], t4[C4 + 1], o4, g4, o4, g4), s4.updateCurvePathMinMax(c4, n4, r4, t4[C4], t4[C4 + 1], o4, g4, o4, g4, l4), C4 += 4;
          break;
        case te3.closePath:
          a4.closePath();
      }
      h4 && s4.updateScalingPathMinMax(c4, l4), s4.setCurrentPoint(o4, g4);
    }
    closePath() {
      this.ctx.closePath();
    }
    stroke(e4 = true) {
      const t4 = this.ctx, i4 = this.current.strokeColor;
      t4.globalAlpha = this.current.strokeAlpha, this.contentVisible && ("object" == typeof i4 && i4?.getPattern ? (t4.save(), t4.strokeStyle = i4.getPattern(t4, this, getCurrentTransformInverse(t4), Se3), this.rescaleAndStroke(false), t4.restore()) : this.rescaleAndStroke(true)), e4 && this.consumePath(this.current.getClippedPathBoundingBox()), t4.globalAlpha = this.current.fillAlpha;
    }
    closeStroke() {
      this.closePath(), this.stroke();
    }
    fill(e4 = true) {
      const t4 = this.ctx, i4 = this.current.fillColor;
      let a4 = false;
      this.current.patternFill && (t4.save(), t4.fillStyle = i4.getPattern(t4, this, getCurrentTransformInverse(t4), De3), a4 = true);
      const s4 = this.current.getClippedPathBoundingBox();
      this.contentVisible && null !== s4 && (this.pendingEOFill ? (t4.fill("evenodd"), this.pendingEOFill = false) : t4.fill()), a4 && t4.restore(), e4 && this.consumePath(s4);
    }
    eoFill() {
      this.pendingEOFill = true, this.fill();
    }
    fillStroke() {
      this.fill(false), this.stroke(false), this.consumePath();
    }
    eoFillStroke() {
      this.pendingEOFill = true, this.fillStroke();
    }
    closeFillStroke() {
      this.closePath(), this.fillStroke();
    }
    closeEOFillStroke() {
      this.pendingEOFill = true, this.closePath(), this.fillStroke();
    }
    endPath() {
      this.consumePath();
    }
    clip() {
      this.pendingClip = Ge3;
    }
    eoClip() {
      this.pendingClip = ve3;
    }
    beginText() {
      this.current.textMatrix = a3, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
    }
    endText() {
      const e4 = this.pendingTextPaths, t4 = this.ctx;
      if (void 0 !== e4) {
        t4.save(), t4.beginPath();
        for (const i4 of e4) t4.setTransform(...i4.transform), t4.translate(i4.x, i4.y), i4.addToPath(t4, i4.fontSize);
        t4.restore(), t4.clip(), t4.beginPath(), delete this.pendingTextPaths;
      } else t4.beginPath();
    }
    setCharSpacing(e4) {
      this.current.charSpacing = e4;
    }
    setWordSpacing(e4) {
      this.current.wordSpacing = e4;
    }
    setHScale(e4) {
      this.current.textHScale = e4 / 100;
    }
    setLeading(e4) {
      this.current.leading = -e4;
    }
    setFont(e4, t4) {
      const i4 = this.commonObjs.get(e4), a4 = this.current;
      if (!i4) throw new Error(`Can't find font for ${e4}`);
      if (a4.fontMatrix = i4.fontMatrix || s3, 0 !== a4.fontMatrix[0] && 0 !== a4.fontMatrix[3] || warn2("Invalid font matrix for font " + e4), t4 < 0 ? (t4 = -t4, a4.fontDirection = -1) : a4.fontDirection = 1, this.current.font = i4, this.current.fontSize = t4, i4.isType3Font) return;
      const n4 = i4.loadedName || "sans-serif", r4 = i4.systemFontInfo?.css || `"${n4}", ${i4.fallbackName}`;
      let o4 = "normal";
      i4.black ? o4 = "900" : i4.bold && (o4 = "bold");
      const g4 = i4.italic ? "italic" : "normal";
      let c4 = t4;
      t4 < 16 ? c4 = 16 : t4 > 100 && (c4 = 100), this.current.fontSizeScale = t4 / c4, this.ctx.font = `${g4} ${o4} ${c4}px ${r4}`;
    }
    setTextRenderingMode(e4) {
      this.current.textRenderingMode = e4;
    }
    setTextRise(e4) {
      this.current.textRise = e4;
    }
    moveText(e4, t4) {
      this.current.x = this.current.lineX += e4, this.current.y = this.current.lineY += t4;
    }
    setLeadingMoveText(e4, t4) {
      this.setLeading(-t4), this.moveText(e4, t4);
    }
    setTextMatrix(e4, t4, i4, a4, s4, n4) {
      this.current.textMatrix = [e4, t4, i4, a4, s4, n4], this.current.textMatrixScale = Math.hypot(e4, t4), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
    }
    nextLine() {
      this.moveText(0, this.current.leading);
    }
    paintChar(e4, t4, i4, a4) {
      const s4 = this.ctx, n4 = this.current, r4 = n4.font, o4 = n4.textRenderingMode, g4 = n4.fontSize / n4.fontSizeScale, c4 = o4 & D3, h4 = !!(o4 & S3), l4 = n4.patternFill && !r4.missingFile;
      let C4;
      if ((r4.disableFontFace || h4 || l4) && (C4 = r4.getPathGenerator(this.commonObjs, e4)), r4.disableFontFace || l4 ? (s4.save(), s4.translate(t4, i4), s4.beginPath(), C4(s4, g4), a4 && s4.setTransform(...a4), c4 !== m3 && c4 !== w3 || s4.fill(), c4 !== y3 && c4 !== w3 || s4.stroke(), s4.restore()) : (c4 !== m3 && c4 !== w3 || s4.fillText(e4, t4, i4), c4 !== y3 && c4 !== w3 || s4.strokeText(e4, t4, i4)), h4) {
        (this.pendingTextPaths || (this.pendingTextPaths = [])).push({ transform: getCurrentTransform(s4), x: t4, y: i4, fontSize: g4, addToPath: C4 });
      }
    }
    get isFontSubpixelAAEnabled() {
      const { context: e4 } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
      e4.scale(1.5, 1), e4.fillText("I", 0, 10);
      const t4 = e4.getImageData(0, 0, 10, 10).data;
      let i4 = false;
      for (let e5 = 3; e5 < t4.length; e5 += 4) if (t4[e5] > 0 && t4[e5] < 255) {
        i4 = true;
        break;
      }
      return shadow2(this, "isFontSubpixelAAEnabled", i4);
    }
    showText(e4) {
      const t4 = this.current, i4 = t4.font;
      if (i4.isType3Font) return this.showType3Text(e4);
      const a4 = t4.fontSize;
      if (0 === a4) return;
      const s4 = this.ctx, n4 = t4.fontSizeScale, r4 = t4.charSpacing, o4 = t4.wordSpacing, g4 = t4.fontDirection, c4 = t4.textHScale * g4, h4 = e4.length, l4 = i4.vertical, C4 = l4 ? 1 : -1, d4 = i4.defaultVMetrics, u4 = a4 * t4.fontMatrix[0], Q4 = t4.textRenderingMode === m3 && !i4.disableFontFace && !t4.patternFill;
      let f4;
      if (s4.save(), s4.transform(...t4.textMatrix), s4.translate(t4.x, t4.y + t4.textRise), g4 > 0 ? s4.scale(c4, -1) : s4.scale(c4, 1), t4.patternFill) {
        s4.save();
        const e5 = t4.fillColor.getPattern(s4, this, getCurrentTransformInverse(s4), De3);
        f4 = getCurrentTransform(s4), s4.restore(), s4.fillStyle = e5;
      }
      let p4 = t4.lineWidth;
      const b4 = t4.textMatrixScale;
      if (0 === b4 || 0 === p4) {
        const e5 = t4.textRenderingMode & D3;
        e5 !== y3 && e5 !== w3 || (p4 = this.getSinglePixelWidth());
      } else p4 /= b4;
      if (1 !== n4 && (s4.scale(n4, n4), p4 /= n4), s4.lineWidth = p4, i4.isInvalidPDFjsFont) {
        const i5 = [];
        let a5 = 0;
        for (const t5 of e4) i5.push(t5.unicode), a5 += t5.width;
        return s4.fillText(i5.join(""), 0, 0), t4.x += a5 * u4 * c4, s4.restore(), void this.compose();
      }
      let S4, F4 = 0;
      for (S4 = 0; S4 < h4; ++S4) {
        const t5 = e4[S4];
        if ("number" == typeof t5) {
          F4 += C4 * t5 * a4 / 1e3;
          continue;
        }
        let c5 = false;
        const h5 = (t5.isSpace ? o4 : 0) + r4, p5 = t5.fontChar, m4 = t5.accent;
        let y4, w4, b5 = t5.width;
        if (l4) {
          const e5 = t5.vmetric || d4, i5 = -(t5.vmetric ? e5[1] : 0.5 * b5) * u4, a5 = e5[2] * u4;
          b5 = e5 ? -e5[0] : b5, y4 = i5 / n4, w4 = (F4 + a5) / n4;
        } else y4 = F4 / n4, w4 = 0;
        if (i4.remeasure && b5 > 0) {
          const e5 = 1e3 * s4.measureText(p5).width / a4 * n4;
          if (b5 < e5 && this.isFontSubpixelAAEnabled) {
            const t6 = b5 / e5;
            c5 = true, s4.save(), s4.scale(t6, 1), y4 /= t6;
          } else b5 !== e5 && (y4 += (b5 - e5) / 2e3 * a4 / n4);
        }
        if (this.contentVisible && (t5.isInFont || i4.missingFile)) {
          if (Q4 && !m4) s4.fillText(p5, y4, w4);
          else if (this.paintChar(p5, y4, w4, f4), m4) {
            const e5 = y4 + a4 * m4.offset.x / n4, t6 = w4 - a4 * m4.offset.y / n4;
            this.paintChar(m4.fontChar, e5, t6, f4);
          }
        }
        F4 += l4 ? b5 * u4 - h5 * g4 : b5 * u4 + h5 * g4, c5 && s4.restore();
      }
      l4 ? t4.y -= F4 : t4.x += F4 * c4, s4.restore(), this.compose();
    }
    showType3Text(e4) {
      const t4 = this.ctx, i4 = this.current, a4 = i4.font, n4 = i4.fontSize, r4 = i4.fontDirection, o4 = a4.vertical ? 1 : -1, g4 = i4.charSpacing, c4 = i4.wordSpacing, h4 = i4.textHScale * r4, l4 = i4.fontMatrix || s3, C4 = e4.length;
      let d4, u4, Q4, f4;
      if (!(i4.textRenderingMode === b3) && 0 !== n4) {
        for (this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, t4.save(), t4.transform(...i4.textMatrix), t4.translate(i4.x, i4.y), t4.scale(h4, r4), d4 = 0; d4 < C4; ++d4) {
          if (u4 = e4[d4], "number" == typeof u4) {
            f4 = o4 * u4 * n4 / 1e3, this.ctx.translate(f4, 0), i4.x += f4 * h4;
            continue;
          }
          const s4 = (u4.isSpace ? c4 : 0) + g4, r5 = a4.charProcOperatorList[u4.operatorListId];
          if (!r5) {
            warn2(`Type3 character "${u4.operatorListId}" is not available.`);
            continue;
          }
          this.contentVisible && (this.processingType3 = u4, this.save(), t4.scale(n4, n4), t4.transform(...l4), this.executeOperatorList(r5), this.restore());
          Q4 = Util2.applyTransform([u4.width, 0], l4)[0] * n4 + s4, t4.translate(Q4, 0), i4.x += Q4 * h4;
        }
        t4.restore(), this.processingType3 = null;
      }
    }
    setCharWidth(e4, t4) {
    }
    setCharWidthAndBounds(e4, t4, i4, a4, s4, n4) {
      this.ctx.rect(i4, a4, s4 - i4, n4 - a4), this.ctx.clip(), this.endPath();
    }
    getColorN_Pattern(e4) {
      let t4;
      if ("TilingPattern" === e4[0]) {
        const i4 = e4[1], a4 = this.baseTransform || getCurrentTransform(this.ctx), s4 = { createCanvasGraphics: (e5) => new _CanvasGraphics(e5, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, { optionalContentConfig: this.optionalContentConfig, markedContentStack: this.markedContentStack }) };
        t4 = new TilingPattern(e4, i4, this.ctx, s4, a4);
      } else t4 = this._getPattern(e4[1], e4[2]);
      return t4;
    }
    setStrokeColorN() {
      this.current.strokeColor = this.getColorN_Pattern(arguments);
    }
    setFillColorN() {
      this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = true;
    }
    setStrokeRGBColor(e4, t4, i4) {
      this.ctx.strokeStyle = this.current.strokeColor = Util2.makeHexColor(e4, t4, i4);
    }
    setStrokeTransparent() {
      this.ctx.strokeStyle = this.current.strokeColor = "transparent";
    }
    setFillRGBColor(e4, t4, i4) {
      this.ctx.fillStyle = this.current.fillColor = Util2.makeHexColor(e4, t4, i4), this.current.patternFill = false;
    }
    setFillTransparent() {
      this.ctx.fillStyle = this.current.fillColor = "transparent", this.current.patternFill = false;
    }
    _getPattern(e4, t4 = null) {
      let i4;
      return this.cachedPatterns.has(e4) ? i4 = this.cachedPatterns.get(e4) : (i4 = function(e5) {
        switch (e5[0]) {
          case "RadialAxial":
            return new RadialAxialShadingPattern(e5);
          case "Mesh":
            return new MeshShadingPattern(e5);
          case "Dummy":
            return new DummyShadingPattern();
        }
        throw new Error(`Unknown IR type: ${e5[0]}`);
      }(this.getObject(e4)), this.cachedPatterns.set(e4, i4)), t4 && (i4.matrix = t4), i4;
    }
    shadingFill(e4) {
      if (!this.contentVisible) return;
      const t4 = this.ctx;
      this.save();
      const i4 = this._getPattern(e4);
      t4.fillStyle = i4.getPattern(t4, this, getCurrentTransformInverse(t4), Fe3);
      const a4 = getCurrentTransformInverse(t4);
      if (a4) {
        const { width: e5, height: i5 } = t4.canvas, [s4, n4, r4, o4] = Util2.getAxialAlignedBoundingBox([0, 0, e5, i5], a4);
        this.ctx.fillRect(s4, n4, r4 - s4, o4 - n4);
      } else this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
      this.compose(this.current.getClippedPathBoundingBox()), this.restore();
    }
    beginInlineImage() {
      unreachable2("Should not call beginInlineImage");
    }
    beginImageData() {
      unreachable2("Should not call beginImageData");
    }
    paintFormXObjectBegin(e4, t4) {
      if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), e4 && this.transform(...e4), this.baseTransform = getCurrentTransform(this.ctx), t4)) {
        const e5 = t4[2] - t4[0], i4 = t4[3] - t4[1];
        this.ctx.rect(t4[0], t4[1], e5, i4), this.current.updateRectMinMax(getCurrentTransform(this.ctx), t4), this.clip(), this.endPath();
      }
    }
    paintFormXObjectEnd() {
      this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop());
    }
    beginGroup(e4) {
      if (!this.contentVisible) return;
      this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
      const t4 = this.ctx;
      e4.isolated || info2("TODO: Support non-isolated groups."), e4.knockout && warn2("Knockout groups not supported.");
      const i4 = getCurrentTransform(t4);
      if (e4.matrix && t4.transform(...e4.matrix), !e4.bbox) throw new Error("Bounding box is required.");
      let a4 = Util2.getAxialAlignedBoundingBox(e4.bbox, getCurrentTransform(t4));
      const s4 = [0, 0, t4.canvas.width, t4.canvas.height];
      a4 = Util2.intersect(a4, s4) || [0, 0, 0, 0];
      const n4 = Math.floor(a4[0]), r4 = Math.floor(a4[1]), o4 = Math.max(Math.ceil(a4[2]) - n4, 1), g4 = Math.max(Math.ceil(a4[3]) - r4, 1);
      this.current.startNewPathAndClipBox([0, 0, o4, g4]);
      let c4 = "groupAt" + this.groupLevel;
      e4.smask && (c4 += "_smask_" + this.smaskCounter++ % 2);
      const h4 = this.cachedCanvases.getCanvas(c4, o4, g4), l4 = h4.context;
      l4.translate(-n4, -r4), l4.transform(...i4), e4.smask ? this.smaskStack.push({ canvas: h4.canvas, context: l4, offsetX: n4, offsetY: r4, subtype: e4.smask.subtype, backdrop: e4.smask.backdrop, transferMap: e4.smask.transferMap || null, startTransformInverse: null }) : (t4.setTransform(1, 0, 0, 1, 0, 0), t4.translate(n4, r4), t4.save()), copyCtxState(t4, l4), this.ctx = l4, this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(t4), this.groupLevel++;
    }
    endGroup(e4) {
      if (!this.contentVisible) return;
      this.groupLevel--;
      const t4 = this.ctx, i4 = this.groupStack.pop();
      if (this.ctx = i4, this.ctx.imageSmoothingEnabled = false, e4.smask) this.tempSMask = this.smaskStack.pop(), this.restore();
      else {
        this.ctx.restore();
        const e5 = getCurrentTransform(this.ctx);
        this.restore(), this.ctx.save(), this.ctx.setTransform(...e5);
        const i5 = Util2.getAxialAlignedBoundingBox([0, 0, t4.canvas.width, t4.canvas.height], e5);
        this.ctx.drawImage(t4.canvas, 0, 0), this.ctx.restore(), this.compose(i5);
      }
    }
    beginAnnotation(e4, t4, i4, a4, s4) {
      if (__privateMethod(this, _CanvasGraphics_instances, yA_fn).call(this), resetCtxToDefault(this.ctx), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), t4) {
        const a5 = t4[2] - t4[0], n4 = t4[3] - t4[1];
        if (s4 && this.annotationCanvasMap) {
          (i4 = i4.slice())[4] -= t4[0], i4[5] -= t4[1], (t4 = t4.slice())[0] = t4[1] = 0, t4[2] = a5, t4[3] = n4;
          const [s5, r4] = Util2.singularValueDecompose2dScale(getCurrentTransform(this.ctx)), { viewportScale: o4 } = this, g4 = Math.ceil(a5 * this.outputScaleX * o4), c4 = Math.ceil(n4 * this.outputScaleY * o4);
          this.annotationCanvas = this.canvasFactory.create(g4, c4);
          const { canvas: h4, context: l4 } = this.annotationCanvas;
          this.annotationCanvasMap.set(e4, h4), this.annotationCanvas.savedCtx = this.ctx, this.ctx = l4, this.ctx.save(), this.ctx.setTransform(s5, 0, 0, -r4, 0, n4 * r4), resetCtxToDefault(this.ctx);
        } else resetCtxToDefault(this.ctx), this.ctx.rect(t4[0], t4[1], a5, n4), this.ctx.clip(), this.endPath();
      }
      this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...i4), this.transform(...a4);
    }
    endAnnotation() {
      this.annotationCanvas && (this.ctx.restore(), __privateMethod(this, _CanvasGraphics_instances, wA_fn).call(this), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
    }
    paintImageMaskXObject(e4) {
      if (!this.contentVisible) return;
      const t4 = e4.count;
      (e4 = this.getObject(e4.data, e4)).count = t4;
      const i4 = this.ctx, a4 = this.processingType3;
      if (a4 && (void 0 === a4.compiled && (a4.compiled = function(e5) {
        const { width: t5, height: i5 } = e5;
        if (t5 > 1e3 || i5 > 1e3) return null;
        const a5 = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), s5 = t5 + 1;
        let n5, r4, o4, g4 = new Uint8Array(s5 * (i5 + 1));
        const c4 = t5 + 7 & -8;
        let h4 = new Uint8Array(c4 * i5), l4 = 0;
        for (const t6 of e5.data) {
          let e6 = 128;
          for (; e6 > 0; ) h4[l4++] = t6 & e6 ? 0 : 255, e6 >>= 1;
        }
        let C4 = 0;
        for (l4 = 0, 0 !== h4[l4] && (g4[0] = 1, ++C4), r4 = 1; r4 < t5; r4++) h4[l4] !== h4[l4 + 1] && (g4[r4] = h4[l4] ? 2 : 1, ++C4), l4++;
        for (0 !== h4[l4] && (g4[r4] = 2, ++C4), n5 = 1; n5 < i5; n5++) {
          l4 = n5 * c4, o4 = n5 * s5, h4[l4 - c4] !== h4[l4] && (g4[o4] = h4[l4] ? 1 : 8, ++C4);
          let e6 = (h4[l4] ? 4 : 0) + (h4[l4 - c4] ? 8 : 0);
          for (r4 = 1; r4 < t5; r4++) e6 = (e6 >> 2) + (h4[l4 + 1] ? 4 : 0) + (h4[l4 - c4 + 1] ? 8 : 0), a5[e6] && (g4[o4 + r4] = a5[e6], ++C4), l4++;
          if (h4[l4 - c4] !== h4[l4] && (g4[o4 + r4] = h4[l4] ? 2 : 4, ++C4), C4 > 1e3) return null;
        }
        for (l4 = c4 * (i5 - 1), o4 = n5 * s5, 0 !== h4[l4] && (g4[o4] = 8, ++C4), r4 = 1; r4 < t5; r4++) h4[l4] !== h4[l4 + 1] && (g4[o4 + r4] = h4[l4] ? 4 : 8, ++C4), l4++;
        if (0 !== h4[l4] && (g4[o4 + r4] = 4, ++C4), C4 > 1e3) return null;
        const d4 = new Int32Array([0, s5, -1, 0, -s5, 0, 0, 0, 1]), u4 = new Path2D();
        for (n5 = 0; C4 && n5 <= i5; n5++) {
          let e6 = n5 * s5;
          const i6 = e6 + t5;
          for (; e6 < i6 && !g4[e6]; ) e6++;
          if (e6 === i6) continue;
          u4.moveTo(e6 % s5, n5);
          const a6 = e6;
          let r5 = g4[e6];
          do {
            const t6 = d4[r5];
            do {
              e6 += t6;
            } while (!g4[e6]);
            const i7 = g4[e6];
            5 !== i7 && 10 !== i7 ? (r5 = i7, g4[e6] = 0) : (r5 = i7 & 51 * r5 >> 4, g4[e6] &= r5 >> 2 | r5 << 2), u4.lineTo(e6 % s5, e6 / s5 | 0), g4[e6] || --C4;
          } while (a6 !== e6);
          --n5;
        }
        return h4 = null, g4 = null, function(e6) {
          e6.save(), e6.scale(1 / t5, -1 / i5), e6.translate(0, -i5), e6.fill(u4), e6.beginPath(), e6.restore();
        };
      }(e4)), a4.compiled)) return void a4.compiled(i4);
      const s4 = this._createMaskCanvas(e4), n4 = s4.canvas;
      i4.save(), i4.setTransform(1, 0, 0, 1, 0, 0), i4.drawImage(n4, s4.offsetX, s4.offsetY), i4.restore(), this.compose();
    }
    paintImageMaskXObjectRepeat(e4, t4, i4 = 0, a4 = 0, s4, n4) {
      if (!this.contentVisible) return;
      e4 = this.getObject(e4.data, e4);
      const r4 = this.ctx;
      r4.save();
      const o4 = getCurrentTransform(r4);
      r4.transform(t4, i4, a4, s4, 0, 0);
      const g4 = this._createMaskCanvas(e4);
      r4.setTransform(1, 0, 0, 1, g4.offsetX - o4[4], g4.offsetY - o4[5]);
      for (let e5 = 0, c4 = n4.length; e5 < c4; e5 += 2) {
        const c5 = Util2.transform(o4, [t4, i4, a4, s4, n4[e5], n4[e5 + 1]]), [h4, l4] = Util2.applyTransform([0, 0], c5);
        r4.drawImage(g4.canvas, h4, l4);
      }
      r4.restore(), this.compose();
    }
    paintImageMaskXObjectGroup(e4) {
      if (!this.contentVisible) return;
      const t4 = this.ctx, i4 = this.current.fillColor, a4 = this.current.patternFill;
      for (const s4 of e4) {
        const { data: e5, width: n4, height: r4, transform: o4 } = s4, g4 = this.cachedCanvases.getCanvas("maskCanvas", n4, r4), c4 = g4.context;
        c4.save();
        putBinaryImageMask(c4, this.getObject(e5, s4)), c4.globalCompositeOperation = "source-in", c4.fillStyle = a4 ? i4.getPattern(c4, this, getCurrentTransformInverse(t4), De3) : i4, c4.fillRect(0, 0, n4, r4), c4.restore(), t4.save(), t4.transform(...o4), t4.scale(1, -1), drawImageAtIntegerCoords(t4, g4.canvas, 0, 0, n4, r4, 0, -1, 1, 1), t4.restore();
      }
      this.compose();
    }
    paintImageXObject(e4) {
      if (!this.contentVisible) return;
      const t4 = this.getObject(e4);
      t4 ? this.paintInlineImageXObject(t4) : warn2("Dependent image isn't ready yet");
    }
    paintImageXObjectRepeat(e4, t4, i4, a4) {
      if (!this.contentVisible) return;
      const s4 = this.getObject(e4);
      if (!s4) return void warn2("Dependent image isn't ready yet");
      const n4 = s4.width, r4 = s4.height, o4 = [];
      for (let e5 = 0, s5 = a4.length; e5 < s5; e5 += 2) o4.push({ transform: [t4, 0, 0, i4, a4[e5], a4[e5 + 1]], x: 0, y: 0, w: n4, h: r4 });
      this.paintInlineImageXObjectGroup(s4, o4);
    }
    applyTransferMapsToCanvas(e4) {
      return "none" !== this.current.transferMaps && (e4.filter = this.current.transferMaps, e4.drawImage(e4.canvas, 0, 0), e4.filter = "none"), e4.canvas;
    }
    applyTransferMapsToBitmap(e4) {
      if ("none" === this.current.transferMaps) return e4.bitmap;
      const { bitmap: t4, width: i4, height: a4 } = e4, s4 = this.cachedCanvases.getCanvas("inlineImage", i4, a4), n4 = s4.context;
      return n4.filter = this.current.transferMaps, n4.drawImage(t4, 0, 0), n4.filter = "none", s4.canvas;
    }
    paintInlineImageXObject(e4) {
      if (!this.contentVisible) return;
      const t4 = e4.width, a4 = e4.height, s4 = this.ctx;
      if (this.save(), !i3) {
        const { filter: e5 } = s4;
        "none" !== e5 && "" !== e5 && (s4.filter = "none");
      }
      let n4;
      if (s4.scale(1 / t4, -1 / a4), e4.bitmap) n4 = this.applyTransferMapsToBitmap(e4);
      else if ("function" == typeof HTMLElement && e4 instanceof HTMLElement || !e4.data) n4 = e4;
      else {
        const i4 = this.cachedCanvases.getCanvas("inlineImage", t4, a4).context;
        putBinaryImageData(i4, e4), n4 = this.applyTransferMapsToCanvas(i4);
      }
      const r4 = this._scaleImage(n4, getCurrentTransformInverse(s4));
      s4.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(s4), e4.interpolate), drawImageAtIntegerCoords(s4, r4.img, 0, 0, r4.paintWidth, r4.paintHeight, 0, -a4, t4, a4), this.compose(), this.restore();
    }
    paintInlineImageXObjectGroup(e4, t4) {
      if (!this.contentVisible) return;
      const i4 = this.ctx;
      let a4;
      if (e4.bitmap) a4 = e4.bitmap;
      else {
        const t5 = e4.width, i5 = e4.height, s4 = this.cachedCanvases.getCanvas("inlineImage", t5, i5).context;
        putBinaryImageData(s4, e4), a4 = this.applyTransferMapsToCanvas(s4);
      }
      for (const e5 of t4) i4.save(), i4.transform(...e5.transform), i4.scale(1, -1), drawImageAtIntegerCoords(i4, a4, e5.x, e5.y, e5.w, e5.h, 0, -1, 1, 1), i4.restore();
      this.compose();
    }
    paintSolidColorImageMask() {
      this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose());
    }
    markPoint(e4) {
    }
    markPointProps(e4, t4) {
    }
    beginMarkedContent(e4) {
      this.markedContentStack.push({ visible: true });
    }
    beginMarkedContentProps(e4, t4) {
      "OC" === e4 ? this.markedContentStack.push({ visible: this.optionalContentConfig.isVisible(t4) }) : this.markedContentStack.push({ visible: true }), this.contentVisible = this.isContentVisible();
    }
    endMarkedContent() {
      this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
    }
    beginCompat() {
    }
    endCompat() {
    }
    consumePath(e4) {
      const t4 = this.current.isEmptyClip();
      this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(e4);
      const i4 = this.ctx;
      this.pendingClip && (t4 || (this.pendingClip === ve3 ? i4.clip("evenodd") : i4.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), i4.beginPath();
    }
    getSinglePixelWidth() {
      if (!this._cachedGetSinglePixelWidth) {
        const e4 = getCurrentTransform(this.ctx);
        if (0 === e4[1] && 0 === e4[2]) this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(e4[0]), Math.abs(e4[3]));
        else {
          const t4 = Math.abs(e4[0] * e4[3] - e4[2] * e4[1]), i4 = Math.hypot(e4[0], e4[2]), a4 = Math.hypot(e4[1], e4[3]);
          this._cachedGetSinglePixelWidth = Math.max(i4, a4) / t4;
        }
      }
      return this._cachedGetSinglePixelWidth;
    }
    getScaleForStroking() {
      if (-1 === this._cachedScaleForStroking[0]) {
        const { lineWidth: e4 } = this.current, { a: t4, b: i4, c: a4, d: s4 } = this.ctx.getTransform();
        let n4, r4;
        if (0 === i4 && 0 === a4) {
          const i5 = Math.abs(t4), a5 = Math.abs(s4);
          if (i5 === a5) if (0 === e4) n4 = r4 = 1 / i5;
          else {
            const t5 = i5 * e4;
            n4 = r4 = t5 < 1 ? 1 / t5 : 1;
          }
          else if (0 === e4) n4 = 1 / i5, r4 = 1 / a5;
          else {
            const t5 = i5 * e4, s5 = a5 * e4;
            n4 = t5 < 1 ? 1 / t5 : 1, r4 = s5 < 1 ? 1 / s5 : 1;
          }
        } else {
          const o4 = Math.abs(t4 * s4 - i4 * a4), g4 = Math.hypot(t4, i4), c4 = Math.hypot(a4, s4);
          if (0 === e4) n4 = c4 / o4, r4 = g4 / o4;
          else {
            const t5 = e4 * o4;
            n4 = c4 > t5 ? c4 / t5 : 1, r4 = g4 > t5 ? g4 / t5 : 1;
          }
        }
        this._cachedScaleForStroking[0] = n4, this._cachedScaleForStroking[1] = r4;
      }
      return this._cachedScaleForStroking;
    }
    rescaleAndStroke(e4) {
      const { ctx: t4 } = this, { lineWidth: i4 } = this.current, [a4, s4] = this.getScaleForStroking();
      if (t4.lineWidth = i4 || 1, 1 === a4 && 1 === s4) return void t4.stroke();
      const n4 = t4.getLineDash();
      if (e4 && t4.save(), t4.scale(a4, s4), n4.length > 0) {
        const e5 = Math.max(a4, s4);
        t4.setLineDash(n4.map((t5) => t5 / e5)), t4.lineDashOffset /= e5;
      }
      t4.stroke(), e4 && t4.restore();
    }
    isContentVisible() {
      for (let e4 = this.markedContentStack.length - 1; e4 >= 0; e4--) if (!this.markedContentStack[e4].visible) return false;
      return true;
    }
  };
  _CanvasGraphics_instances = new WeakSet();
  yA_fn = function() {
    for (; this.stateStack.length || this.inSMaskMode; ) this.restore();
    this.current.activeSMask = null, this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
  };
  wA_fn = function() {
    if (this.pageColors) {
      const e4 = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
      if ("none" !== e4) {
        const t4 = this.ctx.filter;
        this.ctx.filter = e4, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = t4;
      }
    }
  };
  let CanvasGraphics = _CanvasGraphics;
  for (const e4 in te3) void 0 !== CanvasGraphics.prototype[e4] && (CanvasGraphics.prototype[te3[e4]] = CanvasGraphics.prototype[e4]);
  class GlobalWorkerOptions {
    static get workerPort() {
      return __privateGet(this, _bA);
    }
    static set workerPort(e4) {
      if (!("undefined" != typeof Worker && e4 instanceof Worker) && null !== e4) throw new Error("Invalid `workerPort` type.");
      __privateSet(this, _bA, e4);
    }
    static get workerSrc() {
      return __privateGet(this, _DA);
    }
    static set workerSrc(e4) {
      if ("string" != typeof e4) throw new Error("Invalid `workerSrc` type.");
      __privateSet(this, _DA, e4);
    }
  }
  _bA = new WeakMap();
  _DA = new WeakMap();
  __privateAdd(GlobalWorkerOptions, _bA, null);
  __privateAdd(GlobalWorkerOptions, _DA, "");
  const Le3 = 1, Ue3 = 2, He3 = 1, Te3 = 2, Je3 = 3, Ye3 = 4, Pe3 = 5, Oe3 = 6, Ke3 = 7, qe3 = 8;
  function wrapReason2(e4) {
    switch (e4 instanceof Error || "object" == typeof e4 && null !== e4 || unreachable2('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), e4.name) {
      case "AbortException":
        return new AbortException2(e4.message);
      case "MissingPDFException":
        return new MissingPDFException2(e4.message);
      case "PasswordException":
        return new PasswordException2(e4.message, e4.code);
      case "UnexpectedResponseException":
        return new UnexpectedResponseException2(e4.message, e4.status);
      case "UnknownErrorException":
        return new UnknownErrorException2(e4.message, e4.details);
      default:
        return new UnknownErrorException2(e4.message, e4.toString());
    }
  }
  class MessageHandler2 {
    constructor(e4, t4, i4) {
      __privateAdd(this, _MessageHandler_instances2);
      this.sourceName = e4, this.targetName = t4, this.comObj = i4, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (e5) => {
        const t5 = e5.data;
        if (t5.targetName !== this.sourceName) return;
        if (t5.stream) return void __privateMethod(this, _MessageHandler_instances2, K_fn2).call(this, t5);
        if (t5.callback) {
          const e6 = t5.callbackId, i5 = this.callbackCapabilities[e6];
          if (!i5) throw new Error(`Cannot resolve callback ${e6}`);
          if (delete this.callbackCapabilities[e6], t5.callback === Le3) i5.resolve(t5.data);
          else {
            if (t5.callback !== Ue3) throw new Error("Unexpected callback case");
            i5.reject(wrapReason2(t5.reason));
          }
          return;
        }
        const a4 = this.actionHandler[t5.action];
        if (!a4) throw new Error(`Unknown action from worker: ${t5.action}`);
        if (t5.callbackId) {
          const e6 = this.sourceName, s4 = t5.sourceName;
          new Promise(function(e7) {
            e7(a4(t5.data));
          }).then(function(a5) {
            i4.postMessage({ sourceName: e6, targetName: s4, callback: Le3, callbackId: t5.callbackId, data: a5 });
          }, function(a5) {
            i4.postMessage({ sourceName: e6, targetName: s4, callback: Ue3, callbackId: t5.callbackId, reason: wrapReason2(a5) });
          });
        } else t5.streamId ? __privateMethod(this, _MessageHandler_instances2, q_fn2).call(this, t5) : a4(t5.data);
      }, i4.addEventListener("message", this._onComObjOnMessage);
    }
    on(e4, t4) {
      const i4 = this.actionHandler;
      if (i4[e4]) throw new Error(`There is already an actionName called "${e4}"`);
      i4[e4] = t4;
    }
    send(e4, t4, i4) {
      this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: e4, data: t4 }, i4);
    }
    sendWithPromise(e4, t4, i4) {
      const a4 = this.callbackId++, s4 = Promise.withResolvers();
      this.callbackCapabilities[a4] = s4;
      try {
        this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: e4, callbackId: a4, data: t4 }, i4);
      } catch (e5) {
        s4.reject(e5);
      }
      return s4.promise;
    }
    sendWithStream(e4, t4, i4, a4) {
      const s4 = this.streamId++, n4 = this.sourceName, r4 = this.targetName, o4 = this.comObj;
      return new ReadableStream({ start: (i5) => {
        const g4 = Promise.withResolvers();
        return this.streamControllers[s4] = { controller: i5, startCall: g4, pullCall: null, cancelCall: null, isClosed: false }, o4.postMessage({ sourceName: n4, targetName: r4, action: e4, streamId: s4, data: t4, desiredSize: i5.desiredSize }, a4), g4.promise;
      }, pull: (e5) => {
        const t5 = Promise.withResolvers();
        return this.streamControllers[s4].pullCall = t5, o4.postMessage({ sourceName: n4, targetName: r4, stream: Oe3, streamId: s4, desiredSize: e5.desiredSize }), t5.promise;
      }, cancel: (e5) => {
        assert2(e5 instanceof Error, "cancel must have a valid reason");
        const t5 = Promise.withResolvers();
        return this.streamControllers[s4].cancelCall = t5, this.streamControllers[s4].isClosed = true, o4.postMessage({ sourceName: n4, targetName: r4, stream: He3, streamId: s4, reason: wrapReason2(e5) }), t5.promise;
      } }, i4);
    }
    destroy() {
      this.comObj.removeEventListener("message", this._onComObjOnMessage);
    }
  }
  _MessageHandler_instances2 = new WeakSet();
  q_fn2 = function(e4) {
    const t4 = e4.streamId, i4 = this.sourceName, a4 = e4.sourceName, s4 = this.comObj, n4 = this, r4 = this.actionHandler[e4.action], o4 = { enqueue(e5, n5 = 1, r5) {
      if (this.isCancelled) return;
      const o5 = this.desiredSize;
      this.desiredSize -= n5, o5 > 0 && this.desiredSize <= 0 && (this.sinkCapability = Promise.withResolvers(), this.ready = this.sinkCapability.promise), s4.postMessage({ sourceName: i4, targetName: a4, stream: Ye3, streamId: t4, chunk: e5 }, r5);
    }, close() {
      this.isCancelled || (this.isCancelled = true, s4.postMessage({ sourceName: i4, targetName: a4, stream: Je3, streamId: t4 }), delete n4.streamSinks[t4]);
    }, error(e5) {
      assert2(e5 instanceof Error, "error must have a valid reason"), this.isCancelled || (this.isCancelled = true, s4.postMessage({ sourceName: i4, targetName: a4, stream: Pe3, streamId: t4, reason: wrapReason2(e5) }));
    }, sinkCapability: Promise.withResolvers(), onPull: null, onCancel: null, isCancelled: false, desiredSize: e4.desiredSize, ready: null };
    o4.sinkCapability.resolve(), o4.ready = o4.sinkCapability.promise, this.streamSinks[t4] = o4, new Promise(function(t5) {
      t5(r4(e4.data, o4));
    }).then(function() {
      s4.postMessage({ sourceName: i4, targetName: a4, stream: qe3, streamId: t4, success: true });
    }, function(e5) {
      s4.postMessage({ sourceName: i4, targetName: a4, stream: qe3, streamId: t4, reason: wrapReason2(e5) });
    });
  };
  K_fn2 = function(e4) {
    const t4 = e4.streamId, i4 = this.sourceName, a4 = e4.sourceName, s4 = this.comObj, n4 = this.streamControllers[t4], r4 = this.streamSinks[t4];
    switch (e4.stream) {
      case qe3:
        e4.success ? n4.startCall.resolve() : n4.startCall.reject(wrapReason2(e4.reason));
        break;
      case Ke3:
        e4.success ? n4.pullCall.resolve() : n4.pullCall.reject(wrapReason2(e4.reason));
        break;
      case Oe3:
        if (!r4) {
          s4.postMessage({ sourceName: i4, targetName: a4, stream: Ke3, streamId: t4, success: true });
          break;
        }
        r4.desiredSize <= 0 && e4.desiredSize > 0 && r4.sinkCapability.resolve(), r4.desiredSize = e4.desiredSize, new Promise(function(e5) {
          e5(r4.onPull?.());
        }).then(function() {
          s4.postMessage({ sourceName: i4, targetName: a4, stream: Ke3, streamId: t4, success: true });
        }, function(e5) {
          s4.postMessage({ sourceName: i4, targetName: a4, stream: Ke3, streamId: t4, reason: wrapReason2(e5) });
        });
        break;
      case Ye3:
        if (assert2(n4, "enqueue should have stream controller"), n4.isClosed) break;
        n4.controller.enqueue(e4.chunk);
        break;
      case Je3:
        if (assert2(n4, "close should have stream controller"), n4.isClosed) break;
        n4.isClosed = true, n4.controller.close(), __privateMethod(this, _MessageHandler_instances2, __fn2).call(this, n4, t4);
        break;
      case Pe3:
        assert2(n4, "error should have stream controller"), n4.controller.error(wrapReason2(e4.reason)), __privateMethod(this, _MessageHandler_instances2, __fn2).call(this, n4, t4);
        break;
      case Te3:
        e4.success ? n4.cancelCall.resolve() : n4.cancelCall.reject(wrapReason2(e4.reason)), __privateMethod(this, _MessageHandler_instances2, __fn2).call(this, n4, t4);
        break;
      case He3:
        if (!r4) break;
        new Promise(function(t5) {
          t5(r4.onCancel?.(wrapReason2(e4.reason)));
        }).then(function() {
          s4.postMessage({ sourceName: i4, targetName: a4, stream: Te3, streamId: t4, success: true });
        }, function(e5) {
          s4.postMessage({ sourceName: i4, targetName: a4, stream: Te3, streamId: t4, reason: wrapReason2(e5) });
        }), r4.sinkCapability.reject(wrapReason2(e4.reason)), r4.isCancelled = true, delete this.streamSinks[t4];
        break;
      default:
        throw new Error("Unexpected stream case");
    }
  };
  __fn2 = async function(e4, t4) {
    await Promise.allSettled([e4.startCall?.promise, e4.pullCall?.promise, e4.cancelCall?.promise]), delete this.streamControllers[t4];
  };
  class Metadata {
    constructor({ parsedData: e4, rawData: t4 }) {
      __privateAdd(this, _SA);
      __privateAdd(this, _FA);
      __privateSet(this, _SA, e4), __privateSet(this, _FA, t4);
    }
    getRaw() {
      return __privateGet(this, _FA);
    }
    get(e4) {
      return __privateGet(this, _SA).get(e4) ?? null;
    }
    getAll() {
      return objectFromMap(__privateGet(this, _SA));
    }
    has(e4) {
      return __privateGet(this, _SA).has(e4);
    }
  }
  _SA = new WeakMap();
  _FA = new WeakMap();
  const _e3 = Symbol("INTERNAL");
  class OptionalContentGroup {
    constructor(e4, { name: t4, intent: i4, usage: a4 }) {
      __privateAdd(this, _kA, false);
      __privateAdd(this, _RA, false);
      __privateAdd(this, _xA, false);
      __privateAdd(this, _NA, true);
      __privateSet(this, _kA, !!(e4 & o3)), __privateSet(this, _RA, !!(e4 & g3)), this.name = t4, this.intent = i4, this.usage = a4;
    }
    get visible() {
      if (__privateGet(this, _xA)) return __privateGet(this, _NA);
      if (!__privateGet(this, _NA)) return false;
      const { print: e4, view: t4 } = this.usage;
      return __privateGet(this, _kA) ? "OFF" !== t4?.viewState : !__privateGet(this, _RA) || "OFF" !== e4?.printState;
    }
    _setVisible(e4, t4, i4 = false) {
      e4 !== _e3 && unreachable2("Internal method `_setVisible` called."), __privateSet(this, _xA, i4), __privateSet(this, _NA, t4);
    }
  }
  _kA = new WeakMap();
  _RA = new WeakMap();
  _xA = new WeakMap();
  _NA = new WeakMap();
  class OptionalContentConfig {
    constructor(e4, t4 = o3) {
      __privateAdd(this, _OptionalContentConfig_instances);
      __privateAdd(this, _MA, null);
      __privateAdd(this, _GA, /* @__PURE__ */ new Map());
      __privateAdd(this, _vA, null);
      __privateAdd(this, _LA, null);
      if (this.renderingIntent = t4, this.name = null, this.creator = null, null !== e4) {
        this.name = e4.name, this.creator = e4.creator, __privateSet(this, _LA, e4.order);
        for (const i4 of e4.groups) __privateGet(this, _GA).set(i4.id, new OptionalContentGroup(t4, i4));
        if ("OFF" === e4.baseState) for (const e5 of __privateGet(this, _GA).values()) e5._setVisible(_e3, false);
        for (const t5 of e4.on) __privateGet(this, _GA).get(t5)._setVisible(_e3, true);
        for (const t5 of e4.off) __privateGet(this, _GA).get(t5)._setVisible(_e3, false);
        __privateSet(this, _vA, this.getHash());
      }
    }
    isVisible(e4) {
      if (0 === __privateGet(this, _GA).size) return true;
      if (!e4) return info2("Optional content group not defined."), true;
      if ("OCG" === e4.type) return __privateGet(this, _GA).has(e4.id) ? __privateGet(this, _GA).get(e4.id).visible : (warn2(`Optional content group not found: ${e4.id}`), true);
      if ("OCMD" === e4.type) {
        if (e4.expression) return __privateMethod(this, _OptionalContentConfig_instances, UA_fn).call(this, e4.expression);
        if (!e4.policy || "AnyOn" === e4.policy) {
          for (const t4 of e4.ids) {
            if (!__privateGet(this, _GA).has(t4)) return warn2(`Optional content group not found: ${t4}`), true;
            if (__privateGet(this, _GA).get(t4).visible) return true;
          }
          return false;
        }
        if ("AllOn" === e4.policy) {
          for (const t4 of e4.ids) {
            if (!__privateGet(this, _GA).has(t4)) return warn2(`Optional content group not found: ${t4}`), true;
            if (!__privateGet(this, _GA).get(t4).visible) return false;
          }
          return true;
        }
        if ("AnyOff" === e4.policy) {
          for (const t4 of e4.ids) {
            if (!__privateGet(this, _GA).has(t4)) return warn2(`Optional content group not found: ${t4}`), true;
            if (!__privateGet(this, _GA).get(t4).visible) return true;
          }
          return false;
        }
        if ("AllOff" === e4.policy) {
          for (const t4 of e4.ids) {
            if (!__privateGet(this, _GA).has(t4)) return warn2(`Optional content group not found: ${t4}`), true;
            if (__privateGet(this, _GA).get(t4).visible) return false;
          }
          return true;
        }
        return warn2(`Unknown optional content policy ${e4.policy}.`), true;
      }
      return warn2(`Unknown group type ${e4.type}.`), true;
    }
    setVisibility(e4, t4 = true) {
      const i4 = __privateGet(this, _GA).get(e4);
      i4 ? (i4._setVisible(_e3, !!t4, true), __privateSet(this, _MA, null)) : warn2(`Optional content group not found: ${e4}`);
    }
    setOCGState({ state: e4, preserveRB: t4 }) {
      let i4;
      for (const t5 of e4) {
        switch (t5) {
          case "ON":
          case "OFF":
          case "Toggle":
            i4 = t5;
            continue;
        }
        const e5 = __privateGet(this, _GA).get(t5);
        if (e5) switch (i4) {
          case "ON":
            e5._setVisible(_e3, true);
            break;
          case "OFF":
            e5._setVisible(_e3, false);
            break;
          case "Toggle":
            e5._setVisible(_e3, !e5.visible);
        }
      }
      __privateSet(this, _MA, null);
    }
    get hasInitialVisibility() {
      return null === __privateGet(this, _vA) || this.getHash() === __privateGet(this, _vA);
    }
    getOrder() {
      return __privateGet(this, _GA).size ? __privateGet(this, _LA) ? __privateGet(this, _LA).slice() : [...__privateGet(this, _GA).keys()] : null;
    }
    getGroups() {
      return __privateGet(this, _GA).size > 0 ? objectFromMap(__privateGet(this, _GA)) : null;
    }
    getGroup(e4) {
      return __privateGet(this, _GA).get(e4) || null;
    }
    getHash() {
      if (null !== __privateGet(this, _MA)) return __privateGet(this, _MA);
      const e4 = new MurmurHash3_642();
      for (const [t4, i4] of __privateGet(this, _GA)) e4.update(`${t4}:${i4.visible}`);
      return __privateSet(this, _MA, e4.hexdigest());
    }
  }
  _MA = new WeakMap();
  _GA = new WeakMap();
  _vA = new WeakMap();
  _LA = new WeakMap();
  _OptionalContentConfig_instances = new WeakSet();
  UA_fn = function(e4) {
    const t4 = e4.length;
    if (t4 < 2) return true;
    const i4 = e4[0];
    for (let a4 = 1; a4 < t4; a4++) {
      const t5 = e4[a4];
      let s4;
      if (Array.isArray(t5)) s4 = __privateMethod(this, _OptionalContentConfig_instances, UA_fn).call(this, t5);
      else {
        if (!__privateGet(this, _GA).has(t5)) return warn2(`Optional content group not found: ${t5}`), true;
        s4 = __privateGet(this, _GA).get(t5).visible;
      }
      switch (i4) {
        case "And":
          if (!s4) return false;
          break;
        case "Or":
          if (s4) return true;
          break;
        case "Not":
          return !s4;
        default:
          return true;
      }
    }
    return "And" === i4;
  };
  class PDFDataTransportStream {
    constructor(e4, { disableRange: t4 = false, disableStream: i4 = false }) {
      assert2(e4, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
      const { length: a4, initialData: s4, progressiveDone: n4, contentDispositionFilename: r4 } = e4;
      if (this._queuedChunks = [], this._progressiveDone = n4, this._contentDispositionFilename = r4, s4?.length > 0) {
        const e5 = s4 instanceof Uint8Array && s4.byteLength === s4.buffer.byteLength ? s4.buffer : new Uint8Array(s4).buffer;
        this._queuedChunks.push(e5);
      }
      this._pdfDataRangeTransport = e4, this._isStreamingSupported = !i4, this._isRangeSupported = !t4, this._contentLength = a4, this._fullRequestReader = null, this._rangeReaders = [], e4.addRangeListener((e5, t5) => {
        this._onReceiveData({ begin: e5, chunk: t5 });
      }), e4.addProgressListener((e5, t5) => {
        this._onProgress({ loaded: e5, total: t5 });
      }), e4.addProgressiveReadListener((e5) => {
        this._onReceiveData({ chunk: e5 });
      }), e4.addProgressiveDoneListener(() => {
        this._onProgressiveDone();
      }), e4.transportReady();
    }
    _onReceiveData({ begin: e4, chunk: t4 }) {
      const i4 = t4 instanceof Uint8Array && t4.byteLength === t4.buffer.byteLength ? t4.buffer : new Uint8Array(t4).buffer;
      if (void 0 === e4) this._fullRequestReader ? this._fullRequestReader._enqueue(i4) : this._queuedChunks.push(i4);
      else {
        assert2(this._rangeReaders.some(function(t5) {
          return t5._begin === e4 && (t5._enqueue(i4), true);
        }), "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
      }
    }
    get _progressiveDataLength() {
      return this._fullRequestReader?._loaded ?? 0;
    }
    _onProgress(e4) {
      void 0 === e4.total ? this._rangeReaders[0]?.onProgress?.({ loaded: e4.loaded }) : this._fullRequestReader?.onProgress?.({ loaded: e4.loaded, total: e4.total });
    }
    _onProgressiveDone() {
      this._fullRequestReader?.progressiveDone(), this._progressiveDone = true;
    }
    _removeRangeReader(e4) {
      const t4 = this._rangeReaders.indexOf(e4);
      t4 >= 0 && this._rangeReaders.splice(t4, 1);
    }
    getFullReader() {
      assert2(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
      const e4 = this._queuedChunks;
      return this._queuedChunks = null, new PDFDataTransportStreamReader(this, e4, this._progressiveDone, this._contentDispositionFilename);
    }
    getRangeReader(e4, t4) {
      if (t4 <= this._progressiveDataLength) return null;
      const i4 = new PDFDataTransportStreamRangeReader(this, e4, t4);
      return this._pdfDataRangeTransport.requestDataRange(e4, t4), this._rangeReaders.push(i4), i4;
    }
    cancelAllRequests(e4) {
      this._fullRequestReader?.cancel(e4);
      for (const t4 of this._rangeReaders.slice(0)) t4.cancel(e4);
      this._pdfDataRangeTransport.abort();
    }
  }
  class PDFDataTransportStreamReader {
    constructor(e4, t4, i4 = false, a4 = null) {
      this._stream = e4, this._done = i4 || false, this._filename = isPdfFile(a4) ? a4 : null, this._queuedChunks = t4 || [], this._loaded = 0;
      for (const e5 of this._queuedChunks) this._loaded += e5.byteLength;
      this._requests = [], this._headersReady = Promise.resolve(), e4._fullRequestReader = this, this.onProgress = null;
    }
    _enqueue(e4) {
      if (!this._done) {
        if (this._requests.length > 0) {
          this._requests.shift().resolve({ value: e4, done: false });
        } else this._queuedChunks.push(e4);
        this._loaded += e4.byteLength;
      }
    }
    get headersReady() {
      return this._headersReady;
    }
    get filename() {
      return this._filename;
    }
    get isRangeSupported() {
      return this._stream._isRangeSupported;
    }
    get isStreamingSupported() {
      return this._stream._isStreamingSupported;
    }
    get contentLength() {
      return this._stream._contentLength;
    }
    async read() {
      if (this._queuedChunks.length > 0) {
        return { value: this._queuedChunks.shift(), done: false };
      }
      if (this._done) return { value: void 0, done: true };
      const e4 = Promise.withResolvers();
      return this._requests.push(e4), e4.promise;
    }
    cancel(e4) {
      this._done = true;
      for (const e5 of this._requests) e5.resolve({ value: void 0, done: true });
      this._requests.length = 0;
    }
    progressiveDone() {
      this._done || (this._done = true);
    }
  }
  class PDFDataTransportStreamRangeReader {
    constructor(e4, t4, i4) {
      this._stream = e4, this._begin = t4, this._end = i4, this._queuedChunk = null, this._requests = [], this._done = false, this.onProgress = null;
    }
    _enqueue(e4) {
      if (!this._done) {
        if (0 === this._requests.length) this._queuedChunk = e4;
        else {
          this._requests.shift().resolve({ value: e4, done: false });
          for (const e5 of this._requests) e5.resolve({ value: void 0, done: true });
          this._requests.length = 0;
        }
        this._done = true, this._stream._removeRangeReader(this);
      }
    }
    get isStreamingSupported() {
      return false;
    }
    async read() {
      if (this._queuedChunk) {
        const e5 = this._queuedChunk;
        return this._queuedChunk = null, { value: e5, done: false };
      }
      if (this._done) return { value: void 0, done: true };
      const e4 = Promise.withResolvers();
      return this._requests.push(e4), e4.promise;
    }
    cancel(e4) {
      this._done = true;
      for (const e5 of this._requests) e5.resolve({ value: void 0, done: true });
      this._requests.length = 0, this._stream._removeRangeReader(this);
    }
  }
  function validateRangeRequestCapabilities({ getResponseHeader: e4, isHttp: t4, rangeChunkSize: i4, disableRange: a4 }) {
    const s4 = { allowRangeRequests: false, suggestedLength: void 0 }, n4 = parseInt(e4("Content-Length"), 10);
    if (!Number.isInteger(n4)) return s4;
    if (s4.suggestedLength = n4, n4 <= 2 * i4) return s4;
    if (a4 || !t4) return s4;
    if ("bytes" !== e4("Accept-Ranges")) return s4;
    return "identity" !== (e4("Content-Encoding") || "identity") || (s4.allowRangeRequests = true), s4;
  }
  function extractFilenameFromHeader(e4) {
    const t4 = e4("Content-Disposition");
    if (t4) {
      let e5 = function(e6) {
        let t5 = true, i4 = toParamRegExp("filename\\*", "i").exec(e6);
        if (i4) {
          i4 = i4[1];
          let e7 = rfc2616unquote(i4);
          return e7 = unescape(e7), e7 = rfc5987decode(e7), e7 = rfc2047decode(e7), fixupEncoding(e7);
        }
        if (i4 = function(e7) {
          const t6 = [];
          let i5;
          const a4 = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
          for (; null !== (i5 = a4.exec(e7)); ) {
            let [, e8, a5, s5] = i5;
            if (e8 = parseInt(e8, 10), e8 in t6) {
              if (0 === e8) break;
            } else t6[e8] = [a5, s5];
          }
          const s4 = [];
          for (let e8 = 0; e8 < t6.length && e8 in t6; ++e8) {
            let [i6, a5] = t6[e8];
            a5 = rfc2616unquote(a5), i6 && (a5 = unescape(a5), 0 === e8 && (a5 = rfc5987decode(a5))), s4.push(a5);
          }
          return s4.join("");
        }(e6), i4) return fixupEncoding(rfc2047decode(i4));
        if (i4 = toParamRegExp("filename", "i").exec(e6), i4) {
          i4 = i4[1];
          let e7 = rfc2616unquote(i4);
          return e7 = rfc2047decode(e7), fixupEncoding(e7);
        }
        function toParamRegExp(e7, t6) {
          return new RegExp("(?:^|;)\\s*" + e7 + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', t6);
        }
        function textdecode(e7, i5) {
          if (e7) {
            if (!/^[\x00-\xFF]+$/.test(i5)) return i5;
            try {
              const a4 = new TextDecoder(e7, { fatal: true }), s4 = stringToBytes2(i5);
              i5 = a4.decode(s4), t5 = false;
            } catch {
            }
          }
          return i5;
        }
        function fixupEncoding(e7) {
          return t5 && /[\x80-\xff]/.test(e7) && (e7 = textdecode("utf-8", e7), t5 && (e7 = textdecode("iso-8859-1", e7))), e7;
        }
        function rfc2616unquote(e7) {
          if (e7.startsWith('"')) {
            const t6 = e7.slice(1).split('\\"');
            for (let e8 = 0; e8 < t6.length; ++e8) {
              const i5 = t6[e8].indexOf('"');
              -1 !== i5 && (t6[e8] = t6[e8].slice(0, i5), t6.length = e8 + 1), t6[e8] = t6[e8].replaceAll(/\\(.)/g, "$1");
            }
            e7 = t6.join('"');
          }
          return e7;
        }
        function rfc5987decode(e7) {
          const t6 = e7.indexOf("'");
          return -1 === t6 ? e7 : textdecode(e7.slice(0, t6), e7.slice(t6 + 1).replace(/^[^']*'/, ""));
        }
        function rfc2047decode(e7) {
          return !e7.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(e7) ? e7 : e7.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(e8, t6, i5, a4) {
            if ("q" === i5 || "Q" === i5) return textdecode(t6, a4 = (a4 = a4.replaceAll("_", " ")).replaceAll(/=([0-9a-fA-F]{2})/g, function(e9, t7) {
              return String.fromCharCode(parseInt(t7, 16));
            }));
            try {
              a4 = atob(a4);
            } catch {
            }
            return textdecode(t6, a4);
          });
        }
        return "";
      }(t4);
      if (e5.includes("%")) try {
        e5 = decodeURIComponent(e5);
      } catch {
      }
      if (isPdfFile(e5)) return e5;
    }
    return null;
  }
  function createResponseStatusError(e4, t4) {
    return 404 === e4 || 0 === e4 && t4.startsWith("file:") ? new MissingPDFException2('Missing PDF "' + t4 + '".') : new UnexpectedResponseException2(`Unexpected server response (${e4}) while retrieving PDF "${t4}".`, e4);
  }
  function validateResponseStatus(e4) {
    return 200 === e4 || 206 === e4;
  }
  function createFetchOptions(e4, t4, i4) {
    return { method: "GET", headers: e4, signal: i4.signal, mode: "cors", credentials: t4 ? "include" : "same-origin", redirect: "follow" };
  }
  function createHeaders(e4) {
    const t4 = new Headers();
    for (const i4 in e4) {
      const a4 = e4[i4];
      void 0 !== a4 && t4.append(i4, a4);
    }
    return t4;
  }
  function getArrayBuffer(e4) {
    return e4 instanceof Uint8Array ? e4.buffer : e4 instanceof ArrayBuffer ? e4 : (warn2(`getArrayBuffer - unexpected data format: ${e4}`), new Uint8Array(e4).buffer);
  }
  class PDFFetchStream {
    constructor(e4) {
      this.source = e4, this.isHttp = /^https?:/i.test(e4.url), this.httpHeaders = this.isHttp && e4.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
    }
    get _progressiveDataLength() {
      return this._fullRequestReader?._loaded ?? 0;
    }
    getFullReader() {
      return assert2(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new PDFFetchStreamReader(this), this._fullRequestReader;
    }
    getRangeReader(e4, t4) {
      if (t4 <= this._progressiveDataLength) return null;
      const i4 = new PDFFetchStreamRangeReader(this, e4, t4);
      return this._rangeRequestReaders.push(i4), i4;
    }
    cancelAllRequests(e4) {
      this._fullRequestReader?.cancel(e4);
      for (const t4 of this._rangeRequestReaders.slice(0)) t4.cancel(e4);
    }
  }
  class PDFFetchStreamReader {
    constructor(e4) {
      this._stream = e4, this._reader = null, this._loaded = 0, this._filename = null;
      const t4 = e4.source;
      this._withCredentials = t4.withCredentials || false, this._contentLength = t4.length, this._headersCapability = Promise.withResolvers(), this._disableRange = t4.disableRange || false, this._rangeChunkSize = t4.rangeChunkSize, this._rangeChunkSize || this._disableRange || (this._disableRange = true), this._abortController = new AbortController(), this._isStreamingSupported = !t4.disableStream, this._isRangeSupported = !t4.disableRange, this._headers = createHeaders(this._stream.httpHeaders);
      const i4 = t4.url;
      fetch(i4, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((e5) => {
        if (!validateResponseStatus(e5.status)) throw createResponseStatusError(e5.status, i4);
        this._reader = e5.body.getReader(), this._headersCapability.resolve();
        const getResponseHeader = (t6) => e5.headers.get(t6), { allowRangeRequests: t5, suggestedLength: a4 } = validateRangeRequestCapabilities({ getResponseHeader, isHttp: this._stream.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange });
        this._isRangeSupported = t5, this._contentLength = a4 || this._contentLength, this._filename = extractFilenameFromHeader(getResponseHeader), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new AbortException2("Streaming is disabled."));
      }).catch(this._headersCapability.reject), this.onProgress = null;
    }
    get headersReady() {
      return this._headersCapability.promise;
    }
    get filename() {
      return this._filename;
    }
    get contentLength() {
      return this._contentLength;
    }
    get isRangeSupported() {
      return this._isRangeSupported;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    async read() {
      await this._headersCapability.promise;
      const { value: e4, done: t4 } = await this._reader.read();
      return t4 ? { value: e4, done: t4 } : (this._loaded += e4.byteLength, this.onProgress?.({ loaded: this._loaded, total: this._contentLength }), { value: getArrayBuffer(e4), done: false });
    }
    cancel(e4) {
      this._reader?.cancel(e4), this._abortController.abort();
    }
  }
  class PDFFetchStreamRangeReader {
    constructor(e4, t4, i4) {
      this._stream = e4, this._reader = null, this._loaded = 0;
      const a4 = e4.source;
      this._withCredentials = a4.withCredentials || false, this._readCapability = Promise.withResolvers(), this._isStreamingSupported = !a4.disableStream, this._abortController = new AbortController(), this._headers = createHeaders(this._stream.httpHeaders), this._headers.append("Range", `bytes=${t4}-${i4 - 1}`);
      const s4 = a4.url;
      fetch(s4, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((e5) => {
        if (!validateResponseStatus(e5.status)) throw createResponseStatusError(e5.status, s4);
        this._readCapability.resolve(), this._reader = e5.body.getReader();
      }).catch(this._readCapability.reject), this.onProgress = null;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    async read() {
      await this._readCapability.promise;
      const { value: e4, done: t4 } = await this._reader.read();
      return t4 ? { value: e4, done: t4 } : (this._loaded += e4.byteLength, this.onProgress?.({ loaded: this._loaded }), { value: getArrayBuffer(e4), done: false });
    }
    cancel(e4) {
      this._reader?.cancel(e4), this._abortController.abort();
    }
  }
  class NetworkManager {
    constructor(e4, t4 = {}) {
      this.url = e4, this.isHttp = /^https?:/i.test(e4), this.httpHeaders = this.isHttp && t4.httpHeaders || /* @__PURE__ */ Object.create(null), this.withCredentials = t4.withCredentials || false, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
    }
    requestRange(e4, t4, i4) {
      const a4 = { begin: e4, end: t4 };
      for (const e5 in i4) a4[e5] = i4[e5];
      return this.request(a4);
    }
    requestFull(e4) {
      return this.request(e4);
    }
    request(e4) {
      const t4 = new XMLHttpRequest(), i4 = this.currXhrId++, a4 = this.pendingRequests[i4] = { xhr: t4 };
      t4.open("GET", this.url), t4.withCredentials = this.withCredentials;
      for (const e5 in this.httpHeaders) {
        const i5 = this.httpHeaders[e5];
        void 0 !== i5 && t4.setRequestHeader(e5, i5);
      }
      return this.isHttp && "begin" in e4 && "end" in e4 ? (t4.setRequestHeader("Range", `bytes=${e4.begin}-${e4.end - 1}`), a4.expectedStatus = 206) : a4.expectedStatus = 200, t4.responseType = "arraybuffer", e4.onError && (t4.onerror = function(i5) {
        e4.onError(t4.status);
      }), t4.onreadystatechange = this.onStateChange.bind(this, i4), t4.onprogress = this.onProgress.bind(this, i4), a4.onHeadersReceived = e4.onHeadersReceived, a4.onDone = e4.onDone, a4.onError = e4.onError, a4.onProgress = e4.onProgress, t4.send(null), i4;
    }
    onProgress(e4, t4) {
      const i4 = this.pendingRequests[e4];
      i4 && i4.onProgress?.(t4);
    }
    onStateChange(e4, t4) {
      const i4 = this.pendingRequests[e4];
      if (!i4) return;
      const a4 = i4.xhr;
      if (a4.readyState >= 2 && i4.onHeadersReceived && (i4.onHeadersReceived(), delete i4.onHeadersReceived), 4 !== a4.readyState) return;
      if (!(e4 in this.pendingRequests)) return;
      if (delete this.pendingRequests[e4], 0 === a4.status && this.isHttp) return void i4.onError?.(a4.status);
      const s4 = a4.status || 200;
      if (!(200 === s4 && 206 === i4.expectedStatus) && s4 !== i4.expectedStatus) return void i4.onError?.(a4.status);
      const n4 = function(e5) {
        const t5 = e5.response;
        return "string" != typeof t5 ? t5 : stringToBytes2(t5).buffer;
      }(a4);
      if (206 === s4) {
        const e5 = a4.getResponseHeader("Content-Range"), t5 = /bytes (\d+)-(\d+)\/(\d+)/.exec(e5);
        i4.onDone({ begin: parseInt(t5[1], 10), chunk: n4 });
      } else n4 ? i4.onDone({ begin: 0, chunk: n4 }) : i4.onError?.(a4.status);
    }
    getRequestXhr(e4) {
      return this.pendingRequests[e4].xhr;
    }
    isPendingRequest(e4) {
      return e4 in this.pendingRequests;
    }
    abortRequest(e4) {
      const t4 = this.pendingRequests[e4].xhr;
      delete this.pendingRequests[e4], t4.abort();
    }
  }
  class PDFNetworkStream {
    constructor(e4) {
      this._source = e4, this._manager = new NetworkManager(e4.url, { httpHeaders: e4.httpHeaders, withCredentials: e4.withCredentials }), this._rangeChunkSize = e4.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
    }
    _onRangeRequestReaderClosed(e4) {
      const t4 = this._rangeRequestReaders.indexOf(e4);
      t4 >= 0 && this._rangeRequestReaders.splice(t4, 1);
    }
    getFullReader() {
      return assert2(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source), this._fullRequestReader;
    }
    getRangeReader(e4, t4) {
      const i4 = new PDFNetworkStreamRangeRequestReader(this._manager, e4, t4);
      return i4.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(i4), i4;
    }
    cancelAllRequests(e4) {
      this._fullRequestReader?.cancel(e4);
      for (const t4 of this._rangeRequestReaders.slice(0)) t4.cancel(e4);
    }
  }
  class PDFNetworkStreamFullRequestReader {
    constructor(e4, t4) {
      this._manager = e4;
      const i4 = { onHeadersReceived: this._onHeadersReceived.bind(this), onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) };
      this._url = t4.url, this._fullRequestId = e4.requestFull(i4), this._headersReceivedCapability = Promise.withResolvers(), this._disableRange = t4.disableRange || false, this._contentLength = t4.length, this._rangeChunkSize = t4.rangeChunkSize, this._rangeChunkSize || this._disableRange || (this._disableRange = true), this._isStreamingSupported = false, this._isRangeSupported = false, this._cachedChunks = [], this._requests = [], this._done = false, this._storedError = void 0, this._filename = null, this.onProgress = null;
    }
    _onHeadersReceived() {
      const e4 = this._fullRequestId, t4 = this._manager.getRequestXhr(e4), getResponseHeader = (e5) => t4.getResponseHeader(e5), { allowRangeRequests: i4, suggestedLength: a4 } = validateRangeRequestCapabilities({ getResponseHeader, isHttp: this._manager.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange });
      i4 && (this._isRangeSupported = true), this._contentLength = a4 || this._contentLength, this._filename = extractFilenameFromHeader(getResponseHeader), this._isRangeSupported && this._manager.abortRequest(e4), this._headersReceivedCapability.resolve();
    }
    _onDone(e4) {
      if (e4) if (this._requests.length > 0) {
        this._requests.shift().resolve({ value: e4.chunk, done: false });
      } else this._cachedChunks.push(e4.chunk);
      if (this._done = true, !(this._cachedChunks.length > 0)) {
        for (const e5 of this._requests) e5.resolve({ value: void 0, done: true });
        this._requests.length = 0;
      }
    }
    _onError(e4) {
      this._storedError = createResponseStatusError(e4, this._url), this._headersReceivedCapability.reject(this._storedError);
      for (const e5 of this._requests) e5.reject(this._storedError);
      this._requests.length = 0, this._cachedChunks.length = 0;
    }
    _onProgress(e4) {
      this.onProgress?.({ loaded: e4.loaded, total: e4.lengthComputable ? e4.total : this._contentLength });
    }
    get filename() {
      return this._filename;
    }
    get isRangeSupported() {
      return this._isRangeSupported;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    get contentLength() {
      return this._contentLength;
    }
    get headersReady() {
      return this._headersReceivedCapability.promise;
    }
    async read() {
      if (this._storedError) throw this._storedError;
      if (this._cachedChunks.length > 0) {
        return { value: this._cachedChunks.shift(), done: false };
      }
      if (this._done) return { value: void 0, done: true };
      const e4 = Promise.withResolvers();
      return this._requests.push(e4), e4.promise;
    }
    cancel(e4) {
      this._done = true, this._headersReceivedCapability.reject(e4);
      for (const e5 of this._requests) e5.resolve({ value: void 0, done: true });
      this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
    }
  }
  class PDFNetworkStreamRangeRequestReader {
    constructor(e4, t4, i4) {
      this._manager = e4;
      const a4 = { onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) };
      this._url = e4.url, this._requestId = e4.requestRange(t4, i4, a4), this._requests = [], this._queuedChunk = null, this._done = false, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
    }
    _close() {
      this.onClosed?.(this);
    }
    _onDone(e4) {
      const t4 = e4.chunk;
      if (this._requests.length > 0) {
        this._requests.shift().resolve({ value: t4, done: false });
      } else this._queuedChunk = t4;
      this._done = true;
      for (const e5 of this._requests) e5.resolve({ value: void 0, done: true });
      this._requests.length = 0, this._close();
    }
    _onError(e4) {
      this._storedError = createResponseStatusError(e4, this._url);
      for (const e5 of this._requests) e5.reject(this._storedError);
      this._requests.length = 0, this._queuedChunk = null;
    }
    _onProgress(e4) {
      this.isStreamingSupported || this.onProgress?.({ loaded: e4.loaded });
    }
    get isStreamingSupported() {
      return false;
    }
    async read() {
      if (this._storedError) throw this._storedError;
      if (null !== this._queuedChunk) {
        const e5 = this._queuedChunk;
        return this._queuedChunk = null, { value: e5, done: false };
      }
      if (this._done) return { value: void 0, done: true };
      const e4 = Promise.withResolvers();
      return this._requests.push(e4), e4.promise;
    }
    cancel(e4) {
      this._done = true;
      for (const e5 of this._requests) e5.resolve({ value: void 0, done: true });
      this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
    }
  }
  const We3 = /^[a-z][a-z0-9\-+.]+:/i;
  function createRequest(e4, t4, i4) {
    if ("http:" === e4.protocol) {
      return NodePackages.get("http").request(e4, { headers: t4 }, i4);
    }
    return NodePackages.get("https").request(e4, { headers: t4 }, i4);
  }
  class PDFNodeStream {
    constructor(e4) {
      this.source = e4, this.url = function(e5) {
        if (We3.test(e5)) return new URL(e5);
        const t4 = NodePackages.get("url");
        return new URL(t4.pathToFileURL(e5));
      }(e4.url), this.isHttp = "http:" === this.url.protocol || "https:" === this.url.protocol, this.isFsUrl = "file:" === this.url.protocol, this.httpHeaders = this.isHttp && e4.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
    }
    get _progressiveDataLength() {
      return this._fullRequestReader?._loaded ?? 0;
    }
    getFullReader() {
      return assert2(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this), this._fullRequestReader;
    }
    getRangeReader(e4, t4) {
      if (t4 <= this._progressiveDataLength) return null;
      const i4 = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, e4, t4) : new PDFNodeStreamRangeReader(this, e4, t4);
      return this._rangeRequestReaders.push(i4), i4;
    }
    cancelAllRequests(e4) {
      this._fullRequestReader?.cancel(e4);
      for (const t4 of this._rangeRequestReaders.slice(0)) t4.cancel(e4);
    }
  }
  class BaseFullReader {
    constructor(e4) {
      this._url = e4.url, this._done = false, this._storedError = null, this.onProgress = null;
      const t4 = e4.source;
      this._contentLength = t4.length, this._loaded = 0, this._filename = null, this._disableRange = t4.disableRange || false, this._rangeChunkSize = t4.rangeChunkSize, this._rangeChunkSize || this._disableRange || (this._disableRange = true), this._isStreamingSupported = !t4.disableStream, this._isRangeSupported = !t4.disableRange, this._readableStream = null, this._readCapability = Promise.withResolvers(), this._headersCapability = Promise.withResolvers();
    }
    get headersReady() {
      return this._headersCapability.promise;
    }
    get filename() {
      return this._filename;
    }
    get contentLength() {
      return this._contentLength;
    }
    get isRangeSupported() {
      return this._isRangeSupported;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    async read() {
      if (await this._readCapability.promise, this._done) return { value: void 0, done: true };
      if (this._storedError) throw this._storedError;
      const e4 = this._readableStream.read();
      if (null === e4) return this._readCapability = Promise.withResolvers(), this.read();
      this._loaded += e4.length, this.onProgress?.({ loaded: this._loaded, total: this._contentLength });
      return { value: new Uint8Array(e4).buffer, done: false };
    }
    cancel(e4) {
      this._readableStream ? this._readableStream.destroy(e4) : this._error(e4);
    }
    _error(e4) {
      this._storedError = e4, this._readCapability.resolve();
    }
    _setReadableStream(e4) {
      this._readableStream = e4, e4.on("readable", () => {
        this._readCapability.resolve();
      }), e4.on("end", () => {
        e4.destroy(), this._done = true, this._readCapability.resolve();
      }), e4.on("error", (e5) => {
        this._error(e5);
      }), !this._isStreamingSupported && this._isRangeSupported && this._error(new AbortException2("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
    }
  }
  class BaseRangeReader {
    constructor(e4) {
      this._url = e4.url, this._done = false, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = Promise.withResolvers();
      const t4 = e4.source;
      this._isStreamingSupported = !t4.disableStream;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    async read() {
      if (await this._readCapability.promise, this._done) return { value: void 0, done: true };
      if (this._storedError) throw this._storedError;
      const e4 = this._readableStream.read();
      if (null === e4) return this._readCapability = Promise.withResolvers(), this.read();
      this._loaded += e4.length, this.onProgress?.({ loaded: this._loaded });
      return { value: new Uint8Array(e4).buffer, done: false };
    }
    cancel(e4) {
      this._readableStream ? this._readableStream.destroy(e4) : this._error(e4);
    }
    _error(e4) {
      this._storedError = e4, this._readCapability.resolve();
    }
    _setReadableStream(e4) {
      this._readableStream = e4, e4.on("readable", () => {
        this._readCapability.resolve();
      }), e4.on("end", () => {
        e4.destroy(), this._done = true, this._readCapability.resolve();
      }), e4.on("error", (e5) => {
        this._error(e5);
      }), this._storedError && this._readableStream.destroy(this._storedError);
    }
  }
  class PDFNodeStreamFullReader extends BaseFullReader {
    constructor(e4) {
      super(e4);
      this._request = createRequest(this._url, e4.httpHeaders, (t4) => {
        if (404 === t4.statusCode) {
          const e5 = new MissingPDFException2(`Missing PDF "${this._url}".`);
          return this._storedError = e5, void this._headersCapability.reject(e5);
        }
        this._headersCapability.resolve(), this._setReadableStream(t4);
        const getResponseHeader = (e5) => this._readableStream.headers[e5.toLowerCase()], { allowRangeRequests: i4, suggestedLength: a4 } = validateRangeRequestCapabilities({ getResponseHeader, isHttp: e4.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange });
        this._isRangeSupported = i4, this._contentLength = a4 || this._contentLength, this._filename = extractFilenameFromHeader(getResponseHeader);
      }), this._request.on("error", (e5) => {
        this._storedError = e5, this._headersCapability.reject(e5);
      }), this._request.end();
    }
  }
  class PDFNodeStreamRangeReader extends BaseRangeReader {
    constructor(e4, t4, i4) {
      super(e4), this._httpHeaders = {};
      for (const t5 in e4.httpHeaders) {
        const i5 = e4.httpHeaders[t5];
        void 0 !== i5 && (this._httpHeaders[t5] = i5);
      }
      this._httpHeaders.Range = `bytes=${t4}-${i4 - 1}`;
      this._request = createRequest(this._url, this._httpHeaders, (e5) => {
        if (404 !== e5.statusCode) this._setReadableStream(e5);
        else {
          const e6 = new MissingPDFException2(`Missing PDF "${this._url}".`);
          this._storedError = e6;
        }
      }), this._request.on("error", (e5) => {
        this._storedError = e5;
      }), this._request.end();
    }
  }
  class PDFNodeStreamFsFullReader extends BaseFullReader {
    constructor(e4) {
      super(e4);
      const t4 = NodePackages.get("fs");
      t4.promises.lstat(this._url).then((e5) => {
        this._contentLength = e5.size, this._setReadableStream(t4.createReadStream(this._url)), this._headersCapability.resolve();
      }, (e5) => {
        "ENOENT" === e5.code && (e5 = new MissingPDFException2(`Missing PDF "${this._url}".`)), this._storedError = e5, this._headersCapability.reject(e5);
      });
    }
  }
  class PDFNodeStreamFsRangeReader extends BaseRangeReader {
    constructor(e4, t4, i4) {
      super(e4);
      const a4 = NodePackages.get("fs");
      this._setReadableStream(a4.createReadStream(this._url, { start: t4, end: i4 - 1 }));
    }
  }
  const je3 = 30;
  const _TextLayer = class _TextLayer {
    constructor({ textContentSource: e4, container: t4, viewport: i4 }) {
      __privateAdd(this, _TextLayer_instances);
      __privateAdd(this, _HA, Promise.withResolvers());
      __privateAdd(this, _it2, null);
      __privateAdd(this, _TA, false);
      __privateAdd(this, _JA, !!globalThis.FontInspector?.enabled);
      __privateAdd(this, _YA, null);
      __privateAdd(this, _PA, null);
      __privateAdd(this, _OA, 0);
      __privateAdd(this, _KA, 0);
      __privateAdd(this, _qA, null);
      __privateAdd(this, __A, null);
      __privateAdd(this, _WA, 0);
      __privateAdd(this, _jA, 0);
      __privateAdd(this, _XA, /* @__PURE__ */ Object.create(null));
      __privateAdd(this, _VA, []);
      __privateAdd(this, _ZA, null);
      __privateAdd(this, _zA, []);
      __privateAdd(this, _$A, /* @__PURE__ */ new WeakMap());
      __privateAdd(this, _ei, null);
      var _a5;
      if (e4 instanceof ReadableStream) __privateSet(this, _ZA, e4);
      else {
        if ("object" != typeof e4) throw new Error('No "textContentSource" parameter specified.');
        __privateSet(this, _ZA, new ReadableStream({ start(t5) {
          t5.enqueue(e4), t5.close();
        } }));
      }
      __privateSet(this, _it2, __privateSet(this, __A, t4)), __privateSet(this, _jA, i4.scale * (globalThis.devicePixelRatio || 1)), __privateSet(this, _WA, i4.rotation), __privateSet(this, _PA, { prevFontSize: null, prevFontFamily: null, div: null, properties: null, ctx: null });
      const { pageWidth: a4, pageHeight: s4, pageX: n4, pageY: r4 } = i4.rawDims;
      __privateSet(this, _ei, [1, 0, 0, -1, -n4, r4 + s4]), __privateSet(this, _KA, a4), __privateSet(this, _OA, s4), __privateMethod(_a5 = _TextLayer, _TextLayer_static, si_fn).call(_a5), setLayerDimensions(t4, i4), __privateGet(this, _HA).promise.catch(() => {
      }).then(() => {
        __privateGet(_TextLayer, _ai).delete(this), __privateSet(this, _PA, null), __privateSet(this, _XA, null);
      });
    }
    render() {
      const pump = () => {
        __privateGet(this, _qA).read().then(({ value: e4, done: t4 }) => {
          t4 ? __privateGet(this, _HA).resolve() : (__privateGet(this, _YA) ?? __privateSet(this, _YA, e4.lang), Object.assign(__privateGet(this, _XA), e4.styles), __privateMethod(this, _TextLayer_instances, ni_fn).call(this, e4.items), pump());
        }, __privateGet(this, _HA).reject);
      };
      return __privateSet(this, _qA, __privateGet(this, _ZA).getReader()), __privateGet(_TextLayer, _ai).add(this), pump(), __privateGet(this, _HA).promise;
    }
    update({ viewport: e4, onBefore: t4 = null }) {
      var _a5;
      const i4 = e4.scale * (globalThis.devicePixelRatio || 1), a4 = e4.rotation;
      if (a4 !== __privateGet(this, _WA) && (t4?.(), __privateSet(this, _WA, a4), setLayerDimensions(__privateGet(this, __A), { rotation: a4 })), i4 !== __privateGet(this, _jA)) {
        t4?.(), __privateSet(this, _jA, i4);
        const e5 = { prevFontSize: null, prevFontFamily: null, div: null, properties: null, ctx: __privateMethod(_a5 = _TextLayer, _TextLayer_static, ri_fn).call(_a5, __privateGet(this, _YA)) };
        for (const t5 of __privateGet(this, _zA)) e5.properties = __privateGet(this, _$A).get(t5), e5.div = t5, __privateMethod(this, _TextLayer_instances, oi_fn).call(this, e5);
      }
    }
    cancel() {
      const e4 = new AbortException2("TextLayer task cancelled.");
      __privateGet(this, _qA)?.cancel(e4).catch(() => {
      }), __privateSet(this, _qA, null), __privateGet(this, _HA).reject(e4);
    }
    get textDivs() {
      return __privateGet(this, _zA);
    }
    get textContentItemsStr() {
      return __privateGet(this, _VA);
    }
    static cleanup() {
      if (!(__privateGet(this, _ai).size > 0)) {
        __privateGet(this, _ti).clear();
        for (const { canvas: e4 } of __privateGet(this, _Ai).values()) e4.remove();
        __privateGet(this, _Ai).clear();
      }
    }
  };
  _HA = new WeakMap();
  _it2 = new WeakMap();
  _TA = new WeakMap();
  _JA = new WeakMap();
  _YA = new WeakMap();
  _PA = new WeakMap();
  _OA = new WeakMap();
  _KA = new WeakMap();
  _qA = new WeakMap();
  __A = new WeakMap();
  _WA = new WeakMap();
  _jA = new WeakMap();
  _XA = new WeakMap();
  _VA = new WeakMap();
  _ZA = new WeakMap();
  _zA = new WeakMap();
  _$A = new WeakMap();
  _ei = new WeakMap();
  _ti = new WeakMap();
  _Ai = new WeakMap();
  _ii = new WeakMap();
  _ai = new WeakMap();
  _TextLayer_instances = new WeakSet();
  ni_fn = function(e4) {
    var _a5, _b2;
    if (__privateGet(this, _TA)) return;
    (_b2 = __privateGet(this, _PA)).ctx ?? (_b2.ctx = __privateMethod(_a5 = _TextLayer, _TextLayer_static, ri_fn).call(_a5, __privateGet(this, _YA)));
    const t4 = __privateGet(this, _zA), i4 = __privateGet(this, _VA);
    for (const a4 of e4) {
      if (t4.length > 1e5) return warn2("Ignoring additional textDivs for performance reasons."), void __privateSet(this, _TA, true);
      if (void 0 !== a4.str) i4.push(a4.str), __privateMethod(this, _TextLayer_instances, gi_fn).call(this, a4);
      else if ("beginMarkedContentProps" === a4.type || "beginMarkedContent" === a4.type) {
        const e5 = __privateGet(this, _it2);
        __privateSet(this, _it2, document.createElement("span")), __privateGet(this, _it2).classList.add("markedContent"), null !== a4.id && __privateGet(this, _it2).setAttribute("id", `${a4.id}`), e5.append(__privateGet(this, _it2));
      } else "endMarkedContent" === a4.type && __privateSet(this, _it2, __privateGet(this, _it2).parentNode);
    }
  };
  gi_fn = function(e4) {
    var _a5;
    const t4 = document.createElement("span"), i4 = { angle: 0, canvasWidth: 0, hasText: "" !== e4.str, hasEOL: e4.hasEOL, fontSize: 0 };
    __privateGet(this, _zA).push(t4);
    const a4 = Util2.transform(__privateGet(this, _ei), e4.transform);
    let s4 = Math.atan2(a4[1], a4[0]);
    const n4 = __privateGet(this, _XA)[e4.fontName];
    n4.vertical && (s4 += Math.PI / 2);
    const r4 = __privateGet(this, _JA) && n4.fontSubstitution || n4.fontFamily, o4 = Math.hypot(a4[2], a4[3]), g4 = o4 * __privateMethod(_a5 = _TextLayer, _TextLayer_static, ci_fn).call(_a5, r4, __privateGet(this, _YA));
    let c4, h4;
    0 === s4 ? (c4 = a4[4], h4 = a4[5] - g4) : (c4 = a4[4] + g4 * Math.sin(s4), h4 = a4[5] - g4 * Math.cos(s4));
    const l4 = "calc(var(--scale-factor)*", C4 = t4.style;
    __privateGet(this, _it2) === __privateGet(this, __A) ? (C4.left = `${(100 * c4 / __privateGet(this, _KA)).toFixed(2)}%`, C4.top = `${(100 * h4 / __privateGet(this, _OA)).toFixed(2)}%`) : (C4.left = `${l4}${c4.toFixed(2)}px)`, C4.top = `${l4}${h4.toFixed(2)}px)`), C4.fontSize = `${l4}${(__privateGet(_TextLayer, _ii) * o4).toFixed(2)}px)`, C4.fontFamily = r4, i4.fontSize = o4, t4.setAttribute("role", "presentation"), t4.textContent = e4.str, t4.dir = e4.dir, __privateGet(this, _JA) && (t4.dataset.fontName = n4.fontSubstitutionLoadedName || e4.fontName), 0 !== s4 && (i4.angle = s4 * (180 / Math.PI));
    let d4 = false;
    if (e4.str.length > 1) d4 = true;
    else if (" " !== e4.str && e4.transform[0] !== e4.transform[3]) {
      const t5 = Math.abs(e4.transform[0]), i5 = Math.abs(e4.transform[3]);
      t5 !== i5 && Math.max(t5, i5) / Math.min(t5, i5) > 1.5 && (d4 = true);
    }
    if (d4 && (i4.canvasWidth = n4.vertical ? e4.height : e4.width), __privateGet(this, _$A).set(t4, i4), __privateGet(this, _PA).div = t4, __privateGet(this, _PA).properties = i4, __privateMethod(this, _TextLayer_instances, oi_fn).call(this, __privateGet(this, _PA)), i4.hasText && __privateGet(this, _it2).append(t4), i4.hasEOL) {
      const e5 = document.createElement("br");
      e5.setAttribute("role", "presentation"), __privateGet(this, _it2).append(e5);
    }
  };
  oi_fn = function(e4) {
    const { div: t4, properties: i4, ctx: a4, prevFontSize: s4, prevFontFamily: n4 } = e4, { style: r4 } = t4;
    let o4 = "";
    if (__privateGet(_TextLayer, _ii) > 1 && (o4 = `scale(${1 / __privateGet(_TextLayer, _ii)})`), 0 !== i4.canvasWidth && i4.hasText) {
      const { fontFamily: g4 } = r4, { canvasWidth: c4, fontSize: h4 } = i4;
      s4 === h4 && n4 === g4 || (a4.font = `${h4 * __privateGet(this, _jA)}px ${g4}`, e4.prevFontSize = h4, e4.prevFontFamily = g4);
      const { width: l4 } = a4.measureText(t4.textContent);
      l4 > 0 && (o4 = `scaleX(${c4 * __privateGet(this, _jA) / l4}) ${o4}`);
    }
    0 !== i4.angle && (o4 = `rotate(${i4.angle}deg) ${o4}`), o4.length > 0 && (r4.transform = o4);
  };
  _TextLayer_static = new WeakSet();
  ri_fn = function(e4 = null) {
    let t4 = __privateGet(this, _Ai).get(e4 || (e4 = ""));
    if (!t4) {
      const i4 = document.createElement("canvas");
      i4.className = "hiddenCanvasElement", i4.lang = e4, document.body.append(i4), t4 = i4.getContext("2d", { alpha: false, willReadFrequently: true }), __privateGet(this, _Ai).set(e4, t4);
    }
    return t4;
  };
  si_fn = function() {
    if (null !== __privateGet(this, _ii)) return;
    const e4 = document.createElement("div");
    e4.style.opacity = 0, e4.style.lineHeight = 1, e4.style.fontSize = "1px", e4.style.position = "absolute", e4.textContent = "X", document.body.append(e4), __privateSet(this, _ii, e4.getBoundingClientRect().height), e4.remove();
  };
  ci_fn = function(e4, t4) {
    const i4 = __privateGet(this, _ti).get(e4);
    if (i4) return i4;
    const a4 = __privateMethod(this, _TextLayer_static, ri_fn).call(this, t4), s4 = a4.font;
    a4.canvas.width = a4.canvas.height = je3, a4.font = `30px ${e4}`;
    const n4 = a4.measureText("");
    let r4 = n4.fontBoundingBoxAscent, o4 = Math.abs(n4.fontBoundingBoxDescent);
    if (r4) {
      const t5 = r4 / (r4 + o4);
      return __privateGet(this, _ti).set(e4, t5), a4.canvas.width = a4.canvas.height = 0, a4.font = s4, t5;
    }
    a4.strokeStyle = "red", a4.clearRect(0, 0, je3, je3), a4.strokeText("g", 0, 0);
    let g4 = a4.getImageData(0, 0, je3, je3).data;
    o4 = 0;
    for (let e5 = g4.length - 1 - 3; e5 >= 0; e5 -= 4) if (g4[e5] > 0) {
      o4 = Math.ceil(e5 / 4 / je3);
      break;
    }
    a4.clearRect(0, 0, je3, je3), a4.strokeText("A", 0, je3), g4 = a4.getImageData(0, 0, je3, je3).data, r4 = 0;
    for (let e5 = 0, t5 = g4.length; e5 < t5; e5 += 4) if (g4[e5] > 0) {
      r4 = je3 - Math.floor(e5 / 4 / je3);
      break;
    }
    a4.canvas.width = a4.canvas.height = 0, a4.font = s4;
    const c4 = r4 ? r4 / (r4 + o4) : 0.8;
    return __privateGet(this, _ti).set(e4, c4), c4;
  };
  __privateAdd(_TextLayer, _TextLayer_static);
  __privateAdd(_TextLayer, _ti, /* @__PURE__ */ new Map());
  __privateAdd(_TextLayer, _Ai, /* @__PURE__ */ new Map());
  __privateAdd(_TextLayer, _ii, null);
  __privateAdd(_TextLayer, _ai, /* @__PURE__ */ new Set());
  let TextLayer = _TextLayer;
  class XfaText {
    static textContent(e4) {
      const t4 = [], i4 = { items: t4, styles: /* @__PURE__ */ Object.create(null) };
      return function walk(e5) {
        if (!e5) return;
        let i5 = null;
        const a4 = e5.name;
        if ("#text" === a4) i5 = e5.value;
        else {
          if (!XfaText.shouldBuildText(a4)) return;
          e5?.attributes?.textContent ? i5 = e5.attributes.textContent : e5.value && (i5 = e5.value);
        }
        if (null !== i5 && t4.push({ str: i5 }), e5.children) for (const t5 of e5.children) walk(t5);
      }(e4), i4;
    }
    static shouldBuildText(e4) {
      return !("textarea" === e4 || "input" === e4 || "option" === e4 || "select" === e4);
    }
  }
  const Xe3 = 65536, Ve3 = i3 ? class extends BaseCanvasFactory {
    _createCanvas(e4, t4) {
      return NodePackages.get("canvas").createCanvas(e4, t4);
    }
  } : class extends BaseCanvasFactory {
    constructor({ ownerDocument: e4 = globalThis.document, enableHWA: t4 = false } = {}) {
      super({ enableHWA: t4 }), this._document = e4;
    }
    _createCanvas(e4, t4) {
      const i4 = this._document.createElement("canvas");
      return i4.width = e4, i4.height = t4, i4;
    }
  }, Ze3 = i3 ? class extends BaseCMapReaderFactory {
    _fetchData(e4, t4) {
      return node_utils_fetchData(e4).then((e5) => ({ cMapData: e5, compressionType: t4 }));
    }
  } : DOMCMapReaderFactory, ze3 = i3 ? class extends BaseFilterFactory {
  } : (_a4 = class extends BaseFilterFactory {
    constructor({ docId: e4, ownerDocument: t4 = globalThis.document } = {}) {
      super();
      __privateAdd(this, _instances);
      __privateAdd(this, _hi);
      __privateAdd(this, _li);
      __privateAdd(this, _Ii);
      __privateAdd(this, _Ci);
      __privateAdd(this, _di);
      __privateAdd(this, _Bi);
      __privateAdd(this, _ce3, 0);
      __privateSet(this, _Ci, e4), __privateSet(this, _di, t4);
    }
    addFilter(e4) {
      if (!e4) return "none";
      let t4 = __privateGet(this, _instances, le_get).get(e4);
      if (t4) return t4;
      const [i4, a4, s4] = __privateMethod(this, _instances, Ei_fn).call(this, e4), n4 = 1 === e4.length ? i4 : `${i4}${a4}${s4}`;
      if (t4 = __privateGet(this, _instances, le_get).get(n4), t4) return __privateGet(this, _instances, le_get).set(e4, t4), t4;
      const r4 = `g_${__privateGet(this, _Ci)}_transfer_map_${__privateWrapper(this, _ce3)._++}`, o4 = __privateMethod(this, _instances, fi_fn).call(this, r4);
      __privateGet(this, _instances, le_get).set(e4, o4), __privateGet(this, _instances, le_get).set(n4, o4);
      const g4 = __privateMethod(this, _instances, pi_fn).call(this, r4);
      return __privateMethod(this, _instances, mi_fn).call(this, i4, a4, s4, g4), o4;
    }
    addHCMFilter(e4, t4) {
      const i4 = `${e4}-${t4}`, a4 = "base";
      let s4 = __privateGet(this, _instances, ui_get).get(a4);
      if (s4?.key === i4) return s4.url;
      if (s4 ? (s4.filter?.remove(), s4.key = i4, s4.url = "none", s4.filter = null) : (s4 = { key: i4, url: "none", filter: null }, __privateGet(this, _instances, ui_get).set(a4, s4)), !e4 || !t4) return s4.url;
      const n4 = __privateMethod(this, _instances, yi_fn).call(this, e4);
      e4 = Util2.makeHexColor(...n4);
      const r4 = __privateMethod(this, _instances, yi_fn).call(this, t4);
      if (t4 = Util2.makeHexColor(...r4), __privateGet(this, _instances, Qi_get).style.color = "", "#000000" === e4 && "#ffffff" === t4 || e4 === t4) return s4.url;
      const o4 = new Array(256);
      for (let e5 = 0; e5 <= 255; e5++) {
        const t5 = e5 / 255;
        o4[e5] = t5 <= 0.03928 ? t5 / 12.92 : ((t5 + 0.055) / 1.055) ** 2.4;
      }
      const g4 = o4.join(","), c4 = `g_${__privateGet(this, _Ci)}_hcm_filter`, h4 = s4.filter = __privateMethod(this, _instances, pi_fn).call(this, c4);
      __privateMethod(this, _instances, mi_fn).call(this, g4, g4, g4, h4), __privateMethod(this, _instances, wi_fn).call(this, h4);
      const getSteps = (e5, t5) => {
        const i5 = n4[e5] / 255, a5 = r4[e5] / 255, s5 = new Array(t5 + 1);
        for (let e6 = 0; e6 <= t5; e6++) s5[e6] = i5 + e6 / t5 * (a5 - i5);
        return s5.join(",");
      };
      return __privateMethod(this, _instances, mi_fn).call(this, getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), h4), s4.url = __privateMethod(this, _instances, fi_fn).call(this, c4), s4.url;
    }
    addAlphaFilter(e4) {
      let t4 = __privateGet(this, _instances, le_get).get(e4);
      if (t4) return t4;
      const [i4] = __privateMethod(this, _instances, Ei_fn).call(this, [e4]), a4 = `alpha_${i4}`;
      if (t4 = __privateGet(this, _instances, le_get).get(a4), t4) return __privateGet(this, _instances, le_get).set(e4, t4), t4;
      const s4 = `g_${__privateGet(this, _Ci)}_alpha_map_${__privateWrapper(this, _ce3)._++}`, n4 = __privateMethod(this, _instances, fi_fn).call(this, s4);
      __privateGet(this, _instances, le_get).set(e4, n4), __privateGet(this, _instances, le_get).set(a4, n4);
      const r4 = __privateMethod(this, _instances, pi_fn).call(this, s4);
      return __privateMethod(this, _instances, bi_fn).call(this, i4, r4), n4;
    }
    addLuminosityFilter(e4) {
      let t4, i4, a4 = __privateGet(this, _instances, le_get).get(e4 || "luminosity");
      if (a4) return a4;
      if (e4 ? ([t4] = __privateMethod(this, _instances, Ei_fn).call(this, [e4]), i4 = `luminosity_${t4}`) : i4 = "luminosity", a4 = __privateGet(this, _instances, le_get).get(i4), a4) return __privateGet(this, _instances, le_get).set(e4, a4), a4;
      const s4 = `g_${__privateGet(this, _Ci)}_luminosity_map_${__privateWrapper(this, _ce3)._++}`, n4 = __privateMethod(this, _instances, fi_fn).call(this, s4);
      __privateGet(this, _instances, le_get).set(e4, n4), __privateGet(this, _instances, le_get).set(i4, n4);
      const r4 = __privateMethod(this, _instances, pi_fn).call(this, s4);
      return __privateMethod(this, _instances, Di_fn).call(this, r4), e4 && __privateMethod(this, _instances, bi_fn).call(this, t4, r4), n4;
    }
    addHighlightHCMFilter(e4, t4, i4, a4, s4) {
      const n4 = `${t4}-${i4}-${a4}-${s4}`;
      let r4 = __privateGet(this, _instances, ui_get).get(e4);
      if (r4?.key === n4) return r4.url;
      if (r4 ? (r4.filter?.remove(), r4.key = n4, r4.url = "none", r4.filter = null) : (r4 = { key: n4, url: "none", filter: null }, __privateGet(this, _instances, ui_get).set(e4, r4)), !t4 || !i4) return r4.url;
      const [o4, g4] = [t4, i4].map(__privateMethod(this, _instances, yi_fn).bind(this));
      let c4 = Math.round(0.2126 * o4[0] + 0.7152 * o4[1] + 0.0722 * o4[2]), h4 = Math.round(0.2126 * g4[0] + 0.7152 * g4[1] + 0.0722 * g4[2]), [l4, C4] = [a4, s4].map(__privateMethod(this, _instances, yi_fn).bind(this));
      h4 < c4 && ([c4, h4, l4, C4] = [h4, c4, C4, l4]), __privateGet(this, _instances, Qi_get).style.color = "";
      const getSteps = (e5, t5, i5) => {
        const a5 = new Array(256), s5 = (h4 - c4) / i5, n5 = e5 / 255, r5 = (t5 - e5) / (255 * i5);
        let o5 = 0;
        for (let e6 = 0; e6 <= i5; e6++) {
          const t6 = Math.round(c4 + e6 * s5), i6 = n5 + e6 * r5;
          for (let e7 = o5; e7 <= t6; e7++) a5[e7] = i6;
          o5 = t6 + 1;
        }
        for (let e6 = o5; e6 < 256; e6++) a5[e6] = a5[o5 - 1];
        return a5.join(",");
      }, d4 = `g_${__privateGet(this, _Ci)}_hcm_${e4}_filter`, u4 = r4.filter = __privateMethod(this, _instances, pi_fn).call(this, d4);
      return __privateMethod(this, _instances, wi_fn).call(this, u4), __privateMethod(this, _instances, mi_fn).call(this, getSteps(l4[0], C4[0], 5), getSteps(l4[1], C4[1], 5), getSteps(l4[2], C4[2], 5), u4), r4.url = __privateMethod(this, _instances, fi_fn).call(this, d4), r4.url;
    }
    destroy(e4 = false) {
      e4 && 0 !== __privateGet(this, _instances, ui_get).size || (__privateGet(this, _Ii) && (__privateGet(this, _Ii).parentNode.parentNode.remove(), __privateSet(this, _Ii, null)), __privateGet(this, _li) && (__privateGet(this, _li).clear(), __privateSet(this, _li, null)), __privateSet(this, _ce3, 0));
    }
  }, _hi = new WeakMap(), _li = new WeakMap(), _Ii = new WeakMap(), _Ci = new WeakMap(), _di = new WeakMap(), _Bi = new WeakMap(), _ce3 = new WeakMap(), _instances = new WeakSet(), le_get = function() {
    return __privateGet(this, _li) || __privateSet(this, _li, /* @__PURE__ */ new Map());
  }, ui_get = function() {
    return __privateGet(this, _Bi) || __privateSet(this, _Bi, /* @__PURE__ */ new Map());
  }, Qi_get = function() {
    if (!__privateGet(this, _Ii)) {
      const e4 = __privateGet(this, _di).createElement("div"), { style: t4 } = e4;
      t4.visibility = "hidden", t4.contain = "strict", t4.width = t4.height = 0, t4.position = "absolute", t4.top = t4.left = 0, t4.zIndex = -1;
      const i4 = __privateGet(this, _di).createElementNS(Qe3, "svg");
      i4.setAttribute("width", 0), i4.setAttribute("height", 0), __privateSet(this, _Ii, __privateGet(this, _di).createElementNS(Qe3, "defs")), e4.append(i4), i4.append(__privateGet(this, _Ii)), __privateGet(this, _di).body.append(e4);
    }
    return __privateGet(this, _Ii);
  }, Ei_fn = function(e4) {
    if (1 === e4.length) {
      const t5 = e4[0], i5 = new Array(256);
      for (let e5 = 0; e5 < 256; e5++) i5[e5] = t5[e5] / 255;
      const a5 = i5.join(",");
      return [a5, a5, a5];
    }
    const [t4, i4, a4] = e4, s4 = new Array(256), n4 = new Array(256), r4 = new Array(256);
    for (let e5 = 0; e5 < 256; e5++) s4[e5] = t4[e5] / 255, n4[e5] = i4[e5] / 255, r4[e5] = a4[e5] / 255;
    return [s4.join(","), n4.join(","), r4.join(",")];
  }, fi_fn = function(e4) {
    if (void 0 === __privateGet(this, _hi)) {
      __privateSet(this, _hi, "");
      const e5 = __privateGet(this, _di).URL;
      e5 !== __privateGet(this, _di).baseURI && (isDataScheme(e5) ? warn2('#createUrl: ignore "data:"-URL for performance reasons.') : __privateSet(this, _hi, e5.split("#", 1)[0]));
    }
    return `url(${__privateGet(this, _hi)}#${e4})`;
  }, Di_fn = function(e4) {
    const t4 = __privateGet(this, _di).createElementNS(Qe3, "feColorMatrix");
    t4.setAttribute("type", "matrix"), t4.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0"), e4.append(t4);
  }, wi_fn = function(e4) {
    const t4 = __privateGet(this, _di).createElementNS(Qe3, "feColorMatrix");
    t4.setAttribute("type", "matrix"), t4.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), e4.append(t4);
  }, pi_fn = function(e4) {
    const t4 = __privateGet(this, _di).createElementNS(Qe3, "filter");
    return t4.setAttribute("color-interpolation-filters", "sRGB"), t4.setAttribute("id", e4), __privateGet(this, _instances, Qi_get).append(t4), t4;
  }, Si_fn = function(e4, t4, i4) {
    const a4 = __privateGet(this, _di).createElementNS(Qe3, t4);
    a4.setAttribute("type", "discrete"), a4.setAttribute("tableValues", i4), e4.append(a4);
  }, mi_fn = function(e4, t4, i4, a4) {
    const s4 = __privateGet(this, _di).createElementNS(Qe3, "feComponentTransfer");
    a4.append(s4), __privateMethod(this, _instances, Si_fn).call(this, s4, "feFuncR", e4), __privateMethod(this, _instances, Si_fn).call(this, s4, "feFuncG", t4), __privateMethod(this, _instances, Si_fn).call(this, s4, "feFuncB", i4);
  }, bi_fn = function(e4, t4) {
    const i4 = __privateGet(this, _di).createElementNS(Qe3, "feComponentTransfer");
    t4.append(i4), __privateMethod(this, _instances, Si_fn).call(this, i4, "feFuncA", e4);
  }, yi_fn = function(e4) {
    return __privateGet(this, _instances, Qi_get).style.color = e4, getRGB(getComputedStyle(__privateGet(this, _instances, Qi_get)).getPropertyValue("color"));
  }, _a4), $e3 = i3 ? class extends BaseStandardFontDataFactory {
    _fetchData(e4) {
      return node_utils_fetchData(e4);
    }
  } : DOMStandardFontDataFactory;
  function getDocument(e4 = {}) {
    "string" == typeof e4 || e4 instanceof URL ? e4 = { url: e4 } : (e4 instanceof ArrayBuffer || ArrayBuffer.isView(e4)) && (e4 = { data: e4 });
    const t4 = new PDFDocumentLoadingTask(), { docId: a4 } = t4, s4 = e4.url ? function(e5) {
      if (e5 instanceof URL) return e5.href;
      try {
        return new URL(e5, window.location).href;
      } catch {
        if (i3 && "string" == typeof e5) return e5;
      }
      throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
    }(e4.url) : null, n4 = e4.data ? function(e5) {
      if (i3 && void 0 !== Vt && e5 instanceof Vt) throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
      if (e5 instanceof Uint8Array && e5.byteLength === e5.buffer.byteLength) return e5;
      if ("string" == typeof e5) return stringToBytes2(e5);
      if (e5 instanceof ArrayBuffer || ArrayBuffer.isView(e5) || "object" == typeof e5 && !isNaN(e5?.length)) return new Uint8Array(e5);
      throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
    }(e4.data) : null, r4 = e4.httpHeaders || null, o4 = true === e4.withCredentials, g4 = e4.password ?? null, c4 = e4.range instanceof PDFDataRangeTransport ? e4.range : null, h4 = Number.isInteger(e4.rangeChunkSize) && e4.rangeChunkSize > 0 ? e4.rangeChunkSize : Xe3;
    let l4 = e4.worker instanceof PDFWorker ? e4.worker : null;
    const C4 = e4.verbosity, d4 = "string" != typeof e4.docBaseUrl || isDataScheme(e4.docBaseUrl) ? null : e4.docBaseUrl, u4 = "string" == typeof e4.cMapUrl ? e4.cMapUrl : null, Q4 = false !== e4.cMapPacked, f4 = e4.CMapReaderFactory || Ze3, p4 = "string" == typeof e4.standardFontDataUrl ? e4.standardFontDataUrl : null, m4 = e4.StandardFontDataFactory || $e3, y4 = true !== e4.stopAtErrors, w4 = Number.isInteger(e4.maxImageSize) && e4.maxImageSize > -1 ? e4.maxImageSize : -1, b4 = false !== e4.isEvalSupported, D4 = "boolean" == typeof e4.isOffscreenCanvasSupported ? e4.isOffscreenCanvasSupported : !i3, S4 = Number.isInteger(e4.canvasMaxAreaInBytes) ? e4.canvasMaxAreaInBytes : -1, F4 = "boolean" == typeof e4.disableFontFace ? e4.disableFontFace : i3, k4 = true === e4.fontExtraProperties, R4 = true === e4.enableXfa, x4 = e4.ownerDocument || globalThis.document, N4 = true === e4.disableRange, M4 = true === e4.disableStream, G4 = true === e4.disableAutoFetch, v4 = true === e4.pdfBug, L4 = true === e4.enableHWA, U4 = c4 ? c4.length : e4.length ?? NaN, H4 = "boolean" == typeof e4.useSystemFonts ? e4.useSystemFonts : !i3 && !F4, T4 = "boolean" == typeof e4.useWorkerFetch ? e4.useWorkerFetch : f4 === DOMCMapReaderFactory && m4 === DOMStandardFontDataFactory && u4 && p4 && isValidFetchUrl(u4, document.baseURI) && isValidFetchUrl(p4, document.baseURI), J4 = e4.canvasFactory || new Ve3({ ownerDocument: x4, enableHWA: L4 }), Y4 = e4.filterFactory || new ze3({ docId: a4, ownerDocument: x4 });
    setVerbosityLevel(C4);
    const O4 = { canvasFactory: J4, filterFactory: Y4 };
    if (T4 || (O4.cMapReaderFactory = new f4({ baseUrl: u4, isCompressed: Q4 }), O4.standardFontDataFactory = new m4({ baseUrl: p4 })), !l4) {
      const e5 = { verbosity: C4, port: GlobalWorkerOptions.workerPort };
      l4 = e5.port ? PDFWorker.fromPort(e5) : new PDFWorker(e5), t4._worker = l4;
    }
    const K4 = { docId: a4, apiVersion: "4.6.82", data: n4, password: g4, disableAutoFetch: G4, rangeChunkSize: h4, length: U4, docBaseUrl: d4, enableXfa: R4, evaluatorOptions: { maxImageSize: w4, disableFontFace: F4, ignoreErrors: y4, isEvalSupported: b4, isOffscreenCanvasSupported: D4, canvasMaxAreaInBytes: S4, fontExtraProperties: k4, useSystemFonts: H4, cMapUrl: T4 ? u4 : null, standardFontDataUrl: T4 ? p4 : null } }, q4 = { disableFontFace: F4, fontExtraProperties: k4, ownerDocument: x4, pdfBug: v4, styleElement: null, loadingParams: { disableAutoFetch: G4, enableXfa: R4 } };
    return l4.promise.then(function() {
      if (t4.destroyed) throw new Error("Loading aborted");
      if (l4.destroyed) throw new Error("Worker was destroyed");
      const e5 = l4.messageHandler.sendWithPromise("GetDocRequest", K4, n4 ? [n4.buffer] : null);
      let g5;
      if (c4) g5 = new PDFDataTransportStream(c4, { disableRange: N4, disableStream: M4 });
      else if (!n4) {
        if (!s4) throw new Error("getDocument - no `url` parameter provided.");
        g5 = ((e6) => {
          if (i3) {
            return function() {
              return "undefined" != typeof fetch && "undefined" != typeof Response && "body" in Response.prototype;
            }() && isValidFetchUrl(e6.url) ? new PDFFetchStream(e6) : new PDFNodeStream(e6);
          }
          return isValidFetchUrl(e6.url) ? new PDFFetchStream(e6) : new PDFNetworkStream(e6);
        })({ url: s4, length: U4, httpHeaders: r4, withCredentials: o4, rangeChunkSize: h4, disableRange: N4, disableStream: M4 });
      }
      return e5.then((e6) => {
        if (t4.destroyed) throw new Error("Loading aborted");
        if (l4.destroyed) throw new Error("Worker was destroyed");
        const i4 = new MessageHandler2(a4, e6, l4.port), s5 = new WorkerTransport(i4, t4, g5, q4, O4);
        t4._transport = s5, i4.send("Ready", null);
      });
    }).catch(t4._capability.reject), t4;
  }
  function isRefProxy(e4) {
    return "object" == typeof e4 && Number.isInteger(e4?.num) && e4.num >= 0 && Number.isInteger(e4?.gen) && e4.gen >= 0;
  }
  const _PDFDocumentLoadingTask = class _PDFDocumentLoadingTask {
    constructor() {
      this._capability = Promise.withResolvers(), this._transport = null, this._worker = null, this.docId = "d" + __privateWrapper(_PDFDocumentLoadingTask, _Ci2)._++, this.destroyed = false, this.onPassword = null, this.onProgress = null;
    }
    get promise() {
      return this._capability.promise;
    }
    async destroy() {
      this.destroyed = true;
      try {
        this._worker?.port && (this._worker._pendingDestroy = true), await this._transport?.destroy();
      } catch (e4) {
        throw this._worker?.port && delete this._worker._pendingDestroy, e4;
      }
      this._transport = null, this._worker && (this._worker.destroy(), this._worker = null);
    }
  };
  _Ci2 = new WeakMap();
  __privateAdd(_PDFDocumentLoadingTask, _Ci2, 0);
  let PDFDocumentLoadingTask = _PDFDocumentLoadingTask;
  class PDFDataRangeTransport {
    constructor(e4, t4, i4 = false, a4 = null) {
      this.length = e4, this.initialData = t4, this.progressiveDone = i4, this.contentDispositionFilename = a4, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = Promise.withResolvers();
    }
    addRangeListener(e4) {
      this._rangeListeners.push(e4);
    }
    addProgressListener(e4) {
      this._progressListeners.push(e4);
    }
    addProgressiveReadListener(e4) {
      this._progressiveReadListeners.push(e4);
    }
    addProgressiveDoneListener(e4) {
      this._progressiveDoneListeners.push(e4);
    }
    onDataRange(e4, t4) {
      for (const i4 of this._rangeListeners) i4(e4, t4);
    }
    onDataProgress(e4, t4) {
      this._readyCapability.promise.then(() => {
        for (const i4 of this._progressListeners) i4(e4, t4);
      });
    }
    onDataProgressiveRead(e4) {
      this._readyCapability.promise.then(() => {
        for (const t4 of this._progressiveReadListeners) t4(e4);
      });
    }
    onDataProgressiveDone() {
      this._readyCapability.promise.then(() => {
        for (const e4 of this._progressiveDoneListeners) e4();
      });
    }
    transportReady() {
      this._readyCapability.resolve();
    }
    requestDataRange(e4, t4) {
      unreachable2("Abstract method PDFDataRangeTransport.requestDataRange");
    }
    abort() {
    }
  }
  class PDFDocumentProxy {
    constructor(e4, t4) {
      this._pdfInfo = e4, this._transport = t4;
    }
    get annotationStorage() {
      return this._transport.annotationStorage;
    }
    get filterFactory() {
      return this._transport.filterFactory;
    }
    get numPages() {
      return this._pdfInfo.numPages;
    }
    get fingerprints() {
      return this._pdfInfo.fingerprints;
    }
    get isPureXfa() {
      return shadow2(this, "isPureXfa", !!this._transport._htmlForXfa);
    }
    get allXfaHtml() {
      return this._transport._htmlForXfa;
    }
    getPage(e4) {
      return this._transport.getPage(e4);
    }
    getPageIndex(e4) {
      return this._transport.getPageIndex(e4);
    }
    getDestinations() {
      return this._transport.getDestinations();
    }
    getDestination(e4) {
      return this._transport.getDestination(e4);
    }
    getPageLabels() {
      return this._transport.getPageLabels();
    }
    getPageLayout() {
      return this._transport.getPageLayout();
    }
    getPageMode() {
      return this._transport.getPageMode();
    }
    getViewerPreferences() {
      return this._transport.getViewerPreferences();
    }
    getOpenAction() {
      return this._transport.getOpenAction();
    }
    getAttachments() {
      return this._transport.getAttachments();
    }
    getJSActions() {
      return this._transport.getDocJSActions();
    }
    getOutline() {
      return this._transport.getOutline();
    }
    getOptionalContentConfig({ intent: e4 = "display" } = {}) {
      const { renderingIntent: t4 } = this._transport.getRenderingIntent(e4);
      return this._transport.getOptionalContentConfig(t4);
    }
    getPermissions() {
      return this._transport.getPermissions();
    }
    getMetadata() {
      return this._transport.getMetadata();
    }
    getMarkInfo() {
      return this._transport.getMarkInfo();
    }
    getData() {
      return this._transport.getData();
    }
    saveDocument() {
      return this._transport.saveDocument();
    }
    getDownloadInfo() {
      return this._transport.downloadInfoCapability.promise;
    }
    cleanup(e4 = false) {
      return this._transport.startCleanup(e4 || this.isPureXfa);
    }
    destroy() {
      return this.loadingTask.destroy();
    }
    cachedPageNumber(e4) {
      return this._transport.cachedPageNumber(e4);
    }
    get loadingParams() {
      return this._transport.loadingParams;
    }
    get loadingTask() {
      return this._transport.loadingTask;
    }
    getFieldObjects() {
      return this._transport.getFieldObjects();
    }
    hasJSActions() {
      return this._transport.hasJSActions();
    }
    getCalculationOrderIds() {
      return this._transport.getCalculationOrderIds();
    }
  }
  class PDFPageProxy {
    constructor(e4, t4, i4, a4 = false) {
      __privateAdd(this, _PDFPageProxy_instances);
      __privateAdd(this, _Fi, null);
      __privateAdd(this, _ki, false);
      this._pageIndex = e4, this._pageInfo = t4, this._transport = i4, this._stats = a4 ? new StatTimer() : null, this._pdfBug = a4, this.commonObjs = i4.commonObjs, this.objs = new PDFObjects(), this._maybeCleanupAfterRender = false, this._intentStates = /* @__PURE__ */ new Map(), this.destroyed = false;
    }
    get pageNumber() {
      return this._pageIndex + 1;
    }
    get rotate() {
      return this._pageInfo.rotate;
    }
    get ref() {
      return this._pageInfo.ref;
    }
    get userUnit() {
      return this._pageInfo.userUnit;
    }
    get view() {
      return this._pageInfo.view;
    }
    getViewport({ scale: e4, rotation: t4 = this.rotate, offsetX: i4 = 0, offsetY: a4 = 0, dontFlip: s4 = false } = {}) {
      return new PageViewport({ viewBox: this.view, scale: e4, rotation: t4, offsetX: i4, offsetY: a4, dontFlip: s4 });
    }
    getAnnotations({ intent: e4 = "display" } = {}) {
      const { renderingIntent: t4 } = this._transport.getRenderingIntent(e4);
      return this._transport.getAnnotations(this._pageIndex, t4);
    }
    getJSActions() {
      return this._transport.getPageJSActions(this._pageIndex);
    }
    get filterFactory() {
      return this._transport.filterFactory;
    }
    get isPureXfa() {
      return shadow2(this, "isPureXfa", !!this._transport._htmlForXfa);
    }
    async getXfa() {
      return this._transport._htmlForXfa?.children[this._pageIndex] || null;
    }
    render({ canvasContext: e4, viewport: t4, intent: i4 = "display", annotationMode: a4 = u3.ENABLE, transform: s4 = null, background: n4 = null, optionalContentConfigPromise: r4 = null, annotationCanvasMap: o4 = null, pageColors: c4 = null, printAnnotationStorage: h4 = null, isEditing: l4 = false }) {
      this._stats?.time("Overall");
      const C4 = this._transport.getRenderingIntent(i4, a4, h4, l4), { renderingIntent: d4, cacheKey: Q4 } = C4;
      __privateSet(this, _ki, false), __privateMethod(this, _PDFPageProxy_instances, Ri_fn).call(this), r4 || (r4 = this._transport.getOptionalContentConfig(d4));
      let f4 = this._intentStates.get(Q4);
      f4 || (f4 = /* @__PURE__ */ Object.create(null), this._intentStates.set(Q4, f4)), f4.streamReaderCancelTimeout && (clearTimeout(f4.streamReaderCancelTimeout), f4.streamReaderCancelTimeout = null);
      const p4 = !!(d4 & g3);
      f4.displayReadyCapability || (f4.displayReadyCapability = Promise.withResolvers(), f4.operatorList = { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null }, this._stats?.time("Page Request"), this._pumpOperatorList(C4));
      const complete = (e5) => {
        f4.renderTasks.delete(m4), (this._maybeCleanupAfterRender || p4) && __privateSet(this, _ki, true), __privateMethod(this, _PDFPageProxy_instances, xi_fn).call(this, !p4), e5 ? (m4.capability.reject(e5), this._abortOperatorList({ intentState: f4, reason: e5 instanceof Error ? e5 : new Error(e5) })) : m4.capability.resolve(), this._stats && (this._stats.timeEnd("Rendering"), this._stats.timeEnd("Overall"), globalThis.Stats?.enabled && globalThis.Stats.add(this.pageNumber, this._stats));
      }, m4 = new InternalRenderTask({ callback: complete, params: { canvasContext: e4, viewport: t4, transform: s4, background: n4 }, objs: this.objs, commonObjs: this.commonObjs, annotationCanvasMap: o4, operatorList: f4.operatorList, pageIndex: this._pageIndex, canvasFactory: this._transport.canvasFactory, filterFactory: this._transport.filterFactory, useRequestAnimationFrame: !p4, pdfBug: this._pdfBug, pageColors: c4 });
      (f4.renderTasks || (f4.renderTasks = /* @__PURE__ */ new Set())).add(m4);
      const y4 = m4.task;
      return Promise.all([f4.displayReadyCapability.promise, r4]).then(([e5, t5]) => {
        if (this.destroyed) complete();
        else {
          if (this._stats?.time("Rendering"), !(t5.renderingIntent & d4)) throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.");
          m4.initializeGraphics({ transparency: e5, optionalContentConfig: t5 }), m4.operatorListChanged();
        }
      }).catch(complete), y4;
    }
    getOperatorList({ intent: e4 = "display", annotationMode: t4 = u3.ENABLE, printAnnotationStorage: i4 = null, isEditing: a4 = false } = {}) {
      const s4 = this._transport.getRenderingIntent(e4, t4, i4, a4, true);
      let n4, r4 = this._intentStates.get(s4.cacheKey);
      return r4 || (r4 = /* @__PURE__ */ Object.create(null), this._intentStates.set(s4.cacheKey, r4)), r4.opListReadCapability || (n4 = /* @__PURE__ */ Object.create(null), n4.operatorListChanged = function() {
        r4.operatorList.lastChunk && (r4.opListReadCapability.resolve(r4.operatorList), r4.renderTasks.delete(n4));
      }, r4.opListReadCapability = Promise.withResolvers(), (r4.renderTasks || (r4.renderTasks = /* @__PURE__ */ new Set())).add(n4), r4.operatorList = { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null }, this._stats?.time("Page Request"), this._pumpOperatorList(s4)), r4.opListReadCapability.promise;
    }
    streamTextContent({ includeMarkedContent: e4 = false, disableNormalization: t4 = false } = {}) {
      return this._transport.messageHandler.sendWithStream("GetTextContent", { pageIndex: this._pageIndex, includeMarkedContent: true === e4, disableNormalization: true === t4 }, { highWaterMark: 100, size: (e5) => e5.items.length });
    }
    getTextContent(e4 = {}) {
      if (this._transport._htmlForXfa) return this.getXfa().then((e5) => XfaText.textContent(e5));
      const t4 = this.streamTextContent(e4);
      return new Promise(function(e5, i4) {
        const a4 = t4.getReader(), s4 = { items: [], styles: /* @__PURE__ */ Object.create(null), lang: null };
        !function pump() {
          a4.read().then(function({ value: t5, done: i5 }) {
            i5 ? e5(s4) : (s4.lang ?? (s4.lang = t5.lang), Object.assign(s4.styles, t5.styles), s4.items.push(...t5.items), pump());
          }, i4);
        }();
      });
    }
    getStructTree() {
      return this._transport.getStructTree(this._pageIndex);
    }
    _destroy() {
      this.destroyed = true;
      const e4 = [];
      for (const t4 of this._intentStates.values()) if (this._abortOperatorList({ intentState: t4, reason: new Error("Page was destroyed."), force: true }), !t4.opListReadCapability) for (const i4 of t4.renderTasks) e4.push(i4.completed), i4.cancel();
      return this.objs.clear(), __privateSet(this, _ki, false), __privateMethod(this, _PDFPageProxy_instances, Ri_fn).call(this), Promise.all(e4);
    }
    cleanup(e4 = false) {
      __privateSet(this, _ki, true);
      const t4 = __privateMethod(this, _PDFPageProxy_instances, xi_fn).call(this, false);
      return e4 && t4 && (this._stats && (this._stats = new StatTimer())), t4;
    }
    _startRenderPage(e4, t4) {
      const i4 = this._intentStates.get(t4);
      i4 && (this._stats?.timeEnd("Page Request"), i4.displayReadyCapability?.resolve(e4));
    }
    _renderPageChunk(e4, t4) {
      for (let i4 = 0, a4 = e4.length; i4 < a4; i4++) t4.operatorList.fnArray.push(e4.fnArray[i4]), t4.operatorList.argsArray.push(e4.argsArray[i4]);
      t4.operatorList.lastChunk = e4.lastChunk, t4.operatorList.separateAnnots = e4.separateAnnots;
      for (const e5 of t4.renderTasks) e5.operatorListChanged();
      e4.lastChunk && __privateMethod(this, _PDFPageProxy_instances, xi_fn).call(this, true);
    }
    _pumpOperatorList({ renderingIntent: e4, cacheKey: t4, annotationStorageSerializable: i4, modifiedIds: a4 }) {
      const { map: s4, transfer: n4 } = i4, r4 = this._transport.messageHandler.sendWithStream("GetOperatorList", { pageIndex: this._pageIndex, intent: e4, cacheKey: t4, annotationStorage: s4, modifiedIds: a4 }, n4).getReader(), o4 = this._intentStates.get(t4);
      o4.streamReader = r4;
      const pump = () => {
        r4.read().then(({ value: e5, done: t5 }) => {
          t5 ? o4.streamReader = null : this._transport.destroyed || (this._renderPageChunk(e5, o4), pump());
        }, (e5) => {
          if (o4.streamReader = null, !this._transport.destroyed) {
            if (o4.operatorList) {
              o4.operatorList.lastChunk = true;
              for (const e6 of o4.renderTasks) e6.operatorListChanged();
              __privateMethod(this, _PDFPageProxy_instances, xi_fn).call(this, true);
            }
            if (o4.displayReadyCapability) o4.displayReadyCapability.reject(e5);
            else {
              if (!o4.opListReadCapability) throw e5;
              o4.opListReadCapability.reject(e5);
            }
          }
        });
      };
      pump();
    }
    _abortOperatorList({ intentState: e4, reason: t4, force: i4 = false }) {
      if (e4.streamReader) {
        if (e4.streamReaderCancelTimeout && (clearTimeout(e4.streamReaderCancelTimeout), e4.streamReaderCancelTimeout = null), !i4) {
          if (e4.renderTasks.size > 0) return;
          if (t4 instanceof RenderingCancelledException) {
            let i5 = 100;
            return t4.extraDelay > 0 && t4.extraDelay < 1e3 && (i5 += t4.extraDelay), void (e4.streamReaderCancelTimeout = setTimeout(() => {
              e4.streamReaderCancelTimeout = null, this._abortOperatorList({ intentState: e4, reason: t4, force: true });
            }, i5));
          }
        }
        if (e4.streamReader.cancel(new AbortException2(t4.message)).catch(() => {
        }), e4.streamReader = null, !this._transport.destroyed) {
          for (const [t5, i5] of this._intentStates) if (i5 === e4) {
            this._intentStates.delete(t5);
            break;
          }
          this.cleanup();
        }
      }
    }
    get stats() {
      return this._stats;
    }
  }
  _Fi = new WeakMap();
  _ki = new WeakMap();
  _PDFPageProxy_instances = new WeakSet();
  xi_fn = function(e4 = false) {
    if (__privateMethod(this, _PDFPageProxy_instances, Ri_fn).call(this), !__privateGet(this, _ki) || this.destroyed) return false;
    if (e4) return __privateSet(this, _Fi, setTimeout(() => {
      __privateSet(this, _Fi, null), __privateMethod(this, _PDFPageProxy_instances, xi_fn).call(this, false);
    }, 5e3)), false;
    for (const { renderTasks: e5, operatorList: t4 } of this._intentStates.values()) if (e5.size > 0 || !t4.lastChunk) return false;
    return this._intentStates.clear(), this.objs.clear(), __privateSet(this, _ki, false), true;
  };
  Ri_fn = function() {
    __privateGet(this, _Fi) && (clearTimeout(__privateGet(this, _Fi)), __privateSet(this, _Fi, null));
  };
  class LoopbackPort {
    constructor() {
      __privateAdd(this, _Ni, /* @__PURE__ */ new Set());
      __privateAdd(this, _Mi, Promise.resolve());
    }
    postMessage(e4, t4) {
      const i4 = { data: structuredClone(e4, t4 ? { transfer: t4 } : null) };
      __privateGet(this, _Mi).then(() => {
        for (const e5 of __privateGet(this, _Ni)) e5.call(this, i4);
      });
    }
    addEventListener(e4, t4) {
      __privateGet(this, _Ni).add(t4);
    }
    removeEventListener(e4, t4) {
      __privateGet(this, _Ni).delete(t4);
    }
    terminate() {
      __privateGet(this, _Ni).clear();
    }
  }
  _Ni = new WeakMap();
  _Mi = new WeakMap();
  const _PDFWorker = class _PDFWorker {
    constructor({ name: e4 = null, port: t4 = null, verbosity: i4 = getVerbosityLevel2() } = {}) {
      __privateAdd(this, _PDFWorker_instances);
      if (this.name = e4, this.destroyed = false, this.verbosity = i4, this._readyCapability = Promise.withResolvers(), this._port = null, this._webWorker = null, this._messageHandler = null, t4) {
        if (__privateGet(_PDFWorker, _Li)?.has(t4)) throw new Error("Cannot use more than one PDFWorker per port.");
        return (__privateGet(_PDFWorker, _Li) || __privateSet(_PDFWorker, _Li, /* @__PURE__ */ new WeakMap())).set(t4, this), void this._initializeFromPort(t4);
      }
      this._initialize();
    }
    get promise() {
      return i3 ? Promise.all([NodePackages.promise, this._readyCapability.promise]) : this._readyCapability.promise;
    }
    get port() {
      return this._port;
    }
    get messageHandler() {
      return this._messageHandler;
    }
    _initializeFromPort(e4) {
      this._port = e4, this._messageHandler = new MessageHandler2("main", "worker", e4), this._messageHandler.on("ready", function() {
      }), __privateMethod(this, _PDFWorker_instances, Ui_fn).call(this);
    }
    _initialize() {
      if (__privateGet(_PDFWorker, _vi) || __privateGet(_PDFWorker, _PDFWorker_static, Hi_get)) return void this._setupFakeWorker();
      let { workerSrc: e4 } = _PDFWorker;
      try {
        _PDFWorker._isSameOrigin(window.location.href, e4) || (e4 = _PDFWorker._createCDNWrapper(new URL(e4, window.location).href));
        const t4 = new Worker(e4, { type: "module" }), i4 = new MessageHandler2("main", "worker", t4), terminateEarly = () => {
          a4.abort(), i4.destroy(), t4.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
        }, a4 = new AbortController();
        t4.addEventListener("error", () => {
          this._webWorker || terminateEarly();
        }, { signal: a4.signal }), i4.on("test", (e5) => {
          a4.abort(), !this.destroyed && e5 ? (this._messageHandler = i4, this._port = t4, this._webWorker = t4, __privateMethod(this, _PDFWorker_instances, Ui_fn).call(this)) : terminateEarly();
        }), i4.on("ready", (e5) => {
          if (a4.abort(), this.destroyed) terminateEarly();
          else try {
            sendTest();
          } catch {
            this._setupFakeWorker();
          }
        });
        const sendTest = () => {
          const e5 = new Uint8Array();
          i4.send("test", e5, [e5.buffer]);
        };
        return void sendTest();
      } catch {
        info2("The worker has been disabled.");
      }
      this._setupFakeWorker();
    }
    _setupFakeWorker() {
      __privateGet(_PDFWorker, _vi) || (warn2("Setting up fake worker."), __privateSet(_PDFWorker, _vi, true)), _PDFWorker._setupFakeWorkerGlobal.then((e4) => {
        if (this.destroyed) return void this._readyCapability.reject(new Error("Worker was destroyed"));
        const t4 = new LoopbackPort();
        this._port = t4;
        const i4 = "fake" + __privateWrapper(_PDFWorker, _Gi)._++, a4 = new MessageHandler2(i4 + "_worker", i4, t4);
        e4.setup(a4, t4), this._messageHandler = new MessageHandler2(i4, i4 + "_worker", t4), __privateMethod(this, _PDFWorker_instances, Ui_fn).call(this);
      }).catch((e4) => {
        this._readyCapability.reject(new Error(`Setting up fake worker failed: "${e4.message}".`));
      });
    }
    destroy() {
      this.destroyed = true, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), __privateGet(_PDFWorker, _Li)?.delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null);
    }
    static fromPort(e4) {
      if (!e4?.port) throw new Error("PDFWorker.fromPort - invalid method signature.");
      const t4 = __privateGet(this, _Li)?.get(e4.port);
      if (t4) {
        if (t4._pendingDestroy) throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
        return t4;
      }
      return new _PDFWorker(e4);
    }
    static get workerSrc() {
      if (GlobalWorkerOptions.workerSrc) return GlobalWorkerOptions.workerSrc;
      throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
    }
    static get _setupFakeWorkerGlobal() {
      return shadow2(this, "_setupFakeWorkerGlobal", (async () => {
        if (__privateGet(this, _PDFWorker_static, Hi_get)) return __privateGet(this, _PDFWorker_static, Hi_get);
        return (await import(this.workerSrc)).WorkerMessageHandler;
      })());
    }
  };
  _Gi = new WeakMap();
  _vi = new WeakMap();
  _Li = new WeakMap();
  _PDFWorker_instances = new WeakSet();
  Ui_fn = function() {
    this._readyCapability.resolve(), this._messageHandler.send("configure", { verbosity: this.verbosity });
  };
  _PDFWorker_static = new WeakSet();
  Hi_get = function() {
    try {
      return globalThis.pdfjsWorker?.WorkerMessageHandler || null;
    } catch {
      return null;
    }
  };
  __privateAdd(_PDFWorker, _PDFWorker_static);
  __privateAdd(_PDFWorker, _Gi, 0);
  __privateAdd(_PDFWorker, _vi, false);
  __privateAdd(_PDFWorker, _Li);
  i3 && (__privateSet(_PDFWorker, _vi, true), GlobalWorkerOptions.workerSrc || (GlobalWorkerOptions.workerSrc = "./pdf.worker.mjs")), _PDFWorker._isSameOrigin = (e4, t4) => {
    let i4;
    try {
      if (i4 = new URL(e4), !i4.origin || "null" === i4.origin) return false;
    } catch {
      return false;
    }
    const a4 = new URL(t4, i4);
    return i4.origin === a4.origin;
  }, _PDFWorker._createCDNWrapper = (e4) => {
    const t4 = `await import("${e4}");`;
    return URL.createObjectURL(new Blob([t4], { type: "text/javascript" }));
  };
  let PDFWorker = _PDFWorker;
  class WorkerTransport {
    constructor(e4, t4, i4, a4, s4) {
      __privateAdd(this, _WorkerTransport_instances);
      __privateAdd(this, _Ti, /* @__PURE__ */ new Map());
      __privateAdd(this, _Ji, /* @__PURE__ */ new Map());
      __privateAdd(this, _Yi, /* @__PURE__ */ new Map());
      __privateAdd(this, _Pi, /* @__PURE__ */ new Map());
      __privateAdd(this, _Oi, null);
      this.messageHandler = e4, this.loadingTask = t4, this.commonObjs = new PDFObjects(), this.fontLoader = new FontLoader({ ownerDocument: a4.ownerDocument, styleElement: a4.styleElement }), this.loadingParams = a4.loadingParams, this._params = a4, this.canvasFactory = s4.canvasFactory, this.filterFactory = s4.filterFactory, this.cMapReaderFactory = s4.cMapReaderFactory, this.standardFontDataFactory = s4.standardFontDataFactory, this.destroyed = false, this.destroyCapability = null, this._networkStream = i4, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = Promise.withResolvers(), this.setupMessageHandler();
    }
    get annotationStorage() {
      return shadow2(this, "annotationStorage", new AnnotationStorage());
    }
    getRenderingIntent(e4, t4 = u3.ENABLE, i4 = null, a4 = false, s4 = false) {
      let n4 = o3, Q4 = ye3;
      switch (e4) {
        case "any":
          n4 = r3;
          break;
        case "display":
          break;
        case "print":
          n4 = g3;
          break;
        default:
          warn2(`getRenderingIntent - invalid intent: ${e4}`);
      }
      const f4 = n4 & g3 && i4 instanceof PrintAnnotationStorage ? i4 : this.annotationStorage;
      switch (t4) {
        case u3.DISABLE:
          n4 += l3;
          break;
        case u3.ENABLE:
          break;
        case u3.ENABLE_FORMS:
          n4 += c3;
          break;
        case u3.ENABLE_STORAGE:
          n4 += h3, Q4 = f4.serializable;
          break;
        default:
          warn2(`getRenderingIntent - invalid annotationMode: ${t4}`);
      }
      a4 && (n4 += C3), s4 && (n4 += d3);
      const { ids: p4, hash: m4 } = f4.modifiedIds;
      return { renderingIntent: n4, cacheKey: [n4, Q4.hash, m4].join("_"), annotationStorageSerializable: Q4, modifiedIds: p4 };
    }
    destroy() {
      if (this.destroyCapability) return this.destroyCapability.promise;
      this.destroyed = true, this.destroyCapability = Promise.withResolvers(), __privateGet(this, _Oi)?.reject(new Error("Worker was destroyed during onPassword callback"));
      const e4 = [];
      for (const t5 of __privateGet(this, _Ji).values()) e4.push(t5._destroy());
      __privateGet(this, _Ji).clear(), __privateGet(this, _Yi).clear(), __privateGet(this, _Pi).clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
      const t4 = this.messageHandler.sendWithPromise("Terminate", null);
      return e4.push(t4), Promise.all(e4).then(() => {
        this.commonObjs.clear(), this.fontLoader.clear(), __privateGet(this, _Ti).clear(), this.filterFactory.destroy(), TextLayer.cleanup(), this._networkStream?.cancelAllRequests(new AbortException2("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve();
      }, this.destroyCapability.reject), this.destroyCapability.promise;
    }
    setupMessageHandler() {
      const { messageHandler: e4, loadingTask: t4 } = this;
      e4.on("GetReader", (e5, t5) => {
        assert2(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (e6) => {
          this._lastProgress = { loaded: e6.loaded, total: e6.total };
        }, t5.onPull = () => {
          this._fullReader.read().then(function({ value: e6, done: i4 }) {
            i4 ? t5.close() : (assert2(e6 instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), t5.enqueue(new Uint8Array(e6), 1, [e6]));
          }).catch((e6) => {
            t5.error(e6);
          });
        }, t5.onCancel = (e6) => {
          this._fullReader.cancel(e6), t5.ready.catch((e7) => {
            if (!this.destroyed) throw e7;
          });
        };
      }), e4.on("ReaderHeadersReady", (e5) => {
        const i4 = Promise.withResolvers(), a4 = this._fullReader;
        return a4.headersReady.then(() => {
          a4.isStreamingSupported && a4.isRangeSupported || (this._lastProgress && t4.onProgress?.(this._lastProgress), a4.onProgress = (e6) => {
            t4.onProgress?.({ loaded: e6.loaded, total: e6.total });
          }), i4.resolve({ isStreamingSupported: a4.isStreamingSupported, isRangeSupported: a4.isRangeSupported, contentLength: a4.contentLength });
        }, i4.reject), i4.promise;
      }), e4.on("GetRangeReader", (e5, t5) => {
        assert2(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
        const i4 = this._networkStream.getRangeReader(e5.begin, e5.end);
        i4 ? (t5.onPull = () => {
          i4.read().then(function({ value: e6, done: i5 }) {
            i5 ? t5.close() : (assert2(e6 instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), t5.enqueue(new Uint8Array(e6), 1, [e6]));
          }).catch((e6) => {
            t5.error(e6);
          });
        }, t5.onCancel = (e6) => {
          i4.cancel(e6), t5.ready.catch((e7) => {
            if (!this.destroyed) throw e7;
          });
        }) : t5.close();
      }), e4.on("GetDoc", ({ pdfInfo: e5 }) => {
        this._numPages = e5.numPages, this._htmlForXfa = e5.htmlForXfa, delete e5.htmlForXfa, t4._capability.resolve(new PDFDocumentProxy(e5, this));
      }), e4.on("DocException", function(e5) {
        let i4;
        switch (e5.name) {
          case "PasswordException":
            i4 = new PasswordException2(e5.message, e5.code);
            break;
          case "InvalidPDFException":
            i4 = new InvalidPDFException2(e5.message);
            break;
          case "MissingPDFException":
            i4 = new MissingPDFException2(e5.message);
            break;
          case "UnexpectedResponseException":
            i4 = new UnexpectedResponseException2(e5.message, e5.status);
            break;
          case "UnknownErrorException":
            i4 = new UnknownErrorException2(e5.message, e5.details);
            break;
          default:
            unreachable2("DocException - expected a valid Error.");
        }
        t4._capability.reject(i4);
      }), e4.on("PasswordRequest", (e5) => {
        if (__privateSet(this, _Oi, Promise.withResolvers()), t4.onPassword) {
          const updatePassword = (e6) => {
            e6 instanceof Error ? __privateGet(this, _Oi).reject(e6) : __privateGet(this, _Oi).resolve({ password: e6 });
          };
          try {
            t4.onPassword(updatePassword, e5.code);
          } catch (e6) {
            __privateGet(this, _Oi).reject(e6);
          }
        } else __privateGet(this, _Oi).reject(new PasswordException2(e5.message, e5.code));
        return __privateGet(this, _Oi).promise;
      }), e4.on("DataLoaded", (e5) => {
        t4.onProgress?.({ loaded: e5.length, total: e5.length }), this.downloadInfoCapability.resolve(e5);
      }), e4.on("StartRenderPage", (e5) => {
        if (this.destroyed) return;
        __privateGet(this, _Ji).get(e5.pageIndex)._startRenderPage(e5.transparency, e5.cacheKey);
      }), e4.on("commonobj", ([t5, i4, a4]) => {
        if (this.destroyed) return null;
        if (this.commonObjs.has(t5)) return null;
        switch (i4) {
          case "Font":
            const { disableFontFace: s4, fontExtraProperties: n4, pdfBug: r4 } = this._params;
            if ("error" in a4) {
              const e5 = a4.error;
              warn2(`Error during font loading: ${e5}`), this.commonObjs.resolve(t5, e5);
              break;
            }
            const o4 = r4 && globalThis.FontInspector?.enabled ? (e5, t6) => globalThis.FontInspector.fontAdded(e5, t6) : null, g4 = new FontFaceObject(a4, { disableFontFace: s4, inspectFont: o4 });
            this.fontLoader.bind(g4).catch(() => e4.sendWithPromise("FontFallback", { id: t5 })).finally(() => {
              !n4 && g4.data && (g4.data = null), this.commonObjs.resolve(t5, g4);
            });
            break;
          case "CopyLocalImage":
            const { imageRef: c4 } = a4;
            assert2(c4, "The imageRef must be defined.");
            for (const e5 of __privateGet(this, _Ji).values()) for (const [, i5] of e5.objs) if (i5?.ref === c4) return i5.dataLen ? (this.commonObjs.resolve(t5, structuredClone(i5)), i5.dataLen) : null;
            break;
          case "FontPath":
          case "Image":
          case "Pattern":
            this.commonObjs.resolve(t5, a4);
            break;
          default:
            throw new Error(`Got unknown common object type ${i4}`);
        }
        return null;
      }), e4.on("obj", ([e5, t5, i4, a4]) => {
        if (this.destroyed) return;
        const s4 = __privateGet(this, _Ji).get(t5);
        if (!s4.objs.has(e5)) if (0 !== s4._intentStates.size) switch (i4) {
          case "Image":
            s4.objs.resolve(e5, a4), a4?.dataLen > 1e7 && (s4._maybeCleanupAfterRender = true);
            break;
          case "Pattern":
            s4.objs.resolve(e5, a4);
            break;
          default:
            throw new Error(`Got unknown object type ${i4}`);
        }
        else a4?.bitmap?.close();
      }), e4.on("DocProgress", (e5) => {
        this.destroyed || t4.onProgress?.({ loaded: e5.loaded, total: e5.total });
      }), e4.on("FetchBuiltInCMap", (e5) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.cMapReaderFactory ? this.cMapReaderFactory.fetch(e5) : Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."))), e4.on("FetchStandardFontData", (e5) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.standardFontDataFactory ? this.standardFontDataFactory.fetch(e5) : Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.")));
    }
    getData() {
      return this.messageHandler.sendWithPromise("GetData", null);
    }
    saveDocument() {
      this.annotationStorage.size <= 0 && warn2("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
      const { map: e4, transfer: t4 } = this.annotationStorage.serializable;
      return this.messageHandler.sendWithPromise("SaveDocument", { isPureXfa: !!this._htmlForXfa, numPages: this._numPages, annotationStorage: e4, filename: this._fullReader?.filename ?? null }, t4).finally(() => {
        this.annotationStorage.resetModified();
      });
    }
    getPage(e4) {
      if (!Number.isInteger(e4) || e4 <= 0 || e4 > this._numPages) return Promise.reject(new Error("Invalid page request."));
      const t4 = e4 - 1, i4 = __privateGet(this, _Yi).get(t4);
      if (i4) return i4;
      const a4 = this.messageHandler.sendWithPromise("GetPage", { pageIndex: t4 }).then((i5) => {
        if (this.destroyed) throw new Error("Transport destroyed");
        i5.refStr && __privateGet(this, _Pi).set(i5.refStr, e4);
        const a5 = new PDFPageProxy(t4, i5, this, this._params.pdfBug);
        return __privateGet(this, _Ji).set(t4, a5), a5;
      });
      return __privateGet(this, _Yi).set(t4, a4), a4;
    }
    getPageIndex(e4) {
      return isRefProxy(e4) ? this.messageHandler.sendWithPromise("GetPageIndex", { num: e4.num, gen: e4.gen }) : Promise.reject(new Error("Invalid pageIndex request."));
    }
    getAnnotations(e4, t4) {
      return this.messageHandler.sendWithPromise("GetAnnotations", { pageIndex: e4, intent: t4 });
    }
    getFieldObjects() {
      return __privateMethod(this, _WorkerTransport_instances, Ki_fn).call(this, "GetFieldObjects");
    }
    hasJSActions() {
      return __privateMethod(this, _WorkerTransport_instances, Ki_fn).call(this, "HasJSActions");
    }
    getCalculationOrderIds() {
      return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
    }
    getDestinations() {
      return this.messageHandler.sendWithPromise("GetDestinations", null);
    }
    getDestination(e4) {
      return "string" != typeof e4 ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", { id: e4 });
    }
    getPageLabels() {
      return this.messageHandler.sendWithPromise("GetPageLabels", null);
    }
    getPageLayout() {
      return this.messageHandler.sendWithPromise("GetPageLayout", null);
    }
    getPageMode() {
      return this.messageHandler.sendWithPromise("GetPageMode", null);
    }
    getViewerPreferences() {
      return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
    }
    getOpenAction() {
      return this.messageHandler.sendWithPromise("GetOpenAction", null);
    }
    getAttachments() {
      return this.messageHandler.sendWithPromise("GetAttachments", null);
    }
    getDocJSActions() {
      return __privateMethod(this, _WorkerTransport_instances, Ki_fn).call(this, "GetDocJSActions");
    }
    getPageJSActions(e4) {
      return this.messageHandler.sendWithPromise("GetPageJSActions", { pageIndex: e4 });
    }
    getStructTree(e4) {
      return this.messageHandler.sendWithPromise("GetStructTree", { pageIndex: e4 });
    }
    getOutline() {
      return this.messageHandler.sendWithPromise("GetOutline", null);
    }
    getOptionalContentConfig(e4) {
      return __privateMethod(this, _WorkerTransport_instances, Ki_fn).call(this, "GetOptionalContentConfig").then((t4) => new OptionalContentConfig(t4, e4));
    }
    getPermissions() {
      return this.messageHandler.sendWithPromise("GetPermissions", null);
    }
    getMetadata() {
      const e4 = "GetMetadata", t4 = __privateGet(this, _Ti).get(e4);
      if (t4) return t4;
      const i4 = this.messageHandler.sendWithPromise(e4, null).then((e5) => ({ info: e5[0], metadata: e5[1] ? new Metadata(e5[1]) : null, contentDispositionFilename: this._fullReader?.filename ?? null, contentLength: this._fullReader?.contentLength ?? null }));
      return __privateGet(this, _Ti).set(e4, i4), i4;
    }
    getMarkInfo() {
      return this.messageHandler.sendWithPromise("GetMarkInfo", null);
    }
    async startCleanup(e4 = false) {
      if (!this.destroyed) {
        await this.messageHandler.sendWithPromise("Cleanup", null);
        for (const e5 of __privateGet(this, _Ji).values()) {
          if (!e5.cleanup()) throw new Error(`startCleanup: Page ${e5.pageNumber} is currently rendering.`);
        }
        this.commonObjs.clear(), e4 || this.fontLoader.clear(), __privateGet(this, _Ti).clear(), this.filterFactory.destroy(true), TextLayer.cleanup();
      }
    }
    cachedPageNumber(e4) {
      if (!isRefProxy(e4)) return null;
      const t4 = 0 === e4.gen ? `${e4.num}R` : `${e4.num}R${e4.gen}`;
      return __privateGet(this, _Pi).get(t4) ?? null;
    }
  }
  _Ti = new WeakMap();
  _Ji = new WeakMap();
  _Yi = new WeakMap();
  _Pi = new WeakMap();
  _Oi = new WeakMap();
  _WorkerTransport_instances = new WeakSet();
  Ki_fn = function(e4, t4 = null) {
    const i4 = __privateGet(this, _Ti).get(e4);
    if (i4) return i4;
    const a4 = this.messageHandler.sendWithPromise(e4, t4);
    return __privateGet(this, _Ti).set(e4, a4), a4;
  };
  const et3 = Symbol("INITIAL_DATA");
  class PDFObjects {
    constructor() {
      __privateAdd(this, _PDFObjects_instances);
      __privateAdd(this, _qi, /* @__PURE__ */ Object.create(null));
    }
    get(e4, t4 = null) {
      if (t4) {
        const i5 = __privateMethod(this, _PDFObjects_instances, _i_fn).call(this, e4);
        return i5.promise.then(() => t4(i5.data)), null;
      }
      const i4 = __privateGet(this, _qi)[e4];
      if (!i4 || i4.data === et3) throw new Error(`Requesting object that isn't resolved yet ${e4}.`);
      return i4.data;
    }
    has(e4) {
      const t4 = __privateGet(this, _qi)[e4];
      return !!t4 && t4.data !== et3;
    }
    resolve(e4, t4 = null) {
      const i4 = __privateMethod(this, _PDFObjects_instances, _i_fn).call(this, e4);
      i4.data = t4, i4.resolve();
    }
    clear() {
      for (const e4 in __privateGet(this, _qi)) {
        const { data: t4 } = __privateGet(this, _qi)[e4];
        t4?.bitmap?.close();
      }
      __privateSet(this, _qi, /* @__PURE__ */ Object.create(null));
    }
    *[Symbol.iterator]() {
      for (const e4 in __privateGet(this, _qi)) {
        const { data: t4 } = __privateGet(this, _qi)[e4];
        t4 !== et3 && (yield [e4, t4]);
      }
    }
  }
  _qi = new WeakMap();
  _PDFObjects_instances = new WeakSet();
  _i_fn = function(e4) {
    var _a5;
    return (_a5 = __privateGet(this, _qi))[e4] || (_a5[e4] = { ...Promise.withResolvers(), data: et3 });
  };
  class RenderTask {
    constructor(e4) {
      __privateAdd(this, _Wi, null);
      __privateSet(this, _Wi, e4), this.onContinue = null;
    }
    get promise() {
      return __privateGet(this, _Wi).capability.promise;
    }
    cancel(e4 = 0) {
      __privateGet(this, _Wi).cancel(null, e4);
    }
    get separateAnnots() {
      const { separateAnnots: e4 } = __privateGet(this, _Wi).operatorList;
      if (!e4) return false;
      const { annotationCanvasMap: t4 } = __privateGet(this, _Wi);
      return e4.form || e4.canvas && t4?.size > 0;
    }
  }
  _Wi = new WeakMap();
  const _InternalRenderTask = class _InternalRenderTask {
    constructor({ callback: e4, params: t4, objs: i4, commonObjs: a4, annotationCanvasMap: s4, operatorList: n4, pageIndex: r4, canvasFactory: o4, filterFactory: g4, useRequestAnimationFrame: c4 = false, pdfBug: h4 = false, pageColors: l4 = null }) {
      __privateAdd(this, _ji, null);
      this.callback = e4, this.params = t4, this.objs = i4, this.commonObjs = a4, this.annotationCanvasMap = s4, this.operatorListIdx = null, this.operatorList = n4, this._pageIndex = r4, this.canvasFactory = o4, this.filterFactory = g4, this._pdfBug = h4, this.pageColors = l4, this.running = false, this.graphicsReadyCallback = null, this.graphicsReady = false, this._useRequestAnimationFrame = true === c4 && false, this.cancelled = false, this.capability = Promise.withResolvers(), this.task = new RenderTask(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = t4.canvasContext.canvas;
    }
    get completed() {
      return this.capability.promise.catch(function() {
      });
    }
    initializeGraphics({ transparency: e4 = false, optionalContentConfig: t4 }) {
      if (this.cancelled) return;
      if (this._canvas) {
        if (__privateGet(_InternalRenderTask, _Xi).has(this._canvas)) throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
        __privateGet(_InternalRenderTask, _Xi).add(this._canvas);
      }
      this._pdfBug && globalThis.StepperManager?.enabled && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
      const { canvasContext: i4, viewport: a4, transform: s4, background: n4 } = this.params;
      this.gfx = new CanvasGraphics(i4, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, { optionalContentConfig: t4 }, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({ transform: s4, viewport: a4, transparency: e4, background: n4 }), this.operatorListIdx = 0, this.graphicsReady = true, this.graphicsReadyCallback?.();
    }
    cancel(e4 = null, t4 = 0) {
      this.running = false, this.cancelled = true, this.gfx?.endDrawing(), __privateGet(this, _ji) && (window.cancelAnimationFrame(__privateGet(this, _ji)), __privateSet(this, _ji, null)), __privateGet(_InternalRenderTask, _Xi).delete(this._canvas), this.callback(e4 || new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, t4));
    }
    operatorListChanged() {
      this.graphicsReady ? (this.stepper?.updateOperatorList(this.operatorList), this.running || this._continue()) : this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
    }
    _continue() {
      this.running = true, this.cancelled || (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
    }
    _scheduleNext() {
      this._useRequestAnimationFrame ? __privateSet(this, _ji, window.requestAnimationFrame(() => {
        __privateSet(this, _ji, null), this._nextBound().catch(this._cancelBound);
      })) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
    }
    async _next() {
      this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = false, this.operatorList.lastChunk && (this.gfx.endDrawing(), __privateGet(_InternalRenderTask, _Xi).delete(this._canvas), this.callback())));
    }
  };
  _ji = new WeakMap();
  _Xi = new WeakMap();
  __privateAdd(_InternalRenderTask, _Xi, /* @__PURE__ */ new WeakSet());
  let InternalRenderTask = _InternalRenderTask;
  const tt3 = "4.6.82", At3 = "9b541910f";
  function makeColorComp(e4) {
    return Math.floor(255 * Math.max(0, Math.min(1, e4))).toString(16).padStart(2, "0");
  }
  function scaleAndClamp(e4) {
    return Math.max(0, Math.min(255, 255 * e4));
  }
  class ColorConverters {
    static CMYK_G([e4, t4, i4, a4]) {
      return ["G", 1 - Math.min(1, 0.3 * e4 + 0.59 * i4 + 0.11 * t4 + a4)];
    }
    static G_CMYK([e4]) {
      return ["CMYK", 0, 0, 0, 1 - e4];
    }
    static G_RGB([e4]) {
      return ["RGB", e4, e4, e4];
    }
    static G_rgb([e4]) {
      return [e4 = scaleAndClamp(e4), e4, e4];
    }
    static G_HTML([e4]) {
      const t4 = makeColorComp(e4);
      return `#${t4}${t4}${t4}`;
    }
    static RGB_G([e4, t4, i4]) {
      return ["G", 0.3 * e4 + 0.59 * t4 + 0.11 * i4];
    }
    static RGB_rgb(e4) {
      return e4.map(scaleAndClamp);
    }
    static RGB_HTML(e4) {
      return `#${e4.map(makeColorComp).join("")}`;
    }
    static T_HTML() {
      return "#00000000";
    }
    static T_rgb() {
      return [null];
    }
    static CMYK_RGB([e4, t4, i4, a4]) {
      return ["RGB", 1 - Math.min(1, e4 + a4), 1 - Math.min(1, i4 + a4), 1 - Math.min(1, t4 + a4)];
    }
    static CMYK_rgb([e4, t4, i4, a4]) {
      return [scaleAndClamp(1 - Math.min(1, e4 + a4)), scaleAndClamp(1 - Math.min(1, i4 + a4)), scaleAndClamp(1 - Math.min(1, t4 + a4))];
    }
    static CMYK_HTML(e4) {
      const t4 = this.CMYK_RGB(e4).slice(1);
      return this.RGB_HTML(t4);
    }
    static RGB_CMYK([e4, t4, i4]) {
      const a4 = 1 - e4, s4 = 1 - t4, n4 = 1 - i4;
      return ["CMYK", a4, s4, n4, Math.min(a4, s4, n4)];
    }
  }
  class XfaLayer {
    static setupStorage(e4, t4, i4, a4, s4) {
      const n4 = a4.getValue(t4, { value: null });
      switch (i4.name) {
        case "textarea":
          if (null !== n4.value && (e4.textContent = n4.value), "print" === s4) break;
          e4.addEventListener("input", (e5) => {
            a4.setValue(t4, { value: e5.target.value });
          });
          break;
        case "input":
          if ("radio" === i4.attributes.type || "checkbox" === i4.attributes.type) {
            if (n4.value === i4.attributes.xfaOn ? e4.setAttribute("checked", true) : n4.value === i4.attributes.xfaOff && e4.removeAttribute("checked"), "print" === s4) break;
            e4.addEventListener("change", (e5) => {
              a4.setValue(t4, { value: e5.target.checked ? e5.target.getAttribute("xfaOn") : e5.target.getAttribute("xfaOff") });
            });
          } else {
            if (null !== n4.value && e4.setAttribute("value", n4.value), "print" === s4) break;
            e4.addEventListener("input", (e5) => {
              a4.setValue(t4, { value: e5.target.value });
            });
          }
          break;
        case "select":
          if (null !== n4.value) {
            e4.setAttribute("value", n4.value);
            for (const e5 of i4.children) e5.attributes.value === n4.value ? e5.attributes.selected = true : e5.attributes.hasOwnProperty("selected") && delete e5.attributes.selected;
          }
          e4.addEventListener("input", (e5) => {
            const i5 = e5.target.options, s5 = -1 === i5.selectedIndex ? "" : i5[i5.selectedIndex].value;
            a4.setValue(t4, { value: s5 });
          });
      }
    }
    static setAttributes({ html: e4, element: t4, storage: i4 = null, intent: a4, linkService: s4 }) {
      const { attributes: n4 } = t4, r4 = e4 instanceof HTMLAnchorElement;
      "radio" === n4.type && (n4.name = `${n4.name}-${a4}`);
      for (const [t5, i5] of Object.entries(n4)) if (null != i5) switch (t5) {
        case "class":
          i5.length && e4.setAttribute(t5, i5.join(" "));
          break;
        case "dataId":
          break;
        case "id":
          e4.setAttribute("data-element-id", i5);
          break;
        case "style":
          Object.assign(e4.style, i5);
          break;
        case "textContent":
          e4.textContent = i5;
          break;
        default:
          (!r4 || "href" !== t5 && "newWindow" !== t5) && e4.setAttribute(t5, i5);
      }
      r4 && s4.addLinkAttributes(e4, n4.href, n4.newWindow), i4 && n4.dataId && this.setupStorage(e4, n4.dataId, t4, i4);
    }
    static render(e4) {
      const t4 = e4.annotationStorage, i4 = e4.linkService, a4 = e4.xfaHtml, s4 = e4.intent || "display", n4 = document.createElement(a4.name);
      a4.attributes && this.setAttributes({ html: n4, element: a4, intent: s4, linkService: i4 });
      const r4 = "richText" !== s4, o4 = e4.div;
      if (o4.append(n4), e4.viewport) {
        const t5 = `matrix(${e4.viewport.transform.join(",")})`;
        o4.style.transform = t5;
      }
      r4 && o4.setAttribute("class", "xfaLayer xfaFont");
      const g4 = [];
      if (0 === a4.children.length) {
        if (a4.value) {
          const e5 = document.createTextNode(a4.value);
          n4.append(e5), r4 && XfaText.shouldBuildText(a4.name) && g4.push(e5);
        }
        return { textDivs: g4 };
      }
      const c4 = [[a4, -1, n4]];
      for (; c4.length > 0; ) {
        const [e5, a5, n5] = c4.at(-1);
        if (a5 + 1 === e5.children.length) {
          c4.pop();
          continue;
        }
        const o5 = e5.children[++c4.at(-1)[1]];
        if (null === o5) continue;
        const { name: h4 } = o5;
        if ("#text" === h4) {
          const e6 = document.createTextNode(o5.value);
          g4.push(e6), n5.append(e6);
          continue;
        }
        const l4 = o5?.attributes?.xmlns ? document.createElementNS(o5.attributes.xmlns, h4) : document.createElement(h4);
        if (n5.append(l4), o5.attributes && this.setAttributes({ html: l4, element: o5, storage: t4, intent: s4, linkService: i4 }), o5.children?.length > 0) c4.push([o5, -1, l4]);
        else if (o5.value) {
          const e6 = document.createTextNode(o5.value);
          r4 && XfaText.shouldBuildText(h4) && g4.push(e6), l4.append(e6);
        }
      }
      for (const e5 of o4.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) e5.setAttribute("readOnly", true);
      return { textDivs: g4 };
    }
    static update(e4) {
      const t4 = `matrix(${e4.viewport.transform.join(",")})`;
      e4.div.style.transform = t4, e4.div.hidden = false;
    }
  }
  const it3 = 1e3, at3 = /* @__PURE__ */ new WeakSet();
  function getRectDims(e4) {
    return { width: e4[2] - e4[0], height: e4[3] - e4[1] };
  }
  class AnnotationElementFactory {
    static create(e4) {
      switch (e4.data.annotationType) {
        case R3:
          return new LinkAnnotationElement(e4);
        case k3:
          return new TextAnnotationElement(e4);
        case W3:
          switch (e4.data.fieldType) {
            case "Tx":
              return new TextWidgetAnnotationElement(e4);
            case "Btn":
              return e4.data.radioButton ? new RadioButtonWidgetAnnotationElement(e4) : e4.data.checkBox ? new CheckboxWidgetAnnotationElement(e4) : new PushButtonWidgetAnnotationElement(e4);
            case "Ch":
              return new ChoiceWidgetAnnotationElement(e4);
            case "Sig":
              return new SignatureWidgetAnnotationElement(e4);
          }
          return new WidgetAnnotationElement(e4);
        case q3:
          return new PopupAnnotationElement(e4);
        case x3:
          return new FreeTextAnnotationElement(e4);
        case N3:
          return new LineAnnotationElement(e4);
        case M3:
          return new SquareAnnotationElement(e4);
        case G3:
          return new CircleAnnotationElement(e4);
        case L3:
          return new PolylineAnnotationElement(e4);
        case O3:
          return new CaretAnnotationElement(e4);
        case K3:
          return new InkAnnotationElement(e4);
        case v3:
          return new PolygonAnnotationElement(e4);
        case U3:
          return new HighlightAnnotationElement(e4);
        case H3:
          return new UnderlineAnnotationElement(e4);
        case T3:
          return new SquigglyAnnotationElement(e4);
        case J3:
          return new StrikeOutAnnotationElement(e4);
        case Y3:
          return new StampAnnotationElement(e4);
        case _3:
          return new FileAttachmentAnnotationElement(e4);
        default:
          return new AnnotationElement(e4);
      }
    }
  }
  const _AnnotationElement = class _AnnotationElement {
    constructor(e4, { isRenderable: t4 = false, ignoreBorder: i4 = false, createQuadrilaterals: a4 = false } = {}) {
      __privateAdd(this, _AnnotationElement_instances);
      __privateAdd(this, _Vi, null);
      __privateAdd(this, _Zi, false);
      __privateAdd(this, _zi, null);
      this.isRenderable = t4, this.data = e4.data, this.layer = e4.layer, this.linkService = e4.linkService, this.downloadManager = e4.downloadManager, this.imageResourcesPath = e4.imageResourcesPath, this.renderForms = e4.renderForms, this.svgFactory = e4.svgFactory, this.annotationStorage = e4.annotationStorage, this.enableScripting = e4.enableScripting, this.hasJSActions = e4.hasJSActions, this._fieldObjects = e4.fieldObjects, this.parent = e4.parent, t4 && (this.container = this._createContainer(i4)), a4 && this._createQuadrilaterals();
    }
    static _hasPopupData({ titleObj: e4, contentsObj: t4, richText: i4 }) {
      return !!(e4?.str || t4?.str || i4?.str);
    }
    get _isEditable() {
      return this.data.isEditable;
    }
    get hasPopupData() {
      return _AnnotationElement._hasPopupData(this.data);
    }
    updateEdited(e4) {
      if (!this.container) return;
      __privateGet(this, _Vi) || __privateSet(this, _Vi, { rect: this.data.rect.slice(0) });
      const { rect: t4 } = e4;
      t4 && __privateMethod(this, _AnnotationElement_instances, $i_fn).call(this, t4), __privateGet(this, _zi)?.popup.updateEdited(e4);
    }
    resetEdited() {
      __privateGet(this, _Vi) && (__privateMethod(this, _AnnotationElement_instances, $i_fn).call(this, __privateGet(this, _Vi).rect), __privateGet(this, _zi)?.popup.resetEdited(), __privateSet(this, _Vi, null));
    }
    _createContainer(e4) {
      const { data: t4, parent: { page: i4, viewport: a4 } } = this, s4 = document.createElement("section");
      s4.setAttribute("data-annotation-id", t4.id), this instanceof WidgetAnnotationElement || (s4.tabIndex = it3);
      const { style: n4 } = s4;
      if (n4.zIndex = this.parent.zIndex++, t4.popupRef && s4.setAttribute("aria-haspopup", "dialog"), t4.alternativeText && (s4.title = t4.alternativeText), t4.noRotate && s4.classList.add("norotate"), !t4.rect || this instanceof PopupAnnotationElement) {
        const { rotation: e5 } = t4;
        return t4.hasOwnCanvas || 0 === e5 || this.setRotation(e5, s4), s4;
      }
      const { width: r4, height: o4 } = getRectDims(t4.rect);
      if (!e4 && t4.borderStyle.width > 0) {
        n4.borderWidth = `${t4.borderStyle.width}px`;
        const e5 = t4.borderStyle.horizontalCornerRadius, i5 = t4.borderStyle.verticalCornerRadius;
        if (e5 > 0 || i5 > 0) {
          const t5 = `calc(${e5}px * var(--scale-factor)) / calc(${i5}px * var(--scale-factor))`;
          n4.borderRadius = t5;
        } else if (this instanceof RadioButtonWidgetAnnotationElement) {
          const e6 = `calc(${r4}px * var(--scale-factor)) / calc(${o4}px * var(--scale-factor))`;
          n4.borderRadius = e6;
        }
        switch (t4.borderStyle.style) {
          case j3:
            n4.borderStyle = "solid";
            break;
          case X3:
            n4.borderStyle = "dashed";
            break;
          case V3:
            warn2("Unimplemented border style: beveled");
            break;
          case Z3:
            warn2("Unimplemented border style: inset");
            break;
          case z3:
            n4.borderBottomStyle = "solid";
        }
        const a5 = t4.borderColor || null;
        a5 ? (__privateSet(this, _Zi, true), n4.borderColor = Util2.makeHexColor(0 | a5[0], 0 | a5[1], 0 | a5[2])) : n4.borderWidth = 0;
      }
      const g4 = Util2.normalizeRect([t4.rect[0], i4.view[3] - t4.rect[1] + i4.view[1], t4.rect[2], i4.view[3] - t4.rect[3] + i4.view[1]]), { pageWidth: c4, pageHeight: h4, pageX: l4, pageY: C4 } = a4.rawDims;
      n4.left = 100 * (g4[0] - l4) / c4 + "%", n4.top = 100 * (g4[1] - C4) / h4 + "%";
      const { rotation: d4 } = t4;
      return t4.hasOwnCanvas || 0 === d4 ? (n4.width = 100 * r4 / c4 + "%", n4.height = 100 * o4 / h4 + "%") : this.setRotation(d4, s4), s4;
    }
    setRotation(e4, t4 = this.container) {
      if (!this.data.rect) return;
      const { pageWidth: i4, pageHeight: a4 } = this.parent.viewport.rawDims, { width: s4, height: n4 } = getRectDims(this.data.rect);
      let r4, o4;
      e4 % 180 == 0 ? (r4 = 100 * s4 / i4, o4 = 100 * n4 / a4) : (r4 = 100 * n4 / i4, o4 = 100 * s4 / a4), t4.style.width = `${r4}%`, t4.style.height = `${o4}%`, t4.setAttribute("data-main-rotation", (360 - e4) % 360);
    }
    get _commonActions() {
      const setColor = (e4, t4, i4) => {
        const a4 = i4.detail[e4], s4 = a4[0], n4 = a4.slice(1);
        i4.target.style[t4] = ColorConverters[`${s4}_HTML`](n4), this.annotationStorage.setValue(this.data.id, { [t4]: ColorConverters[`${s4}_rgb`](n4) });
      };
      return shadow2(this, "_commonActions", { display: (e4) => {
        const { display: t4 } = e4.detail, i4 = t4 % 2 == 1;
        this.container.style.visibility = i4 ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, { noView: i4, noPrint: 1 === t4 || 2 === t4 });
      }, print: (e4) => {
        this.annotationStorage.setValue(this.data.id, { noPrint: !e4.detail.print });
      }, hidden: (e4) => {
        const { hidden: t4 } = e4.detail;
        this.container.style.visibility = t4 ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, { noPrint: t4, noView: t4 });
      }, focus: (e4) => {
        setTimeout(() => e4.target.focus({ preventScroll: false }), 0);
      }, userName: (e4) => {
        e4.target.title = e4.detail.userName;
      }, readonly: (e4) => {
        e4.target.disabled = e4.detail.readonly;
      }, required: (e4) => {
        this._setRequired(e4.target, e4.detail.required);
      }, bgColor: (e4) => {
        setColor("bgColor", "backgroundColor", e4);
      }, fillColor: (e4) => {
        setColor("fillColor", "backgroundColor", e4);
      }, fgColor: (e4) => {
        setColor("fgColor", "color", e4);
      }, textColor: (e4) => {
        setColor("textColor", "color", e4);
      }, borderColor: (e4) => {
        setColor("borderColor", "borderColor", e4);
      }, strokeColor: (e4) => {
        setColor("strokeColor", "borderColor", e4);
      }, rotation: (e4) => {
        const t4 = e4.detail.rotation;
        this.setRotation(t4), this.annotationStorage.setValue(this.data.id, { rotation: t4 });
      } });
    }
    _dispatchEventFromSandbox(e4, t4) {
      const i4 = this._commonActions;
      for (const a4 of Object.keys(t4.detail)) {
        const s4 = e4[a4] || i4[a4];
        s4?.(t4);
      }
    }
    _setDefaultPropertiesFromJS(e4) {
      if (!this.enableScripting) return;
      const t4 = this.annotationStorage.getRawValue(this.data.id);
      if (!t4) return;
      const i4 = this._commonActions;
      for (const [a4, s4] of Object.entries(t4)) {
        const n4 = i4[a4];
        if (n4) {
          n4({ detail: { [a4]: s4 }, target: e4 }), delete t4[a4];
        }
      }
    }
    _createQuadrilaterals() {
      if (!this.container) return;
      const { quadPoints: e4 } = this.data;
      if (!e4) return;
      const [t4, i4, a4, s4] = this.data.rect.map((e5) => Math.fround(e5));
      if (8 === e4.length) {
        const [n5, r5, o5, g5] = e4.subarray(2, 6);
        if (a4 === n5 && s4 === r5 && t4 === o5 && i4 === g5) return;
      }
      const { style: n4 } = this.container;
      let r4;
      if (__privateGet(this, _Zi)) {
        const { borderColor: e5, borderWidth: t5 } = n4;
        n4.borderWidth = 0, r4 = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${e5}" stroke-width="${t5}">`], this.container.classList.add("hasBorder");
      }
      const o4 = a4 - t4, g4 = s4 - i4, { svgFactory: c4 } = this, h4 = c4.createElement("svg");
      h4.classList.add("quadrilateralsContainer"), h4.setAttribute("width", 0), h4.setAttribute("height", 0);
      const l4 = c4.createElement("defs");
      h4.append(l4);
      const C4 = c4.createElement("clipPath"), d4 = `clippath_${this.data.id}`;
      C4.setAttribute("id", d4), C4.setAttribute("clipPathUnits", "objectBoundingBox"), l4.append(C4);
      for (let i5 = 2, a5 = e4.length; i5 < a5; i5 += 8) {
        const a6 = e4[i5], n5 = e4[i5 + 1], h5 = e4[i5 + 2], l5 = e4[i5 + 3], d5 = c4.createElement("rect"), u4 = (h5 - t4) / o4, Q4 = (s4 - n5) / g4, f4 = (a6 - h5) / o4, p4 = (n5 - l5) / g4;
        d5.setAttribute("x", u4), d5.setAttribute("y", Q4), d5.setAttribute("width", f4), d5.setAttribute("height", p4), C4.append(d5), r4?.push(`<rect vector-effect="non-scaling-stroke" x="${u4}" y="${Q4}" width="${f4}" height="${p4}"/>`);
      }
      __privateGet(this, _Zi) && (r4.push("</g></svg>')"), n4.backgroundImage = r4.join("")), this.container.append(h4), this.container.style.clipPath = `url(#${d4})`;
    }
    _createPopup() {
      const { container: e4, data: t4 } = this;
      e4.setAttribute("aria-haspopup", "dialog");
      const i4 = __privateSet(this, _zi, new PopupAnnotationElement({ data: { color: t4.color, titleObj: t4.titleObj, modificationDate: t4.modificationDate, contentsObj: t4.contentsObj, richText: t4.richText, parentRect: t4.rect, borderStyle: 0, id: `popup_${t4.id}`, rotation: t4.rotation }, parent: this.parent, elements: [this] }));
      this.parent.div.append(i4.render());
    }
    render() {
      unreachable2("Abstract method `AnnotationElement.render` called");
    }
    _getElementsByName(e4, t4 = null) {
      const i4 = [];
      if (this._fieldObjects) {
        const a4 = this._fieldObjects[e4];
        if (a4) for (const { page: e5, id: s4, exportValues: n4 } of a4) {
          if (-1 === e5) continue;
          if (s4 === t4) continue;
          const a5 = "string" == typeof n4 ? n4 : null, r4 = document.querySelector(`[data-element-id="${s4}"]`);
          !r4 || at3.has(r4) ? i4.push({ id: s4, exportValue: a5, domElement: r4 }) : warn2(`_getElementsByName - element not allowed: ${s4}`);
        }
        return i4;
      }
      for (const a4 of document.getElementsByName(e4)) {
        const { exportValue: e5 } = a4, s4 = a4.getAttribute("data-element-id");
        s4 !== t4 && (at3.has(a4) && i4.push({ id: s4, exportValue: e5, domElement: a4 }));
      }
      return i4;
    }
    show() {
      this.container && (this.container.hidden = false), this.popup?.maybeShow();
    }
    hide() {
      this.container && (this.container.hidden = true), this.popup?.forceHide();
    }
    getElementsToTriggerPopup() {
      return this.container;
    }
    addHighlightArea() {
      const e4 = this.getElementsToTriggerPopup();
      if (Array.isArray(e4)) for (const t4 of e4) t4.classList.add("highlightArea");
      else e4.classList.add("highlightArea");
    }
    _editOnDoubleClick() {
      if (!this._isEditable) return;
      const { annotationEditorType: e4, data: { id: t4 } } = this;
      this.container.addEventListener("dblclick", () => {
        this.linkService.eventBus?.dispatch("switchannotationeditormode", { source: this, mode: e4, editId: t4 });
      });
    }
  };
  _Vi = new WeakMap();
  _Zi = new WeakMap();
  _zi = new WeakMap();
  _AnnotationElement_instances = new WeakSet();
  $i_fn = function(e4) {
    const { container: { style: t4 }, data: { rect: i4, rotation: a4 }, parent: { viewport: { rawDims: { pageWidth: s4, pageHeight: n4, pageX: r4, pageY: o4 } } } } = this;
    i4?.splice(0, 4, ...e4);
    const { width: g4, height: c4 } = getRectDims(e4);
    t4.left = 100 * (e4[0] - r4) / s4 + "%", t4.top = 100 * (n4 - e4[3] + o4) / n4 + "%", 0 === a4 ? (t4.width = 100 * g4 / s4 + "%", t4.height = 100 * c4 / n4 + "%") : this.setRotation(a4);
  };
  let AnnotationElement = _AnnotationElement;
  class LinkAnnotationElement extends AnnotationElement {
    constructor(e4, t4 = null) {
      super(e4, { isRenderable: true, ignoreBorder: !!t4?.ignoreBorder, createQuadrilaterals: true });
      __privateAdd(this, _LinkAnnotationElement_instances);
      this.isTooltipOnly = e4.data.isTooltipOnly;
    }
    render() {
      const { data: e4, linkService: t4 } = this, i4 = document.createElement("a");
      i4.setAttribute("data-element-id", e4.id);
      let a4 = false;
      return e4.url ? (t4.addLinkAttributes(i4, e4.url, e4.newWindow), a4 = true) : e4.action ? (this._bindNamedAction(i4, e4.action), a4 = true) : e4.attachment ? (__privateMethod(this, _LinkAnnotationElement_instances, ea_fn).call(this, i4, e4.attachment, e4.attachmentDest), a4 = true) : e4.setOCGState ? (__privateMethod(this, _LinkAnnotationElement_instances, ta_fn).call(this, i4, e4.setOCGState), a4 = true) : e4.dest ? (this._bindLink(i4, e4.dest), a4 = true) : (e4.actions && (e4.actions.Action || e4.actions["Mouse Up"] || e4.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(i4, e4), a4 = true), e4.resetForm ? (this._bindResetFormAction(i4, e4.resetForm), a4 = true) : this.isTooltipOnly && !a4 && (this._bindLink(i4, ""), a4 = true)), this.container.classList.add("linkAnnotation"), a4 && this.container.append(i4), this.container;
    }
    _bindLink(e4, t4) {
      e4.href = this.linkService.getDestinationHash(t4), e4.onclick = () => (t4 && this.linkService.goToDestination(t4), false), (t4 || "" === t4) && __privateMethod(this, _LinkAnnotationElement_instances, Aa_fn).call(this);
    }
    _bindNamedAction(e4, t4) {
      e4.href = this.linkService.getAnchorUrl(""), e4.onclick = () => (this.linkService.executeNamedAction(t4), false), __privateMethod(this, _LinkAnnotationElement_instances, Aa_fn).call(this);
    }
    _bindJSAction(e4, t4) {
      e4.href = this.linkService.getAnchorUrl("");
      const i4 = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
      for (const a4 of Object.keys(t4.actions)) {
        const s4 = i4.get(a4);
        s4 && (e4[s4] = () => (this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: t4.id, name: a4 } }), false));
      }
      e4.onclick || (e4.onclick = () => false), __privateMethod(this, _LinkAnnotationElement_instances, Aa_fn).call(this);
    }
    _bindResetFormAction(e4, t4) {
      const i4 = e4.onclick;
      if (i4 || (e4.href = this.linkService.getAnchorUrl("")), __privateMethod(this, _LinkAnnotationElement_instances, Aa_fn).call(this), !this._fieldObjects) return warn2('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), void (i4 || (e4.onclick = () => false));
      e4.onclick = () => {
        i4?.();
        const { fields: e5, refs: a4, include: s4 } = t4, n4 = [];
        if (0 !== e5.length || 0 !== a4.length) {
          const t5 = new Set(a4);
          for (const i5 of e5) {
            const e6 = this._fieldObjects[i5] || [];
            for (const { id: i6 } of e6) t5.add(i6);
          }
          for (const e6 of Object.values(this._fieldObjects)) for (const i5 of e6) t5.has(i5.id) === s4 && n4.push(i5);
        } else for (const e6 of Object.values(this._fieldObjects)) n4.push(...e6);
        const r4 = this.annotationStorage, o4 = [];
        for (const e6 of n4) {
          const { id: t5 } = e6;
          switch (o4.push(t5), e6.type) {
            case "text": {
              const i6 = e6.defaultValue || "";
              r4.setValue(t5, { value: i6 });
              break;
            }
            case "checkbox":
            case "radiobutton": {
              const i6 = e6.defaultValue === e6.exportValues;
              r4.setValue(t5, { value: i6 });
              break;
            }
            case "combobox":
            case "listbox": {
              const i6 = e6.defaultValue || "";
              r4.setValue(t5, { value: i6 });
              break;
            }
            default:
              continue;
          }
          const i5 = document.querySelector(`[data-element-id="${t5}"]`);
          i5 && (at3.has(i5) ? i5.dispatchEvent(new Event("resetform")) : warn2(`_bindResetFormAction - element not allowed: ${t5}`));
        }
        return this.enableScripting && this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: "app", ids: o4, name: "ResetForm" } }), false;
      };
    }
  }
  _LinkAnnotationElement_instances = new WeakSet();
  Aa_fn = function() {
    this.container.setAttribute("data-internal-link", "");
  };
  ea_fn = function(e4, t4, i4 = null) {
    e4.href = this.linkService.getAnchorUrl(""), t4.description && (e4.title = t4.description), e4.onclick = () => (this.downloadManager?.openOrDownloadData(t4.content, t4.filename, i4), false), __privateMethod(this, _LinkAnnotationElement_instances, Aa_fn).call(this);
  };
  ta_fn = function(e4, t4) {
    e4.href = this.linkService.getAnchorUrl(""), e4.onclick = () => (this.linkService.executeSetOCGState(t4), false), __privateMethod(this, _LinkAnnotationElement_instances, Aa_fn).call(this);
  };
  class TextAnnotationElement extends AnnotationElement {
    constructor(e4) {
      super(e4, { isRenderable: true });
    }
    render() {
      this.container.classList.add("textAnnotation");
      const e4 = document.createElement("img");
      return e4.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", e4.setAttribute("data-l10n-id", "pdfjs-text-annotation-type"), e4.setAttribute("data-l10n-args", JSON.stringify({ type: this.data.name })), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(e4), this.container;
    }
  }
  class WidgetAnnotationElement extends AnnotationElement {
    render() {
      return this.container;
    }
    showElementAndHideCanvas(e4) {
      this.data.hasOwnCanvas && ("CANVAS" === e4.previousSibling?.nodeName && (e4.previousSibling.hidden = true), e4.hidden = false);
    }
    _getKeyModifier(e4) {
      return util_FeatureTest.platform.isMac ? e4.metaKey : e4.ctrlKey;
    }
    _setEventListener(e4, t4, i4, a4, s4) {
      i4.includes("mouse") ? e4.addEventListener(i4, (e5) => {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: this.data.id, name: a4, value: s4(e5), shift: e5.shiftKey, modifier: this._getKeyModifier(e5) } });
      }) : e4.addEventListener(i4, (e5) => {
        if ("blur" === i4) {
          if (!t4.focused || !e5.relatedTarget) return;
          t4.focused = false;
        } else if ("focus" === i4) {
          if (t4.focused) return;
          t4.focused = true;
        }
        s4 && this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: this.data.id, name: a4, value: s4(e5) } });
      });
    }
    _setEventListeners(e4, t4, i4, a4) {
      for (const [s4, n4] of i4) ("Action" === n4 || this.data.actions?.[n4]) && ("Focus" !== n4 && "Blur" !== n4 || (t4 || (t4 = { focused: false })), this._setEventListener(e4, t4, s4, n4, a4), "Focus" !== n4 || this.data.actions?.Blur ? "Blur" !== n4 || this.data.actions?.Focus || this._setEventListener(e4, t4, "focus", "Focus", null) : this._setEventListener(e4, t4, "blur", "Blur", null));
    }
    _setBackgroundColor(e4) {
      const t4 = this.data.backgroundColor || null;
      e4.style.backgroundColor = null === t4 ? "transparent" : Util2.makeHexColor(t4[0], t4[1], t4[2]);
    }
    _setTextStyle(e4) {
      const t4 = ["left", "center", "right"], { fontColor: i4 } = this.data.defaultAppearanceData, a4 = this.data.defaultAppearanceData.fontSize || 9, s4 = e4.style;
      let r4;
      const roundToOneDecimal = (e5) => Math.round(10 * e5) / 10;
      if (this.data.multiLine) {
        const e5 = Math.abs(this.data.rect[3] - this.data.rect[1] - 2), t5 = e5 / (Math.round(e5 / (n3 * a4)) || 1);
        r4 = Math.min(a4, roundToOneDecimal(t5 / n3));
      } else {
        const e5 = Math.abs(this.data.rect[3] - this.data.rect[1] - 2);
        r4 = Math.min(a4, roundToOneDecimal(e5 / n3));
      }
      s4.fontSize = `calc(${r4}px * var(--scale-factor))`, s4.color = Util2.makeHexColor(i4[0], i4[1], i4[2]), null !== this.data.textAlignment && (s4.textAlign = t4[this.data.textAlignment]);
    }
    _setRequired(e4, t4) {
      t4 ? e4.setAttribute("required", true) : e4.removeAttribute("required"), e4.setAttribute("aria-required", t4);
    }
  }
  class TextWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(e4) {
      super(e4, { isRenderable: e4.renderForms || e4.data.hasOwnCanvas || !e4.data.hasAppearance && !!e4.data.fieldValue });
    }
    setPropertyOnSiblings(e4, t4, i4, a4) {
      const s4 = this.annotationStorage;
      for (const n4 of this._getElementsByName(e4.name, e4.id)) n4.domElement && (n4.domElement[t4] = i4), s4.setValue(n4.id, { [a4]: i4 });
    }
    render() {
      const e4 = this.annotationStorage, t4 = this.data.id;
      this.container.classList.add("textWidgetAnnotation");
      let i4 = null;
      if (this.renderForms) {
        const a4 = e4.getValue(t4, { value: this.data.fieldValue });
        let s4 = a4.value || "";
        const n4 = e4.getValue(t4, { charLimit: this.data.maxLen }).charLimit;
        n4 && s4.length > n4 && (s4 = s4.slice(0, n4));
        let r4 = a4.formattedValue || this.data.textContent?.join("\n") || null;
        r4 && this.data.comb && (r4 = r4.replaceAll(/\s+/g, ""));
        const o4 = { userValue: s4, formattedValue: r4, lastCommittedValue: null, commitKey: 1, focused: false };
        this.data.multiLine ? (i4 = document.createElement("textarea"), i4.textContent = r4 ?? s4, this.data.doNotScroll && (i4.style.overflowY = "hidden")) : (i4 = document.createElement("input"), i4.type = "text", i4.setAttribute("value", r4 ?? s4), this.data.doNotScroll && (i4.style.overflowX = "hidden")), this.data.hasOwnCanvas && (i4.hidden = true), at3.add(i4), i4.setAttribute("data-element-id", t4), i4.disabled = this.data.readOnly, i4.name = this.data.fieldName, i4.tabIndex = it3, this._setRequired(i4, this.data.required), n4 && (i4.maxLength = n4), i4.addEventListener("input", (a5) => {
          e4.setValue(t4, { value: a5.target.value }), this.setPropertyOnSiblings(i4, "value", a5.target.value, "value"), o4.formattedValue = null;
        }), i4.addEventListener("resetform", (e5) => {
          const t5 = this.data.defaultFieldValue ?? "";
          i4.value = o4.userValue = t5, o4.formattedValue = null;
        });
        let blurListener = (e5) => {
          const { formattedValue: t5 } = o4;
          null != t5 && (e5.target.value = t5), e5.target.scrollLeft = 0;
        };
        if (this.enableScripting && this.hasJSActions) {
          i4.addEventListener("focus", (e5) => {
            if (o4.focused) return;
            const { target: t5 } = e5;
            o4.userValue && (t5.value = o4.userValue), o4.lastCommittedValue = t5.value, o4.commitKey = 1, this.data.actions?.Focus || (o4.focused = true);
          }), i4.addEventListener("updatefromsandbox", (i5) => {
            this.showElementAndHideCanvas(i5.target);
            const a6 = { value(i6) {
              o4.userValue = i6.detail.value ?? "", e4.setValue(t4, { value: o4.userValue.toString() }), i6.target.value = o4.userValue;
            }, formattedValue(i6) {
              const { formattedValue: a7 } = i6.detail;
              o4.formattedValue = a7, null != a7 && i6.target !== document.activeElement && (i6.target.value = a7), e4.setValue(t4, { formattedValue: a7 });
            }, selRange(e5) {
              e5.target.setSelectionRange(...e5.detail.selRange);
            }, charLimit: (i6) => {
              const { charLimit: a7 } = i6.detail, { target: s5 } = i6;
              if (0 === a7) return void s5.removeAttribute("maxLength");
              s5.setAttribute("maxLength", a7);
              let n5 = o4.userValue;
              !n5 || n5.length <= a7 || (n5 = n5.slice(0, a7), s5.value = o4.userValue = n5, e4.setValue(t4, { value: n5 }), this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: t4, name: "Keystroke", value: n5, willCommit: true, commitKey: 1, selStart: s5.selectionStart, selEnd: s5.selectionEnd } }));
            } };
            this._dispatchEventFromSandbox(a6, i5);
          }), i4.addEventListener("keydown", (e5) => {
            o4.commitKey = 1;
            let i5 = -1;
            if ("Escape" === e5.key ? i5 = 0 : "Enter" !== e5.key || this.data.multiLine ? "Tab" === e5.key && (o4.commitKey = 3) : i5 = 2, -1 === i5) return;
            const { value: a6 } = e5.target;
            o4.lastCommittedValue !== a6 && (o4.lastCommittedValue = a6, o4.userValue = a6, this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: t4, name: "Keystroke", value: a6, willCommit: true, commitKey: i5, selStart: e5.target.selectionStart, selEnd: e5.target.selectionEnd } }));
          });
          const a5 = blurListener;
          blurListener = null, i4.addEventListener("blur", (e5) => {
            if (!o4.focused || !e5.relatedTarget) return;
            this.data.actions?.Blur || (o4.focused = false);
            const { value: i5 } = e5.target;
            o4.userValue = i5, o4.lastCommittedValue !== i5 && this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: t4, name: "Keystroke", value: i5, willCommit: true, commitKey: o4.commitKey, selStart: e5.target.selectionStart, selEnd: e5.target.selectionEnd } }), a5(e5);
          }), this.data.actions?.Keystroke && i4.addEventListener("beforeinput", (e5) => {
            o4.lastCommittedValue = null;
            const { data: i5, target: a6 } = e5, { value: s5, selectionStart: n5, selectionEnd: r5 } = a6;
            let g4 = n5, c4 = r5;
            switch (e5.inputType) {
              case "deleteWordBackward": {
                const e6 = s5.substring(0, n5).match(/\w*[^\w]*$/);
                e6 && (g4 -= e6[0].length);
                break;
              }
              case "deleteWordForward": {
                const e6 = s5.substring(n5).match(/^[^\w]*\w*/);
                e6 && (c4 += e6[0].length);
                break;
              }
              case "deleteContentBackward":
                n5 === r5 && (g4 -= 1);
                break;
              case "deleteContentForward":
                n5 === r5 && (c4 += 1);
            }
            e5.preventDefault(), this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: t4, name: "Keystroke", value: s5, change: i5 || "", willCommit: false, selStart: g4, selEnd: c4 } });
          }), this._setEventListeners(i4, o4, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (e5) => e5.target.value);
        }
        if (blurListener && i4.addEventListener("blur", blurListener), this.data.comb) {
          const e5 = (this.data.rect[2] - this.data.rect[0]) / n4;
          i4.classList.add("comb"), i4.style.letterSpacing = `calc(${e5}px * var(--scale-factor) - 1ch)`;
        }
      } else i4 = document.createElement("div"), i4.textContent = this.data.fieldValue, i4.style.verticalAlign = "middle", i4.style.display = "table-cell", this.data.hasOwnCanvas && (i4.hidden = true);
      return this._setTextStyle(i4), this._setBackgroundColor(i4), this._setDefaultPropertiesFromJS(i4), this.container.append(i4), this.container;
    }
  }
  class SignatureWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(e4) {
      super(e4, { isRenderable: !!e4.data.hasOwnCanvas });
    }
  }
  class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(e4) {
      super(e4, { isRenderable: e4.renderForms });
    }
    render() {
      const e4 = this.annotationStorage, t4 = this.data, i4 = t4.id;
      let a4 = e4.getValue(i4, { value: t4.exportValue === t4.fieldValue }).value;
      "string" == typeof a4 && (a4 = "Off" !== a4, e4.setValue(i4, { value: a4 })), this.container.classList.add("buttonWidgetAnnotation", "checkBox");
      const s4 = document.createElement("input");
      return at3.add(s4), s4.setAttribute("data-element-id", i4), s4.disabled = t4.readOnly, this._setRequired(s4, this.data.required), s4.type = "checkbox", s4.name = t4.fieldName, a4 && s4.setAttribute("checked", true), s4.setAttribute("exportValue", t4.exportValue), s4.tabIndex = it3, s4.addEventListener("change", (a5) => {
        const { name: s5, checked: n4 } = a5.target;
        for (const a6 of this._getElementsByName(s5, i4)) {
          const i5 = n4 && a6.exportValue === t4.exportValue;
          a6.domElement && (a6.domElement.checked = i5), e4.setValue(a6.id, { value: i5 });
        }
        e4.setValue(i4, { value: n4 });
      }), s4.addEventListener("resetform", (e5) => {
        const i5 = t4.defaultFieldValue || "Off";
        e5.target.checked = i5 === t4.exportValue;
      }), this.enableScripting && this.hasJSActions && (s4.addEventListener("updatefromsandbox", (t5) => {
        const a5 = { value(t6) {
          t6.target.checked = "Off" !== t6.detail.value, e4.setValue(i4, { value: t6.target.checked });
        } };
        this._dispatchEventFromSandbox(a5, t5);
      }), this._setEventListeners(s4, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (e5) => e5.target.checked)), this._setBackgroundColor(s4), this._setDefaultPropertiesFromJS(s4), this.container.append(s4), this.container;
    }
  }
  class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(e4) {
      super(e4, { isRenderable: e4.renderForms });
    }
    render() {
      this.container.classList.add("buttonWidgetAnnotation", "radioButton");
      const e4 = this.annotationStorage, t4 = this.data, i4 = t4.id;
      let a4 = e4.getValue(i4, { value: t4.fieldValue === t4.buttonValue }).value;
      if ("string" == typeof a4 && (a4 = a4 !== t4.buttonValue, e4.setValue(i4, { value: a4 })), a4) for (const a5 of this._getElementsByName(t4.fieldName, i4)) e4.setValue(a5.id, { value: false });
      const s4 = document.createElement("input");
      if (at3.add(s4), s4.setAttribute("data-element-id", i4), s4.disabled = t4.readOnly, this._setRequired(s4, this.data.required), s4.type = "radio", s4.name = t4.fieldName, a4 && s4.setAttribute("checked", true), s4.tabIndex = it3, s4.addEventListener("change", (t5) => {
        const { name: a5, checked: s5 } = t5.target;
        for (const t6 of this._getElementsByName(a5, i4)) e4.setValue(t6.id, { value: false });
        e4.setValue(i4, { value: s5 });
      }), s4.addEventListener("resetform", (e5) => {
        const i5 = t4.defaultFieldValue;
        e5.target.checked = null != i5 && i5 === t4.buttonValue;
      }), this.enableScripting && this.hasJSActions) {
        const a5 = t4.buttonValue;
        s4.addEventListener("updatefromsandbox", (t5) => {
          const s5 = { value: (t6) => {
            const s6 = a5 === t6.detail.value;
            for (const a6 of this._getElementsByName(t6.target.name)) {
              const t7 = s6 && a6.id === i4;
              a6.domElement && (a6.domElement.checked = t7), e4.setValue(a6.id, { value: t7 });
            }
          } };
          this._dispatchEventFromSandbox(s5, t5);
        }), this._setEventListeners(s4, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (e5) => e5.target.checked);
      }
      return this._setBackgroundColor(s4), this._setDefaultPropertiesFromJS(s4), this.container.append(s4), this.container;
    }
  }
  class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
    constructor(e4) {
      super(e4, { ignoreBorder: e4.data.hasAppearance });
    }
    render() {
      const e4 = super.render();
      e4.classList.add("buttonWidgetAnnotation", "pushButton");
      const t4 = e4.lastChild;
      return this.enableScripting && this.hasJSActions && t4 && (this._setDefaultPropertiesFromJS(t4), t4.addEventListener("updatefromsandbox", (e5) => {
        this._dispatchEventFromSandbox({}, e5);
      })), e4;
    }
  }
  class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(e4) {
      super(e4, { isRenderable: e4.renderForms });
    }
    render() {
      this.container.classList.add("choiceWidgetAnnotation");
      const e4 = this.annotationStorage, t4 = this.data.id, i4 = e4.getValue(t4, { value: this.data.fieldValue }), a4 = document.createElement("select");
      at3.add(a4), a4.setAttribute("data-element-id", t4), a4.disabled = this.data.readOnly, this._setRequired(a4, this.data.required), a4.name = this.data.fieldName, a4.tabIndex = it3;
      let s4 = this.data.combo && this.data.options.length > 0;
      this.data.combo || (a4.size = this.data.options.length, this.data.multiSelect && (a4.multiple = true)), a4.addEventListener("resetform", (e5) => {
        const t5 = this.data.defaultFieldValue;
        for (const e6 of a4.options) e6.selected = e6.value === t5;
      });
      for (const e5 of this.data.options) {
        const t5 = document.createElement("option");
        t5.textContent = e5.displayValue, t5.value = e5.exportValue, i4.value.includes(e5.exportValue) && (t5.setAttribute("selected", true), s4 = false), a4.append(t5);
      }
      let n4 = null;
      if (s4) {
        const e5 = document.createElement("option");
        e5.value = " ", e5.setAttribute("hidden", true), e5.setAttribute("selected", true), a4.prepend(e5), n4 = () => {
          e5.remove(), a4.removeEventListener("input", n4), n4 = null;
        }, a4.addEventListener("input", n4);
      }
      const getValue = (e5) => {
        const t5 = e5 ? "value" : "textContent", { options: i5, multiple: s5 } = a4;
        return s5 ? Array.prototype.filter.call(i5, (e6) => e6.selected).map((e6) => e6[t5]) : -1 === i5.selectedIndex ? null : i5[i5.selectedIndex][t5];
      };
      let r4 = getValue(false);
      const getItems = (e5) => {
        const t5 = e5.target.options;
        return Array.prototype.map.call(t5, (e6) => ({ displayValue: e6.textContent, exportValue: e6.value }));
      };
      return this.enableScripting && this.hasJSActions ? (a4.addEventListener("updatefromsandbox", (i5) => {
        const s5 = { value(i6) {
          n4?.();
          const s6 = i6.detail.value, o4 = new Set(Array.isArray(s6) ? s6 : [s6]);
          for (const e5 of a4.options) e5.selected = o4.has(e5.value);
          e4.setValue(t4, { value: getValue(true) }), r4 = getValue(false);
        }, multipleSelection(e5) {
          a4.multiple = true;
        }, remove(i6) {
          const s6 = a4.options, n5 = i6.detail.remove;
          if (s6[n5].selected = false, a4.remove(n5), s6.length > 0) {
            -1 === Array.prototype.findIndex.call(s6, (e5) => e5.selected) && (s6[0].selected = true);
          }
          e4.setValue(t4, { value: getValue(true), items: getItems(i6) }), r4 = getValue(false);
        }, clear(i6) {
          for (; 0 !== a4.length; ) a4.remove(0);
          e4.setValue(t4, { value: null, items: [] }), r4 = getValue(false);
        }, insert(i6) {
          const { index: s6, displayValue: n5, exportValue: o4 } = i6.detail.insert, g4 = a4.children[s6], c4 = document.createElement("option");
          c4.textContent = n5, c4.value = o4, g4 ? g4.before(c4) : a4.append(c4), e4.setValue(t4, { value: getValue(true), items: getItems(i6) }), r4 = getValue(false);
        }, items(i6) {
          const { items: s6 } = i6.detail;
          for (; 0 !== a4.length; ) a4.remove(0);
          for (const e5 of s6) {
            const { displayValue: t5, exportValue: i7 } = e5, s7 = document.createElement("option");
            s7.textContent = t5, s7.value = i7, a4.append(s7);
          }
          a4.options.length > 0 && (a4.options[0].selected = true), e4.setValue(t4, { value: getValue(true), items: getItems(i6) }), r4 = getValue(false);
        }, indices(i6) {
          const a5 = new Set(i6.detail.indices);
          for (const e5 of i6.target.options) e5.selected = a5.has(e5.index);
          e4.setValue(t4, { value: getValue(true) }), r4 = getValue(false);
        }, editable(e5) {
          e5.target.disabled = !e5.detail.editable;
        } };
        this._dispatchEventFromSandbox(s5, i5);
      }), a4.addEventListener("input", (i5) => {
        const a5 = getValue(true), s5 = getValue(false);
        e4.setValue(t4, { value: a5 }), i5.preventDefault(), this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: t4, name: "Keystroke", value: r4, change: s5, changeEx: a5, willCommit: false, commitKey: 1, keyDown: false } });
      }), this._setEventListeners(a4, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (e5) => e5.target.value)) : a4.addEventListener("input", function(i5) {
        e4.setValue(t4, { value: getValue(true) });
      }), this.data.combo && this._setTextStyle(a4), this._setBackgroundColor(a4), this._setDefaultPropertiesFromJS(a4), this.container.append(a4), this.container;
    }
  }
  class PopupAnnotationElement extends AnnotationElement {
    constructor(e4) {
      const { data: t4, elements: i4 } = e4;
      super(e4, { isRenderable: AnnotationElement._hasPopupData(t4) }), this.elements = i4, this.popup = null;
    }
    render() {
      this.container.classList.add("popupAnnotation");
      const e4 = this.popup = new PopupElement({ container: this.container, color: this.data.color, titleObj: this.data.titleObj, modificationDate: this.data.modificationDate, contentsObj: this.data.contentsObj, richText: this.data.richText, rect: this.data.rect, parentRect: this.data.parentRect || null, parent: this.parent, elements: this.elements, open: this.data.open }), t4 = [];
      for (const i4 of this.elements) i4.popup = e4, t4.push(i4.data.id), i4.addHighlightArea();
      return this.container.setAttribute("aria-controls", t4.map((e5) => `${oe3}${e5}`).join(",")), this.container;
    }
  }
  class PopupElement {
    constructor({ container: e4, color: t4, elements: i4, titleObj: a4, modificationDate: s4, contentsObj: n4, richText: r4, parent: o4, rect: g4, parentRect: c4, open: h4 }) {
      __privateAdd(this, _PopupElement_instances);
      __privateAdd(this, _ia, __privateMethod(this, _PopupElement_instances, aa_fn).bind(this));
      __privateAdd(this, _sa, __privateMethod(this, _PopupElement_instances, na_fn).bind(this));
      __privateAdd(this, _ra, __privateMethod(this, _PopupElement_instances, oa_fn).bind(this));
      __privateAdd(this, _ga, __privateMethod(this, _PopupElement_instances, ca_fn).bind(this));
      __privateAdd(this, _ha, null);
      __privateAdd(this, _it3, null);
      __privateAdd(this, _la, null);
      __privateAdd(this, _Ia, null);
      __privateAdd(this, _Ca, null);
      __privateAdd(this, _da, null);
      __privateAdd(this, _Ba, null);
      __privateAdd(this, _ua, false);
      __privateAdd(this, _Qa, null);
      __privateAdd(this, _ue2, null);
      __privateAdd(this, _Ea, null);
      __privateAdd(this, _fa, null);
      __privateAdd(this, _pa, null);
      __privateAdd(this, _Vi2, null);
      __privateAdd(this, _ma, false);
      __privateSet(this, _it3, e4), __privateSet(this, _pa, a4), __privateSet(this, _la, n4), __privateSet(this, _fa, r4), __privateSet(this, _da, o4), __privateSet(this, _ha, t4), __privateSet(this, _Ea, g4), __privateSet(this, _Ba, c4), __privateSet(this, _Ca, i4), __privateSet(this, _Ia, PDFDateString.toDateObject(s4)), this.trigger = i4.flatMap((e5) => e5.getElementsToTriggerPopup());
      for (const e5 of this.trigger) e5.addEventListener("click", __privateGet(this, _ga)), e5.addEventListener("mouseenter", __privateGet(this, _ra)), e5.addEventListener("mouseleave", __privateGet(this, _sa)), e5.classList.add("popupTriggerArea");
      for (const e5 of i4) e5.container?.addEventListener("keydown", __privateGet(this, _ia));
      __privateGet(this, _it3).hidden = true, h4 && __privateMethod(this, _PopupElement_instances, ca_fn).call(this);
    }
    render() {
      if (__privateGet(this, _Qa)) return;
      const e4 = __privateSet(this, _Qa, document.createElement("div"));
      if (e4.className = "popup", __privateGet(this, _ha)) {
        const t5 = e4.style.outlineColor = Util2.makeHexColor(...__privateGet(this, _ha));
        if (CSS.supports("background-color", "color-mix(in srgb, red 30%, white)")) e4.style.backgroundColor = `color-mix(in srgb, ${t5} 30%, white)`;
        else {
          const t6 = 0.7;
          e4.style.backgroundColor = Util2.makeHexColor(...__privateGet(this, _ha).map((e5) => Math.floor(t6 * (255 - e5) + e5)));
        }
      }
      const t4 = document.createElement("span");
      t4.className = "header";
      const i4 = document.createElement("h1");
      if (t4.append(i4), { dir: i4.dir, str: i4.textContent } = __privateGet(this, _pa), e4.append(t4), __privateGet(this, _Ia)) {
        const e5 = document.createElement("span");
        e5.classList.add("popupDate"), e5.setAttribute("data-l10n-id", "pdfjs-annotation-date-time-string"), e5.setAttribute("data-l10n-args", JSON.stringify({ dateObj: __privateGet(this, _Ia).valueOf() })), t4.append(e5);
      }
      const a4 = __privateGet(this, _PopupElement_instances, ya_get);
      if (a4) XfaLayer.render({ xfaHtml: a4, intent: "richText", div: e4 }), e4.lastChild.classList.add("richText", "popupContent");
      else {
        const t5 = this._formatContents(__privateGet(this, _la));
        e4.append(t5);
      }
      __privateGet(this, _it3).append(e4);
    }
    _formatContents({ str: e4, dir: t4 }) {
      const i4 = document.createElement("p");
      i4.classList.add("popupContent"), i4.dir = t4;
      const a4 = e4.split(/(?:\r\n?|\n)/);
      for (let e5 = 0, t5 = a4.length; e5 < t5; ++e5) {
        const s4 = a4[e5];
        i4.append(document.createTextNode(s4)), e5 < t5 - 1 && i4.append(document.createElement("br"));
      }
      return i4;
    }
    updateEdited({ rect: e4, popupContent: t4 }) {
      __privateGet(this, _Vi2) || __privateSet(this, _Vi2, { contentsObj: __privateGet(this, _la), richText: __privateGet(this, _fa) }), e4 && __privateSet(this, _ue2, null), t4 && (__privateSet(this, _fa, __privateMethod(this, _PopupElement_instances, Da_fn).call(this, t4)), __privateSet(this, _la, null)), __privateGet(this, _Qa)?.remove(), __privateSet(this, _Qa, null);
    }
    resetEdited() {
      __privateGet(this, _Vi2) && ({ contentsObj: __privateWrapper(this, _la)._, richText: __privateWrapper(this, _fa)._ } = __privateGet(this, _Vi2), __privateSet(this, _Vi2, null), __privateGet(this, _Qa)?.remove(), __privateSet(this, _Qa, null), __privateSet(this, _ue2, null));
    }
    forceHide() {
      __privateSet(this, _ma, this.isVisible), __privateGet(this, _ma) && (__privateGet(this, _it3).hidden = true);
    }
    maybeShow() {
      __privateGet(this, _ma) && (__privateGet(this, _Qa) || __privateMethod(this, _PopupElement_instances, oa_fn).call(this), __privateSet(this, _ma, false), __privateGet(this, _it3).hidden = false);
    }
    get isVisible() {
      return false === __privateGet(this, _it3).hidden;
    }
  }
  _ia = new WeakMap();
  _sa = new WeakMap();
  _ra = new WeakMap();
  _ga = new WeakMap();
  _ha = new WeakMap();
  _it3 = new WeakMap();
  _la = new WeakMap();
  _Ia = new WeakMap();
  _Ca = new WeakMap();
  _da = new WeakMap();
  _Ba = new WeakMap();
  _ua = new WeakMap();
  _Qa = new WeakMap();
  _ue2 = new WeakMap();
  _Ea = new WeakMap();
  _fa = new WeakMap();
  _pa = new WeakMap();
  _Vi2 = new WeakMap();
  _ma = new WeakMap();
  _PopupElement_instances = new WeakSet();
  ya_get = function() {
    const e4 = __privateGet(this, _fa), t4 = __privateGet(this, _la);
    return !e4?.str || t4?.str && t4.str !== e4.str ? null : __privateGet(this, _fa).html || null;
  };
  wa_get = function() {
    return __privateGet(this, _PopupElement_instances, ya_get)?.attributes?.style?.fontSize || 0;
  };
  ba_get = function() {
    return __privateGet(this, _PopupElement_instances, ya_get)?.attributes?.style?.color || null;
  };
  Da_fn = function(e4) {
    const t4 = [], i4 = { str: e4, html: { name: "div", attributes: { dir: "auto" }, children: [{ name: "p", children: t4 }] } }, a4 = { style: { color: __privateGet(this, _PopupElement_instances, ba_get), fontSize: __privateGet(this, _PopupElement_instances, wa_get) ? `calc(${__privateGet(this, _PopupElement_instances, wa_get)}px * var(--scale-factor))` : "" } };
    for (const i5 of e4.split("\n")) t4.push({ name: "span", value: i5, attributes: a4 });
    return i4;
  };
  aa_fn = function(e4) {
    e4.altKey || e4.shiftKey || e4.ctrlKey || e4.metaKey || ("Enter" === e4.key || "Escape" === e4.key && __privateGet(this, _ua)) && __privateMethod(this, _PopupElement_instances, ca_fn).call(this);
  };
  Sa_fn = function() {
    if (null !== __privateGet(this, _ue2)) return;
    const { page: { view: e4 }, viewport: { rawDims: { pageWidth: t4, pageHeight: i4, pageX: a4, pageY: s4 } } } = __privateGet(this, _da);
    let n4 = !!__privateGet(this, _Ba), r4 = n4 ? __privateGet(this, _Ba) : __privateGet(this, _Ea);
    for (const e5 of __privateGet(this, _Ca)) if (!r4 || null !== Util2.intersect(e5.data.rect, r4)) {
      r4 = e5.data.rect, n4 = true;
      break;
    }
    const o4 = Util2.normalizeRect([r4[0], e4[3] - r4[1] + e4[1], r4[2], e4[3] - r4[3] + e4[1]]), g4 = n4 ? r4[2] - r4[0] + 5 : 0, c4 = o4[0] + g4, h4 = o4[1];
    __privateSet(this, _ue2, [100 * (c4 - a4) / t4, 100 * (h4 - s4) / i4]);
    const { style: l4 } = __privateGet(this, _it3);
    l4.left = `${__privateGet(this, _ue2)[0]}%`, l4.top = `${__privateGet(this, _ue2)[1]}%`;
  };
  ca_fn = function() {
    __privateSet(this, _ua, !__privateGet(this, _ua)), __privateGet(this, _ua) ? (__privateMethod(this, _PopupElement_instances, oa_fn).call(this), __privateGet(this, _it3).addEventListener("click", __privateGet(this, _ga)), __privateGet(this, _it3).addEventListener("keydown", __privateGet(this, _ia))) : (__privateMethod(this, _PopupElement_instances, na_fn).call(this), __privateGet(this, _it3).removeEventListener("click", __privateGet(this, _ga)), __privateGet(this, _it3).removeEventListener("keydown", __privateGet(this, _ia)));
  };
  oa_fn = function() {
    __privateGet(this, _Qa) || this.render(), this.isVisible ? __privateGet(this, _ua) && __privateGet(this, _it3).classList.add("focused") : (__privateMethod(this, _PopupElement_instances, Sa_fn).call(this), __privateGet(this, _it3).hidden = false, __privateGet(this, _it3).style.zIndex = parseInt(__privateGet(this, _it3).style.zIndex) + 1e3);
  };
  na_fn = function() {
    __privateGet(this, _it3).classList.remove("focused"), !__privateGet(this, _ua) && this.isVisible && (__privateGet(this, _it3).hidden = true, __privateGet(this, _it3).style.zIndex = parseInt(__privateGet(this, _it3).style.zIndex) - 1e3);
  };
  class FreeTextAnnotationElement extends AnnotationElement {
    constructor(e4) {
      super(e4, { isRenderable: true, ignoreBorder: true }), this.textContent = e4.data.textContent, this.textPosition = e4.data.textPosition, this.annotationEditorType = Q3.FREETEXT;
    }
    render() {
      if (this.container.classList.add("freeTextAnnotation"), this.textContent) {
        const e4 = document.createElement("div");
        e4.classList.add("annotationTextContent"), e4.setAttribute("role", "comment");
        for (const t4 of this.textContent) {
          const i4 = document.createElement("span");
          i4.textContent = t4, e4.append(i4);
        }
        this.container.append(e4);
      }
      return !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
    }
  }
  class LineAnnotationElement extends AnnotationElement {
    constructor(e4) {
      super(e4, { isRenderable: true, ignoreBorder: true });
      __privateAdd(this, _Fa, null);
    }
    render() {
      this.container.classList.add("lineAnnotation");
      const e4 = this.data, { width: t4, height: i4 } = getRectDims(e4.rect), a4 = this.svgFactory.create(t4, i4, true), s4 = __privateSet(this, _Fa, this.svgFactory.createElement("svg:line"));
      return s4.setAttribute("x1", e4.rect[2] - e4.lineCoordinates[0]), s4.setAttribute("y1", e4.rect[3] - e4.lineCoordinates[1]), s4.setAttribute("x2", e4.rect[2] - e4.lineCoordinates[2]), s4.setAttribute("y2", e4.rect[3] - e4.lineCoordinates[3]), s4.setAttribute("stroke-width", e4.borderStyle.width || 1), s4.setAttribute("stroke", "transparent"), s4.setAttribute("fill", "transparent"), a4.append(s4), this.container.append(a4), !e4.popupRef && this.hasPopupData && this._createPopup(), this.container;
    }
    getElementsToTriggerPopup() {
      return __privateGet(this, _Fa);
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  _Fa = new WeakMap();
  class SquareAnnotationElement extends AnnotationElement {
    constructor(e4) {
      super(e4, { isRenderable: true, ignoreBorder: true });
      __privateAdd(this, _ka, null);
    }
    render() {
      this.container.classList.add("squareAnnotation");
      const e4 = this.data, { width: t4, height: i4 } = getRectDims(e4.rect), a4 = this.svgFactory.create(t4, i4, true), s4 = e4.borderStyle.width, n4 = __privateSet(this, _ka, this.svgFactory.createElement("svg:rect"));
      return n4.setAttribute("x", s4 / 2), n4.setAttribute("y", s4 / 2), n4.setAttribute("width", t4 - s4), n4.setAttribute("height", i4 - s4), n4.setAttribute("stroke-width", s4 || 1), n4.setAttribute("stroke", "transparent"), n4.setAttribute("fill", "transparent"), a4.append(n4), this.container.append(a4), !e4.popupRef && this.hasPopupData && this._createPopup(), this.container;
    }
    getElementsToTriggerPopup() {
      return __privateGet(this, _ka);
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  _ka = new WeakMap();
  class CircleAnnotationElement extends AnnotationElement {
    constructor(e4) {
      super(e4, { isRenderable: true, ignoreBorder: true });
      __privateAdd(this, _Ra, null);
    }
    render() {
      this.container.classList.add("circleAnnotation");
      const e4 = this.data, { width: t4, height: i4 } = getRectDims(e4.rect), a4 = this.svgFactory.create(t4, i4, true), s4 = e4.borderStyle.width, n4 = __privateSet(this, _Ra, this.svgFactory.createElement("svg:ellipse"));
      return n4.setAttribute("cx", t4 / 2), n4.setAttribute("cy", i4 / 2), n4.setAttribute("rx", t4 / 2 - s4 / 2), n4.setAttribute("ry", i4 / 2 - s4 / 2), n4.setAttribute("stroke-width", s4 || 1), n4.setAttribute("stroke", "transparent"), n4.setAttribute("fill", "transparent"), a4.append(n4), this.container.append(a4), !e4.popupRef && this.hasPopupData && this._createPopup(), this.container;
    }
    getElementsToTriggerPopup() {
      return __privateGet(this, _Ra);
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  _Ra = new WeakMap();
  class PolylineAnnotationElement extends AnnotationElement {
    constructor(e4) {
      super(e4, { isRenderable: true, ignoreBorder: true });
      __privateAdd(this, _xa, null);
      this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
    }
    render() {
      this.container.classList.add(this.containerClassName);
      const { data: { rect: e4, vertices: t4, borderStyle: i4, popupRef: a4 } } = this;
      if (!t4) return this.container;
      const { width: s4, height: n4 } = getRectDims(e4), r4 = this.svgFactory.create(s4, n4, true);
      let o4 = [];
      for (let i5 = 0, a5 = t4.length; i5 < a5; i5 += 2) {
        const a6 = t4[i5] - e4[0], s5 = e4[3] - t4[i5 + 1];
        o4.push(`${a6},${s5}`);
      }
      o4 = o4.join(" ");
      const g4 = __privateSet(this, _xa, this.svgFactory.createElement(this.svgElementName));
      return g4.setAttribute("points", o4), g4.setAttribute("stroke-width", i4.width || 1), g4.setAttribute("stroke", "transparent"), g4.setAttribute("fill", "transparent"), r4.append(g4), this.container.append(r4), !a4 && this.hasPopupData && this._createPopup(), this.container;
    }
    getElementsToTriggerPopup() {
      return __privateGet(this, _xa);
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  _xa = new WeakMap();
  class PolygonAnnotationElement extends PolylineAnnotationElement {
    constructor(e4) {
      super(e4), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
    }
  }
  class CaretAnnotationElement extends AnnotationElement {
    constructor(e4) {
      super(e4, { isRenderable: true, ignoreBorder: true });
    }
    render() {
      return this.container.classList.add("caretAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
    }
  }
  class InkAnnotationElement extends AnnotationElement {
    constructor(e4) {
      super(e4, { isRenderable: true, ignoreBorder: true });
      __privateAdd(this, _Na, []);
      this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = Q3.INK;
    }
    render() {
      this.container.classList.add(this.containerClassName);
      const { data: { rect: e4, inkLists: t4, borderStyle: i4, popupRef: a4 } } = this, { width: s4, height: n4 } = getRectDims(e4), r4 = this.svgFactory.create(s4, n4, true);
      for (const s5 of t4) {
        let t5 = [];
        for (let i5 = 0, a5 = s5.length; i5 < a5; i5 += 2) {
          const a6 = s5[i5] - e4[0], n6 = e4[3] - s5[i5 + 1];
          t5.push(`${a6},${n6}`);
        }
        t5 = t5.join(" ");
        const n5 = this.svgFactory.createElement(this.svgElementName);
        __privateGet(this, _Na).push(n5), n5.setAttribute("points", t5), n5.setAttribute("stroke-width", i4.width || 1), n5.setAttribute("stroke", "transparent"), n5.setAttribute("fill", "transparent"), !a4 && this.hasPopupData && this._createPopup(), r4.append(n5);
      }
      return this.container.append(r4), this.container;
    }
    getElementsToTriggerPopup() {
      return __privateGet(this, _Na);
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  _Na = new WeakMap();
  class HighlightAnnotationElement extends AnnotationElement {
    constructor(e4) {
      super(e4, { isRenderable: true, ignoreBorder: true, createQuadrilaterals: true });
    }
    render() {
      return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("highlightAnnotation"), this.container;
    }
  }
  class UnderlineAnnotationElement extends AnnotationElement {
    constructor(e4) {
      super(e4, { isRenderable: true, ignoreBorder: true, createQuadrilaterals: true });
    }
    render() {
      return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("underlineAnnotation"), this.container;
    }
  }
  class SquigglyAnnotationElement extends AnnotationElement {
    constructor(e4) {
      super(e4, { isRenderable: true, ignoreBorder: true, createQuadrilaterals: true });
    }
    render() {
      return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("squigglyAnnotation"), this.container;
    }
  }
  class StrikeOutAnnotationElement extends AnnotationElement {
    constructor(e4) {
      super(e4, { isRenderable: true, ignoreBorder: true, createQuadrilaterals: true });
    }
    render() {
      return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("strikeoutAnnotation"), this.container;
    }
  }
  class StampAnnotationElement extends AnnotationElement {
    constructor(e4) {
      super(e4, { isRenderable: true, ignoreBorder: true });
    }
    render() {
      return this.container.classList.add("stampAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
    }
  }
  class FileAttachmentAnnotationElement extends AnnotationElement {
    constructor(e4) {
      super(e4, { isRenderable: true });
      __privateAdd(this, _FileAttachmentAnnotationElement_instances);
      __privateAdd(this, _Ma, null);
      const { file: t4 } = this.data;
      this.filename = t4.filename, this.content = t4.content, this.linkService.eventBus?.dispatch("fileattachmentannotation", { source: this, ...t4 });
    }
    render() {
      this.container.classList.add("fileAttachmentAnnotation");
      const { container: e4, data: t4 } = this;
      let i4;
      t4.hasAppearance || 0 === t4.fillAlpha ? i4 = document.createElement("div") : (i4 = document.createElement("img"), i4.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(t4.name) ? "paperclip" : "pushpin"}.svg`, t4.fillAlpha && t4.fillAlpha < 1 && (i4.style = `filter: opacity(${Math.round(100 * t4.fillAlpha)}%);`)), i4.addEventListener("dblclick", __privateMethod(this, _FileAttachmentAnnotationElement_instances, Ga_fn).bind(this)), __privateSet(this, _Ma, i4);
      const { isMac: a4 } = util_FeatureTest.platform;
      return e4.addEventListener("keydown", (e5) => {
        "Enter" === e5.key && (a4 ? e5.metaKey : e5.ctrlKey) && __privateMethod(this, _FileAttachmentAnnotationElement_instances, Ga_fn).call(this);
      }), !t4.popupRef && this.hasPopupData ? this._createPopup() : i4.classList.add("popupTriggerArea"), e4.append(i4), e4;
    }
    getElementsToTriggerPopup() {
      return __privateGet(this, _Ma);
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  _Ma = new WeakMap();
  _FileAttachmentAnnotationElement_instances = new WeakSet();
  Ga_fn = function() {
    this.downloadManager?.openOrDownloadData(this.content, this.filename);
  };
  class AnnotationLayer {
    constructor({ div: e4, accessibilityManager: t4, annotationCanvasMap: i4, annotationEditorUIManager: a4, page: s4, viewport: n4 }) {
      __privateAdd(this, _AnnotationLayer_instances);
      __privateAdd(this, _va, null);
      __privateAdd(this, _La, null);
      __privateAdd(this, _Ua, /* @__PURE__ */ new Map());
      this.div = e4, __privateSet(this, _va, t4), __privateSet(this, _La, i4), this.page = s4, this.viewport = n4, this.zIndex = 0, this._annotationEditorUIManager = a4;
    }
    hasEditableAnnotations() {
      return __privateGet(this, _Ua).size > 0;
    }
    async render(e4) {
      const { annotations: t4 } = e4, i4 = this.div;
      setLayerDimensions(i4, this.viewport);
      const a4 = /* @__PURE__ */ new Map(), s4 = { data: null, layer: i4, linkService: e4.linkService, downloadManager: e4.downloadManager, imageResourcesPath: e4.imageResourcesPath || "", renderForms: false !== e4.renderForms, svgFactory: new DOMSVGFactory(), annotationStorage: e4.annotationStorage || new AnnotationStorage(), enableScripting: true === e4.enableScripting, hasJSActions: e4.hasJSActions, fieldObjects: e4.fieldObjects, parent: this, elements: null };
      for (const e5 of t4) {
        if (e5.noHTML) continue;
        const t5 = e5.annotationType === q3;
        if (t5) {
          const t6 = a4.get(e5.id);
          if (!t6) continue;
          s4.elements = t6;
        } else {
          const { width: t6, height: i6 } = getRectDims(e5.rect);
          if (t6 <= 0 || i6 <= 0) continue;
        }
        s4.data = e5;
        const i5 = AnnotationElementFactory.create(s4);
        if (!i5.isRenderable) continue;
        if (!t5 && e5.popupRef) {
          const t6 = a4.get(e5.popupRef);
          t6 ? t6.push(i5) : a4.set(e5.popupRef, [i5]);
        }
        const n4 = i5.render();
        e5.hidden && (n4.style.visibility = "hidden"), __privateMethod(this, _AnnotationLayer_instances, Ha_fn).call(this, n4, e5.id), i5._isEditable && (__privateGet(this, _Ua).set(i5.data.id, i5), this._annotationEditorUIManager?.renderAnnotationElement(i5));
      }
      __privateMethod(this, _AnnotationLayer_instances, Ta_fn).call(this);
    }
    update({ viewport: e4 }) {
      const t4 = this.div;
      this.viewport = e4, setLayerDimensions(t4, { rotation: e4.rotation }), __privateMethod(this, _AnnotationLayer_instances, Ta_fn).call(this), t4.hidden = false;
    }
    getEditableAnnotations() {
      return Array.from(__privateGet(this, _Ua).values());
    }
    getEditableAnnotation(e4) {
      return __privateGet(this, _Ua).get(e4);
    }
  }
  _va = new WeakMap();
  _La = new WeakMap();
  _Ua = new WeakMap();
  _AnnotationLayer_instances = new WeakSet();
  Ha_fn = function(e4, t4) {
    const i4 = e4.firstChild || e4;
    i4.id = `${oe3}${t4}`, this.div.append(e4), __privateGet(this, _va)?.moveElementInDOM(this.div, e4, i4, false);
  };
  Ta_fn = function() {
    if (!__privateGet(this, _La)) return;
    const e4 = this.div;
    for (const [t4, i4] of __privateGet(this, _La)) {
      const a4 = e4.querySelector(`[data-annotation-id="${t4}"]`);
      if (!a4) continue;
      i4.className = "annotationContent";
      const { firstChild: s4 } = a4;
      s4 ? "CANVAS" === s4.nodeName ? s4.replaceWith(i4) : s4.classList.contains("annotationContent") ? s4.after(i4) : s4.before(i4) : a4.append(i4);
    }
    __privateGet(this, _La).clear();
  };
  const st3 = /\r\n?|\n/g;
  const _FreeTextEditor = class _FreeTextEditor extends AnnotationEditor {
    constructor(e4) {
      super({ ...e4, name: "freeTextEditor" });
      __privateAdd(this, _FreeTextEditor_instances);
      __privateAdd(this, _ha2);
      __privateAdd(this, _Ja, "");
      __privateAdd(this, _Ya, `${this.id}-editor`);
      __privateAdd(this, _Pa, null);
      __privateAdd(this, _wa);
      __privateAdd(this, _Oa, null);
      __privateSet(this, _ha2, e4.color || _FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor), __privateSet(this, _wa, e4.fontSize || _FreeTextEditor._defaultFontSize);
    }
    static get _keyboardManager() {
      const e4 = _FreeTextEditor.prototype, arrowChecker = (e5) => e5.isEmpty(), t4 = AnnotationEditorUIManager.TRANSLATE_SMALL, i4 = AnnotationEditorUIManager.TRANSLATE_BIG;
      return shadow2(this, "_keyboardManager", new KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], e4.commitOrRemove, { bubbles: true }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], e4.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], e4._translateEmpty, { args: [-t4, 0], checker: arrowChecker }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], e4._translateEmpty, { args: [-i4, 0], checker: arrowChecker }], [["ArrowRight", "mac+ArrowRight"], e4._translateEmpty, { args: [t4, 0], checker: arrowChecker }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], e4._translateEmpty, { args: [i4, 0], checker: arrowChecker }], [["ArrowUp", "mac+ArrowUp"], e4._translateEmpty, { args: [0, -t4], checker: arrowChecker }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], e4._translateEmpty, { args: [0, -i4], checker: arrowChecker }], [["ArrowDown", "mac+ArrowDown"], e4._translateEmpty, { args: [0, t4], checker: arrowChecker }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], e4._translateEmpty, { args: [0, i4], checker: arrowChecker }]]));
    }
    static initialize(e4, t4) {
      AnnotationEditor.initialize(e4, t4, { strings: ["pdfjs-free-text-default-content"] });
      const i4 = getComputedStyle(document.documentElement);
      this._internalPadding = parseFloat(i4.getPropertyValue("--freetext-padding"));
    }
    static updateDefaultParams(e4, t4) {
      switch (e4) {
        case f3.FREETEXT_SIZE:
          _FreeTextEditor._defaultFontSize = t4;
          break;
        case f3.FREETEXT_COLOR:
          _FreeTextEditor._defaultColor = t4;
      }
    }
    updateParams(e4, t4) {
      switch (e4) {
        case f3.FREETEXT_SIZE:
          __privateMethod(this, _FreeTextEditor_instances, Ka_fn).call(this, t4);
          break;
        case f3.FREETEXT_COLOR:
          __privateMethod(this, _FreeTextEditor_instances, qa_fn).call(this, t4);
      }
    }
    static get defaultPropertiesToUpdate() {
      return [[f3.FREETEXT_SIZE, _FreeTextEditor._defaultFontSize], [f3.FREETEXT_COLOR, _FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor]];
    }
    get propertiesToUpdate() {
      return [[f3.FREETEXT_SIZE, __privateGet(this, _wa)], [f3.FREETEXT_COLOR, __privateGet(this, _ha2)]];
    }
    _translateEmpty(e4, t4) {
      this._uiManager.translateSelectedEditors(e4, t4, true);
    }
    getInitialTranslation() {
      const e4 = this.parentScale;
      return [-_FreeTextEditor._internalPadding * e4, -(_FreeTextEditor._internalPadding + __privateGet(this, _wa)) * e4];
    }
    rebuild() {
      this.parent && (super.rebuild(), null !== this.div && (this.isAttachedToDOM || this.parent.add(this)));
    }
    enableEditMode() {
      if (this.isInEditMode()) return;
      this.parent.setEditingState(false), this.parent.updateToolbar(Q3.FREETEXT), super.enableEditMode(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = true, this._isDraggable = false, this.div.removeAttribute("aria-activedescendant"), __privateSet(this, _Pa, new AbortController());
      const e4 = this._uiManager.combinedSignal(__privateGet(this, _Pa));
      this.editorDiv.addEventListener("keydown", this.editorDivKeydown.bind(this), { signal: e4 }), this.editorDiv.addEventListener("focus", this.editorDivFocus.bind(this), { signal: e4 }), this.editorDiv.addEventListener("blur", this.editorDivBlur.bind(this), { signal: e4 }), this.editorDiv.addEventListener("input", this.editorDivInput.bind(this), { signal: e4 }), this.editorDiv.addEventListener("paste", this.editorDivPaste.bind(this), { signal: e4 });
    }
    disableEditMode() {
      this.isInEditMode() && (this.parent.setEditingState(true), super.disableEditMode(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = false, this.div.setAttribute("aria-activedescendant", __privateGet(this, _Ya)), this._isDraggable = true, __privateGet(this, _Pa)?.abort(), __privateSet(this, _Pa, null), this.div.focus({ preventScroll: true }), this.isEditing = false, this.parent.div.classList.add("freetextEditing"));
    }
    focusin(e4) {
      this._focusEventsAllowed && (super.focusin(e4), e4.target !== this.editorDiv && this.editorDiv.focus());
    }
    onceAdded() {
      this.width || (this.enableEditMode(), this.editorDiv.focus(), this._initialOptions?.isCentered && this.center(), this._initialOptions = null);
    }
    isEmpty() {
      return !this.editorDiv || "" === this.editorDiv.innerText.trim();
    }
    remove() {
      this.isEditing = false, this.parent && (this.parent.setEditingState(true), this.parent.div.classList.add("freetextEditing")), super.remove();
    }
    commit() {
      if (!this.isInEditMode()) return;
      super.commit(), this.disableEditMode();
      const e4 = __privateGet(this, _Ja), t4 = __privateSet(this, _Ja, __privateMethod(this, _FreeTextEditor_instances, Wa_fn).call(this).trimEnd());
      if (e4 === t4) return;
      const setText = (e5) => {
        __privateSet(this, _Ja, e5), e5 ? (__privateMethod(this, _FreeTextEditor_instances, Xa_fn).call(this), this._uiManager.rebuild(this), __privateMethod(this, _FreeTextEditor_instances, _a_fn).call(this)) : this.remove();
      };
      this.addCommands({ cmd: () => {
        setText(t4);
      }, undo: () => {
        setText(e4);
      }, mustExec: false }), __privateMethod(this, _FreeTextEditor_instances, _a_fn).call(this);
    }
    shouldGetKeyboardEvents() {
      return this.isInEditMode();
    }
    enterInEditMode() {
      this.enableEditMode(), this.editorDiv.focus();
    }
    dblclick(e4) {
      this.enterInEditMode();
    }
    keydown(e4) {
      e4.target === this.div && "Enter" === e4.key && (this.enterInEditMode(), e4.preventDefault());
    }
    editorDivKeydown(e4) {
      _FreeTextEditor._keyboardManager.exec(this, e4);
    }
    editorDivFocus(e4) {
      this.isEditing = true;
    }
    editorDivBlur(e4) {
      this.isEditing = false;
    }
    editorDivInput(e4) {
      this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
    }
    disableEditing() {
      this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
    }
    enableEditing() {
      this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", true);
    }
    render() {
      if (this.div) return this.div;
      let e4, t4;
      this.width && (e4 = this.x, t4 = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", __privateGet(this, _Ya)), this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text"), this.enableEditing(), AnnotationEditor._l10nPromise.get("pdfjs-free-text-default-content").then((e5) => this.editorDiv?.setAttribute("default-content", e5)), this.editorDiv.contentEditable = true;
      const { style: i4 } = this.editorDiv;
      if (i4.fontSize = `calc(${__privateGet(this, _wa)}px * var(--scale-factor))`, i4.color = __privateGet(this, _ha2), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), bindEvents(this, this.div, ["dblclick", "keydown"]), this.width) {
        const [i5, a4] = this.parentDimensions;
        if (this.annotationElementId) {
          const { position: s4 } = __privateGet(this, _Oa);
          let [n4, r4] = this.getInitialTranslation();
          [n4, r4] = this.pageTranslationToScreen(n4, r4);
          const [o4, g4] = this.pageDimensions, [c4, h4] = this.pageTranslation;
          let l4, C4;
          switch (this.rotation) {
            case 0:
              l4 = e4 + (s4[0] - c4) / o4, C4 = t4 + this.height - (s4[1] - h4) / g4;
              break;
            case 90:
              l4 = e4 + (s4[0] - c4) / o4, C4 = t4 - (s4[1] - h4) / g4, [n4, r4] = [r4, -n4];
              break;
            case 180:
              l4 = e4 - this.width + (s4[0] - c4) / o4, C4 = t4 - (s4[1] - h4) / g4, [n4, r4] = [-n4, -r4];
              break;
            case 270:
              l4 = e4 + (s4[0] - c4 - this.height * g4) / o4, C4 = t4 + (s4[1] - h4 - this.width * o4) / g4, [n4, r4] = [-r4, n4];
          }
          this.setAt(l4 * i5, C4 * a4, n4, r4);
        } else this.setAt(e4 * i5, t4 * a4, this.width * i5, this.height * a4);
        __privateMethod(this, _FreeTextEditor_instances, Xa_fn).call(this), this._isDraggable = true, this.editorDiv.contentEditable = false;
      } else this._isDraggable = false, this.editorDiv.contentEditable = true;
      return this.div;
    }
    editorDivPaste(e4) {
      var _a5, _b2, _c3;
      const t4 = e4.clipboardData || window.clipboardData, { types: i4 } = t4;
      if (1 === i4.length && "text/plain" === i4[0]) return;
      e4.preventDefault();
      const a4 = __privateMethod(_a5 = _FreeTextEditor, _FreeTextEditor_static, Va_fn).call(_a5, t4.getData("text") || "").replaceAll(st3, "\n");
      if (!a4) return;
      const s4 = window.getSelection();
      if (!s4.rangeCount) return;
      this.editorDiv.normalize(), s4.deleteFromDocument();
      const n4 = s4.getRangeAt(0);
      if (!a4.includes("\n")) return n4.insertNode(document.createTextNode(a4)), this.editorDiv.normalize(), void s4.collapseToStart();
      const { startContainer: r4, startOffset: o4 } = n4, g4 = [], c4 = [];
      if (r4.nodeType === Node.TEXT_NODE) {
        const e5 = r4.parentElement;
        if (c4.push(r4.nodeValue.slice(o4).replaceAll(st3, "")), e5 !== this.editorDiv) {
          let t5 = g4;
          for (const i5 of this.editorDiv.childNodes) i5 !== e5 ? t5.push(__privateMethod(_b2 = _FreeTextEditor, _FreeTextEditor_static, ja_fn).call(_b2, i5)) : t5 = c4;
        }
        g4.push(r4.nodeValue.slice(0, o4).replaceAll(st3, ""));
      } else if (r4 === this.editorDiv) {
        let e5 = g4, t5 = 0;
        for (const i5 of this.editorDiv.childNodes) t5++ === o4 && (e5 = c4), e5.push(__privateMethod(_c3 = _FreeTextEditor, _FreeTextEditor_static, ja_fn).call(_c3, i5));
      }
      __privateSet(this, _Ja, `${g4.join("\n")}${a4}${c4.join("\n")}`), __privateMethod(this, _FreeTextEditor_instances, Xa_fn).call(this);
      const h4 = new Range();
      let l4 = g4.reduce((e5, t5) => e5 + t5.length, 0);
      for (const { firstChild: e5 } of this.editorDiv.childNodes) if (e5.nodeType === Node.TEXT_NODE) {
        const t5 = e5.nodeValue.length;
        if (l4 <= t5) {
          h4.setStart(e5, l4), h4.setEnd(e5, l4);
          break;
        }
        l4 -= t5;
      }
      s4.removeAllRanges(), s4.addRange(h4);
    }
    get contentDiv() {
      return this.editorDiv;
    }
    static deserialize(e4, t4, i4) {
      var _a5;
      let a4 = null;
      if (e4 instanceof FreeTextAnnotationElement) {
        const { data: { defaultAppearanceData: { fontSize: t5, fontColor: i5 }, rect: s5, rotation: n4, id: r4 }, textContent: o4, textPosition: g4, parent: { page: { pageNumber: c4 } } } = e4;
        if (!o4 || 0 === o4.length) return null;
        a4 = e4 = { annotationType: Q3.FREETEXT, color: Array.from(i5), fontSize: t5, value: o4.join("\n"), position: g4, pageIndex: c4 - 1, rect: s5.slice(0), rotation: n4, id: r4, deleted: false };
      }
      const s4 = super.deserialize(e4, t4, i4);
      return __privateSet(s4, _wa, e4.fontSize), __privateSet(s4, _ha2, Util2.makeHexColor(...e4.color)), __privateSet(s4, _Ja, __privateMethod(_a5 = _FreeTextEditor, _FreeTextEditor_static, Va_fn).call(_a5, e4.value)), s4.annotationElementId = e4.id || null, __privateSet(s4, _Oa, a4), s4;
    }
    serialize(e4 = false) {
      if (this.isEmpty()) return null;
      if (this.deleted) return { pageIndex: this.pageIndex, id: this.annotationElementId, deleted: true };
      const t4 = _FreeTextEditor._internalPadding * this.parentScale, i4 = this.getRect(t4, t4), a4 = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : __privateGet(this, _ha2)), s4 = { annotationType: Q3.FREETEXT, color: a4, fontSize: __privateGet(this, _wa), value: __privateMethod(this, _FreeTextEditor_instances, Za_fn).call(this), pageIndex: this.pageIndex, rect: i4, rotation: this.rotation, structTreeParentId: this._structTreeParentId };
      return e4 ? s4 : this.annotationElementId && !__privateMethod(this, _FreeTextEditor_instances, za_fn).call(this, s4) ? null : (s4.id = this.annotationElementId, s4);
    }
    renderAnnotationElement(e4) {
      const t4 = super.renderAnnotationElement(e4);
      if (this.deleted) return t4;
      const { style: i4 } = t4;
      i4.fontSize = `calc(${__privateGet(this, _wa)}px * var(--scale-factor))`, i4.color = __privateGet(this, _ha2), t4.replaceChildren();
      for (const e5 of __privateGet(this, _Ja).split("\n")) {
        const i5 = document.createElement("div");
        i5.append(e5 ? document.createTextNode(e5) : document.createElement("br")), t4.append(i5);
      }
      const a4 = _FreeTextEditor._internalPadding * this.parentScale;
      return e4.updateEdited({ rect: this.getRect(a4, a4), popupContent: __privateGet(this, _Ja) }), t4;
    }
    resetAnnotationElement(e4) {
      super.resetAnnotationElement(e4), e4.resetEdited();
    }
  };
  _ha2 = new WeakMap();
  _Ja = new WeakMap();
  _Ya = new WeakMap();
  _Pa = new WeakMap();
  _wa = new WeakMap();
  _Oa = new WeakMap();
  _FreeTextEditor_instances = new WeakSet();
  Ka_fn = function(e4) {
    const setFontsize = (e5) => {
      this.editorDiv.style.fontSize = `calc(${e5}px * var(--scale-factor))`, this.translate(0, -(e5 - __privateGet(this, _wa)) * this.parentScale), __privateSet(this, _wa, e5), __privateMethod(this, _FreeTextEditor_instances, _a_fn).call(this);
    }, t4 = __privateGet(this, _wa);
    this.addCommands({ cmd: setFontsize.bind(this, e4), undo: setFontsize.bind(this, t4), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: true, type: f3.FREETEXT_SIZE, overwriteIfSameType: true, keepUndo: true });
  };
  qa_fn = function(e4) {
    const setColor = (e5) => {
      __privateSet(this, _ha2, this.editorDiv.style.color = e5);
    }, t4 = __privateGet(this, _ha2);
    this.addCommands({ cmd: setColor.bind(this, e4), undo: setColor.bind(this, t4), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: true, type: f3.FREETEXT_COLOR, overwriteIfSameType: true, keepUndo: true });
  };
  Wa_fn = function() {
    var _a5;
    const e4 = [];
    this.editorDiv.normalize();
    for (const t4 of this.editorDiv.childNodes) e4.push(__privateMethod(_a5 = _FreeTextEditor, _FreeTextEditor_static, ja_fn).call(_a5, t4));
    return e4.join("\n");
  };
  _a_fn = function() {
    const [e4, t4] = this.parentDimensions;
    let i4;
    if (this.isAttachedToDOM) i4 = this.div.getBoundingClientRect();
    else {
      const { currentLayer: e5, div: t5 } = this, a4 = t5.style.display, s4 = t5.classList.contains("hidden");
      t5.classList.remove("hidden"), t5.style.display = "hidden", e5.div.append(this.div), i4 = t5.getBoundingClientRect(), t5.remove(), t5.style.display = a4, t5.classList.toggle("hidden", s4);
    }
    this.rotation % 180 == this.parentRotation % 180 ? (this.width = i4.width / e4, this.height = i4.height / t4) : (this.width = i4.height / e4, this.height = i4.width / t4), this.fixAndSetPosition();
  };
  _FreeTextEditor_static = new WeakSet();
  ja_fn = function(e4) {
    return (e4.nodeType === Node.TEXT_NODE ? e4.nodeValue : e4.innerText).replaceAll(st3, "");
  };
  Xa_fn = function() {
    if (this.editorDiv.replaceChildren(), __privateGet(this, _Ja)) for (const e4 of __privateGet(this, _Ja).split("\n")) {
      const t4 = document.createElement("div");
      t4.append(e4 ? document.createTextNode(e4) : document.createElement("br")), this.editorDiv.append(t4);
    }
  };
  Za_fn = function() {
    return __privateGet(this, _Ja).replaceAll("\xA0", " ");
  };
  Va_fn = function(e4) {
    return e4.replaceAll(" ", "\xA0");
  };
  za_fn = function(e4) {
    const { value: t4, fontSize: i4, color: a4, pageIndex: s4 } = __privateGet(this, _Oa);
    return this._hasBeenMoved || e4.value !== t4 || e4.fontSize !== i4 || e4.color.some((e5, t5) => e5 !== a4[t5]) || e4.pageIndex !== s4;
  };
  __privateAdd(_FreeTextEditor, _FreeTextEditor_static);
  __publicField(_FreeTextEditor, "_freeTextDefaultContent", "");
  __publicField(_FreeTextEditor, "_internalPadding", 0);
  __publicField(_FreeTextEditor, "_defaultColor", null);
  __publicField(_FreeTextEditor, "_defaultFontSize", 10);
  __publicField(_FreeTextEditor, "_type", "freetext");
  __publicField(_FreeTextEditor, "_editorType", Q3.FREETEXT);
  let FreeTextEditor = _FreeTextEditor;
  class Outliner {
    constructor(e4, t4 = 0, i4 = 0, a4 = true) {
      __privateAdd(this, _Outliner_instances);
      __privateAdd(this, _$a);
      __privateAdd(this, _es, []);
      __privateAdd(this, _ts, []);
      let s4 = 1 / 0, n4 = -1 / 0, r4 = 1 / 0, o4 = -1 / 0;
      const g4 = 10 ** -4;
      for (const { x: i5, y: a5, width: c5, height: h5 } of e4) {
        const e5 = Math.floor((i5 - t4) / g4) * g4, l5 = Math.ceil((i5 + c5 + t4) / g4) * g4, C5 = Math.floor((a5 - t4) / g4) * g4, d5 = Math.ceil((a5 + h5 + t4) / g4) * g4, u5 = [e5, C5, d5, true], Q4 = [l5, C5, d5, false];
        __privateGet(this, _es).push(u5, Q4), s4 = Math.min(s4, e5), n4 = Math.max(n4, l5), r4 = Math.min(r4, C5), o4 = Math.max(o4, d5);
      }
      const c4 = n4 - s4 + 2 * i4, h4 = o4 - r4 + 2 * i4, l4 = s4 - i4, C4 = r4 - i4, d4 = __privateGet(this, _es).at(a4 ? -1 : -2), u4 = [d4[0], d4[2]];
      for (const e5 of __privateGet(this, _es)) {
        const [t5, i5, a5] = e5;
        e5[0] = (t5 - l4) / c4, e5[1] = (i5 - C4) / h4, e5[2] = (a5 - C4) / h4;
      }
      __privateSet(this, _$a, { x: l4, y: C4, width: c4, height: h4, lastPoint: u4 });
    }
    getOutlines() {
      __privateGet(this, _es).sort((e5, t4) => e5[0] - t4[0] || e5[1] - t4[1] || e5[2] - t4[2]);
      const e4 = [];
      for (const t4 of __privateGet(this, _es)) t4[3] ? (e4.push(...__privateMethod(this, _Outliner_instances, As_fn).call(this, t4)), __privateMethod(this, _Outliner_instances, is_fn).call(this, t4)) : (__privateMethod(this, _Outliner_instances, as_fn).call(this, t4), e4.push(...__privateMethod(this, _Outliner_instances, As_fn).call(this, t4)));
      return __privateMethod(this, _Outliner_instances, ss_fn).call(this, e4);
    }
  }
  _$a = new WeakMap();
  _es = new WeakMap();
  _ts = new WeakMap();
  _Outliner_instances = new WeakSet();
  ss_fn = function(e4) {
    const t4 = [], i4 = /* @__PURE__ */ new Set();
    for (const i5 of e4) {
      const [e5, a5, s5] = i5;
      t4.push([e5, a5, i5], [e5, s5, i5]);
    }
    t4.sort((e5, t5) => e5[1] - t5[1] || e5[0] - t5[0]);
    for (let e5 = 0, a5 = t4.length; e5 < a5; e5 += 2) {
      const a6 = t4[e5][2], s5 = t4[e5 + 1][2];
      a6.push(s5), s5.push(a6), i4.add(a6), i4.add(s5);
    }
    const a4 = [];
    let s4;
    for (; i4.size > 0; ) {
      const e5 = i4.values().next().value;
      let [t5, n4, r4, o4, g4] = e5;
      i4.delete(e5);
      let c4 = t5, h4 = n4;
      for (s4 = [t5, r4], a4.push(s4); ; ) {
        let e6;
        if (i4.has(o4)) e6 = o4;
        else {
          if (!i4.has(g4)) break;
          e6 = g4;
        }
        i4.delete(e6), [t5, n4, r4, o4, g4] = e6, c4 !== t5 && (s4.push(c4, h4, t5, h4 === n4 ? n4 : r4), c4 = t5), h4 = h4 === n4 ? r4 : n4;
      }
      s4.push(c4, h4);
    }
    return new HighlightOutline(a4, __privateGet(this, _$a));
  };
  ns_fn = function(e4) {
    const t4 = __privateGet(this, _ts);
    let i4 = 0, a4 = t4.length - 1;
    for (; i4 <= a4; ) {
      const s4 = i4 + a4 >> 1, n4 = t4[s4][0];
      if (n4 === e4) return s4;
      n4 < e4 ? i4 = s4 + 1 : a4 = s4 - 1;
    }
    return a4 + 1;
  };
  is_fn = function([, e4, t4]) {
    const i4 = __privateMethod(this, _Outliner_instances, ns_fn).call(this, e4);
    __privateGet(this, _ts).splice(i4, 0, [e4, t4]);
  };
  as_fn = function([, e4, t4]) {
    const i4 = __privateMethod(this, _Outliner_instances, ns_fn).call(this, e4);
    for (let a4 = i4; a4 < __privateGet(this, _ts).length; a4++) {
      const [i5, s4] = __privateGet(this, _ts)[a4];
      if (i5 !== e4) break;
      if (i5 === e4 && s4 === t4) return void __privateGet(this, _ts).splice(a4, 1);
    }
    for (let a4 = i4 - 1; a4 >= 0; a4--) {
      const [i5, s4] = __privateGet(this, _ts)[a4];
      if (i5 !== e4) break;
      if (i5 === e4 && s4 === t4) return void __privateGet(this, _ts).splice(a4, 1);
    }
  };
  As_fn = function(e4) {
    const [t4, i4, a4] = e4, s4 = [[t4, i4, a4]], n4 = __privateMethod(this, _Outliner_instances, ns_fn).call(this, a4);
    for (let e5 = 0; e5 < n4; e5++) {
      const [i5, a5] = __privateGet(this, _ts)[e5];
      for (let e6 = 0, n5 = s4.length; e6 < n5; e6++) {
        const [, r4, o4] = s4[e6];
        if (!(a5 <= r4 || o4 <= i5)) if (r4 >= i5) if (o4 > a5) s4[e6][1] = a5;
        else {
          if (1 === n5) return [];
          s4.splice(e6, 1), e6--, n5--;
        }
        else s4[e6][2] = i5, o4 > a5 && s4.push([t4, a5, o4]);
      }
    }
    return s4;
  };
  class Outline {
    toSVGPath() {
      throw new Error("Abstract method `toSVGPath` must be implemented.");
    }
    get box() {
      throw new Error("Abstract getter `box` must be implemented.");
    }
    serialize(e4, t4) {
      throw new Error("Abstract method `serialize` must be implemented.");
    }
    get free() {
      return this instanceof FreeHighlightOutline;
    }
  }
  class HighlightOutline extends Outline {
    constructor(e4, t4) {
      super();
      __privateAdd(this, _$a2);
      __privateAdd(this, _rs);
      __privateSet(this, _rs, e4), __privateSet(this, _$a2, t4);
    }
    toSVGPath() {
      const e4 = [];
      for (const t4 of __privateGet(this, _rs)) {
        let [i4, a4] = t4;
        e4.push(`M${i4} ${a4}`);
        for (let s4 = 2; s4 < t4.length; s4 += 2) {
          const n4 = t4[s4], r4 = t4[s4 + 1];
          n4 === i4 ? (e4.push(`V${r4}`), a4 = r4) : r4 === a4 && (e4.push(`H${n4}`), i4 = n4);
        }
        e4.push("Z");
      }
      return e4.join(" ");
    }
    serialize([e4, t4, i4, a4], s4) {
      const n4 = [], r4 = i4 - e4, o4 = a4 - t4;
      for (const t5 of __privateGet(this, _rs)) {
        const i5 = new Array(t5.length);
        for (let s5 = 0; s5 < t5.length; s5 += 2) i5[s5] = e4 + t5[s5] * r4, i5[s5 + 1] = a4 - t5[s5 + 1] * o4;
        n4.push(i5);
      }
      return n4;
    }
    get box() {
      return __privateGet(this, _$a2);
    }
  }
  _$a2 = new WeakMap();
  _rs = new WeakMap();
  const _FreeOutliner = class _FreeOutliner {
    constructor({ x: e4, y: t4 }, i4, a4, s4, n4, r4 = 0) {
      __privateAdd(this, _FreeOutliner_instances);
      __privateAdd(this, _$a3);
      __privateAdd(this, _os, []);
      __privateAdd(this, _gs);
      __privateAdd(this, _cs);
      __privateAdd(this, _hs, []);
      __privateAdd(this, _ls, new Float64Array(18));
      __privateAdd(this, _Is);
      __privateAdd(this, _Cs);
      __privateAdd(this, _ds);
      __privateAdd(this, _Bs);
      __privateAdd(this, _us);
      __privateAdd(this, _Qs);
      __privateAdd(this, _Es, []);
      __privateSet(this, _$a3, i4), __privateSet(this, _Qs, s4 * a4), __privateSet(this, _cs, n4), __privateGet(this, _ls).set([NaN, NaN, NaN, NaN, e4, t4], 6), __privateSet(this, _gs, r4), __privateSet(this, _Bs, __privateGet(_FreeOutliner, _fs) * a4), __privateSet(this, _ds, __privateGet(_FreeOutliner, _ms) * a4), __privateSet(this, _us, a4), __privateGet(this, _Es).push(e4, t4);
    }
    get free() {
      return true;
    }
    isEmpty() {
      return isNaN(__privateGet(this, _ls)[8]);
    }
    add({ x: e4, y: t4 }) {
      __privateSet(this, _Is, e4), __privateSet(this, _Cs, t4);
      const [i4, a4, s4, n4] = __privateGet(this, _$a3);
      let [r4, o4, g4, c4] = __privateGet(this, _ls).subarray(8, 12);
      const h4 = e4 - g4, l4 = t4 - c4, C4 = Math.hypot(h4, l4);
      if (C4 < __privateGet(this, _ds)) return false;
      const d4 = C4 - __privateGet(this, _Bs), u4 = d4 / C4, Q4 = u4 * h4, f4 = u4 * l4;
      let p4 = r4, m4 = o4;
      r4 = g4, o4 = c4, g4 += Q4, c4 += f4, __privateGet(this, _Es)?.push(e4, t4);
      const y4 = Q4 / d4, w4 = -f4 / d4 * __privateGet(this, _Qs), b4 = y4 * __privateGet(this, _Qs);
      if (__privateGet(this, _ls).set(__privateGet(this, _ls).subarray(2, 8), 0), __privateGet(this, _ls).set([g4 + w4, c4 + b4], 4), __privateGet(this, _ls).set(__privateGet(this, _ls).subarray(14, 18), 12), __privateGet(this, _ls).set([g4 - w4, c4 - b4], 16), isNaN(__privateGet(this, _ls)[6])) return 0 === __privateGet(this, _hs).length && (__privateGet(this, _ls).set([r4 + w4, o4 + b4], 2), __privateGet(this, _hs).push(NaN, NaN, NaN, NaN, (r4 + w4 - i4) / s4, (o4 + b4 - a4) / n4), __privateGet(this, _ls).set([r4 - w4, o4 - b4], 14), __privateGet(this, _os).push(NaN, NaN, NaN, NaN, (r4 - w4 - i4) / s4, (o4 - b4 - a4) / n4)), __privateGet(this, _ls).set([p4, m4, r4, o4, g4, c4], 6), !this.isEmpty();
      __privateGet(this, _ls).set([p4, m4, r4, o4, g4, c4], 6);
      return Math.abs(Math.atan2(m4 - o4, p4 - r4) - Math.atan2(f4, Q4)) < Math.PI / 2 ? ([r4, o4, g4, c4] = __privateGet(this, _ls).subarray(2, 6), __privateGet(this, _hs).push(NaN, NaN, NaN, NaN, ((r4 + g4) / 2 - i4) / s4, ((o4 + c4) / 2 - a4) / n4), [r4, o4, p4, m4] = __privateGet(this, _ls).subarray(14, 18), __privateGet(this, _os).push(NaN, NaN, NaN, NaN, ((p4 + r4) / 2 - i4) / s4, ((m4 + o4) / 2 - a4) / n4), true) : ([p4, m4, r4, o4, g4, c4] = __privateGet(this, _ls).subarray(0, 6), __privateGet(this, _hs).push(((p4 + 5 * r4) / 6 - i4) / s4, ((m4 + 5 * o4) / 6 - a4) / n4, ((5 * r4 + g4) / 6 - i4) / s4, ((5 * o4 + c4) / 6 - a4) / n4, ((r4 + g4) / 2 - i4) / s4, ((o4 + c4) / 2 - a4) / n4), [g4, c4, r4, o4, p4, m4] = __privateGet(this, _ls).subarray(12, 18), __privateGet(this, _os).push(((p4 + 5 * r4) / 6 - i4) / s4, ((m4 + 5 * o4) / 6 - a4) / n4, ((5 * r4 + g4) / 6 - i4) / s4, ((5 * o4 + c4) / 6 - a4) / n4, ((r4 + g4) / 2 - i4) / s4, ((o4 + c4) / 2 - a4) / n4), true);
    }
    toSVGPath() {
      if (this.isEmpty()) return "";
      const e4 = __privateGet(this, _hs), t4 = __privateGet(this, _os), i4 = __privateGet(this, _ls).subarray(4, 6), a4 = __privateGet(this, _ls).subarray(16, 18), [s4, n4, r4, o4] = __privateGet(this, _$a3), [g4, c4, h4, l4] = __privateMethod(this, _FreeOutliner_instances, ys_fn).call(this);
      if (isNaN(__privateGet(this, _ls)[6]) && !this.isEmpty()) return `M${(__privateGet(this, _ls)[2] - s4) / r4} ${(__privateGet(this, _ls)[3] - n4) / o4} L${(__privateGet(this, _ls)[4] - s4) / r4} ${(__privateGet(this, _ls)[5] - n4) / o4} L${g4} ${c4} L${h4} ${l4} L${(__privateGet(this, _ls)[16] - s4) / r4} ${(__privateGet(this, _ls)[17] - n4) / o4} L${(__privateGet(this, _ls)[14] - s4) / r4} ${(__privateGet(this, _ls)[15] - n4) / o4} Z`;
      const C4 = [];
      C4.push(`M${e4[4]} ${e4[5]}`);
      for (let t5 = 6; t5 < e4.length; t5 += 6) isNaN(e4[t5]) ? C4.push(`L${e4[t5 + 4]} ${e4[t5 + 5]}`) : C4.push(`C${e4[t5]} ${e4[t5 + 1]} ${e4[t5 + 2]} ${e4[t5 + 3]} ${e4[t5 + 4]} ${e4[t5 + 5]}`);
      C4.push(`L${(i4[0] - s4) / r4} ${(i4[1] - n4) / o4} L${g4} ${c4} L${h4} ${l4} L${(a4[0] - s4) / r4} ${(a4[1] - n4) / o4}`);
      for (let e5 = t4.length - 6; e5 >= 6; e5 -= 6) isNaN(t4[e5]) ? C4.push(`L${t4[e5 + 4]} ${t4[e5 + 5]}`) : C4.push(`C${t4[e5]} ${t4[e5 + 1]} ${t4[e5 + 2]} ${t4[e5 + 3]} ${t4[e5 + 4]} ${t4[e5 + 5]}`);
      return C4.push(`L${t4[4]} ${t4[5]} Z`), C4.join(" ");
    }
    getOutlines() {
      const e4 = __privateGet(this, _hs), t4 = __privateGet(this, _os), i4 = __privateGet(this, _ls), a4 = i4.subarray(4, 6), s4 = i4.subarray(16, 18), [n4, r4, o4, g4] = __privateGet(this, _$a3), c4 = new Float64Array((__privateGet(this, _Es)?.length ?? 0) + 2);
      for (let e5 = 0, t5 = c4.length - 2; e5 < t5; e5 += 2) c4[e5] = (__privateGet(this, _Es)[e5] - n4) / o4, c4[e5 + 1] = (__privateGet(this, _Es)[e5 + 1] - r4) / g4;
      c4[c4.length - 2] = (__privateGet(this, _Is) - n4) / o4, c4[c4.length - 1] = (__privateGet(this, _Cs) - r4) / g4;
      const [h4, l4, C4, d4] = __privateMethod(this, _FreeOutliner_instances, ys_fn).call(this);
      if (isNaN(i4[6]) && !this.isEmpty()) {
        const e5 = new Float64Array(36);
        return e5.set([NaN, NaN, NaN, NaN, (i4[2] - n4) / o4, (i4[3] - r4) / g4, NaN, NaN, NaN, NaN, (i4[4] - n4) / o4, (i4[5] - r4) / g4, NaN, NaN, NaN, NaN, h4, l4, NaN, NaN, NaN, NaN, C4, d4, NaN, NaN, NaN, NaN, (i4[16] - n4) / o4, (i4[17] - r4) / g4, NaN, NaN, NaN, NaN, (i4[14] - n4) / o4, (i4[15] - r4) / g4], 0), new FreeHighlightOutline(e5, c4, __privateGet(this, _$a3), __privateGet(this, _us), __privateGet(this, _gs), __privateGet(this, _cs));
      }
      const u4 = new Float64Array(__privateGet(this, _hs).length + 24 + __privateGet(this, _os).length);
      let Q4 = e4.length;
      for (let t5 = 0; t5 < Q4; t5 += 2) isNaN(e4[t5]) ? u4[t5] = u4[t5 + 1] = NaN : (u4[t5] = e4[t5], u4[t5 + 1] = e4[t5 + 1]);
      u4.set([NaN, NaN, NaN, NaN, (a4[0] - n4) / o4, (a4[1] - r4) / g4, NaN, NaN, NaN, NaN, h4, l4, NaN, NaN, NaN, NaN, C4, d4, NaN, NaN, NaN, NaN, (s4[0] - n4) / o4, (s4[1] - r4) / g4], Q4), Q4 += 24;
      for (let e5 = t4.length - 6; e5 >= 6; e5 -= 6) for (let i5 = 0; i5 < 6; i5 += 2) isNaN(t4[e5 + i5]) ? (u4[Q4] = u4[Q4 + 1] = NaN, Q4 += 2) : (u4[Q4] = t4[e5 + i5], u4[Q4 + 1] = t4[e5 + i5 + 1], Q4 += 2);
      return u4.set([NaN, NaN, NaN, NaN, t4[4], t4[5]], Q4), new FreeHighlightOutline(u4, c4, __privateGet(this, _$a3), __privateGet(this, _us), __privateGet(this, _gs), __privateGet(this, _cs));
    }
  };
  _$a3 = new WeakMap();
  _os = new WeakMap();
  _gs = new WeakMap();
  _cs = new WeakMap();
  _hs = new WeakMap();
  _ls = new WeakMap();
  _Is = new WeakMap();
  _Cs = new WeakMap();
  _ds = new WeakMap();
  _Bs = new WeakMap();
  _us = new WeakMap();
  _Qs = new WeakMap();
  _Es = new WeakMap();
  _fs = new WeakMap();
  _ps = new WeakMap();
  _ms = new WeakMap();
  _FreeOutliner_instances = new WeakSet();
  ys_fn = function() {
    const e4 = __privateGet(this, _ls).subarray(4, 6), t4 = __privateGet(this, _ls).subarray(16, 18), [i4, a4, s4, n4] = __privateGet(this, _$a3);
    return [(__privateGet(this, _Is) + (e4[0] - t4[0]) / 2 - i4) / s4, (__privateGet(this, _Cs) + (e4[1] - t4[1]) / 2 - a4) / n4, (__privateGet(this, _Is) + (t4[0] - e4[0]) / 2 - i4) / s4, (__privateGet(this, _Cs) + (t4[1] - e4[1]) / 2 - a4) / n4];
  };
  __privateAdd(_FreeOutliner, _fs, 8);
  __privateAdd(_FreeOutliner, _ps, 2);
  __privateAdd(_FreeOutliner, _ms, __privateGet(_FreeOutliner, _fs) + __privateGet(_FreeOutliner, _ps));
  let FreeOutliner = _FreeOutliner;
  class FreeHighlightOutline extends Outline {
    constructor(e4, t4, i4, a4, s4, n4) {
      super();
      __privateAdd(this, _FreeHighlightOutline_instances);
      __privateAdd(this, _$a4);
      __privateAdd(this, _ws, null);
      __privateAdd(this, _gs2);
      __privateAdd(this, _cs2);
      __privateAdd(this, _Es2);
      __privateAdd(this, _us2);
      __privateAdd(this, _bs);
      __privateSet(this, _bs, e4), __privateSet(this, _Es2, t4), __privateSet(this, _$a4, i4), __privateSet(this, _us2, a4), __privateSet(this, _gs2, s4), __privateSet(this, _cs2, n4), __privateMethod(this, _FreeHighlightOutline_instances, Ds_fn).call(this, n4);
      const { x: r4, y: o4, width: g4, height: c4 } = __privateGet(this, _ws);
      for (let t5 = 0, i5 = e4.length; t5 < i5; t5 += 2) e4[t5] = (e4[t5] - r4) / g4, e4[t5 + 1] = (e4[t5 + 1] - o4) / c4;
      for (let e5 = 0, i5 = t4.length; e5 < i5; e5 += 2) t4[e5] = (t4[e5] - r4) / g4, t4[e5 + 1] = (t4[e5 + 1] - o4) / c4;
    }
    toSVGPath() {
      const e4 = [`M${__privateGet(this, _bs)[4]} ${__privateGet(this, _bs)[5]}`];
      for (let t4 = 6, i4 = __privateGet(this, _bs).length; t4 < i4; t4 += 6) isNaN(__privateGet(this, _bs)[t4]) ? e4.push(`L${__privateGet(this, _bs)[t4 + 4]} ${__privateGet(this, _bs)[t4 + 5]}`) : e4.push(`C${__privateGet(this, _bs)[t4]} ${__privateGet(this, _bs)[t4 + 1]} ${__privateGet(this, _bs)[t4 + 2]} ${__privateGet(this, _bs)[t4 + 3]} ${__privateGet(this, _bs)[t4 + 4]} ${__privateGet(this, _bs)[t4 + 5]}`);
      return e4.push("Z"), e4.join(" ");
    }
    serialize([e4, t4, i4, a4], s4) {
      const n4 = i4 - e4, r4 = a4 - t4;
      let o4, g4;
      switch (s4) {
        case 0:
          o4 = __privateMethod(this, _FreeHighlightOutline_instances, Ss_fn).call(this, __privateGet(this, _bs), e4, a4, n4, -r4), g4 = __privateMethod(this, _FreeHighlightOutline_instances, Ss_fn).call(this, __privateGet(this, _Es2), e4, a4, n4, -r4);
          break;
        case 90:
          o4 = __privateMethod(this, _FreeHighlightOutline_instances, Fs_fn).call(this, __privateGet(this, _bs), e4, t4, n4, r4), g4 = __privateMethod(this, _FreeHighlightOutline_instances, Fs_fn).call(this, __privateGet(this, _Es2), e4, t4, n4, r4);
          break;
        case 180:
          o4 = __privateMethod(this, _FreeHighlightOutline_instances, Ss_fn).call(this, __privateGet(this, _bs), i4, t4, -n4, r4), g4 = __privateMethod(this, _FreeHighlightOutline_instances, Ss_fn).call(this, __privateGet(this, _Es2), i4, t4, -n4, r4);
          break;
        case 270:
          o4 = __privateMethod(this, _FreeHighlightOutline_instances, Fs_fn).call(this, __privateGet(this, _bs), i4, a4, -n4, -r4), g4 = __privateMethod(this, _FreeHighlightOutline_instances, Fs_fn).call(this, __privateGet(this, _Es2), i4, a4, -n4, -r4);
      }
      return { outline: Array.from(o4), points: [Array.from(g4)] };
    }
    get box() {
      return __privateGet(this, _ws);
    }
    getNewOutline(e4, t4) {
      const { x: i4, y: a4, width: s4, height: n4 } = __privateGet(this, _ws), [r4, o4, g4, c4] = __privateGet(this, _$a4), h4 = s4 * g4, l4 = n4 * c4, C4 = i4 * g4 + r4, d4 = a4 * c4 + o4, u4 = new FreeOutliner({ x: __privateGet(this, _Es2)[0] * h4 + C4, y: __privateGet(this, _Es2)[1] * l4 + d4 }, __privateGet(this, _$a4), __privateGet(this, _us2), e4, __privateGet(this, _cs2), t4 ?? __privateGet(this, _gs2));
      for (let e5 = 2; e5 < __privateGet(this, _Es2).length; e5 += 2) u4.add({ x: __privateGet(this, _Es2)[e5] * h4 + C4, y: __privateGet(this, _Es2)[e5 + 1] * l4 + d4 });
      return u4.getOutlines();
    }
  }
  _$a4 = new WeakMap();
  _ws = new WeakMap();
  _gs2 = new WeakMap();
  _cs2 = new WeakMap();
  _Es2 = new WeakMap();
  _us2 = new WeakMap();
  _bs = new WeakMap();
  _FreeHighlightOutline_instances = new WeakSet();
  Ss_fn = function(e4, t4, i4, a4, s4) {
    const n4 = new Float64Array(e4.length);
    for (let r4 = 0, o4 = e4.length; r4 < o4; r4 += 2) n4[r4] = t4 + e4[r4] * a4, n4[r4 + 1] = i4 + e4[r4 + 1] * s4;
    return n4;
  };
  Fs_fn = function(e4, t4, i4, a4, s4) {
    const n4 = new Float64Array(e4.length);
    for (let r4 = 0, o4 = e4.length; r4 < o4; r4 += 2) n4[r4] = t4 + e4[r4 + 1] * a4, n4[r4 + 1] = i4 + e4[r4] * s4;
    return n4;
  };
  Ds_fn = function(e4) {
    const t4 = __privateGet(this, _bs);
    let i4 = t4[4], a4 = t4[5], s4 = i4, n4 = a4, r4 = i4, o4 = a4, g4 = i4, c4 = a4;
    const h4 = e4 ? Math.max : Math.min;
    for (let e5 = 6, l5 = t4.length; e5 < l5; e5 += 6) {
      if (isNaN(t4[e5])) s4 = Math.min(s4, t4[e5 + 4]), n4 = Math.min(n4, t4[e5 + 5]), r4 = Math.max(r4, t4[e5 + 4]), o4 = Math.max(o4, t4[e5 + 5]), c4 < t4[e5 + 5] ? (g4 = t4[e5 + 4], c4 = t4[e5 + 5]) : c4 === t4[e5 + 5] && (g4 = h4(g4, t4[e5 + 4]));
      else {
        const l6 = Util2.bezierBoundingBox(i4, a4, ...t4.slice(e5, e5 + 6));
        s4 = Math.min(s4, l6[0]), n4 = Math.min(n4, l6[1]), r4 = Math.max(r4, l6[2]), o4 = Math.max(o4, l6[3]), c4 < l6[3] ? (g4 = l6[2], c4 = l6[3]) : c4 === l6[3] && (g4 = h4(g4, l6[2]));
      }
      i4 = t4[e5 + 4], a4 = t4[e5 + 5];
    }
    const l4 = s4 - __privateGet(this, _gs2), C4 = n4 - __privateGet(this, _gs2), d4 = r4 - s4 + 2 * __privateGet(this, _gs2), u4 = o4 - n4 + 2 * __privateGet(this, _gs2);
    __privateSet(this, _ws, { x: l4, y: C4, width: d4, height: u4, lastPoint: [g4, c4] });
  };
  const _ColorPicker = class _ColorPicker {
    constructor({ editor: e4 = null, uiManager: t4 = null }) {
      __privateAdd(this, _ColorPicker_instances);
      __privateAdd(this, _ia2, __privateMethod(this, _ColorPicker_instances, aa_fn2).bind(this));
      __privateAdd(this, _ks, __privateMethod(this, _ColorPicker_instances, ee_fn2).bind(this));
      __privateAdd(this, _Rs, null);
      __privateAdd(this, _xs, null);
      __privateAdd(this, _Ns);
      __privateAdd(this, _Ms, null);
      __privateAdd(this, _Gs, false);
      __privateAdd(this, _vs, false);
      __privateAdd(this, _V3, null);
      __privateAdd(this, _Ls);
      __privateAdd(this, _ne2, null);
      __privateAdd(this, _Us);
      e4 ? (__privateSet(this, _vs, false), __privateSet(this, _Us, f3.HIGHLIGHT_COLOR), __privateSet(this, _V3, e4)) : (__privateSet(this, _vs, true), __privateSet(this, _Us, f3.HIGHLIGHT_DEFAULT_COLOR)), __privateSet(this, _ne2, e4?._uiManager || t4), __privateSet(this, _Ls, __privateGet(this, _ne2)._eventBus), __privateSet(this, _Ns, e4?.color || __privateGet(this, _ne2)?.highlightColors.values().next().value || "#FFFF98");
    }
    static get _keyboardManager() {
      return shadow2(this, "_keyboardManager", new KeyboardManager([[["Escape", "mac+Escape"], _ColorPicker.prototype._hideDropdownFromKeyboard], [[" ", "mac+ "], _ColorPicker.prototype._colorSelectFromKeyboard], [["ArrowDown", "ArrowRight", "mac+ArrowDown", "mac+ArrowRight"], _ColorPicker.prototype._moveToNext], [["ArrowUp", "ArrowLeft", "mac+ArrowUp", "mac+ArrowLeft"], _ColorPicker.prototype._moveToPrevious], [["Home", "mac+Home"], _ColorPicker.prototype._moveToBeginning], [["End", "mac+End"], _ColorPicker.prototype._moveToEnd]]));
    }
    renderButton() {
      const e4 = __privateSet(this, _Rs, document.createElement("button"));
      e4.className = "colorPicker", e4.tabIndex = "0", e4.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button"), e4.setAttribute("aria-haspopup", true);
      const t4 = __privateGet(this, _ne2)._signal;
      e4.addEventListener("click", __privateMethod(this, _ColorPicker_instances, Hs_fn).bind(this), { signal: t4 }), e4.addEventListener("keydown", __privateGet(this, _ia2), { signal: t4 });
      const i4 = __privateSet(this, _xs, document.createElement("span"));
      return i4.className = "swatch", i4.setAttribute("aria-hidden", true), i4.style.backgroundColor = __privateGet(this, _Ns), e4.append(i4), e4;
    }
    renderMainDropdown() {
      const e4 = __privateSet(this, _Ms, __privateMethod(this, _ColorPicker_instances, Ts_fn).call(this));
      return e4.setAttribute("aria-orientation", "horizontal"), e4.setAttribute("aria-labelledby", "highlightColorPickerLabel"), e4;
    }
    _colorSelectFromKeyboard(e4) {
      if (e4.target === __privateGet(this, _Rs)) return void __privateMethod(this, _ColorPicker_instances, Hs_fn).call(this, e4);
      const t4 = e4.target.getAttribute("data-color");
      t4 && __privateMethod(this, _ColorPicker_instances, Js_fn).call(this, t4, e4);
    }
    _moveToNext(e4) {
      __privateGet(this, _ColorPicker_instances, Ys_get) ? e4.target !== __privateGet(this, _Rs) ? e4.target.nextSibling?.focus() : __privateGet(this, _Ms).firstChild?.focus() : __privateMethod(this, _ColorPicker_instances, Hs_fn).call(this, e4);
    }
    _moveToPrevious(e4) {
      e4.target !== __privateGet(this, _Ms)?.firstChild && e4.target !== __privateGet(this, _Rs) ? (__privateGet(this, _ColorPicker_instances, Ys_get) || __privateMethod(this, _ColorPicker_instances, Hs_fn).call(this, e4), e4.target.previousSibling?.focus()) : __privateGet(this, _ColorPicker_instances, Ys_get) && this._hideDropdownFromKeyboard();
    }
    _moveToBeginning(e4) {
      __privateGet(this, _ColorPicker_instances, Ys_get) ? __privateGet(this, _Ms).firstChild?.focus() : __privateMethod(this, _ColorPicker_instances, Hs_fn).call(this, e4);
    }
    _moveToEnd(e4) {
      __privateGet(this, _ColorPicker_instances, Ys_get) ? __privateGet(this, _Ms).lastChild?.focus() : __privateMethod(this, _ColorPicker_instances, Hs_fn).call(this, e4);
    }
    hideDropdown() {
      __privateGet(this, _Ms)?.classList.add("hidden"), window.removeEventListener("pointerdown", __privateGet(this, _ks));
    }
    _hideDropdownFromKeyboard() {
      __privateGet(this, _vs) || (__privateGet(this, _ColorPicker_instances, Ys_get) ? (this.hideDropdown(), __privateGet(this, _Rs).focus({ preventScroll: true, focusVisible: __privateGet(this, _Gs) })) : __privateGet(this, _V3)?.unselect());
    }
    updateColor(e4) {
      if (__privateGet(this, _xs) && (__privateGet(this, _xs).style.backgroundColor = e4), !__privateGet(this, _Ms)) return;
      const t4 = __privateGet(this, _ne2).highlightColors.values();
      for (const i4 of __privateGet(this, _Ms).children) i4.setAttribute("aria-selected", t4.next().value === e4);
    }
    destroy() {
      __privateGet(this, _Rs)?.remove(), __privateSet(this, _Rs, null), __privateSet(this, _xs, null), __privateGet(this, _Ms)?.remove(), __privateSet(this, _Ms, null);
    }
  };
  _ia2 = new WeakMap();
  _ks = new WeakMap();
  _Rs = new WeakMap();
  _xs = new WeakMap();
  _Ns = new WeakMap();
  _Ms = new WeakMap();
  _Gs = new WeakMap();
  _vs = new WeakMap();
  _V3 = new WeakMap();
  _Ls = new WeakMap();
  _ne2 = new WeakMap();
  _Us = new WeakMap();
  _ColorPicker_instances = new WeakSet();
  Ts_fn = function() {
    const e4 = document.createElement("div"), t4 = __privateGet(this, _ne2)._signal;
    e4.addEventListener("contextmenu", noContextMenu, { signal: t4 }), e4.className = "dropdown", e4.role = "listbox", e4.setAttribute("aria-multiselectable", false), e4.setAttribute("aria-orientation", "vertical"), e4.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown");
    for (const [i4, a4] of __privateGet(this, _ne2).highlightColors) {
      const s4 = document.createElement("button");
      s4.tabIndex = "0", s4.role = "option", s4.setAttribute("data-color", a4), s4.title = i4, s4.setAttribute("data-l10n-id", `pdfjs-editor-colorpicker-${i4}`);
      const n4 = document.createElement("span");
      s4.append(n4), n4.className = "swatch", n4.style.backgroundColor = a4, s4.setAttribute("aria-selected", a4 === __privateGet(this, _Ns)), s4.addEventListener("click", __privateMethod(this, _ColorPicker_instances, Js_fn).bind(this, a4), { signal: t4 }), e4.append(s4);
    }
    return e4.addEventListener("keydown", __privateGet(this, _ia2), { signal: t4 }), e4;
  };
  Js_fn = function(e4, t4) {
    t4.stopPropagation(), __privateGet(this, _Ls).dispatch("switchannotationeditorparams", { source: this, type: __privateGet(this, _Us), value: e4 });
  };
  aa_fn2 = function(e4) {
    _ColorPicker._keyboardManager.exec(this, e4);
  };
  Hs_fn = function(e4) {
    if (__privateGet(this, _ColorPicker_instances, Ys_get)) return void this.hideDropdown();
    if (__privateSet(this, _Gs, 0 === e4.detail), window.addEventListener("pointerdown", __privateGet(this, _ks), { signal: __privateGet(this, _ne2)._signal }), __privateGet(this, _Ms)) return void __privateGet(this, _Ms).classList.remove("hidden");
    const t4 = __privateSet(this, _Ms, __privateMethod(this, _ColorPicker_instances, Ts_fn).call(this));
    __privateGet(this, _Rs).append(t4);
  };
  ee_fn2 = function(e4) {
    __privateGet(this, _Ms)?.contains(e4.target) || this.hideDropdown();
  };
  Ys_get = function() {
    return __privateGet(this, _Ms) && !__privateGet(this, _Ms).classList.contains("hidden");
  };
  let ColorPicker = _ColorPicker;
  const _HighlightEditor = class _HighlightEditor extends AnnotationEditor {
    constructor(e4) {
      super({ ...e4, name: "highlightEditor" });
      __privateAdd(this, _HighlightEditor_instances);
      __privateAdd(this, _Ps, null);
      __privateAdd(this, _Os, 0);
      __privateAdd(this, _Ks);
      __privateAdd(this, _qs, null);
      __privateAdd(this, _X2, null);
      __privateAdd(this, __s, null);
      __privateAdd(this, _Ws, null);
      __privateAdd(this, _js, 0);
      __privateAdd(this, _Xs, null);
      __privateAdd(this, _Vs, null);
      __privateAdd(this, _ce4, null);
      __privateAdd(this, _Zs, false);
      __privateAdd(this, _zs, null);
      __privateAdd(this, _$s);
      __privateAdd(this, _en, null);
      __privateAdd(this, _tn, "");
      __privateAdd(this, _Qs2);
      __privateAdd(this, _An, "");
      this.color = e4.color || _HighlightEditor._defaultColor, __privateSet(this, _Qs2, e4.thickness || _HighlightEditor._defaultThickness), __privateSet(this, _$s, e4.opacity || _HighlightEditor._defaultOpacity), __privateSet(this, _Ks, e4.boxes || null), __privateSet(this, _An, e4.methodOfCreation || ""), __privateSet(this, _tn, e4.text || ""), this._isDraggable = false, e4.highlightId > -1 ? (__privateSet(this, _Zs, true), __privateMethod(this, _HighlightEditor_instances, in_fn).call(this, e4), __privateMethod(this, _HighlightEditor_instances, an_fn).call(this)) : (__privateSet(this, _Ps, e4.anchorNode), __privateSet(this, _Os, e4.anchorOffset), __privateSet(this, _Ws, e4.focusNode), __privateSet(this, _js, e4.focusOffset), __privateMethod(this, _HighlightEditor_instances, sn_fn).call(this), __privateMethod(this, _HighlightEditor_instances, an_fn).call(this), this.rotate(this.rotation));
    }
    static get _keyboardManager() {
      const e4 = _HighlightEditor.prototype;
      return shadow2(this, "_keyboardManager", new KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], e4._moveCaret, { args: [0] }], [["ArrowRight", "mac+ArrowRight"], e4._moveCaret, { args: [1] }], [["ArrowUp", "mac+ArrowUp"], e4._moveCaret, { args: [2] }], [["ArrowDown", "mac+ArrowDown"], e4._moveCaret, { args: [3] }]]));
    }
    get telemetryInitialData() {
      return { action: "added", type: __privateGet(this, _Zs) ? "free_highlight" : "highlight", color: this._uiManager.highlightColorNames.get(this.color), thickness: __privateGet(this, _Qs2), methodOfCreation: __privateGet(this, _An) };
    }
    get telemetryFinalData() {
      return { type: "highlight", color: this._uiManager.highlightColorNames.get(this.color) };
    }
    static computeTelemetryFinalData(e4) {
      return { numberOfColors: e4.get("color").size };
    }
    static initialize(e4, t4) {
      AnnotationEditor.initialize(e4, t4), _HighlightEditor._defaultColor || (_HighlightEditor._defaultColor = t4.highlightColors?.values().next().value || "#fff066");
    }
    static updateDefaultParams(e4, t4) {
      switch (e4) {
        case f3.HIGHLIGHT_DEFAULT_COLOR:
          _HighlightEditor._defaultColor = t4;
          break;
        case f3.HIGHLIGHT_THICKNESS:
          _HighlightEditor._defaultThickness = t4;
      }
    }
    translateInPage(e4, t4) {
    }
    get toolbarPosition() {
      return __privateGet(this, _zs);
    }
    updateParams(e4, t4) {
      switch (e4) {
        case f3.HIGHLIGHT_COLOR:
          __privateMethod(this, _HighlightEditor_instances, qa_fn2).call(this, t4);
          break;
        case f3.HIGHLIGHT_THICKNESS:
          __privateMethod(this, _HighlightEditor_instances, rn_fn).call(this, t4);
      }
    }
    static get defaultPropertiesToUpdate() {
      return [[f3.HIGHLIGHT_DEFAULT_COLOR, _HighlightEditor._defaultColor], [f3.HIGHLIGHT_THICKNESS, _HighlightEditor._defaultThickness]];
    }
    get propertiesToUpdate() {
      return [[f3.HIGHLIGHT_COLOR, this.color || _HighlightEditor._defaultColor], [f3.HIGHLIGHT_THICKNESS, __privateGet(this, _Qs2) || _HighlightEditor._defaultThickness], [f3.HIGHLIGHT_FREE, __privateGet(this, _Zs)]];
    }
    async addEditToolbar() {
      const e4 = await super.addEditToolbar();
      return e4 ? (this._uiManager.highlightColors && (__privateSet(this, _X2, new ColorPicker({ editor: this })), e4.addColorPicker(__privateGet(this, _X2))), e4) : null;
    }
    disableEditing() {
      super.disableEditing(), this.div.classList.toggle("disabled", true);
    }
    enableEditing() {
      super.enableEditing(), this.div.classList.toggle("disabled", false);
    }
    fixAndSetPosition() {
      return super.fixAndSetPosition(__privateMethod(this, _HighlightEditor_instances, gn_fn).call(this));
    }
    getBaseTranslation() {
      return [0, 0];
    }
    getRect(e4, t4) {
      return super.getRect(e4, t4, __privateMethod(this, _HighlightEditor_instances, gn_fn).call(this));
    }
    onceAdded() {
      this.parent.addUndoableEditor(this), this.div.focus();
    }
    remove() {
      __privateMethod(this, _HighlightEditor_instances, cn_fn).call(this), this._reportTelemetry({ action: "deleted" }), super.remove();
    }
    rebuild() {
      this.parent && (super.rebuild(), null !== this.div && (__privateMethod(this, _HighlightEditor_instances, an_fn).call(this), this.isAttachedToDOM || this.parent.add(this)));
    }
    setParent(e4) {
      let t4 = false;
      this.parent && !e4 ? __privateMethod(this, _HighlightEditor_instances, cn_fn).call(this) : e4 && (__privateMethod(this, _HighlightEditor_instances, an_fn).call(this, e4), t4 = !this.parent && this.div?.classList.contains("selectedEditor")), super.setParent(e4), this.show(this._isVisible), t4 && this.select();
    }
    rotate(e4) {
      var _a5, _b2, _c3;
      const { drawLayer: t4 } = this.parent;
      let i4;
      __privateGet(this, _Zs) ? (e4 = (e4 - this.rotation + 360) % 360, i4 = __privateMethod(_a5 = _HighlightEditor, _HighlightEditor_static, nn_fn).call(_a5, __privateGet(this, _Vs).box, e4)) : i4 = __privateMethod(_b2 = _HighlightEditor, _HighlightEditor_static, nn_fn).call(_b2, this, e4), t4.rotate(__privateGet(this, _ce4), e4), t4.rotate(__privateGet(this, _en), e4), t4.updateBox(__privateGet(this, _ce4), i4), t4.updateBox(__privateGet(this, _en), __privateMethod(_c3 = _HighlightEditor, _HighlightEditor_static, nn_fn).call(_c3, __privateGet(this, __s).box, e4));
    }
    render() {
      if (this.div) return this.div;
      const e4 = super.render();
      __privateGet(this, _tn) && (e4.setAttribute("aria-label", __privateGet(this, _tn)), e4.setAttribute("role", "mark")), __privateGet(this, _Zs) ? e4.classList.add("free") : this.div.addEventListener("keydown", __privateMethod(this, _HighlightEditor_instances, hn_fn).bind(this), { signal: this._uiManager._signal });
      const t4 = __privateSet(this, _Xs, document.createElement("div"));
      e4.append(t4), t4.setAttribute("aria-hidden", "true"), t4.className = "internal", t4.style.clipPath = __privateGet(this, _qs);
      const [i4, a4] = this.parentDimensions;
      return this.setDims(this.width * i4, this.height * a4), bindEvents(this, __privateGet(this, _Xs), ["pointerover", "pointerleave"]), this.enableEditing(), e4;
    }
    pointerover() {
      this.parent.drawLayer.addClass(__privateGet(this, _en), "hovered");
    }
    pointerleave() {
      this.parent.drawLayer.removeClass(__privateGet(this, _en), "hovered");
    }
    _moveCaret(e4) {
      switch (this.parent.unselect(this), e4) {
        case 0:
        case 2:
          __privateMethod(this, _HighlightEditor_instances, ln_fn).call(this, true);
          break;
        case 1:
        case 3:
          __privateMethod(this, _HighlightEditor_instances, ln_fn).call(this, false);
      }
    }
    select() {
      super.select(), __privateGet(this, _en) && (this.parent?.drawLayer.removeClass(__privateGet(this, _en), "hovered"), this.parent?.drawLayer.addClass(__privateGet(this, _en), "selected"));
    }
    unselect() {
      super.unselect(), __privateGet(this, _en) && (this.parent?.drawLayer.removeClass(__privateGet(this, _en), "selected"), __privateGet(this, _Zs) || __privateMethod(this, _HighlightEditor_instances, ln_fn).call(this, false));
    }
    get _mustFixPosition() {
      return !__privateGet(this, _Zs);
    }
    show(e4 = this._isVisible) {
      super.show(e4), this.parent && (this.parent.drawLayer.show(__privateGet(this, _ce4), e4), this.parent.drawLayer.show(__privateGet(this, _en), e4));
    }
    static startHighlighting(e4, t4, { target: i4, x: a4, y: s4 }) {
      const { x: n4, y: r4, width: o4, height: g4 } = i4.getBoundingClientRect(), c4 = new AbortController(), h4 = e4.combinedSignal(c4), pointerUpCallback = (t5) => {
        c4.abort(), __privateMethod(this, _HighlightEditor_static, dn_fn).call(this, e4, t5);
      };
      window.addEventListener("blur", pointerUpCallback, { signal: h4 }), window.addEventListener("pointerup", pointerUpCallback, { signal: h4 }), window.addEventListener("pointerdown", (e5) => {
        e5.preventDefault(), e5.stopPropagation();
      }, { capture: true, passive: false, signal: h4 }), window.addEventListener("contextmenu", noContextMenu, { signal: h4 }), i4.addEventListener("pointermove", __privateMethod(this, _HighlightEditor_static, Bn_fn).bind(this, e4), { signal: h4 }), this._freeHighlight = new FreeOutliner({ x: a4, y: s4 }, [n4, r4, o4, g4], e4.scale, this._defaultThickness / 2, t4, 1e-3), { id: this._freeHighlightId, clipPathId: this._freeHighlightClipId } = e4.drawLayer.highlight(this._freeHighlight, this._defaultColor, this._defaultOpacity, true);
    }
    static deserialize(e4, t4, i4) {
      var _a5;
      const a4 = super.deserialize(e4, t4, i4), { rect: [s4, n4, r4, o4], color: g4, quadPoints: c4 } = e4;
      a4.color = Util2.makeHexColor(...g4), __privateSet(a4, _$s, e4.opacity);
      const [h4, l4] = a4.pageDimensions;
      a4.width = (r4 - s4) / h4, a4.height = (o4 - n4) / l4;
      const C4 = __privateSet(a4, _Ks, []);
      for (let e5 = 0; e5 < c4.length; e5 += 8) C4.push({ x: (c4[4] - r4) / h4, y: (o4 - (1 - c4[e5 + 5])) / l4, width: (c4[e5 + 2] - c4[e5]) / h4, height: (c4[e5 + 5] - c4[e5 + 1]) / l4 });
      return __privateMethod(_a5 = a4, _HighlightEditor_instances, sn_fn).call(_a5), a4;
    }
    serialize(e4 = false) {
      if (this.isEmpty() || e4) return null;
      const t4 = this.getRect(0, 0), i4 = AnnotationEditor._colorManager.convert(this.color);
      return { annotationType: Q3.HIGHLIGHT, color: i4, opacity: __privateGet(this, _$s), thickness: __privateGet(this, _Qs2), quadPoints: __privateMethod(this, _HighlightEditor_instances, In_fn).call(this), outlines: __privateMethod(this, _HighlightEditor_instances, Cn_fn).call(this, t4), pageIndex: this.pageIndex, rect: t4, rotation: __privateMethod(this, _HighlightEditor_instances, gn_fn).call(this), structTreeParentId: this._structTreeParentId };
    }
    static canCreateNewEmptyEditor() {
      return false;
    }
  };
  _Ps = new WeakMap();
  _Os = new WeakMap();
  _Ks = new WeakMap();
  _qs = new WeakMap();
  _X2 = new WeakMap();
  __s = new WeakMap();
  _Ws = new WeakMap();
  _js = new WeakMap();
  _Xs = new WeakMap();
  _Vs = new WeakMap();
  _ce4 = new WeakMap();
  _Zs = new WeakMap();
  _zs = new WeakMap();
  _$s = new WeakMap();
  _en = new WeakMap();
  _tn = new WeakMap();
  _Qs2 = new WeakMap();
  _An = new WeakMap();
  _HighlightEditor_instances = new WeakSet();
  sn_fn = function() {
    const e4 = new Outliner(__privateGet(this, _Ks), 1e-3);
    __privateSet(this, _Vs, e4.getOutlines()), { x: this.x, y: this.y, width: this.width, height: this.height } = __privateGet(this, _Vs).box;
    const t4 = new Outliner(__privateGet(this, _Ks), 25e-4, 1e-3, "ltr" === this._uiManager.direction);
    __privateSet(this, __s, t4.getOutlines());
    const { lastPoint: i4 } = __privateGet(this, __s).box;
    __privateSet(this, _zs, [(i4[0] - this.x) / this.width, (i4[1] - this.y) / this.height]);
  };
  in_fn = function({ highlightOutlines: e4, highlightId: t4, clipPathId: i4 }) {
    var _a5, _b2;
    __privateSet(this, _Vs, e4);
    if (__privateSet(this, __s, e4.getNewOutline(__privateGet(this, _Qs2) / 2 + 1.5, 25e-4)), t4 >= 0) __privateSet(this, _ce4, t4), __privateSet(this, _qs, i4), this.parent.drawLayer.finalizeLine(t4, e4), __privateSet(this, _en, this.parent.drawLayer.highlightOutline(__privateGet(this, __s)));
    else if (this.parent) {
      const t5 = this.parent.viewport.rotation;
      this.parent.drawLayer.updateLine(__privateGet(this, _ce4), e4), this.parent.drawLayer.updateBox(__privateGet(this, _ce4), __privateMethod(_a5 = _HighlightEditor, _HighlightEditor_static, nn_fn).call(_a5, __privateGet(this, _Vs).box, (t5 - this.rotation + 360) % 360)), this.parent.drawLayer.updateLine(__privateGet(this, _en), __privateGet(this, __s)), this.parent.drawLayer.updateBox(__privateGet(this, _en), __privateMethod(_b2 = _HighlightEditor, _HighlightEditor_static, nn_fn).call(_b2, __privateGet(this, __s).box, t5));
    }
    const { x: a4, y: s4, width: n4, height: r4 } = e4.box;
    switch (this.rotation) {
      case 0:
        this.x = a4, this.y = s4, this.width = n4, this.height = r4;
        break;
      case 90: {
        const [e5, t5] = this.parentDimensions;
        this.x = s4, this.y = 1 - a4, this.width = n4 * t5 / e5, this.height = r4 * e5 / t5;
        break;
      }
      case 180:
        this.x = 1 - a4, this.y = 1 - s4, this.width = n4, this.height = r4;
        break;
      case 270: {
        const [e5, t5] = this.parentDimensions;
        this.x = 1 - s4, this.y = a4, this.width = n4 * t5 / e5, this.height = r4 * e5 / t5;
        break;
      }
    }
    const { lastPoint: o4 } = __privateGet(this, __s).box;
    __privateSet(this, _zs, [(o4[0] - a4) / n4, (o4[1] - s4) / r4]);
  };
  qa_fn2 = function(e4) {
    const setColor = (e5) => {
      this.color = e5, this.parent?.drawLayer.changeColor(__privateGet(this, _ce4), e5), __privateGet(this, _X2)?.updateColor(e5);
    }, t4 = this.color;
    this.addCommands({ cmd: setColor.bind(this, e4), undo: setColor.bind(this, t4), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: true, type: f3.HIGHLIGHT_COLOR, overwriteIfSameType: true, keepUndo: true }), this._reportTelemetry({ action: "color_changed", color: this._uiManager.highlightColorNames.get(e4) }, true);
  };
  rn_fn = function(e4) {
    const t4 = __privateGet(this, _Qs2), setThickness = (e5) => {
      __privateSet(this, _Qs2, e5), __privateMethod(this, _HighlightEditor_instances, on_fn).call(this, e5);
    };
    this.addCommands({ cmd: setThickness.bind(this, e4), undo: setThickness.bind(this, t4), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: true, type: f3.INK_THICKNESS, overwriteIfSameType: true, keepUndo: true }), this._reportTelemetry({ action: "thickness_changed", thickness: e4 }, true);
  };
  on_fn = function(e4) {
    if (!__privateGet(this, _Zs)) return;
    __privateMethod(this, _HighlightEditor_instances, in_fn).call(this, { highlightOutlines: __privateGet(this, _Vs).getNewOutline(e4 / 2) }), this.fixAndSetPosition();
    const [t4, i4] = this.parentDimensions;
    this.setDims(this.width * t4, this.height * i4);
  };
  cn_fn = function() {
    null !== __privateGet(this, _ce4) && this.parent && (this.parent.drawLayer.remove(__privateGet(this, _ce4)), __privateSet(this, _ce4, null), this.parent.drawLayer.remove(__privateGet(this, _en)), __privateSet(this, _en, null));
  };
  an_fn = function(e4 = this.parent) {
    null === __privateGet(this, _ce4) && ({ id: __privateWrapper(this, _ce4)._, clipPathId: __privateWrapper(this, _qs)._ } = e4.drawLayer.highlight(__privateGet(this, _Vs), this.color, __privateGet(this, _$s)), __privateSet(this, _en, e4.drawLayer.highlightOutline(__privateGet(this, __s))), __privateGet(this, _Xs) && (__privateGet(this, _Xs).style.clipPath = __privateGet(this, _qs)));
  };
  _HighlightEditor_static = new WeakSet();
  nn_fn = function({ x: e4, y: t4, width: i4, height: a4 }, s4) {
    switch (s4) {
      case 90:
        return { x: 1 - t4 - a4, y: e4, width: a4, height: i4 };
      case 180:
        return { x: 1 - e4 - i4, y: 1 - t4 - a4, width: i4, height: a4 };
      case 270:
        return { x: t4, y: 1 - e4 - i4, width: a4, height: i4 };
    }
    return { x: e4, y: t4, width: i4, height: a4 };
  };
  hn_fn = function(e4) {
    _HighlightEditor._keyboardManager.exec(this, e4);
  };
  ln_fn = function(e4) {
    if (!__privateGet(this, _Ps)) return;
    const t4 = window.getSelection();
    e4 ? t4.setPosition(__privateGet(this, _Ps), __privateGet(this, _Os)) : t4.setPosition(__privateGet(this, _Ws), __privateGet(this, _js));
  };
  gn_fn = function() {
    return __privateGet(this, _Zs) ? this.rotation : 0;
  };
  In_fn = function() {
    if (__privateGet(this, _Zs)) return null;
    const [e4, t4] = this.pageDimensions, [i4, a4] = this.pageTranslation, s4 = __privateGet(this, _Ks), n4 = new Float32Array(8 * s4.length);
    let r4 = 0;
    for (const { x: o4, y: g4, width: c4, height: h4 } of s4) {
      const s5 = o4 * e4 + i4, l4 = (1 - g4 - h4) * t4 + a4;
      n4[r4] = n4[r4 + 4] = s5, n4[r4 + 1] = n4[r4 + 3] = l4, n4[r4 + 2] = n4[r4 + 6] = s5 + c4 * e4, n4[r4 + 5] = n4[r4 + 7] = l4 + h4 * t4, r4 += 8;
    }
    return n4;
  };
  Cn_fn = function(e4) {
    return __privateGet(this, _Vs).serialize(e4, __privateMethod(this, _HighlightEditor_instances, gn_fn).call(this));
  };
  Bn_fn = function(e4, t4) {
    this._freeHighlight.add(t4) && e4.drawLayer.updatePath(this._freeHighlightId, this._freeHighlight);
  };
  dn_fn = function(e4, t4) {
    this._freeHighlight.isEmpty() ? e4.drawLayer.removeFreeHighlight(this._freeHighlightId) : e4.createAndAddNewEditor(t4, false, { highlightId: this._freeHighlightId, highlightOutlines: this._freeHighlight.getOutlines(), clipPathId: this._freeHighlightClipId, methodOfCreation: "main_toolbar" }), this._freeHighlightId = -1, this._freeHighlight = null, this._freeHighlightClipId = "";
  };
  __privateAdd(_HighlightEditor, _HighlightEditor_static);
  __publicField(_HighlightEditor, "_defaultColor", null);
  __publicField(_HighlightEditor, "_defaultOpacity", 1);
  __publicField(_HighlightEditor, "_defaultThickness", 12);
  __publicField(_HighlightEditor, "_l10nPromise");
  __publicField(_HighlightEditor, "_type", "highlight");
  __publicField(_HighlightEditor, "_editorType", Q3.HIGHLIGHT);
  __publicField(_HighlightEditor, "_freeHighlightId", -1);
  __publicField(_HighlightEditor, "_freeHighlight", null);
  __publicField(_HighlightEditor, "_freeHighlightClipId", "");
  let HighlightEditor = _HighlightEditor;
  const _InkEditor = class _InkEditor extends AnnotationEditor {
    constructor(e4) {
      super({ ...e4, name: "inkEditor" });
      __privateAdd(this, _InkEditor_instances);
      __privateAdd(this, _un, 0);
      __privateAdd(this, _Qn, 0);
      __privateAdd(this, _En, null);
      __privateAdd(this, _fn, new Path2D());
      __privateAdd(this, _pn, false);
      __privateAdd(this, _mn, null);
      __privateAdd(this, _yn, false);
      __privateAdd(this, _wn, false);
      __privateAdd(this, _bn, null);
      __privateAdd(this, _Dn, null);
      __privateAdd(this, _Sn, 0);
      __privateAdd(this, _Fn, 0);
      __privateAdd(this, _kn, null);
      this.color = e4.color || null, this.thickness = e4.thickness || null, this.opacity = e4.opacity || null, this.paths = [], this.bezierPath2D = [], this.allRawPaths = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0, this._willKeepAspectRatio = true;
    }
    static initialize(e4, t4) {
      AnnotationEditor.initialize(e4, t4);
    }
    static updateDefaultParams(e4, t4) {
      switch (e4) {
        case f3.INK_THICKNESS:
          _InkEditor._defaultThickness = t4;
          break;
        case f3.INK_COLOR:
          _InkEditor._defaultColor = t4;
          break;
        case f3.INK_OPACITY:
          _InkEditor._defaultOpacity = t4 / 100;
      }
    }
    updateParams(e4, t4) {
      switch (e4) {
        case f3.INK_THICKNESS:
          __privateMethod(this, _InkEditor_instances, rn_fn2).call(this, t4);
          break;
        case f3.INK_COLOR:
          __privateMethod(this, _InkEditor_instances, qa_fn3).call(this, t4);
          break;
        case f3.INK_OPACITY:
          __privateMethod(this, _InkEditor_instances, Rn_fn).call(this, t4);
      }
    }
    static get defaultPropertiesToUpdate() {
      return [[f3.INK_THICKNESS, _InkEditor._defaultThickness], [f3.INK_COLOR, _InkEditor._defaultColor || AnnotationEditor._defaultLineColor], [f3.INK_OPACITY, Math.round(100 * _InkEditor._defaultOpacity)]];
    }
    get propertiesToUpdate() {
      return [[f3.INK_THICKNESS, this.thickness || _InkEditor._defaultThickness], [f3.INK_COLOR, this.color || _InkEditor._defaultColor || AnnotationEditor._defaultLineColor], [f3.INK_OPACITY, Math.round(100 * (this.opacity ?? _InkEditor._defaultOpacity))]];
    }
    rebuild() {
      this.parent && (super.rebuild(), null !== this.div && (this.canvas || (__privateMethod(this, _InkEditor_instances, Mn_fn).call(this), __privateMethod(this, _InkEditor_instances, Gn_fn).call(this)), this.isAttachedToDOM || (this.parent.add(this), __privateMethod(this, _InkEditor_instances, vn_fn).call(this)), __privateMethod(this, _InkEditor_instances, xn_fn).call(this)));
    }
    remove() {
      null !== this.canvas && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, __privateGet(this, _En) && (clearTimeout(__privateGet(this, _En)), __privateSet(this, _En, null)), __privateGet(this, _bn)?.disconnect(), __privateSet(this, _bn, null), super.remove());
    }
    setParent(e4) {
      !this.parent && e4 ? this._uiManager.removeShouldRescale(this) : this.parent && null === e4 && this._uiManager.addShouldRescale(this), super.setParent(e4);
    }
    onScaleChanging() {
      const [e4, t4] = this.parentDimensions, i4 = this.width * e4, a4 = this.height * t4;
      this.setDimensions(i4, a4);
    }
    enableEditMode() {
      __privateGet(this, _pn) || null === this.canvas || (super.enableEditMode(), this._isDraggable = false, __privateMethod(this, _InkEditor_instances, Ln_fn).call(this));
    }
    disableEditMode() {
      this.isInEditMode() && null !== this.canvas && (super.disableEditMode(), this._isDraggable = !this.isEmpty(), this.div.classList.remove("editing"), __privateMethod(this, _InkEditor_instances, Un_fn).call(this));
    }
    onceAdded() {
      this._isDraggable = !this.isEmpty();
    }
    isEmpty() {
      return 0 === this.paths.length || 1 === this.paths.length && 0 === this.paths[0].length;
    }
    commit() {
      __privateGet(this, _pn) || (super.commit(), this.isEditing = false, this.disableEditMode(), this.setInForeground(), __privateSet(this, _pn, true), this.div.classList.add("disabled"), __privateMethod(this, _InkEditor_instances, xn_fn).call(this, true), this.select(), this.parent.addInkEditorIfNeeded(true), this.moveInDOM(), this.div.focus({ preventScroll: true }));
    }
    focusin(e4) {
      this._focusEventsAllowed && (super.focusin(e4), this.enableEditMode());
    }
    canvasPointerdown(e4) {
      0 === e4.button && this.isInEditMode() && !__privateGet(this, _pn) && (this.setInForeground(), e4.preventDefault(), this.div.contains(document.activeElement) || this.div.focus({ preventScroll: true }), __privateMethod(this, _InkEditor_instances, Jn_fn).call(this, e4.offsetX, e4.offsetY));
    }
    canvasPointermove(e4) {
      e4.preventDefault(), __privateMethod(this, _InkEditor_instances, Pn_fn).call(this, e4.offsetX, e4.offsetY);
    }
    canvasPointerup(e4) {
      e4.preventDefault(), __privateMethod(this, _InkEditor_instances, jn_fn).call(this, e4);
    }
    canvasPointerleave(e4) {
      __privateMethod(this, _InkEditor_instances, jn_fn).call(this, e4);
    }
    get isResizable() {
      return !this.isEmpty() && __privateGet(this, _pn);
    }
    render() {
      if (this.div) return this.div;
      let e4, t4;
      this.width && (e4 = this.x, t4 = this.y), super.render(), this.div.setAttribute("data-l10n-id", "pdfjs-ink");
      const [i4, a4, s4, n4] = __privateMethod(this, _InkEditor_instances, Hn_fn).call(this);
      if (this.setAt(i4, a4, 0, 0), this.setDims(s4, n4), __privateMethod(this, _InkEditor_instances, Mn_fn).call(this), this.width) {
        const [i5, a5] = this.parentDimensions;
        this.setAspectRatio(this.width * i5, this.height * a5), this.setAt(e4 * i5, t4 * a5, this.width * i5, this.height * a5), __privateSet(this, _wn, true), __privateMethod(this, _InkEditor_instances, vn_fn).call(this), this.setDims(this.width * i5, this.height * a5), __privateMethod(this, _InkEditor_instances, Nn_fn).call(this), this.div.classList.add("disabled");
      } else this.div.classList.add("editing"), this.enableEditMode();
      return __privateMethod(this, _InkEditor_instances, Gn_fn).call(this), this.div;
    }
    setDimensions(e4, t4) {
      const i4 = Math.round(e4), a4 = Math.round(t4);
      if (__privateGet(this, _Sn) === i4 && __privateGet(this, _Fn) === a4) return;
      __privateSet(this, _Sn, i4), __privateSet(this, _Fn, a4), this.canvas.style.visibility = "hidden";
      const [s4, n4] = this.parentDimensions;
      this.width = e4 / s4, this.height = t4 / n4, this.fixAndSetPosition(), __privateGet(this, _pn) && __privateMethod(this, _InkEditor_instances, Xn_fn).call(this, e4, t4), __privateMethod(this, _InkEditor_instances, vn_fn).call(this), __privateMethod(this, _InkEditor_instances, Nn_fn).call(this), this.canvas.style.visibility = "visible", this.fixDims();
    }
    static deserialize(e4, t4, i4) {
      var _a5, _b2, _c3;
      if (e4 instanceof InkAnnotationElement) return null;
      const a4 = super.deserialize(e4, t4, i4);
      a4.thickness = e4.thickness, a4.color = Util2.makeHexColor(...e4.color), a4.opacity = e4.opacity;
      const [s4, n4] = a4.pageDimensions, r4 = a4.width * s4, o4 = a4.height * n4, g4 = a4.parentScale, c4 = e4.thickness / 2;
      __privateSet(a4, _pn, true), __privateSet(a4, _Sn, Math.round(r4)), __privateSet(a4, _Fn, Math.round(o4));
      const { paths: h4, rect: l4, rotation: C4 } = e4;
      for (let { bezier: e5 } of h4) {
        e5 = __privateMethod(_a5 = _InkEditor, _InkEditor_static, $n_fn).call(_a5, e5, l4, C4);
        const t5 = [];
        a4.paths.push(t5);
        let i5 = g4 * (e5[0] - c4), s5 = g4 * (e5[1] - c4);
        for (let a5 = 2, n6 = e5.length; a5 < n6; a5 += 6) {
          const n7 = g4 * (e5[a5] - c4), r5 = g4 * (e5[a5 + 1] - c4), o5 = g4 * (e5[a5 + 2] - c4), h5 = g4 * (e5[a5 + 3] - c4), l5 = g4 * (e5[a5 + 4] - c4), C5 = g4 * (e5[a5 + 5] - c4);
          t5.push([[i5, s5], [n7, r5], [o5, h5], [l5, C5]]), i5 = l5, s5 = C5;
        }
        const n5 = __privateMethod(this, _InkEditor_static, Zn_fn).call(this, t5);
        a4.bezierPath2D.push(n5);
      }
      const d4 = __privateMethod(_b2 = a4, _InkEditor_instances, tr_fn).call(_b2);
      return __privateSet(a4, _Qn, Math.max(AnnotationEditor.MIN_SIZE, d4[2] - d4[0])), __privateSet(a4, _un, Math.max(AnnotationEditor.MIN_SIZE, d4[3] - d4[1])), __privateMethod(_c3 = a4, _InkEditor_instances, Xn_fn).call(_c3, r4, o4), a4;
    }
    serialize() {
      if (this.isEmpty()) return null;
      const e4 = this.getRect(0, 0), t4 = AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
      return { annotationType: Q3.INK, color: t4, thickness: this.thickness, opacity: this.opacity, paths: __privateMethod(this, _InkEditor_instances, er_fn).call(this, this.scaleFactor / this.parentScale, this.translationX, this.translationY, e4), pageIndex: this.pageIndex, rect: e4, rotation: this.rotation, structTreeParentId: this._structTreeParentId };
    }
  };
  _un = new WeakMap();
  _Qn = new WeakMap();
  _En = new WeakMap();
  _fn = new WeakMap();
  _pn = new WeakMap();
  _mn = new WeakMap();
  _yn = new WeakMap();
  _wn = new WeakMap();
  _bn = new WeakMap();
  _Dn = new WeakMap();
  _Sn = new WeakMap();
  _Fn = new WeakMap();
  _kn = new WeakMap();
  _InkEditor_instances = new WeakSet();
  rn_fn2 = function(e4) {
    const setThickness = (e5) => {
      this.thickness = e5, __privateMethod(this, _InkEditor_instances, xn_fn).call(this);
    }, t4 = this.thickness;
    this.addCommands({ cmd: setThickness.bind(this, e4), undo: setThickness.bind(this, t4), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: true, type: f3.INK_THICKNESS, overwriteIfSameType: true, keepUndo: true });
  };
  qa_fn3 = function(e4) {
    const setColor = (e5) => {
      this.color = e5, __privateMethod(this, _InkEditor_instances, Nn_fn).call(this);
    }, t4 = this.color;
    this.addCommands({ cmd: setColor.bind(this, e4), undo: setColor.bind(this, t4), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: true, type: f3.INK_COLOR, overwriteIfSameType: true, keepUndo: true });
  };
  Rn_fn = function(e4) {
    const setOpacity = (e5) => {
      this.opacity = e5, __privateMethod(this, _InkEditor_instances, Nn_fn).call(this);
    };
    e4 /= 100;
    const t4 = this.opacity;
    this.addCommands({ cmd: setOpacity.bind(this, e4), undo: setOpacity.bind(this, t4), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: true, type: f3.INK_OPACITY, overwriteIfSameType: true, keepUndo: true });
  };
  Hn_fn = function() {
    const { parentRotation: e4, parentDimensions: [t4, i4] } = this;
    switch (e4) {
      case 90:
        return [0, i4, i4, t4];
      case 180:
        return [t4, i4, t4, i4];
      case 270:
        return [t4, 0, i4, t4];
      default:
        return [0, 0, t4, i4];
    }
  };
  Tn_fn = function() {
    const { ctx: e4, color: t4, opacity: i4, thickness: a4, parentScale: s4, scaleFactor: n4 } = this;
    e4.lineWidth = a4 * s4 / n4, e4.lineCap = "round", e4.lineJoin = "round", e4.miterLimit = 10, e4.strokeStyle = `${t4}${function(e5) {
      return Math.round(Math.min(255, Math.max(1, 255 * e5))).toString(16).padStart(2, "0");
    }(i4)}`;
  };
  Jn_fn = function(e4, t4) {
    this.canvas.addEventListener("contextmenu", noContextMenu, { signal: this._uiManager._signal }), __privateMethod(this, _InkEditor_instances, Un_fn).call(this), __privateSet(this, _mn, new AbortController());
    const i4 = this._uiManager.combinedSignal(__privateGet(this, _mn));
    this.canvas.addEventListener("pointerleave", this.canvasPointerleave.bind(this), { signal: i4 }), this.canvas.addEventListener("pointermove", this.canvasPointermove.bind(this), { signal: i4 }), this.canvas.addEventListener("pointerup", this.canvasPointerup.bind(this), { signal: i4 }), this.isEditing = true, __privateGet(this, _wn) || (__privateSet(this, _wn, true), __privateMethod(this, _InkEditor_instances, vn_fn).call(this), this.thickness || (this.thickness = _InkEditor._defaultThickness), this.color || (this.color = _InkEditor._defaultColor || AnnotationEditor._defaultLineColor), this.opacity ?? (this.opacity = _InkEditor._defaultOpacity)), this.currentPath.push([e4, t4]), __privateSet(this, _yn, false), __privateMethod(this, _InkEditor_instances, Tn_fn).call(this), __privateSet(this, _kn, () => {
      __privateMethod(this, _InkEditor_instances, Yn_fn).call(this), __privateGet(this, _kn) && window.requestAnimationFrame(__privateGet(this, _kn));
    }), window.requestAnimationFrame(__privateGet(this, _kn));
  };
  Pn_fn = function(e4, t4) {
    const [i4, a4] = this.currentPath.at(-1);
    if (this.currentPath.length > 1 && e4 === i4 && t4 === a4) return;
    const s4 = this.currentPath;
    let n4 = __privateGet(this, _fn);
    if (s4.push([e4, t4]), __privateSet(this, _yn, true), s4.length <= 2) return n4.moveTo(...s4[0]), void n4.lineTo(e4, t4);
    3 === s4.length && (__privateSet(this, _fn, n4 = new Path2D()), n4.moveTo(...s4[0])), __privateMethod(this, _InkEditor_instances, On_fn).call(this, n4, ...s4.at(-3), ...s4.at(-2), e4, t4);
  };
  Kn_fn = function() {
    if (0 === this.currentPath.length) return;
    const e4 = this.currentPath.at(-1);
    __privateGet(this, _fn).lineTo(...e4);
  };
  qn_fn = function(e4, t4) {
    let i4;
    if (__privateSet(this, _kn, null), e4 = Math.min(Math.max(e4, 0), this.canvas.width), t4 = Math.min(Math.max(t4, 0), this.canvas.height), __privateMethod(this, _InkEditor_instances, Pn_fn).call(this, e4, t4), __privateMethod(this, _InkEditor_instances, Kn_fn).call(this), 1 !== this.currentPath.length) i4 = __privateMethod(this, _InkEditor_instances, _n_fn).call(this);
    else {
      const a5 = [e4, t4];
      i4 = [[a5, a5.slice(), a5.slice(), a5]];
    }
    const a4 = __privateGet(this, _fn), s4 = this.currentPath;
    this.currentPath = [], __privateSet(this, _fn, new Path2D());
    this.addCommands({ cmd: () => {
      this.allRawPaths.push(s4), this.paths.push(i4), this.bezierPath2D.push(a4), this._uiManager.rebuild(this);
    }, undo: () => {
      this.allRawPaths.pop(), this.paths.pop(), this.bezierPath2D.pop(), 0 === this.paths.length ? this.remove() : (this.canvas || (__privateMethod(this, _InkEditor_instances, Mn_fn).call(this), __privateMethod(this, _InkEditor_instances, Gn_fn).call(this)), __privateMethod(this, _InkEditor_instances, xn_fn).call(this));
    }, mustExec: true });
  };
  Yn_fn = function() {
    if (!__privateGet(this, _yn)) return;
    __privateSet(this, _yn, false);
    Math.ceil(this.thickness * this.parentScale);
    const e4 = this.currentPath.slice(-3), t4 = e4.map((e5) => e5[0]), i4 = e4.map((e5) => e5[1]);
    Math.min(...t4), Math.max(...t4), Math.min(...i4), Math.max(...i4);
    const { ctx: a4 } = this;
    a4.save(), a4.clearRect(0, 0, this.canvas.width, this.canvas.height);
    for (const e5 of this.bezierPath2D) a4.stroke(e5);
    a4.stroke(__privateGet(this, _fn)), a4.restore();
  };
  On_fn = function(e4, t4, i4, a4, s4, n4, r4) {
    const o4 = (t4 + a4) / 2, g4 = (i4 + s4) / 2, c4 = (a4 + n4) / 2, h4 = (s4 + r4) / 2;
    e4.bezierCurveTo(o4 + 2 * (a4 - o4) / 3, g4 + 2 * (s4 - g4) / 3, c4 + 2 * (a4 - c4) / 3, h4 + 2 * (s4 - h4) / 3, c4, h4);
  };
  _n_fn = function() {
    const e4 = this.currentPath;
    if (e4.length <= 2) return [[e4[0], e4[0], e4.at(-1), e4.at(-1)]];
    const t4 = [];
    let i4, [a4, s4] = e4[0];
    for (i4 = 1; i4 < e4.length - 2; i4++) {
      const [n5, r5] = e4[i4], [o5, g5] = e4[i4 + 1], c5 = (n5 + o5) / 2, h5 = (r5 + g5) / 2, l4 = [a4 + 2 * (n5 - a4) / 3, s4 + 2 * (r5 - s4) / 3], C4 = [c5 + 2 * (n5 - c5) / 3, h5 + 2 * (r5 - h5) / 3];
      t4.push([[a4, s4], l4, C4, [c5, h5]]), [a4, s4] = [c5, h5];
    }
    const [n4, r4] = e4[i4], [o4, g4] = e4[i4 + 1], c4 = [a4 + 2 * (n4 - a4) / 3, s4 + 2 * (r4 - s4) / 3], h4 = [o4 + 2 * (n4 - o4) / 3, g4 + 2 * (r4 - g4) / 3];
    return t4.push([[a4, s4], c4, h4, [o4, g4]]), t4;
  };
  Nn_fn = function() {
    if (this.isEmpty()) return void __privateMethod(this, _InkEditor_instances, Wn_fn).call(this);
    __privateMethod(this, _InkEditor_instances, Tn_fn).call(this);
    const { canvas: e4, ctx: t4 } = this;
    t4.setTransform(1, 0, 0, 1, 0, 0), t4.clearRect(0, 0, e4.width, e4.height), __privateMethod(this, _InkEditor_instances, Wn_fn).call(this);
    for (const e5 of this.bezierPath2D) t4.stroke(e5);
  };
  Ln_fn = function() {
    if (__privateGet(this, _Dn)) return;
    __privateSet(this, _Dn, new AbortController());
    const e4 = this._uiManager.combinedSignal(__privateGet(this, _Dn));
    this.canvas.addEventListener("pointerdown", this.canvasPointerdown.bind(this), { signal: e4 });
  };
  Un_fn = function() {
    this.pointerdownAC?.abort(), this.pointerdownAC = null;
  };
  jn_fn = function(e4) {
    __privateGet(this, _mn)?.abort(), __privateSet(this, _mn, null), __privateMethod(this, _InkEditor_instances, Ln_fn).call(this), __privateGet(this, _En) && clearTimeout(__privateGet(this, _En)), __privateSet(this, _En, setTimeout(() => {
      __privateSet(this, _En, null), this.canvas.removeEventListener("contextmenu", noContextMenu);
    }, 10)), __privateMethod(this, _InkEditor_instances, qn_fn).call(this, e4.offsetX, e4.offsetY), this.addToAnnotationStorage(), this.setInBackground();
  };
  Mn_fn = function() {
    this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", this.canvas.setAttribute("data-l10n-id", "pdfjs-ink-canvas"), this.div.append(this.canvas), this.ctx = this.canvas.getContext("2d");
  };
  Gn_fn = function() {
    __privateSet(this, _bn, new ResizeObserver((e4) => {
      const t4 = e4[0].contentRect;
      t4.width && t4.height && this.setDimensions(t4.width, t4.height);
    })), __privateGet(this, _bn).observe(this.div), this._uiManager._signal.addEventListener("abort", () => {
      __privateGet(this, _bn)?.disconnect(), __privateSet(this, _bn, null);
    }, { once: true });
  };
  vn_fn = function() {
    if (!__privateGet(this, _wn)) return;
    const [e4, t4] = this.parentDimensions;
    this.canvas.width = Math.ceil(this.width * e4), this.canvas.height = Math.ceil(this.height * t4), __privateMethod(this, _InkEditor_instances, Wn_fn).call(this);
  };
  Xn_fn = function(e4, t4) {
    const i4 = __privateMethod(this, _InkEditor_instances, Vn_fn).call(this), a4 = (e4 - i4) / __privateGet(this, _Qn), s4 = (t4 - i4) / __privateGet(this, _un);
    this.scaleFactor = Math.min(a4, s4);
  };
  Wn_fn = function() {
    const e4 = __privateMethod(this, _InkEditor_instances, Vn_fn).call(this) / 2;
    this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + e4, this.translationY * this.scaleFactor + e4);
  };
  _InkEditor_static = new WeakSet();
  Zn_fn = function(e4) {
    const t4 = new Path2D();
    for (let i4 = 0, a4 = e4.length; i4 < a4; i4++) {
      const [a5, s4, n4, r4] = e4[i4];
      0 === i4 && t4.moveTo(...a5), t4.bezierCurveTo(s4[0], s4[1], n4[0], n4[1], r4[0], r4[1]);
    }
    return t4;
  };
  zn_fn = function(e4, t4, i4) {
    const [a4, s4, n4, r4] = t4;
    switch (i4) {
      case 0:
        for (let t5 = 0, i5 = e4.length; t5 < i5; t5 += 2) e4[t5] += a4, e4[t5 + 1] = r4 - e4[t5 + 1];
        break;
      case 90:
        for (let t5 = 0, i5 = e4.length; t5 < i5; t5 += 2) {
          const i6 = e4[t5];
          e4[t5] = e4[t5 + 1] + a4, e4[t5 + 1] = i6 + s4;
        }
        break;
      case 180:
        for (let t5 = 0, i5 = e4.length; t5 < i5; t5 += 2) e4[t5] = n4 - e4[t5], e4[t5 + 1] += s4;
        break;
      case 270:
        for (let t5 = 0, i5 = e4.length; t5 < i5; t5 += 2) {
          const i6 = e4[t5];
          e4[t5] = n4 - e4[t5 + 1], e4[t5 + 1] = r4 - i6;
        }
        break;
      default:
        throw new Error("Invalid rotation");
    }
    return e4;
  };
  $n_fn = function(e4, t4, i4) {
    const [a4, s4, n4, r4] = t4;
    switch (i4) {
      case 0:
        for (let t5 = 0, i5 = e4.length; t5 < i5; t5 += 2) e4[t5] -= a4, e4[t5 + 1] = r4 - e4[t5 + 1];
        break;
      case 90:
        for (let t5 = 0, i5 = e4.length; t5 < i5; t5 += 2) {
          const i6 = e4[t5];
          e4[t5] = e4[t5 + 1] - s4, e4[t5 + 1] = i6 - a4;
        }
        break;
      case 180:
        for (let t5 = 0, i5 = e4.length; t5 < i5; t5 += 2) e4[t5] = n4 - e4[t5], e4[t5 + 1] -= s4;
        break;
      case 270:
        for (let t5 = 0, i5 = e4.length; t5 < i5; t5 += 2) {
          const i6 = e4[t5];
          e4[t5] = r4 - e4[t5 + 1], e4[t5 + 1] = n4 - i6;
        }
        break;
      default:
        throw new Error("Invalid rotation");
    }
    return e4;
  };
  er_fn = function(e4, t4, i4, a4) {
    var _a5, _b2;
    const s4 = [], n4 = this.thickness / 2, r4 = e4 * t4 + n4, o4 = e4 * i4 + n4;
    for (const t5 of this.paths) {
      const i5 = [], n5 = [];
      for (let a5 = 0, s5 = t5.length; a5 < s5; a5++) {
        const [g4, c4, h4, l4] = t5[a5];
        if (g4[0] === l4[0] && g4[1] === l4[1] && 1 === s5) {
          const t6 = e4 * g4[0] + r4, a6 = e4 * g4[1] + o4;
          i5.push(t6, a6), n5.push(t6, a6);
          break;
        }
        const C4 = e4 * g4[0] + r4, d4 = e4 * g4[1] + o4, u4 = e4 * c4[0] + r4, Q4 = e4 * c4[1] + o4, f4 = e4 * h4[0] + r4, p4 = e4 * h4[1] + o4, m4 = e4 * l4[0] + r4, y4 = e4 * l4[1] + o4;
        0 === a5 && (i5.push(C4, d4), n5.push(C4, d4)), i5.push(u4, Q4, f4, p4, m4, y4), n5.push(u4, Q4), a5 === s5 - 1 && n5.push(m4, y4);
      }
      s4.push({ bezier: __privateMethod(_a5 = _InkEditor, _InkEditor_static, zn_fn).call(_a5, i5, a4, this.rotation), points: __privateMethod(_b2 = _InkEditor, _InkEditor_static, zn_fn).call(_b2, n5, a4, this.rotation) });
    }
    return s4;
  };
  tr_fn = function() {
    let e4 = 1 / 0, t4 = -1 / 0, i4 = 1 / 0, a4 = -1 / 0;
    for (const s4 of this.paths) for (const [n4, r4, o4, g4] of s4) {
      const s5 = Util2.bezierBoundingBox(...n4, ...r4, ...o4, ...g4);
      e4 = Math.min(e4, s5[0]), i4 = Math.min(i4, s5[1]), t4 = Math.max(t4, s5[2]), a4 = Math.max(a4, s5[3]);
    }
    return [e4, i4, t4, a4];
  };
  Vn_fn = function() {
    return __privateGet(this, _pn) ? Math.ceil(this.thickness * this.parentScale) : 0;
  };
  xn_fn = function(e4 = false) {
    if (this.isEmpty()) return;
    if (!__privateGet(this, _pn)) return void __privateMethod(this, _InkEditor_instances, Nn_fn).call(this);
    const t4 = __privateMethod(this, _InkEditor_instances, tr_fn).call(this), i4 = __privateMethod(this, _InkEditor_instances, Vn_fn).call(this);
    __privateSet(this, _Qn, Math.max(AnnotationEditor.MIN_SIZE, t4[2] - t4[0])), __privateSet(this, _un, Math.max(AnnotationEditor.MIN_SIZE, t4[3] - t4[1]));
    const a4 = Math.ceil(i4 + __privateGet(this, _Qn) * this.scaleFactor), s4 = Math.ceil(i4 + __privateGet(this, _un) * this.scaleFactor), [n4, r4] = this.parentDimensions;
    this.width = a4 / n4, this.height = s4 / r4, this.setAspectRatio(a4, s4);
    const o4 = this.translationX, g4 = this.translationY;
    this.translationX = -t4[0], this.translationY = -t4[1], __privateMethod(this, _InkEditor_instances, vn_fn).call(this), __privateMethod(this, _InkEditor_instances, Nn_fn).call(this), __privateSet(this, _Sn, a4), __privateSet(this, _Fn, s4), this.setDims(a4, s4);
    const c4 = e4 ? i4 / this.scaleFactor / 2 : 0;
    this.translate(o4 - this.translationX - c4, g4 - this.translationY - c4);
  };
  __privateAdd(_InkEditor, _InkEditor_static);
  __publicField(_InkEditor, "_defaultColor", null);
  __publicField(_InkEditor, "_defaultOpacity", 1);
  __publicField(_InkEditor, "_defaultThickness", 1);
  __publicField(_InkEditor, "_type", "ink");
  __publicField(_InkEditor, "_editorType", Q3.INK);
  let InkEditor = _InkEditor;
  const _StampEditor = class _StampEditor extends AnnotationEditor {
    constructor(e4) {
      super({ ...e4, name: "stampEditor" });
      __privateAdd(this, _StampEditor_instances);
      __privateAdd(this, _Ar, null);
      __privateAdd(this, _ir, null);
      __privateAdd(this, _ar, null);
      __privateAdd(this, _sr, null);
      __privateAdd(this, _nr, null);
      __privateAdd(this, _rr, "");
      __privateAdd(this, _or, null);
      __privateAdd(this, _bn2, null);
      __privateAdd(this, _gr, null);
      __privateAdd(this, _cr, false);
      __privateAdd(this, _hr, false);
      __privateSet(this, _sr, e4.bitmapUrl), __privateSet(this, _nr, e4.bitmapFile);
    }
    static initialize(e4, t4) {
      AnnotationEditor.initialize(e4, t4);
    }
    static get supportedTypes() {
      return shadow2(this, "supportedTypes", ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"].map((e4) => `image/${e4}`));
    }
    static get supportedTypesStr() {
      return shadow2(this, "supportedTypesStr", this.supportedTypes.join(","));
    }
    static isHandlingMimeForPasting(e4) {
      return this.supportedTypes.includes(e4);
    }
    static paste(e4, t4) {
      t4.pasteEditor(Q3.STAMP, { bitmapFile: e4.getAsFile() });
    }
    altTextFinish() {
      this._uiManager.useNewAltTextFlow && (this.div.hidden = false), super.altTextFinish();
    }
    get telemetryFinalData() {
      return { type: "stamp", hasAltText: !!this.altTextData?.altText };
    }
    static computeTelemetryFinalData(e4) {
      const t4 = e4.get("hasAltText");
      return { hasAltText: t4.get(true) ?? 0, hasNoAltText: t4.get(false) ?? 0 };
    }
    async mlGuessAltText(e4 = null, t4 = true) {
      if (this.hasAltTextData()) return null;
      const { mlManager: i4 } = this._uiManager;
      if (!i4) throw new Error("No ML.");
      if (!await i4.isEnabledFor("altText")) throw new Error("ML isn't enabled for alt text.");
      const { data: a4, width: s4, height: n4 } = e4 || this.copyCanvas(null, true).imageData, r4 = await i4.guess({ name: "altText", request: { data: a4, width: s4, height: n4, channels: a4.length / (s4 * n4) } });
      if (!r4) throw new Error("No response from the AI service.");
      if (r4.error) throw new Error("Error from the AI service.");
      if (r4.cancel) return null;
      if (!r4.output) throw new Error("No valid response from the AI service.");
      const o4 = r4.output;
      return await this.setGuessedAltText(o4), t4 && !this.hasAltTextData() && (this.altTextData = { alt: o4, decorative: false }), o4;
    }
    remove() {
      __privateGet(this, _ir) && (__privateSet(this, _Ar, null), this._uiManager.imageManager.deleteId(__privateGet(this, _ir)), __privateGet(this, _or)?.remove(), __privateSet(this, _or, null), __privateGet(this, _bn2)?.disconnect(), __privateSet(this, _bn2, null), __privateGet(this, _gr) && (clearTimeout(__privateGet(this, _gr)), __privateSet(this, _gr, null))), super.remove();
    }
    rebuild() {
      this.parent ? (super.rebuild(), null !== this.div && (__privateGet(this, _ir) && null === __privateGet(this, _or) && __privateMethod(this, _StampEditor_instances, Cr_fn).call(this), this.isAttachedToDOM || this.parent.add(this))) : __privateGet(this, _ir) && __privateMethod(this, _StampEditor_instances, Cr_fn).call(this);
    }
    onceAdded() {
      this._isDraggable = true, this.div.focus();
    }
    isEmpty() {
      return !(__privateGet(this, _ar) || __privateGet(this, _Ar) || __privateGet(this, _sr) || __privateGet(this, _nr) || __privateGet(this, _ir));
    }
    get isResizable() {
      return true;
    }
    render() {
      if (this.div) return this.div;
      let e4, t4;
      if (this.width && (e4 = this.x, t4 = this.y), super.render(), this.div.hidden = true, this.addAltTextButton(), __privateGet(this, _Ar) ? __privateMethod(this, _StampEditor_instances, Mn_fn2).call(this) : __privateMethod(this, _StampEditor_instances, Cr_fn).call(this), this.width) {
        const [i4, a4] = this.parentDimensions;
        this.setAt(e4 * i4, t4 * a4, this.width * i4, this.height * a4);
      }
      return this.div;
    }
    copyCanvas(e4, t4 = false) {
      e4 || (e4 = 224);
      const { width: i4, height: a4 } = __privateGet(this, _Ar), s4 = document.createElement("canvas");
      let n4 = __privateGet(this, _Ar), r4 = i4, o4 = a4;
      if (i4 > e4 || a4 > e4) {
        const t5 = Math.min(e4 / i4, e4 / a4);
        r4 = Math.floor(i4 * t5), o4 = Math.floor(a4 * t5), __privateGet(this, _cr) || (n4 = __privateMethod(this, _StampEditor_instances, Br_fn).call(this, r4, o4));
      }
      s4.width = r4, s4.height = o4;
      const g4 = s4.getContext("2d");
      g4.filter = this._uiManager.hcmFilter;
      let c4 = "white", h4 = "#cfcfd8";
      "none" !== this._uiManager.hcmFilter ? h4 = "black" : window.matchMedia?.("(prefers-color-scheme: dark)").matches && (c4 = "#8f8f9d", h4 = "#42414d");
      const l4 = 15, C4 = new OffscreenCanvas(30, 30), d4 = C4.getContext("2d");
      if (d4.fillStyle = c4, d4.fillRect(0, 0, 30, 30), d4.fillStyle = h4, d4.fillRect(0, 0, l4, l4), d4.fillRect(l4, l4, l4, l4), g4.fillStyle = g4.createPattern(C4, "repeat"), g4.fillRect(0, 0, r4, o4), t4) {
        const e5 = new OffscreenCanvas(r4, o4), t5 = e5.getContext("2d", { willReadFrequently: true });
        t5.drawImage(n4, 0, 0, n4.width, n4.height, 0, 0, r4, o4);
        const i5 = t5.getImageData(0, 0, r4, o4).data;
        return g4.drawImage(e5, 0, 0), { canvas: s4, imageData: { width: r4, height: o4, data: i5 } };
      }
      return g4.drawImage(n4, 0, 0, n4.width, n4.height, 0, 0, r4, o4), { canvas: s4, imageData: null };
    }
    getImageForAltText() {
      return __privateGet(this, _or);
    }
    static deserialize(e4, t4, i4) {
      if (e4 instanceof StampAnnotationElement) return null;
      const a4 = super.deserialize(e4, t4, i4), { rect: s4, bitmapUrl: n4, bitmapId: r4, isSvg: o4, accessibilityData: g4 } = e4;
      r4 && i4.imageManager.isValidId(r4) ? __privateSet(a4, _ir, r4) : __privateSet(a4, _sr, n4), __privateSet(a4, _cr, o4);
      const [c4, h4] = a4.pageDimensions;
      return a4.width = (s4[2] - s4[0]) / c4, a4.height = (s4[3] - s4[1]) / h4, g4 && (a4.altTextData = g4), a4;
    }
    serialize(e4 = false, t4 = null) {
      if (this.isEmpty()) return null;
      const i4 = { annotationType: Q3.STAMP, bitmapId: __privateGet(this, _ir), pageIndex: this.pageIndex, rect: this.getRect(0, 0), rotation: this.rotation, isSvg: __privateGet(this, _cr), structTreeParentId: this._structTreeParentId };
      if (e4) return i4.bitmapUrl = __privateMethod(this, _StampEditor_instances, Qr_fn).call(this, true), i4.accessibilityData = this.serializeAltText(true), i4;
      const { decorative: a4, altText: s4 } = this.serializeAltText(false);
      if (!a4 && s4 && (i4.accessibilityData = { type: "Figure", alt: s4 }), null === t4) return i4;
      t4.stamps || (t4.stamps = /* @__PURE__ */ new Map());
      const n4 = __privateGet(this, _cr) ? (i4.rect[2] - i4.rect[0]) * (i4.rect[3] - i4.rect[1]) : null;
      if (t4.stamps.has(__privateGet(this, _ir))) {
        if (__privateGet(this, _cr)) {
          const e5 = t4.stamps.get(__privateGet(this, _ir));
          n4 > e5.area && (e5.area = n4, e5.serialized.bitmap.close(), e5.serialized.bitmap = __privateMethod(this, _StampEditor_instances, Qr_fn).call(this, false));
        }
      } else t4.stamps.set(__privateGet(this, _ir), { area: n4, serialized: i4 }), i4.bitmap = __privateMethod(this, _StampEditor_instances, Qr_fn).call(this, false);
      return i4;
    }
  };
  _Ar = new WeakMap();
  _ir = new WeakMap();
  _ar = new WeakMap();
  _sr = new WeakMap();
  _nr = new WeakMap();
  _rr = new WeakMap();
  _or = new WeakMap();
  _bn2 = new WeakMap();
  _gr = new WeakMap();
  _cr = new WeakMap();
  _hr = new WeakMap();
  _StampEditor_instances = new WeakSet();
  lr_fn = function(e4, t4 = false) {
    e4 ? (__privateSet(this, _Ar, e4.bitmap), t4 || (__privateSet(this, _ir, e4.id), __privateSet(this, _cr, e4.isSvg)), e4.file && __privateSet(this, _rr, e4.file.name), __privateMethod(this, _StampEditor_instances, Mn_fn2).call(this)) : this.remove();
  };
  Ir_fn = function() {
    if (__privateSet(this, _ar, null), this._uiManager.enableWaiting(false), __privateGet(this, _or)) {
      if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && __privateGet(this, _Ar)) return this._editToolbar.hide(), void this._uiManager.editAltText(this, true);
      if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && __privateGet(this, _Ar)) {
        this._reportTelemetry({ action: "pdfjs.image.image_added", data: { alt_text_modal: false, alt_text_type: "empty" } });
        try {
          this.mlGuessAltText();
        } catch {
        }
      }
      this.div.focus();
    }
  };
  Cr_fn = function() {
    if (__privateGet(this, _ir)) return this._uiManager.enableWaiting(true), void this._uiManager.imageManager.getFromId(__privateGet(this, _ir)).then((e5) => __privateMethod(this, _StampEditor_instances, lr_fn).call(this, e5, true)).finally(() => __privateMethod(this, _StampEditor_instances, Ir_fn).call(this));
    if (__privateGet(this, _sr)) {
      const e5 = __privateGet(this, _sr);
      return __privateSet(this, _sr, null), this._uiManager.enableWaiting(true), void __privateSet(this, _ar, this._uiManager.imageManager.getFromUrl(e5).then((e6) => __privateMethod(this, _StampEditor_instances, lr_fn).call(this, e6)).finally(() => __privateMethod(this, _StampEditor_instances, Ir_fn).call(this)));
    }
    if (__privateGet(this, _nr)) {
      const e5 = __privateGet(this, _nr);
      return __privateSet(this, _nr, null), this._uiManager.enableWaiting(true), void __privateSet(this, _ar, this._uiManager.imageManager.getFromFile(e5).then((e6) => __privateMethod(this, _StampEditor_instances, lr_fn).call(this, e6)).finally(() => __privateMethod(this, _StampEditor_instances, Ir_fn).call(this)));
    }
    const e4 = document.createElement("input");
    e4.type = "file", e4.accept = _StampEditor.supportedTypesStr;
    const t4 = this._uiManager._signal;
    __privateSet(this, _ar, new Promise((i4) => {
      e4.addEventListener("change", async () => {
        if (e4.files && 0 !== e4.files.length) {
          this._uiManager.enableWaiting(true);
          const t5 = await this._uiManager.imageManager.getFromFile(e4.files[0]);
          this._reportTelemetry({ action: "pdfjs.image.image_selected", data: { alt_text_modal: this._uiManager.useNewAltTextFlow } }), __privateMethod(this, _StampEditor_instances, lr_fn).call(this, t5);
        } else this.remove();
        i4();
      }, { signal: t4 }), e4.addEventListener("cancel", () => {
        this.remove(), i4();
      }, { signal: t4 });
    }).finally(() => __privateMethod(this, _StampEditor_instances, Ir_fn).call(this))), e4.click();
  };
  Mn_fn2 = function() {
    const { div: e4 } = this;
    let { width: t4, height: i4 } = __privateGet(this, _Ar);
    const [a4, s4] = this.pageDimensions, n4 = 0.75;
    if (this.width) t4 = this.width * a4, i4 = this.height * s4;
    else if (t4 > n4 * a4 || i4 > n4 * s4) {
      const e5 = Math.min(n4 * a4 / t4, n4 * s4 / i4);
      t4 *= e5, i4 *= e5;
    }
    const [r4, o4] = this.parentDimensions;
    this.setDims(t4 * r4 / a4, i4 * o4 / s4), this._uiManager.enableWaiting(false);
    const g4 = __privateSet(this, _or, document.createElement("canvas"));
    e4.append(g4), this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow || (e4.hidden = false), __privateMethod(this, _StampEditor_instances, dr_fn).call(this, t4, i4), __privateMethod(this, _StampEditor_instances, Gn_fn2).call(this), __privateGet(this, _hr) || (this.parent.addUndoableEditor(this), __privateSet(this, _hr, true)), this._reportTelemetry({ action: "inserted_image" }), __privateGet(this, _rr) && g4.setAttribute("aria-label", __privateGet(this, _rr));
  };
  ur_fn = function(e4, t4) {
    const [i4, a4] = this.parentDimensions;
    this.width = e4 / i4, this.height = t4 / a4, this.setDims(e4, t4), this._initialOptions?.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, null !== __privateGet(this, _gr) && clearTimeout(__privateGet(this, _gr));
    __privateSet(this, _gr, setTimeout(() => {
      __privateSet(this, _gr, null), __privateMethod(this, _StampEditor_instances, dr_fn).call(this, e4, t4);
    }, 200));
  };
  Br_fn = function(e4, t4) {
    const { width: i4, height: a4 } = __privateGet(this, _Ar);
    let s4 = i4, n4 = a4, r4 = __privateGet(this, _Ar);
    for (; s4 > 2 * e4 || n4 > 2 * t4; ) {
      const i5 = s4, a5 = n4;
      s4 > 2 * e4 && (s4 = s4 >= 16384 ? Math.floor(s4 / 2) - 1 : Math.ceil(s4 / 2)), n4 > 2 * t4 && (n4 = n4 >= 16384 ? Math.floor(n4 / 2) - 1 : Math.ceil(n4 / 2));
      const o4 = new OffscreenCanvas(s4, n4);
      o4.getContext("2d").drawImage(r4, 0, 0, i5, a5, 0, 0, s4, n4), r4 = o4.transferToImageBitmap();
    }
    return r4;
  };
  dr_fn = function(e4, t4) {
    e4 = Math.ceil(e4), t4 = Math.ceil(t4);
    const i4 = __privateGet(this, _or);
    if (!i4 || i4.width === e4 && i4.height === t4) return;
    i4.width = e4, i4.height = t4;
    const a4 = __privateGet(this, _cr) ? __privateGet(this, _Ar) : __privateMethod(this, _StampEditor_instances, Br_fn).call(this, e4, t4), s4 = i4.getContext("2d");
    s4.filter = this._uiManager.hcmFilter, s4.drawImage(a4, 0, 0, a4.width, a4.height, 0, 0, e4, t4);
  };
  Qr_fn = function(e4) {
    if (e4) {
      if (__privateGet(this, _cr)) {
        const e6 = this._uiManager.imageManager.getSvgUrl(__privateGet(this, _ir));
        if (e6) return e6;
      }
      const e5 = document.createElement("canvas");
      ({ width: e5.width, height: e5.height } = __privateGet(this, _Ar));
      return e5.getContext("2d").drawImage(__privateGet(this, _Ar), 0, 0), e5.toDataURL();
    }
    if (__privateGet(this, _cr)) {
      const [e5, t4] = this.pageDimensions, i4 = Math.round(this.width * e5 * PixelsPerInch.PDF_TO_CSS_UNITS), a4 = Math.round(this.height * t4 * PixelsPerInch.PDF_TO_CSS_UNITS), s4 = new OffscreenCanvas(i4, a4);
      return s4.getContext("2d").drawImage(__privateGet(this, _Ar), 0, 0, __privateGet(this, _Ar).width, __privateGet(this, _Ar).height, 0, 0, i4, a4), s4.transferToImageBitmap();
    }
    return structuredClone(__privateGet(this, _Ar));
  };
  Gn_fn2 = function() {
    this._uiManager._signal && (__privateSet(this, _bn2, new ResizeObserver((e4) => {
      const t4 = e4[0].contentRect;
      t4.width && t4.height && __privateMethod(this, _StampEditor_instances, ur_fn).call(this, t4.width, t4.height);
    })), __privateGet(this, _bn2).observe(this.div), this._uiManager._signal.addEventListener("abort", () => {
      __privateGet(this, _bn2)?.disconnect(), __privateSet(this, _bn2, null);
    }, { once: true }));
  };
  __publicField(_StampEditor, "_type", "stamp");
  __publicField(_StampEditor, "_editorType", Q3.STAMP);
  let StampEditor = _StampEditor;
  const _AnnotationEditorLayer = class _AnnotationEditorLayer {
    constructor({ uiManager: e4, pageIndex: t4, div: i4, accessibilityManager: a4, annotationLayer: s4, drawLayer: n4, textLayer: r4, viewport: o4, l10n: g4 }) {
      __privateAdd(this, _AnnotationEditorLayer_instances);
      __privateAdd(this, _va2);
      __privateAdd(this, _Er, false);
      __privateAdd(this, _fr, null);
      __privateAdd(this, _pr, null);
      __privateAdd(this, _mr, null);
      __privateAdd(this, _yr, /* @__PURE__ */ new Map());
      __privateAdd(this, _wr, false);
      __privateAdd(this, _br, false);
      __privateAdd(this, _Dr, false);
      __privateAdd(this, _Sr, null);
      __privateAdd(this, _Fr, null);
      __privateAdd(this, _ne3);
      const c4 = [...__privateGet(_AnnotationEditorLayer, _xe2).values()];
      if (!_AnnotationEditorLayer._initialized) {
        _AnnotationEditorLayer._initialized = true;
        for (const t5 of c4) t5.initialize(g4, e4);
      }
      e4.registerEditorTypes(c4), __privateSet(this, _ne3, e4), this.pageIndex = t4, this.div = i4, __privateSet(this, _va2, a4), __privateSet(this, _fr, s4), this.viewport = o4, __privateSet(this, _Sr, r4), this.drawLayer = n4, __privateGet(this, _ne3).addLayer(this);
    }
    get isEmpty() {
      return 0 === __privateGet(this, _yr).size;
    }
    get isInvisible() {
      return this.isEmpty && __privateGet(this, _ne3).getMode() === Q3.NONE;
    }
    updateToolbar(e4) {
      __privateGet(this, _ne3).updateToolbar(e4);
    }
    updateMode(e4 = __privateGet(this, _ne3).getMode()) {
      switch (__privateMethod(this, _AnnotationEditorLayer_instances, kr_fn).call(this), e4) {
        case Q3.NONE:
          return this.disableTextSelection(), this.togglePointerEvents(false), this.toggleAnnotationLayerPointerEvents(true), void this.disableClick();
        case Q3.INK:
          this.addInkEditorIfNeeded(false), this.disableTextSelection(), this.togglePointerEvents(true), this.disableClick();
          break;
        case Q3.HIGHLIGHT:
          this.enableTextSelection(), this.togglePointerEvents(false), this.disableClick();
          break;
        default:
          this.disableTextSelection(), this.togglePointerEvents(true), this.enableClick();
      }
      this.toggleAnnotationLayerPointerEvents(false);
      const { classList: t4 } = this.div;
      for (const i4 of __privateGet(_AnnotationEditorLayer, _xe2).values()) t4.toggle(`${i4._type}Editing`, e4 === i4._editorType);
      this.div.hidden = false;
    }
    hasTextLayer(e4) {
      return e4 === __privateGet(this, _Sr)?.div;
    }
    addInkEditorIfNeeded(e4) {
      if (__privateGet(this, _ne3).getMode() !== Q3.INK) return;
      if (!e4) {
        for (const e5 of __privateGet(this, _yr).values()) if (e5.isEmpty()) return void e5.setInBackground();
      }
      this.createAndAddNewEditor({ offsetX: 0, offsetY: 0 }, false).setInBackground();
    }
    setEditingState(e4) {
      __privateGet(this, _ne3).setEditingState(e4);
    }
    addCommands(e4) {
      __privateGet(this, _ne3).addCommands(e4);
    }
    toggleDrawing(e4 = false) {
      this.div.classList.toggle("drawing", !e4);
    }
    togglePointerEvents(e4 = false) {
      this.div.classList.toggle("disabled", !e4);
    }
    toggleAnnotationLayerPointerEvents(e4 = false) {
      __privateGet(this, _fr)?.div.classList.toggle("disabled", !e4);
    }
    enable() {
      this.div.tabIndex = 0, this.togglePointerEvents(true);
      const e4 = /* @__PURE__ */ new Set();
      for (const t5 of __privateGet(this, _yr).values()) t5.enableEditing(), t5.show(true), t5.annotationElementId && (__privateGet(this, _ne3).removeChangedExistingAnnotation(t5), e4.add(t5.annotationElementId));
      if (!__privateGet(this, _fr)) return;
      const t4 = __privateGet(this, _fr).getEditableAnnotations();
      for (const i4 of t4) {
        if (i4.hide(), __privateGet(this, _ne3).isDeletedAnnotationElement(i4.data.id)) continue;
        if (e4.has(i4.data.id)) continue;
        const t5 = this.deserialize(i4);
        t5 && (this.addOrRebuild(t5), t5.enableEditing());
      }
    }
    disable() {
      __privateSet(this, _Dr, true), this.div.tabIndex = -1, this.togglePointerEvents(false);
      const e4 = /* @__PURE__ */ new Map(), t4 = /* @__PURE__ */ new Map();
      for (const i5 of __privateGet(this, _yr).values()) i5.disableEditing(), i5.annotationElementId && (null === i5.serialize() ? (t4.set(i5.annotationElementId, i5), this.getEditableAnnotation(i5.annotationElementId)?.show(), i5.remove()) : e4.set(i5.annotationElementId, i5));
      if (__privateGet(this, _fr)) {
        const i5 = __privateGet(this, _fr).getEditableAnnotations();
        for (const a4 of i5) {
          const { id: i6 } = a4.data;
          if (__privateGet(this, _ne3).isDeletedAnnotationElement(i6)) continue;
          let s4 = t4.get(i6);
          s4 ? (s4.resetAnnotationElement(a4), s4.show(false), a4.show()) : (s4 = e4.get(i6), s4 && (__privateGet(this, _ne3).addChangedExistingAnnotation(s4), s4.renderAnnotationElement(a4), s4.show(false)), a4.show());
        }
      }
      __privateMethod(this, _AnnotationEditorLayer_instances, kr_fn).call(this), this.isEmpty && (this.div.hidden = true);
      const { classList: i4 } = this.div;
      for (const e5 of __privateGet(_AnnotationEditorLayer, _xe2).values()) i4.remove(`${e5._type}Editing`);
      this.disableTextSelection(), this.toggleAnnotationLayerPointerEvents(true), __privateSet(this, _Dr, false);
    }
    getEditableAnnotation(e4) {
      return __privateGet(this, _fr)?.getEditableAnnotation(e4) || null;
    }
    setActiveEditor(e4) {
      __privateGet(this, _ne3).getActive() !== e4 && __privateGet(this, _ne3).setActiveEditor(e4);
    }
    enableTextSelection() {
      if (this.div.tabIndex = -1, __privateGet(this, _Sr)?.div && !__privateGet(this, _Fr)) {
        __privateSet(this, _Fr, new AbortController());
        const e4 = __privateGet(this, _ne3).combinedSignal(__privateGet(this, _Fr));
        __privateGet(this, _Sr).div.addEventListener("pointerdown", __privateMethod(this, _AnnotationEditorLayer_instances, Rr_fn).bind(this), { signal: e4 }), __privateGet(this, _Sr).div.classList.add("highlighting");
      }
    }
    disableTextSelection() {
      this.div.tabIndex = 0, __privateGet(this, _Sr)?.div && __privateGet(this, _Fr) && (__privateGet(this, _Fr).abort(), __privateSet(this, _Fr, null), __privateGet(this, _Sr).div.classList.remove("highlighting"));
    }
    enableClick() {
      if (__privateGet(this, _pr)) return;
      __privateSet(this, _pr, new AbortController());
      const e4 = __privateGet(this, _ne3).combinedSignal(__privateGet(this, _pr));
      this.div.addEventListener("pointerdown", this.pointerdown.bind(this), { signal: e4 }), this.div.addEventListener("pointerup", this.pointerup.bind(this), { signal: e4 });
    }
    disableClick() {
      __privateGet(this, _pr)?.abort(), __privateSet(this, _pr, null);
    }
    attach(e4) {
      __privateGet(this, _yr).set(e4.id, e4);
      const { annotationElementId: t4 } = e4;
      t4 && __privateGet(this, _ne3).isDeletedAnnotationElement(t4) && __privateGet(this, _ne3).removeDeletedAnnotationElement(e4);
    }
    detach(e4) {
      __privateGet(this, _yr).delete(e4.id), __privateGet(this, _va2)?.removePointerInTextLayer(e4.contentDiv), !__privateGet(this, _Dr) && e4.annotationElementId && __privateGet(this, _ne3).addDeletedAnnotationElement(e4);
    }
    remove(e4) {
      this.detach(e4), __privateGet(this, _ne3).removeEditor(e4), e4.div.remove(), e4.isAttachedToDOM = false, __privateGet(this, _br) || this.addInkEditorIfNeeded(false);
    }
    changeParent(e4) {
      e4.parent !== this && (e4.parent && e4.annotationElementId && (__privateGet(this, _ne3).addDeletedAnnotationElement(e4.annotationElementId), AnnotationEditor.deleteAnnotationElement(e4), e4.annotationElementId = null), this.attach(e4), e4.parent?.detach(e4), e4.setParent(this), e4.div && e4.isAttachedToDOM && (e4.div.remove(), this.div.append(e4.div)));
    }
    add(e4) {
      if (e4.parent !== this || !e4.isAttachedToDOM) {
        if (this.changeParent(e4), __privateGet(this, _ne3).addEditor(e4), this.attach(e4), !e4.isAttachedToDOM) {
          const t4 = e4.render();
          this.div.append(t4), e4.isAttachedToDOM = true;
        }
        e4.fixAndSetPosition(), e4.onceAdded(), __privateGet(this, _ne3).addToAnnotationStorage(e4), e4._reportTelemetry(e4.telemetryInitialData);
      }
    }
    moveEditorInDOM(e4) {
      if (!e4.isAttachedToDOM) return;
      const { activeElement: t4 } = document;
      e4.div.contains(t4) && !__privateGet(this, _mr) && (e4._focusEventsAllowed = false, __privateSet(this, _mr, setTimeout(() => {
        __privateSet(this, _mr, null), e4.div.contains(document.activeElement) ? e4._focusEventsAllowed = true : (e4.div.addEventListener("focusin", () => {
          e4._focusEventsAllowed = true;
        }, { once: true, signal: __privateGet(this, _ne3)._signal }), t4.focus());
      }, 0))), e4._structTreeParentId = __privateGet(this, _va2)?.moveElementInDOM(this.div, e4.div, e4.contentDiv, true);
    }
    addOrRebuild(e4) {
      e4.needsToBeRebuilt() ? (e4.parent || (e4.parent = this), e4.rebuild(), e4.show()) : this.add(e4);
    }
    addUndoableEditor(e4) {
      this.addCommands({ cmd: () => e4._uiManager.rebuild(e4), undo: () => {
        e4.remove();
      }, mustExec: false });
    }
    getNextId() {
      return __privateGet(this, _ne3).getId();
    }
    combinedSignal(e4) {
      return __privateGet(this, _ne3).combinedSignal(e4);
    }
    canCreateNewEmptyEditor() {
      return __privateGet(this, _AnnotationEditorLayer_instances, xr_get)?.canCreateNewEmptyEditor();
    }
    pasteEditor(e4, t4) {
      __privateGet(this, _ne3).updateToolbar(e4), __privateGet(this, _ne3).updateMode(e4);
      const { offsetX: i4, offsetY: a4 } = __privateMethod(this, _AnnotationEditorLayer_instances, Mr_fn).call(this), s4 = this.getNextId(), n4 = __privateMethod(this, _AnnotationEditorLayer_instances, Nr_fn).call(this, { parent: this, id: s4, x: i4, y: a4, uiManager: __privateGet(this, _ne3), isCentered: true, ...t4 });
      n4 && this.add(n4);
    }
    deserialize(e4) {
      return __privateGet(_AnnotationEditorLayer, _xe2).get(e4.annotationType ?? e4.annotationEditorType)?.deserialize(e4, this, __privateGet(this, _ne3)) || null;
    }
    createAndAddNewEditor(e4, t4, i4 = {}) {
      const a4 = this.getNextId(), s4 = __privateMethod(this, _AnnotationEditorLayer_instances, Nr_fn).call(this, { parent: this, id: a4, x: e4.offsetX, y: e4.offsetY, uiManager: __privateGet(this, _ne3), isCentered: t4, ...i4 });
      return s4 && this.add(s4), s4;
    }
    addNewEditor() {
      this.createAndAddNewEditor(__privateMethod(this, _AnnotationEditorLayer_instances, Mr_fn).call(this), true);
    }
    setSelected(e4) {
      __privateGet(this, _ne3).setSelected(e4);
    }
    toggleSelected(e4) {
      __privateGet(this, _ne3).toggleSelected(e4);
    }
    isSelected(e4) {
      return __privateGet(this, _ne3).isSelected(e4);
    }
    unselect(e4) {
      __privateGet(this, _ne3).unselect(e4);
    }
    pointerup(e4) {
      const { isMac: t4 } = util_FeatureTest.platform;
      0 !== e4.button || e4.ctrlKey && t4 || e4.target === this.div && __privateGet(this, _wr) && (__privateSet(this, _wr, false), __privateGet(this, _Er) ? __privateGet(this, _ne3).getMode() !== Q3.STAMP ? this.createAndAddNewEditor(e4, false) : __privateGet(this, _ne3).unselectAll() : __privateSet(this, _Er, true));
    }
    pointerdown(e4) {
      if (__privateGet(this, _ne3).getMode() === Q3.HIGHLIGHT && this.enableTextSelection(), __privateGet(this, _wr)) return void __privateSet(this, _wr, false);
      const { isMac: t4 } = util_FeatureTest.platform;
      if (0 !== e4.button || e4.ctrlKey && t4) return;
      if (e4.target !== this.div) return;
      __privateSet(this, _wr, true);
      const i4 = __privateGet(this, _ne3).getActive();
      __privateSet(this, _Er, !i4 || i4.isEmpty());
    }
    findNewParent(e4, t4, i4) {
      const a4 = __privateGet(this, _ne3).findParent(t4, i4);
      return null !== a4 && a4 !== this && (a4.changeParent(e4), true);
    }
    destroy() {
      __privateGet(this, _ne3).getActive()?.parent === this && (__privateGet(this, _ne3).commitOrRemove(), __privateGet(this, _ne3).setActiveEditor(null)), __privateGet(this, _mr) && (clearTimeout(__privateGet(this, _mr)), __privateSet(this, _mr, null));
      for (const e4 of __privateGet(this, _yr).values()) __privateGet(this, _va2)?.removePointerInTextLayer(e4.contentDiv), e4.setParent(null), e4.isAttachedToDOM = false, e4.div.remove();
      this.div = null, __privateGet(this, _yr).clear(), __privateGet(this, _ne3).removeLayer(this);
    }
    render({ viewport: e4 }) {
      this.viewport = e4, setLayerDimensions(this.div, e4);
      for (const e5 of __privateGet(this, _ne3).getEditors(this.pageIndex)) this.add(e5), e5.rebuild();
      this.updateMode();
    }
    update({ viewport: e4 }) {
      __privateGet(this, _ne3).commitOrRemove(), __privateMethod(this, _AnnotationEditorLayer_instances, kr_fn).call(this);
      const t4 = this.viewport.rotation, i4 = e4.rotation;
      if (this.viewport = e4, setLayerDimensions(this.div, { rotation: i4 }), t4 !== i4) for (const e5 of __privateGet(this, _yr).values()) e5.rotate(i4);
      this.addInkEditorIfNeeded(false);
    }
    get pageDimensions() {
      const { pageWidth: e4, pageHeight: t4 } = this.viewport.rawDims;
      return [e4, t4];
    }
    get scale() {
      return __privateGet(this, _ne3).viewParameters.realScale;
    }
  };
  _va2 = new WeakMap();
  _Er = new WeakMap();
  _fr = new WeakMap();
  _pr = new WeakMap();
  _mr = new WeakMap();
  _yr = new WeakMap();
  _wr = new WeakMap();
  _br = new WeakMap();
  _Dr = new WeakMap();
  _Sr = new WeakMap();
  _Fr = new WeakMap();
  _ne3 = new WeakMap();
  _xe2 = new WeakMap();
  _AnnotationEditorLayer_instances = new WeakSet();
  Rr_fn = function(e4) {
    __privateGet(this, _ne3).unselectAll();
    const { target: t4 } = e4;
    if (t4 === __privateGet(this, _Sr).div || t4.classList.contains("endOfContent") && __privateGet(this, _Sr).div.contains(t4)) {
      const { isMac: t5 } = util_FeatureTest.platform;
      if (0 !== e4.button || e4.ctrlKey && t5) return;
      __privateGet(this, _ne3).showAllEditors("highlight", true, true), __privateGet(this, _Sr).div.classList.add("free"), this.toggleDrawing(), HighlightEditor.startHighlighting(this, "ltr" === __privateGet(this, _ne3).direction, e4), __privateGet(this, _Sr).div.addEventListener("pointerup", () => {
        __privateGet(this, _Sr).div.classList.remove("free"), this.toggleDrawing(true);
      }, { once: true, signal: __privateGet(this, _ne3)._signal }), e4.preventDefault();
    }
  };
  xr_get = function() {
    return __privateGet(_AnnotationEditorLayer, _xe2).get(__privateGet(this, _ne3).getMode());
  };
  Nr_fn = function(e4) {
    const t4 = __privateGet(this, _AnnotationEditorLayer_instances, xr_get);
    return t4 ? new t4.prototype.constructor(e4) : null;
  };
  Mr_fn = function() {
    const { x: e4, y: t4, width: i4, height: a4 } = this.div.getBoundingClientRect(), s4 = Math.max(0, e4), n4 = Math.max(0, t4), r4 = (s4 + Math.min(window.innerWidth, e4 + i4)) / 2 - e4, o4 = (n4 + Math.min(window.innerHeight, t4 + a4)) / 2 - t4, [g4, c4] = this.viewport.rotation % 180 == 0 ? [r4, o4] : [o4, r4];
    return { offsetX: g4, offsetY: c4 };
  };
  kr_fn = function() {
    __privateSet(this, _br, true);
    for (const e4 of __privateGet(this, _yr).values()) e4.isEmpty() && e4.remove();
    __privateSet(this, _br, false);
  };
  __publicField(_AnnotationEditorLayer, "_initialized", false);
  __privateAdd(_AnnotationEditorLayer, _xe2, new Map([FreeTextEditor, InkEditor, StampEditor, HighlightEditor].map((e4) => [e4._editorType, e4])));
  let AnnotationEditorLayer = _AnnotationEditorLayer;
  const _DrawLayer = class _DrawLayer {
    constructor({ pageIndex: e4 }) {
      __privateAdd(this, _DrawLayer_instances);
      __privateAdd(this, _da2, null);
      __privateAdd(this, _ce5, 0);
      __privateAdd(this, _Gr, /* @__PURE__ */ new Map());
      __privateAdd(this, _vr, /* @__PURE__ */ new Map());
      this.pageIndex = e4;
    }
    setParent(e4) {
      if (__privateGet(this, _da2)) {
        if (__privateGet(this, _da2) !== e4) {
          if (__privateGet(this, _Gr).size > 0) for (const t4 of __privateGet(this, _Gr).values()) t4.remove(), e4.append(t4);
          __privateSet(this, _da2, e4);
        }
      } else __privateSet(this, _da2, e4);
    }
    static get _svgFactory() {
      return shadow2(this, "_svgFactory", new DOMSVGFactory());
    }
    highlight(e4, t4, i4, a4 = false) {
      const s4 = __privateWrapper(this, _ce5)._++, n4 = __privateMethod(this, _DrawLayer_instances, Ur_fn).call(this, e4.box);
      n4.classList.add("highlight"), e4.free && n4.classList.add("free");
      const r4 = _DrawLayer._svgFactory.createElement("defs");
      n4.append(r4);
      const o4 = _DrawLayer._svgFactory.createElement("path");
      r4.append(o4);
      const g4 = `path_p${this.pageIndex}_${s4}`;
      o4.setAttribute("id", g4), o4.setAttribute("d", e4.toSVGPath()), a4 && __privateGet(this, _vr).set(s4, o4);
      const c4 = __privateMethod(this, _DrawLayer_instances, Hr_fn).call(this, r4, g4), h4 = _DrawLayer._svgFactory.createElement("use");
      return n4.append(h4), n4.setAttribute("fill", t4), n4.setAttribute("fill-opacity", i4), h4.setAttribute("href", `#${g4}`), __privateGet(this, _Gr).set(s4, n4), { id: s4, clipPathId: `url(#${c4})` };
    }
    highlightOutline(e4) {
      const t4 = __privateWrapper(this, _ce5)._++, i4 = __privateMethod(this, _DrawLayer_instances, Ur_fn).call(this, e4.box);
      i4.classList.add("highlightOutline");
      const a4 = _DrawLayer._svgFactory.createElement("defs");
      i4.append(a4);
      const s4 = _DrawLayer._svgFactory.createElement("path");
      a4.append(s4);
      const n4 = `path_p${this.pageIndex}_${t4}`;
      let r4;
      if (s4.setAttribute("id", n4), s4.setAttribute("d", e4.toSVGPath()), s4.setAttribute("vector-effect", "non-scaling-stroke"), e4.free) {
        i4.classList.add("free");
        const e5 = _DrawLayer._svgFactory.createElement("mask");
        a4.append(e5), r4 = `mask_p${this.pageIndex}_${t4}`, e5.setAttribute("id", r4), e5.setAttribute("maskUnits", "objectBoundingBox");
        const s5 = _DrawLayer._svgFactory.createElement("rect");
        e5.append(s5), s5.setAttribute("width", "1"), s5.setAttribute("height", "1"), s5.setAttribute("fill", "white");
        const o5 = _DrawLayer._svgFactory.createElement("use");
        e5.append(o5), o5.setAttribute("href", `#${n4}`), o5.setAttribute("stroke", "none"), o5.setAttribute("fill", "black"), o5.setAttribute("fill-rule", "nonzero"), o5.classList.add("mask");
      }
      const o4 = _DrawLayer._svgFactory.createElement("use");
      i4.append(o4), o4.setAttribute("href", `#${n4}`), r4 && o4.setAttribute("mask", `url(#${r4})`);
      const g4 = o4.cloneNode();
      return i4.append(g4), o4.classList.add("mainOutline"), g4.classList.add("secondaryOutline"), __privateGet(this, _Gr).set(t4, i4), t4;
    }
    finalizeLine(e4, t4) {
      const i4 = __privateGet(this, _vr).get(e4);
      __privateGet(this, _vr).delete(e4), this.updateBox(e4, t4.box), i4.setAttribute("d", t4.toSVGPath());
    }
    updateLine(e4, t4) {
      __privateGet(this, _Gr).get(e4).firstChild.firstChild.setAttribute("d", t4.toSVGPath());
    }
    removeFreeHighlight(e4) {
      this.remove(e4), __privateGet(this, _vr).delete(e4);
    }
    updatePath(e4, t4) {
      __privateGet(this, _vr).get(e4).setAttribute("d", t4.toSVGPath());
    }
    updateBox(e4, t4) {
      var _a5;
      __privateMethod(_a5 = _DrawLayer, _DrawLayer_static, Lr_fn).call(_a5, __privateGet(this, _Gr).get(e4), t4);
    }
    show(e4, t4) {
      __privateGet(this, _Gr).get(e4).classList.toggle("hidden", !t4);
    }
    rotate(e4, t4) {
      __privateGet(this, _Gr).get(e4).setAttribute("data-main-rotation", t4);
    }
    changeColor(e4, t4) {
      __privateGet(this, _Gr).get(e4).setAttribute("fill", t4);
    }
    changeOpacity(e4, t4) {
      __privateGet(this, _Gr).get(e4).setAttribute("fill-opacity", t4);
    }
    addClass(e4, t4) {
      __privateGet(this, _Gr).get(e4).classList.add(t4);
    }
    removeClass(e4, t4) {
      __privateGet(this, _Gr).get(e4).classList.remove(t4);
    }
    remove(e4) {
      null !== __privateGet(this, _da2) && (__privateGet(this, _Gr).get(e4).remove(), __privateGet(this, _Gr).delete(e4));
    }
    destroy() {
      __privateSet(this, _da2, null);
      for (const e4 of __privateGet(this, _Gr).values()) e4.remove();
      __privateGet(this, _Gr).clear();
    }
  };
  _da2 = new WeakMap();
  _ce5 = new WeakMap();
  _Gr = new WeakMap();
  _vr = new WeakMap();
  _DrawLayer_static = new WeakSet();
  Lr_fn = function(e4, { x: t4 = 0, y: i4 = 0, width: a4 = 1, height: s4 = 1 } = {}) {
    const { style: n4 } = e4;
    n4.top = 100 * i4 + "%", n4.left = 100 * t4 + "%", n4.width = 100 * a4 + "%", n4.height = 100 * s4 + "%";
  };
  _DrawLayer_instances = new WeakSet();
  Ur_fn = function(e4) {
    var _a5;
    const t4 = _DrawLayer._svgFactory.create(1, 1, true);
    return __privateGet(this, _da2).append(t4), t4.setAttribute("aria-hidden", true), __privateMethod(_a5 = _DrawLayer, _DrawLayer_static, Lr_fn).call(_a5, t4, e4), t4;
  };
  Hr_fn = function(e4, t4) {
    const i4 = _DrawLayer._svgFactory.createElement("clipPath");
    e4.append(i4);
    const a4 = `clip_${t4}`;
    i4.setAttribute("id", a4), i4.setAttribute("clipPathUnits", "objectBoundingBox");
    const s4 = _DrawLayer._svgFactory.createElement("use");
    return i4.append(s4), s4.setAttribute("href", `#${t4}`), s4.classList.add("clip"), a4;
  };
  __privateAdd(_DrawLayer, _DrawLayer_static);
  let DrawLayer = _DrawLayer;
  return { AbortException: t3.AbortException, AnnotationEditorLayer: t3.AnnotationEditorLayer, AnnotationEditorParamsType: t3.AnnotationEditorParamsType, AnnotationEditorType: t3.AnnotationEditorType, AnnotationEditorUIManager: t3.AnnotationEditorUIManager, AnnotationLayer: t3.AnnotationLayer, AnnotationMode: t3.AnnotationMode, CMapCompressionType: t3.CMapCompressionType, ColorPicker: t3.ColorPicker, DOMSVGFactory: t3.DOMSVGFactory, DrawLayer: t3.DrawLayer, FeatureTest: t3.FeatureTest, GlobalWorkerOptions: t3.GlobalWorkerOptions, ImageKind: t3.ImageKind, InvalidPDFException: t3.InvalidPDFException, MissingPDFException: t3.MissingPDFException, OPS: t3.OPS, PDFDataRangeTransport: t3.PDFDataRangeTransport, PDFDateString: t3.PDFDateString, PDFWorker: t3.PDFWorker, PasswordResponses: t3.PasswordResponses, PermissionFlag: t3.PermissionFlag, PixelsPerInch: t3.PixelsPerInch, RenderingCancelledException: t3.RenderingCancelledException, TextLayer: t3.TextLayer, UnexpectedResponseException: t3.UnexpectedResponseException, Util: t3.Util, VerbosityLevel: t3.VerbosityLevel, XfaLayer: t3.XfaLayer, build: t3.build, createValidAbsoluteUrl: t3.createValidAbsoluteUrl, fetchData: t3.fetchData, getDocument: t3.getDocument, getFilenameFromUrl: t3.getFilenameFromUrl, getPdfFilenameFromUrl: t3.getPdfFilenameFromUrl, getXfaPageViewport: t3.getXfaPageViewport, isDataScheme: t3.isDataScheme, isPdfFile: t3.isPdfFile, noContextMenu: t3.noContextMenu, normalizeUnicode: t3.normalizeUnicode, setLayerDimensions: t3.setLayerDimensions, shadow: t3.shadow, version: t3.version };
}
function resolvePDFJS() {
  return __main__();
}
var fn, e, t, i, a, s, n, r, o, g, c, h, l, C, d, u, Q, f, p, m, y, w, b, D, S, F, k, R, x, N, M, G, v, L, U, H, T, J, Y, O, K, q, _, W, j, X, V, Z, z, $, ee, te, Ae, ie, ae, se, ne, re, oe, ge, ce, he, le, Ie, Ce, de, Be, ue, Qe, Ee, fe, pe, me, ye, we, be, De, Se, Fe, ke, Re, xe, Ne, Me, Ge, ve, Le, Ue, He, Te, Je, Ye, Pe, Oe, Ke, qe, _e, We, je, Xe, Ve, Ze, ze, existsSync, $e, et, tt, At, it, at, st, nt, rt, ot, gt, ct, ht, lt, It, Ct, dt, Bt, ut, Qt, Et, ft, pt, mt, yt, wt, bt, Dt, St, Ft, kt, Rt, xt, Nt, Mt, Gt, vt, Lt, Ut, Ht, _Readable, Tt, Jt, Yt, Pt, Ot, Kt, qt, _t, Wt, jt, Xt, Vt, Zt, zt, $t, eA, Socket, IncomingMessage, ServerResponse, tA, AA, iA, aA, sA, nA, rA, oA, gA, cA, hA, lA, IA, CA, dA, BA, uA, QA, EA, fA, parse, resolve, urlToHttpOptions, format, domainToASCII, domainToUnicode, pathToFileURL, fileURLToPath, pA, mA, yA, wA, bA, DA, SA, FA, kA, RA, xA, NA, MA, GA, vA, LA, UA, HA, TA, JA, YA, PA, OA, KA, qA, _A, WA, jA, XA, VA, ZA, zA, $A, ei, ti, Ai, ii, ai, si, ni, ri, oi, gi, ci, hi, li, Ii, Ci, di, Bi, ui, Qi, Ei, fi, pi, mi, yi, wi, bi, Di, Si, Fi, ki, Ri, xi, Ni, Mi, Gi, vi, Hi, Ti, Ji, Yi, Pi, Oi, Ki, qi, _i, Wi, ji, Xi, Vi, Zi, zi, $i, ea, ta, Aa, ia, aa, sa, na, ra, oa, ga, ca, ha, la, Ia, Ca, da, Ba, ua, Qa, Ea, fa, pa, ma, ya, wa, ba, Da, Sa, Fa, ka, Ra, xa, Na, Ma, Ga, va, La, Ua, Ha, Ta, Ja, Ya, Pa, Oa, Ka, qa, _a, Wa, ja, Xa, Va, Za, za, $a, es, ts, As, is, as, ss, ns, rs, os, gs, cs, hs, ls, Is, Cs, ds, Bs, us, Qs, Es, fs, ps, ms, ys, ws, bs, Ds, Ss, Fs, ks, Rs, xs, Ns, Ms, PasswordException, UnknownErrorException, InvalidPDFException, MissingPDFException, UnexpectedResponseException, FormatError, AbortException, FeatureTest, Gs, _Util_static, e_fn, t_fn, Util, vs, Ls, Us, Hs, Ts, Js, Ys, Os, Ks, qs, _s, Ws, js, Xs, Vs, Zs, zs, Name, Cmd, nonSerializable, Dict, Ref, RefSet, RefSetCache, BaseStream, $s, MissingDataException, ParserEOFException, XRefEntryException, XRefParseException, en, tn, Stream, StringStream, NullStream, ChunkedStream, ChunkedStreamManager, ColorSpace, AlternateCS, PatternCS, IndexedCS, DeviceGrayCS, DeviceRgbCS, DeviceRgbaCS, _DeviceCmykCS_instances, A_fn, DeviceCmykCS, _CalGrayCS_instances, A_fn2, CalGrayCS, _i2, _a2, _s2, _n, _r, _o, _g, _c, _CalRGBCS_instances, h_fn, l_fn, I_fn, C_fn, d_fn, B_fn, u_fn, Q_fn, E_fn, A_fn3, _CalRGBCS, CalRGBCS, _LabCS_instances, f_fn, p_fn, A_fn4, LabCS, An, BinaryCMapStream, BinaryCMapReader, an, DecodeStream, StreamsSequenceStream, Ascii85Stream, AsciiHexStream, sn, nn, rn, on, gn, cn, hn, CCITTFaxDecoder, CCITTFaxStream, ln, In, Cn, dn, Bn, _FlateStream_instances, m_fn, FlateStream, un, ArithmeticDecoder, Jbig2Error, ContextCache, DecodingContext, Qn, En, pn, mn, yn, SimpleSegmentVisitor, HuffmanLine, HuffmanTreeNode, HuffmanTable, wn, Reader, Jbig2Image, Jbig2Stream, JpegError, DNLMarkerError, EOIMarkerError, bn, Dn, Sn, Fn, kn, Rn, xn, Nn, Mn, JpegImage, JpegStream, Gn, vn, Ln, JpxError, _y, JpxImage, JpxStream, LZWStream, PredictorStream, RunLengthStream, _Parser_instances, w_fn, Parser, Un, Lexer, Linearization, Hn, Tn, CMap, IdentityCMap, CMapFactory, Jn, Yn, Pn, On, Kn, qn, _n2, Wn, jn, Xn, Vn, Zn, zn, $n, CFFParser, CFF, CFFHeader, CFFStrings, CFFIndex, CFFDict, er, CFFTopDict, tr, CFFPrivateDict, Ar, CFFCharset, CFFEncoding, CFFFDSelect, CFFOffsetTracker, CFFCompiler, ir, ar, sr, nr, rr, or, gr, cr, hr, lr, Ir, Cr, dr, ur, Qr, Er, fr, pr, mr, yr, wr, ToUnicodeMap, IdentityToUnicodeMap, CFFFont, br, Commands, CompiledFont, TrueTypeCompiled, Type2Compiled, FontRendererFactory, Dr, Sr, GlyfTable, Glyph, GlyphHeader, Contour, SimpleGlyph, CompositeGlyph, OpenTypeFileBuilder, Fr, kr, Rr, xr, Nr, Mr, Gr, vr, Lr, Ur, Hr, Type1CharString, Type1Parser, Type1Font, Tr, Jr, Yr, Pr, fonts_Glyph, Font, ErrorFont, Or, Kr, qr, _r2, Wr, jr, Pattern, BaseShading, RadialAxialShading, MeshStreamReader, Xr, _MeshShading, MeshShading, DummyShading, Vr, Zr, zr, $r, eo, to, Ao, io, ao, so, no, ro, oo, go, co, ho, lo, Io, Co, Bo, uo, Qo, Eo, fo, po, mo, yo, wo, bo, Do, So, Fo, ko, Ro, xo, No, Mo, Go, vo, Lo, Uo, PostScriptParser, Ho, PostScriptToken, PostScriptLexer, BaseLocalCache, LocalImageCache, LocalColorSpaceCache, LocalFunctionCache, LocalGStateCache, LocalTilingPatternCache, RegionalImageCache, _b, _GlobalImageCache_instances, D_get, S_get, _GlobalImageCache, GlobalImageCache, PDFFunctionFactory, PDFFunction, _PostScriptStack, PostScriptStack, PostScriptEvaluator, AstNode, AstArgument, AstLiteral, AstBinaryOperation, AstMin, AstVariable, AstVariableDefinition, ExpressionBuilderVisitor, PostScriptCompiler, Jo, Yo, Po, Oo, Ko, qo, _o2, Wo, jo, Xo, ImageResizer, Vo, Zo, zo, MurmurHash3_64, $o, NullOptimizer, QueueOptimizer, _OperatorList, OperatorList, PDFImage, eg, tg, Ag, ig, _TimeSlotManager, TimeSlotManager, PartialEvaluator, TranslatedFont, StateManager, TextState, EvalState, _EvaluatorPreprocessor, EvaluatorPreprocessor, DefaultAppearanceEvaluator, AppearanceStreamEvaluator, FakeUnicodeFont, NameOrNumberTree, NameTree, NumberTree, _F, FileSpec, ag, sg, ng, rg, og, gg, cg, XMLParserBase, SimpleDOMNode, SimpleXMLParser, MetadataParser, DecryptStream, ARCFourCipher, hg, Word64, lg, Ig, NullCipher, AESBaseCipher, AES128Cipher, AES256Cipher, PDF17, PDF20, CipherTransform, _k, _CipherTransformFactory_instances, R_fn, x_fn, N_fn, M_fn, G_fn, _CipherTransformFactory, CipherTransformFactory, Cg, dg, Bg, ug, Qg, _StructTreeRoot_instances, v_fn, _StructTreeRoot_static, L_fn, U_fn, H_fn, _StructTreeRoot, StructTreeRoot, StructElementNode, StructElement, StructTreePage, _Catalog_instances, T_fn, J_fn, _Catalog, Catalog, ObjectLoader, Eg, fg, pg, mg, yg, wg, bg, Dg, Sg, Fg, kg, Rg, xg, Ng, Mg, Gg, vg, Lg, Ug, Hg, Tg, Jg, Yg, Pg, Og, Kg, qg, _g2, Wg, jg, Xg, Vg, Zg, zg, $g, ec, tc, Ac, ic, ac, sc, nc, rc, oc, gc, cc, hc, lc, Ic, Cc, dc, Bc, uc, Qc, Ec, fc, pc, mc, yc, wc, bc, Dc, Sc, Fc, kc, Rc, xc, Nc, Mc, Gc, vc, Lc, HTMLResult, FontFinder, FontInfo, FontSelector, TextMeasure, Uc, Hc, Tc, Jc, Yc, Pc, Oc, Kc, qc, _c2, Wc, jc, Xc, Vc, Zc, zc, $c, eh, th, Ah, ih, ah, sh, nh, rh, oh, gh, hh, XFAObject, XFAObjectArray, XFAAttribute, XmlObject, ContentObject, OptionObject, StringObject, IntegerObject, Option01, Option10, lh, Ih, Ch, dh, Bh, uh, AppearanceFilter, Arc, Area, Assist, Barcode, Bind, BindItems, Bookend, BooleanElement, Border, Break, BreakAfter, BreakBefore, Button, Calculate, Caption, Certificate, Certificates, CheckButton, ChoiceList, Color, Comb, Connect, ContentArea, Corner, DateElement, DateTime, DateTimeEdit, Decimal, DefaultUi, Desc, DigestMethod, DigestMethods, Draw, Edge, Encoding, Encodings, Encrypt, EncryptData, Encryption, EncryptionMethod, EncryptionMethods, Qh, ExData, ExObject, ExclGroup, Execute, Extras, Field, Fill, Filter, Float, template_Font, Format, Handler, Hyphenation, Eh, ImageEdit, Integer, Issuers, Items, Keep, KeyUsage, Line, Linear, LockDocument, Manifest, Margin, Mdp, Medium, Message, NumericEdit, Occur, Oid, Oids, Overflow, PageArea, PageSet, Para, PasswordEdit, template_Pattern, Picture, Proto, Radial, Reason, Reasons, Rectangle, RefElement, Script, SetProperty, SignData, Signature, Signing, Solid, Speak, Stipple, Subform, SubformSet, SubjectDN, SubjectDNs, Submit, Template, Text, TextEdit, Time, TimeStamp, ToolTip, Traversal, Traverse, Ui, Validate, Value, Variables, TemplateNamespace, fh, Binder, DataHandler, ph, Acrobat, Acrobat7, ADBE_JSConsole, ADBE_JSDebugger, AddSilentPrint, AddViewerPreferences, AdjustData, AdobeExtensionLevel, Agent, AlwaysEmbed, Amd, config_Area, Attributes, AutoSave, Base, BatchOutput, BehaviorOverride, Cache, Change, Common, Compress, CompressLogicalStructure, CompressObjectStream, Compression, Config, Conformance, ContentCopy, Copies, Creator, CurrentPage, Data, Debug, DefaultTypeface, Destination, DocumentAssembly, Driver, DuplexOption, DynamicRender, Embed, config_Encrypt, config_Encryption, EncryptionLevel, Enforce, Equate, EquateRange, Exclude, ExcludeNS, FlipLabel, config_FontInfo, FormFieldFilling, GroupParent, IfEmpty, IncludeXDPContent, IncrementalLoad, IncrementalMerge, Interactive, Jog, LabelPrinter, Layout, Level, Linearized, Locale, LocaleSet, Log, MapElement, MediumInfo, config_Message, Messaging, Mode, ModifyAnnots, MsgId, NameAttr, NeverEmbed, NumberOfCopies, OpenAction, Output, OutputBin, OutputXSL, Overprint, Packets, PageOffset, PageRange, Pagination, PaginationOverride, Part, Pcl, Pdf, Pdfa, Permissions, PickTrayByPDFSize, config_Picture, PlaintextMetadata, Presence, Present, Print, PrintHighQuality, PrintScaling, PrinterName, Producer, Ps, mh, Record, Relevant, Rename, RenderPolicy, RunScripts, config_Script, ScriptModel, Severity, SilentPrint, Staple, StartNode, StartPage, SubmitFormat, SubmitUrl, SubsetBelow, SuppressBanner, Tagged, config_Template, Threshold, To, TemplateCache, Trace, Transform, Type, Uri, config_Validate, ValidateApprovalSignatures, ValidationMessaging, Version, VersionControl, ViewerPreferences, WebClient, Whitespace, Window, Xdc, Xdp, Xsl, Zpl, ConfigNamespace, yh, ConnectionSet, EffectiveInputPolicy, EffectiveOutputPolicy, Operation, RootElement, SoapAction, SoapAddress, connection_set_Uri, WsdlAddress, WsdlConnection, XmlConnection, XsdConnection, ConnectionSetNamespace, wh, datasets_Data, Datasets, DatasetsNamespace, bh, CalendarSymbols, CurrencySymbol, CurrencySymbols, DatePattern, DatePatterns, DateTimeSymbols, Day, DayNames, Era, EraNames, locale_set_Locale, locale_set_LocaleSet, Meridiem, MeridiemNames, Month, MonthNames, NumberPattern, NumberPatterns, NumberSymbol, NumberSymbols, TimePattern, TimePatterns, TypeFace, TypeFaces, LocaleSetNamespace, Dh, signature_Signature, SignatureNamespace, Sh, Stylesheet, StylesheetNamespace, Fh, xdp_Xdp, XdpNamespace, kh, Rh, xh, Nh, Mh, Gh, vh, Lh, XhtmlObject, A, B, Body, Br, Html, I, Li, Ol, P, Span, Sub, Sup, Ul, XhtmlNamespace, Uh, UnknownNamespace, Root, Empty, Builder, XFAParser, XFAFactory, AnnotationFactory, Annotation, AnnotationBorderStyle, MarkupAnnotation, WidgetAnnotation, TextWidgetAnnotation, ButtonWidgetAnnotation, ChoiceWidgetAnnotation, SignatureWidgetAnnotation, TextAnnotation, LinkAnnotation, PopupAnnotation, FreeTextAnnotation, LineAnnotation, SquareAnnotation, CircleAnnotation, PolylineAnnotation, PolygonAnnotation, CaretAnnotation, InkAnnotation, HighlightAnnotation, UnderlineAnnotation, SquigglyAnnotation, StrikeOutAnnotation, StampAnnotation, FileAttachmentAnnotation, DatasetXMLParser, DatasetReader, _Y, XRef, Hh, _Page_instances, P_fn, Page, Th, Jh, Yh, _PDFDocument_instances, O_fn, PDFDocument, BasePdfManager, LocalPdfManager, NetworkPdfManager, Ph, Oh, Kh, qh, _h, Wh, jh, Xh, Vh, Zh, _MessageHandler_instances, q_fn, K_fn, __fn, MessageHandler, PDFWorkerStream, PDFWorkerStreamReader, PDFWorkerStreamRangeReader, WorkerTask, WorkerMessageHandler, zh;
var init_pdfjs = __esm({
  "node_modules/unpdf/dist/pdfjs.mjs"() {
    fn = function() {
    };
    e = function createMock(e3, t3 = {}) {
      fn.prototype.name = e3;
      const i3 = {};
      return new Proxy(fn, { get: (a3, s3) => "caller" === s3 ? null : "__createMock__" === s3 ? createMock : "__unenv__" === s3 || (s3 in t3 ? t3[s3] : i3[s3] = i3[s3] || createMock(`${e3}.${s3.toString()}`)), apply: (t4, i4, a3) => createMock(`${e3}()`), construct: (t4, i4, a3) => createMock(`[${e3}]`), enumerate: () => [] });
    }("mock");
    t = e.__createMock__("fs.Dir");
    i = e.__createMock__("fs.Dirent");
    a = e.__createMock__("fs.Stats");
    s = e.__createMock__("fs.ReadStream");
    n = e.__createMock__("fs.WriteStream");
    r = e.__createMock__("fs.FileReadStream");
    o = e.__createMock__("fs.FileWriteStream");
    g = e.__createMock__("fs.StatsFs");
    c = Object.freeze({ __proto__: null, Dir: t, Dirent: i, FileReadStream: r, FileWriteStream: o, ReadStream: s, Stats: a, StatsFs: g, WriteStream: n });
    h = /* @__PURE__ */ Object.create({ UV_FS_SYMLINK_DIR: 1, UV_FS_SYMLINK_JUNCTION: 2, O_RDONLY: 0, O_WRONLY: 1, O_RDWR: 2, UV_DIRENT_UNKNOWN: 0, UV_DIRENT_FILE: 1, UV_DIRENT_DIR: 2, UV_DIRENT_LINK: 3, UV_DIRENT_FIFO: 4, UV_DIRENT_SOCKET: 5, UV_DIRENT_CHAR: 6, UV_DIRENT_BLOCK: 7, S_IFMT: 61440, S_IFREG: 32768, S_IFDIR: 16384, S_IFCHR: 8192, S_IFBLK: 24576, S_IFIFO: 4096, S_IFLNK: 40960, S_IFSOCK: 49152, O_CREAT: 64, O_EXCL: 128, UV_FS_O_FILEMAP: 0, O_NOCTTY: 256, O_TRUNC: 512, O_APPEND: 1024, O_DIRECTORY: 65536, O_NOATIME: 262144, O_NOFOLLOW: 131072, O_SYNC: 1052672, O_DSYNC: 4096, O_DIRECT: 16384, O_NONBLOCK: 2048, S_IRWXU: 448, S_IRUSR: 256, S_IWUSR: 128, S_IXUSR: 64, S_IRWXG: 56, S_IRGRP: 32, S_IWGRP: 16, S_IXGRP: 8, S_IRWXO: 7, S_IROTH: 4, S_IWOTH: 2, S_IXOTH: 1, F_OK: 0, R_OK: 4, W_OK: 2, X_OK: 1, UV_FS_COPYFILE_EXCL: 1, COPYFILE_EXCL: 1, UV_FS_COPYFILE_FICLONE: 2, COPYFILE_FICLONE: 2, UV_FS_COPYFILE_FICLONE_FORCE: 4, COPYFILE_FICLONE_FORCE: 4 });
    l = Object.freeze({ __proto__: null, F_OK: 0, R_OK: 4, W_OK: 2, X_OK: 1, constants: h });
    C = notImplemented("fs.access");
    d = notImplemented("fs.copyFile");
    u = notImplemented("fs.cp");
    Q = notImplemented("fs.open");
    f = notImplemented("fs.opendir");
    p = notImplemented("fs.rename");
    m = notImplemented("fs.truncate");
    y = notImplemented("fs.rm");
    w = notImplemented("fs.rmdir");
    b = notImplemented("fs.mkdir");
    D = notImplemented("fs.readdir");
    S = notImplemented("fs.readlink");
    F = notImplemented("fs.symlink");
    k = notImplemented("fs.lstat");
    R = notImplemented("fs.stat");
    x = notImplemented("fs.link");
    N = notImplemented("fs.unlink");
    M = notImplemented("fs.chmod");
    G = notImplemented("fs.lchmod");
    v = notImplemented("fs.lchown");
    L = notImplemented("fs.chown");
    U = notImplemented("fs.utimes");
    H = notImplemented("fs.lutimes");
    T = notImplemented("fs.realpath");
    J = notImplemented("fs.mkdtemp");
    Y = notImplemented("fs.writeFile");
    O = notImplemented("fs.appendFile");
    K = notImplemented("fs.readFile");
    q = notImplemented("fs.watch");
    _ = notImplemented("fs.statfs");
    W = Object.freeze({ __proto__: null, access: C, appendFile: O, chmod: M, chown: L, constants: h, copyFile: d, cp: u, default: {}, lchmod: G, lchown: v, link: x, lstat: k, lutimes: H, mkdir: b, mkdtemp: J, open: Q, opendir: f, readFile: K, readdir: D, readlink: S, realpath: T, rename: p, rm: y, rmdir: w, stat: R, statfs: _, symlink: F, truncate: m, unlink: N, utimes: U, watch: q, writeFile: Y });
    j = callbackify(C);
    X = callbackify(O);
    V = callbackify(L);
    Z = callbackify(M);
    z = callbackify(d);
    $ = callbackify(u);
    ee = callbackify(v);
    te = callbackify(G);
    Ae = callbackify(x);
    ie = callbackify(k);
    ae = callbackify(H);
    se = callbackify(b);
    ne = callbackify(J);
    re = callbackify(T);
    oe = callbackify(Q);
    ge = callbackify(f);
    ce = callbackify(D);
    he = callbackify(K);
    le = callbackify(S);
    Ie = callbackify(p);
    Ce = callbackify(y);
    de = callbackify(w);
    Be = callbackify(R);
    ue = callbackify(F);
    Qe = callbackify(m);
    Ee = callbackify(N);
    fe = callbackify(U);
    pe = callbackify(Y);
    me = callbackify(_);
    ye = notImplementedAsync("fs.close");
    we = notImplementedAsync("fs.createReadStream");
    be = notImplementedAsync("fs.createWriteStream");
    De = notImplementedAsync("fs.exists");
    Se = notImplementedAsync("fs.fchown");
    Fe = notImplementedAsync("fs.fchmod");
    ke = notImplementedAsync("fs.fdatasync");
    Re = notImplementedAsync("fs.fstat");
    xe = notImplementedAsync("fs.fsync");
    Ne = notImplementedAsync("fs.ftruncate");
    Me = notImplementedAsync("fs.futimes");
    Ge = notImplementedAsync("fs.lstatSync");
    ve = notImplementedAsync("fs.read");
    Le = notImplementedAsync("fs.readv");
    Ue = notImplementedAsync("fs.realpathSync");
    He = notImplementedAsync("fs.statSync");
    Te = notImplementedAsync("fs.unwatchFile");
    Je = notImplementedAsync("fs.watch");
    Ye = notImplementedAsync("fs.watchFile");
    Pe = notImplementedAsync("fs.write");
    Oe = notImplementedAsync("fs.writev");
    Ke = notImplementedAsync("fs._toUnixTimestamp");
    qe = notImplementedAsync("fs.openAsBlob");
    _e = notImplemented("fs.appendFileSync");
    We = notImplemented("fs.accessSync");
    je = notImplemented("fs.chownSync");
    Xe = notImplemented("fs.chmodSync");
    Ve = notImplemented("fs.closeSync");
    Ze = notImplemented("fs.copyFileSync");
    ze = notImplemented("fs.cpSync");
    existsSync = () => false;
    $e = notImplemented("fs.fchownSync");
    et = notImplemented("fs.fchmodSync");
    tt = notImplemented("fs.fdatasyncSync");
    At = notImplemented("fs.fstatSync");
    it = notImplemented("fs.fsyncSync");
    at = notImplemented("fs.ftruncateSync");
    st = notImplemented("fs.futimesSync");
    nt = notImplemented("fs.lchownSync");
    rt = notImplemented("fs.lchmodSync");
    ot = notImplemented("fs.linkSync");
    gt = notImplemented("fs.lutimesSync");
    ct = notImplemented("fs.mkdirSync");
    ht = notImplemented("fs.mkdtempSync");
    lt = notImplemented("fs.openSync");
    It = notImplemented("fs.opendirSync");
    Ct = notImplemented("fs.readdirSync");
    dt = notImplemented("fs.readSync");
    Bt = notImplemented("fs.readvSync");
    ut = notImplemented("fs.readFileSync");
    Qt = notImplemented("fs.readlinkSync");
    Et = notImplemented("fs.renameSync");
    ft = notImplemented("fs.rmSync");
    pt = notImplemented("fs.rmdirSync");
    mt = notImplemented("fs.symlinkSync");
    yt = notImplemented("fs.truncateSync");
    wt = notImplemented("fs.unlinkSync");
    bt = notImplemented("fs.utimesSync");
    Dt = notImplemented("fs.writeFileSync");
    St = notImplemented("fs.writeSync");
    Ft = notImplemented("fs.writevSync");
    kt = notImplemented("fs.statfsSync");
    Rt = W;
    xt = { ...c, ...l, ...Object.freeze({ __proto__: null, _toUnixTimestamp: Ke, access: j, accessSync: We, appendFile: X, appendFileSync: _e, chmod: Z, chmodSync: Xe, chown: V, chownSync: je, close: ye, closeSync: Ve, copyFile: z, copyFileSync: Ze, cp: $, cpSync: ze, createReadStream: we, createWriteStream: be, exists: De, existsSync, fchmod: Fe, fchmodSync: et, fchown: Se, fchownSync: $e, fdatasync: ke, fdatasyncSync: tt, fstat: Re, fstatSync: At, fsync: xe, fsyncSync: it, ftruncate: Ne, ftruncateSync: at, futimes: Me, futimesSync: st, lchmod: te, lchmodSync: rt, lchown: ee, lchownSync: nt, link: Ae, linkSync: ot, lstat: ie, lstatSync: Ge, lutimes: ae, lutimesSync: gt, mkdir: se, mkdirSync: ct, mkdtemp: ne, mkdtempSync: ht, open: oe, openAsBlob: qe, openSync: lt, opendir: ge, opendirSync: It, read: ve, readFile: he, readFileSync: ut, readSync: dt, readdir: ce, readdirSync: Ct, readlink: le, readlinkSync: Qt, readv: Le, readvSync: Bt, realpath: re, realpathSync: Ue, rename: Ie, renameSync: Et, rm: Ce, rmSync: ft, rmdir: de, rmdirSync: pt, stat: Be, statSync: He, statfs: me, statfsSync: kt, symlink: ue, symlinkSync: mt, truncate: Qe, truncateSync: yt, unlink: Ee, unlinkSync: wt, unwatchFile: Te, utimes: fe, utimesSync: bt, watch: Je, watchFile: Ye, write: Pe, writeFile: pe, writeFileSync: Dt, writeSync: St, writev: Oe, writevSync: Ft }), promises: Rt };
    Nt = Object.freeze({ __proto__: null, Dir: t, Dirent: i, F_OK: 0, FileReadStream: r, FileWriteStream: o, R_OK: 4, ReadStream: s, Stats: a, StatsFs: g, W_OK: 2, WriteStream: n, X_OK: 1, _toUnixTimestamp: Ke, access: j, accessSync: We, appendFile: X, appendFileSync: _e, chmod: Z, chmodSync: Xe, chown: V, chownSync: je, close: ye, closeSync: Ve, constants: h, copyFile: z, copyFileSync: Ze, cp: $, cpSync: ze, createReadStream: we, createWriteStream: be, default: xt, exists: De, existsSync, fchmod: Fe, fchmodSync: et, fchown: Se, fchownSync: $e, fdatasync: ke, fdatasyncSync: tt, fstat: Re, fstatSync: At, fsync: xe, fsyncSync: it, ftruncate: Ne, ftruncateSync: at, futimes: Me, futimesSync: st, lchmod: te, lchmodSync: rt, lchown: ee, lchownSync: nt, link: Ae, linkSync: ot, lstat: ie, lstatSync: Ge, lutimes: ae, lutimesSync: gt, mkdir: se, mkdirSync: ct, mkdtemp: ne, mkdtempSync: ht, open: oe, openAsBlob: qe, openSync: lt, opendir: ge, opendirSync: It, promises: Rt, read: ve, readFile: he, readFileSync: ut, readSync: dt, readdir: ce, readdirSync: Ct, readlink: le, readlinkSync: Qt, readv: Le, readvSync: Bt, realpath: re, realpathSync: Ue, rename: Ie, renameSync: Et, rm: Ce, rmSync: ft, rmdir: de, rmdirSync: pt, stat: Be, statSync: He, statfs: me, statfsSync: kt, symlink: ue, symlinkSync: mt, truncate: Qe, truncateSync: yt, unlink: Ee, unlinkSync: wt, unwatchFile: Te, utimes: fe, utimesSync: bt, watch: Je, watchFile: Ye, write: Pe, writeFile: pe, writeFileSync: Dt, writeSync: St, writev: Oe, writevSync: Ft });
    Mt = ["ACL", "BIND", "CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LINK", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCALENDAR", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PRI", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REBIND", "REPORT", "SEARCH", "SOURCE", "SUBSCRIBE", "TRACE", "UNBIND", "UNLINK", "UNLOCK", "UNSUBSCRIBE"];
    Gt = { 100: "Continue", 101: "Switching Protocols", 102: "Processing", 103: "Early Hints", 200: "OK", 201: "Created", 202: "Accepted", 203: "Non-Authoritative Information", 204: "No Content", 205: "Reset Content", 206: "Partial Content", 207: "Multi-Status", 208: "Already Reported", 226: "IM Used", 300: "Multiple Choices", 301: "Moved Permanently", 302: "Found", 303: "See Other", 304: "Not Modified", 305: "Use Proxy", 307: "Temporary Redirect", 308: "Permanent Redirect", 400: "Bad Request", 401: "Unauthorized", 402: "Payment Required", 403: "Forbidden", 404: "Not Found", 405: "Method Not Allowed", 406: "Not Acceptable", 407: "Proxy Authentication Required", 408: "Request Timeout", 409: "Conflict", 410: "Gone", 411: "Length Required", 412: "Precondition Failed", 413: "Payload Too Large", 414: "URI Too Long", 415: "Unsupported Media Type", 416: "Range Not Satisfiable", 417: "Expectation Failed", 418: "I'm a Teapot", 421: "Misdirected Request", 422: "Unprocessable Entity", 423: "Locked", 424: "Failed Dependency", 425: "Too Early", 426: "Upgrade Required", 428: "Precondition Required", 429: "Too Many Requests", 431: "Request Header Fields Too Large", 451: "Unavailable For Legal Reasons", 500: "Internal Server Error", 501: "Not Implemented", 502: "Bad Gateway", 503: "Service Unavailable", 504: "Gateway Timeout", 505: "HTTP Version Not Supported", 506: "Variant Also Negotiates", 507: "Insufficient Storage", 508: "Loop Detected", 509: "Bandwidth Limit Exceeded", 510: "Not Extended", 511: "Network Authentication Required" };
    vt = Object.freeze({ __proto__: null, METHODS: Mt, STATUS_CODES: Gt, maxHeaderSize: 16384 });
    Lt = 10;
    Ut = class {
      constructor() {
        __publicField(this, "__unenv__", true);
        __publicField(this, "_events", /* @__PURE__ */ Object.create(null));
        __publicField(this, "_maxListeners");
      }
      static get defaultMaxListeners() {
        return Lt;
      }
      static set defaultMaxListeners(e3) {
        if ("number" != typeof e3 || e3 < 0 || Number.isNaN(e3)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e3 + ".");
        Lt = e3;
      }
      setMaxListeners(e3) {
        if ("number" != typeof e3 || e3 < 0 || Number.isNaN(e3)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e3 + ".");
        return this._maxListeners = e3, this;
      }
      getMaxListeners() {
        return _getMaxListeners(this);
      }
      emit(e3, ...t3) {
        if (!this._events[e3] || 0 === this._events[e3].length) return false;
        if ("error" === e3) {
          let e4;
          if (t3.length > 0 && (e4 = t3[0]), e4 instanceof Error) throw e4;
          const i3 = new Error("Unhandled error." + (e4 ? " (" + e4.message + ")" : ""));
          throw i3.context = e4, i3;
        }
        for (const i3 of this._events[e3]) (i3.listener || i3).apply(this, t3);
        return true;
      }
      addListener(e3, t3) {
        return _addListener(this, e3, t3, false);
      }
      on(e3, t3) {
        return _addListener(this, e3, t3, false);
      }
      prependListener(e3, t3) {
        return _addListener(this, e3, t3, true);
      }
      once(e3, t3) {
        return this.on(e3, _wrapOnce(this, e3, t3));
      }
      prependOnceListener(e3, t3) {
        return this.prependListener(e3, _wrapOnce(this, e3, t3));
      }
      removeListener(e3, t3) {
        return function(e4, t4, i3) {
          if (_checkListener(i3), !e4._events[t4] || 0 === e4._events[t4].length) return e4;
          const a3 = e4._events[t4].length;
          if (e4._events[t4] = e4._events[t4].filter((e5) => e5 !== i3), a3 === e4._events[t4].length) return e4;
          e4._events.removeListener && e4.emit("removeListener", t4, i3.listener || i3);
          0 === e4._events[t4].length && delete e4._events[t4];
          return e4;
        }(this, e3, t3);
      }
      off(e3, t3) {
        return this.removeListener(e3, t3);
      }
      removeAllListeners(e3) {
        return function(e4, t3) {
          if (!e4._events[t3] || 0 === e4._events[t3].length) return e4;
          if (e4._events.removeListener) for (const i3 of e4._events[t3]) e4.emit("removeListener", t3, i3.listener || i3);
          return delete e4._events[t3], e4;
        }(this, e3);
      }
      listeners(e3) {
        return _listeners(this, e3, true);
      }
      rawListeners(e3) {
        return _listeners(this, e3, false);
      }
      listenerCount(e3) {
        return this.rawListeners(e3).length;
      }
      eventNames() {
        return Object.keys(this._events);
      }
    };
    Ht = globalThis.EventEmitter || Ut;
    _Readable = class __Readable extends Ht {
      constructor(e3) {
        super();
        __publicField(this, "__unenv__", true);
        __publicField(this, "readableEncoding", null);
        __publicField(this, "readableEnded", true);
        __publicField(this, "readableFlowing", false);
        __publicField(this, "readableHighWaterMark", 0);
        __publicField(this, "readableLength", 0);
        __publicField(this, "readableObjectMode", false);
        __publicField(this, "readableAborted", false);
        __publicField(this, "readableDidRead", false);
        __publicField(this, "closed", false);
        __publicField(this, "errored", null);
        __publicField(this, "readable", false);
        __publicField(this, "destroyed", false);
      }
      static from(e3, t3) {
        return new __Readable(t3);
      }
      _read(e3) {
      }
      read(e3) {
      }
      setEncoding(e3) {
        return this;
      }
      pause() {
        return this;
      }
      resume() {
        return this;
      }
      isPaused() {
        return true;
      }
      unpipe(e3) {
        return this;
      }
      unshift(e3, t3) {
      }
      wrap(e3) {
        return this;
      }
      push(e3, t3) {
        return false;
      }
      _destroy(e3, t3) {
        this.removeAllListeners();
      }
      destroy(e3) {
        return this.destroyed = true, this._destroy(e3), this;
      }
      pipe(e3, t3) {
        return {};
      }
      compose(e3, t3) {
        throw new Error("[unenv] Method not implemented.");
      }
      [Symbol.asyncDispose]() {
        return this.destroy(), Promise.resolve();
      }
      async *[Symbol.asyncIterator]() {
        throw createNotImplementedError("Readable.asyncIterator");
      }
      iterator(e3) {
        throw createNotImplementedError("Readable.iterator");
      }
      map(e3, t3) {
        throw createNotImplementedError("Readable.map");
      }
      filter(e3, t3) {
        throw createNotImplementedError("Readable.filter");
      }
      forEach(e3, t3) {
        throw createNotImplementedError("Readable.forEach");
      }
      reduce(e3, t3, i3) {
        throw createNotImplementedError("Readable.reduce");
      }
      find(e3, t3) {
        throw createNotImplementedError("Readable.find");
      }
      findIndex(e3, t3) {
        throw createNotImplementedError("Readable.findIndex");
      }
      some(e3, t3) {
        throw createNotImplementedError("Readable.some");
      }
      toArray(e3) {
        throw createNotImplementedError("Readable.toArray");
      }
      every(e3, t3) {
        throw createNotImplementedError("Readable.every");
      }
      flatMap(e3, t3) {
        throw createNotImplementedError("Readable.flatMap");
      }
      drop(e3, t3) {
        throw createNotImplementedError("Readable.drop");
      }
      take(e3, t3) {
        throw createNotImplementedError("Readable.take");
      }
      asIndexedPairs(e3) {
        throw createNotImplementedError("Readable.asIndexedPairs");
      }
    };
    Tt = globalThis.Readable || _Readable;
    Jt = [];
    Yt = [];
    Pt = "undefined" == typeof Uint8Array ? Array : Uint8Array;
    Ot = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (let e3 = 0, t3 = 64; e3 < t3; ++e3) Jt[e3] = Ot[e3], Yt[Ot.charCodeAt(e3)] = e3;
    Yt["-".charCodeAt(0)] = 62, Yt["_".charCodeAt(0)] = 63;
    Kt = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
    qt = 2147483647;
    Buffer$1.TYPED_ARRAY_SUPPORT = function() {
      try {
        const e3 = new Uint8Array(1), t3 = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(t3, Uint8Array.prototype), Object.setPrototypeOf(e3, t3), 42 === e3.foo();
      } catch {
        return false;
      }
    }(), Buffer$1.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This environment lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(Buffer$1.prototype, "parent", { enumerable: true, get: function() {
      if (Buffer$1.isBuffer(this)) return this.buffer;
    } }), Object.defineProperty(Buffer$1.prototype, "offset", { enumerable: true, get: function() {
      if (Buffer$1.isBuffer(this)) return this.byteOffset;
    } }), Buffer$1.poolSize = 8192, Buffer$1.from = function(e3, t3, i3) {
      return from(e3, t3, i3);
    }, Object.setPrototypeOf(Buffer$1.prototype, Uint8Array.prototype), Object.setPrototypeOf(Buffer$1, Uint8Array), Buffer$1.alloc = function(e3, t3, i3) {
      return function(e4, t4, i4) {
        return assertSize(e4), e4 <= 0 ? createBuffer(e4) : void 0 !== t4 ? "string" == typeof i4 ? createBuffer(e4).fill(t4, i4) : createBuffer(e4).fill(t4) : createBuffer(e4);
      }(e3, t3, i3);
    }, Buffer$1.allocUnsafe = function(e3) {
      return allocUnsafe(e3);
    }, Buffer$1.allocUnsafeSlow = function(e3) {
      return allocUnsafe(e3);
    }, Buffer$1.isBuffer = function(e3) {
      return null != e3 && true === e3._isBuffer && e3 !== Buffer$1.prototype;
    }, Buffer$1.compare = function(e3, t3) {
      if (isInstance(e3, Uint8Array) && (e3 = Buffer$1.from(e3, e3.offset, e3.byteLength)), isInstance(t3, Uint8Array) && (t3 = Buffer$1.from(t3, t3.offset, t3.byteLength)), !Buffer$1.isBuffer(e3) || !Buffer$1.isBuffer(t3)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (e3 === t3) return 0;
      let i3 = e3.length, a3 = t3.length;
      for (let s3 = 0, n3 = Math.min(i3, a3); s3 < n3; ++s3) if (e3[s3] !== t3[s3]) {
        i3 = e3[s3], a3 = t3[s3];
        break;
      }
      return i3 < a3 ? -1 : a3 < i3 ? 1 : 0;
    }, Buffer$1.isEncoding = function(e3) {
      switch (String(e3).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, Buffer$1.concat = function(e3, t3) {
      if (!Array.isArray(e3)) throw new TypeError('"list" argument must be an Array of Buffers');
      if (0 === e3.length) return Buffer$1.alloc(0);
      let i3;
      if (void 0 === t3) for (t3 = 0, i3 = 0; i3 < e3.length; ++i3) t3 += e3[i3].length;
      const a3 = Buffer$1.allocUnsafe(t3);
      let s3 = 0;
      for (i3 = 0; i3 < e3.length; ++i3) {
        let t4 = e3[i3];
        if (isInstance(t4, Uint8Array)) s3 + t4.length > a3.length ? (Buffer$1.isBuffer(t4) || (t4 = Buffer$1.from(t4.buffer, t4.byteOffset, t4.byteLength)), t4.copy(a3, s3)) : Uint8Array.prototype.set.call(a3, t4, s3);
        else {
          if (!Buffer$1.isBuffer(t4)) throw new TypeError('"list" argument must be an Array of Buffers');
          t4.copy(a3, s3);
        }
        s3 += t4.length;
      }
      return a3;
    }, Buffer$1.byteLength = byteLength, Buffer$1.prototype._isBuffer = true, Buffer$1.prototype.swap16 = function() {
      const e3 = this.length;
      if (e3 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let t3 = 0; t3 < e3; t3 += 2) swap(this, t3, t3 + 1);
      return this;
    }, Buffer$1.prototype.swap32 = function() {
      const e3 = this.length;
      if (e3 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let t3 = 0; t3 < e3; t3 += 4) swap(this, t3, t3 + 3), swap(this, t3 + 1, t3 + 2);
      return this;
    }, Buffer$1.prototype.swap64 = function() {
      const e3 = this.length;
      if (e3 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let t3 = 0; t3 < e3; t3 += 8) swap(this, t3, t3 + 7), swap(this, t3 + 1, t3 + 6), swap(this, t3 + 2, t3 + 5), swap(this, t3 + 3, t3 + 4);
      return this;
    }, Buffer$1.prototype.toString = function() {
      const e3 = this.length;
      return 0 === e3 ? "" : 0 === arguments.length ? utf8Slice(this, 0, e3) : Reflect.apply(slowToString, this, arguments);
    }, Buffer$1.prototype.toLocaleString = Buffer$1.prototype.toString, Buffer$1.prototype.equals = function(e3) {
      if (!Buffer$1.isBuffer(e3)) throw new TypeError("Argument must be a Buffer");
      return this === e3 || 0 === Buffer$1.compare(this, e3);
    }, Buffer$1.prototype.inspect = function() {
      let e3 = "";
      return e3 = this.toString("hex", 0, 50).replace(/(.{2})/g, "$1 ").trim(), this.length > 50 && (e3 += " ... "), "<Buffer " + e3 + ">";
    }, Kt && (Buffer$1.prototype[Kt] = Buffer$1.prototype.inspect), Buffer$1.prototype.compare = function(e3, t3, i3, a3, s3) {
      if (isInstance(e3, Uint8Array) && (e3 = Buffer$1.from(e3, e3.offset, e3.byteLength)), !Buffer$1.isBuffer(e3)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e3);
      if (void 0 === t3 && (t3 = 0), void 0 === i3 && (i3 = e3 ? e3.length : 0), void 0 === a3 && (a3 = 0), void 0 === s3 && (s3 = this.length), t3 < 0 || i3 > e3.length || a3 < 0 || s3 > this.length) throw new RangeError("out of range index");
      if (a3 >= s3 && t3 >= i3) return 0;
      if (a3 >= s3) return -1;
      if (t3 >= i3) return 1;
      if (this === e3) return 0;
      let n3 = (s3 >>>= 0) - (a3 >>>= 0), r3 = (i3 >>>= 0) - (t3 >>>= 0);
      const o3 = Math.min(n3, r3), g3 = this.slice(a3, s3), c3 = e3.slice(t3, i3);
      for (let e4 = 0; e4 < o3; ++e4) if (g3[e4] !== c3[e4]) {
        n3 = g3[e4], r3 = c3[e4];
        break;
      }
      return n3 < r3 ? -1 : r3 < n3 ? 1 : 0;
    }, Buffer$1.prototype.includes = function(e3, t3, i3) {
      return -1 !== this.indexOf(e3, t3, i3);
    }, Buffer$1.prototype.indexOf = function(e3, t3, i3) {
      return bidirectionalIndexOf(this, e3, t3, i3, true);
    }, Buffer$1.prototype.lastIndexOf = function(e3, t3, i3) {
      return bidirectionalIndexOf(this, e3, t3, i3, false);
    }, Buffer$1.prototype.write = function(e3, t3, i3, a3) {
      if (void 0 === t3) a3 = "utf8", i3 = this.length, t3 = 0;
      else if (void 0 === i3 && "string" == typeof t3) a3 = t3, i3 = this.length, t3 = 0;
      else {
        if (!Number.isFinite(t3)) throw new TypeError("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        t3 >>>= 0, Number.isFinite(i3) ? (i3 >>>= 0, void 0 === a3 && (a3 = "utf8")) : (a3 = i3, i3 = void 0);
      }
      const s3 = this.length - t3;
      if ((void 0 === i3 || i3 > s3) && (i3 = s3), e3.length > 0 && (i3 < 0 || t3 < 0) || t3 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
      a3 || (a3 = "utf8");
      let n3 = false;
      for (; ; ) switch (a3) {
        case "hex":
          return hexWrite(this, e3, t3, i3);
        case "utf8":
        case "utf-8":
          return utf8Write(this, e3, t3, i3);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, e3, t3, i3);
        case "base64":
          return base64Write(this, e3, t3, i3);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, e3, t3, i3);
        default:
          if (n3) throw new TypeError("Unknown encoding: " + a3);
          a3 = ("" + a3).toLowerCase(), n3 = true;
      }
    }, Buffer$1.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    _t = 4096;
    Buffer$1.prototype.slice = function(e3, t3) {
      const i3 = this.length;
      (e3 = Math.trunc(e3)) < 0 ? (e3 += i3) < 0 && (e3 = 0) : e3 > i3 && (e3 = i3), (t3 = void 0 === t3 ? i3 : Math.trunc(t3)) < 0 ? (t3 += i3) < 0 && (t3 = 0) : t3 > i3 && (t3 = i3), t3 < e3 && (t3 = e3);
      const a3 = this.subarray(e3, t3);
      return Object.setPrototypeOf(a3, Buffer$1.prototype), a3;
    }, Buffer$1.prototype.readUintLE = Buffer$1.prototype.readUIntLE = function(e3, t3, i3) {
      e3 >>>= 0, t3 >>>= 0, i3 || checkOffset(e3, t3, this.length);
      let a3 = this[e3], s3 = 1, n3 = 0;
      for (; ++n3 < t3 && (s3 *= 256); ) a3 += this[e3 + n3] * s3;
      return a3;
    }, Buffer$1.prototype.readUintBE = Buffer$1.prototype.readUIntBE = function(e3, t3, i3) {
      e3 >>>= 0, t3 >>>= 0, i3 || checkOffset(e3, t3, this.length);
      let a3 = this[e3 + --t3], s3 = 1;
      for (; t3 > 0 && (s3 *= 256); ) a3 += this[e3 + --t3] * s3;
      return a3;
    }, Buffer$1.prototype.readUint8 = Buffer$1.prototype.readUInt8 = function(e3, t3) {
      return e3 >>>= 0, t3 || checkOffset(e3, 1, this.length), this[e3];
    }, Buffer$1.prototype.readUint16LE = Buffer$1.prototype.readUInt16LE = function(e3, t3) {
      return e3 >>>= 0, t3 || checkOffset(e3, 2, this.length), this[e3] | this[e3 + 1] << 8;
    }, Buffer$1.prototype.readUint16BE = Buffer$1.prototype.readUInt16BE = function(e3, t3) {
      return e3 >>>= 0, t3 || checkOffset(e3, 2, this.length), this[e3] << 8 | this[e3 + 1];
    }, Buffer$1.prototype.readUint32LE = Buffer$1.prototype.readUInt32LE = function(e3, t3) {
      return e3 >>>= 0, t3 || checkOffset(e3, 4, this.length), (this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16) + 16777216 * this[e3 + 3];
    }, Buffer$1.prototype.readUint32BE = Buffer$1.prototype.readUInt32BE = function(e3, t3) {
      return e3 >>>= 0, t3 || checkOffset(e3, 4, this.length), 16777216 * this[e3] + (this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3]);
    }, Buffer$1.prototype.readBigUInt64LE = defineBigIntMethod(function(e3) {
      validateNumber(e3 >>>= 0, "offset");
      const t3 = this[e3], i3 = this[e3 + 7];
      void 0 !== t3 && void 0 !== i3 || boundsError(e3, this.length - 8);
      const a3 = t3 + 256 * this[++e3] + 65536 * this[++e3] + this[++e3] * 2 ** 24, s3 = this[++e3] + 256 * this[++e3] + 65536 * this[++e3] + i3 * 2 ** 24;
      return BigInt(a3) + (BigInt(s3) << BigInt(32));
    }), Buffer$1.prototype.readBigUInt64BE = defineBigIntMethod(function(e3) {
      validateNumber(e3 >>>= 0, "offset");
      const t3 = this[e3], i3 = this[e3 + 7];
      void 0 !== t3 && void 0 !== i3 || boundsError(e3, this.length - 8);
      const a3 = t3 * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + this[++e3], s3 = this[++e3] * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + i3;
      return (BigInt(a3) << BigInt(32)) + BigInt(s3);
    }), Buffer$1.prototype.readIntLE = function(e3, t3, i3) {
      e3 >>>= 0, t3 >>>= 0, i3 || checkOffset(e3, t3, this.length);
      let a3 = this[e3], s3 = 1, n3 = 0;
      for (; ++n3 < t3 && (s3 *= 256); ) a3 += this[e3 + n3] * s3;
      return s3 *= 128, a3 >= s3 && (a3 -= Math.pow(2, 8 * t3)), a3;
    }, Buffer$1.prototype.readIntBE = function(e3, t3, i3) {
      e3 >>>= 0, t3 >>>= 0, i3 || checkOffset(e3, t3, this.length);
      let a3 = t3, s3 = 1, n3 = this[e3 + --a3];
      for (; a3 > 0 && (s3 *= 256); ) n3 += this[e3 + --a3] * s3;
      return s3 *= 128, n3 >= s3 && (n3 -= Math.pow(2, 8 * t3)), n3;
    }, Buffer$1.prototype.readInt8 = function(e3, t3) {
      return e3 >>>= 0, t3 || checkOffset(e3, 1, this.length), 128 & this[e3] ? -1 * (255 - this[e3] + 1) : this[e3];
    }, Buffer$1.prototype.readInt16LE = function(e3, t3) {
      e3 >>>= 0, t3 || checkOffset(e3, 2, this.length);
      const i3 = this[e3] | this[e3 + 1] << 8;
      return 32768 & i3 ? 4294901760 | i3 : i3;
    }, Buffer$1.prototype.readInt16BE = function(e3, t3) {
      e3 >>>= 0, t3 || checkOffset(e3, 2, this.length);
      const i3 = this[e3 + 1] | this[e3] << 8;
      return 32768 & i3 ? 4294901760 | i3 : i3;
    }, Buffer$1.prototype.readInt32LE = function(e3, t3) {
      return e3 >>>= 0, t3 || checkOffset(e3, 4, this.length), this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16 | this[e3 + 3] << 24;
    }, Buffer$1.prototype.readInt32BE = function(e3, t3) {
      return e3 >>>= 0, t3 || checkOffset(e3, 4, this.length), this[e3] << 24 | this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3];
    }, Buffer$1.prototype.readBigInt64LE = defineBigIntMethod(function(e3) {
      validateNumber(e3 >>>= 0, "offset");
      const t3 = this[e3], i3 = this[e3 + 7];
      void 0 !== t3 && void 0 !== i3 || boundsError(e3, this.length - 8);
      const a3 = this[e3 + 4] + 256 * this[e3 + 5] + 65536 * this[e3 + 6] + (i3 << 24);
      return (BigInt(a3) << BigInt(32)) + BigInt(t3 + 256 * this[++e3] + 65536 * this[++e3] + this[++e3] * 2 ** 24);
    }), Buffer$1.prototype.readBigInt64BE = defineBigIntMethod(function(e3) {
      validateNumber(e3 >>>= 0, "offset");
      const t3 = this[e3], i3 = this[e3 + 7];
      void 0 !== t3 && void 0 !== i3 || boundsError(e3, this.length - 8);
      const a3 = (t3 << 24) + 65536 * this[++e3] + 256 * this[++e3] + this[++e3];
      return (BigInt(a3) << BigInt(32)) + BigInt(this[++e3] * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + i3);
    }), Buffer$1.prototype.readFloatLE = function(e3, t3) {
      return e3 >>>= 0, t3 || checkOffset(e3, 4, this.length), read(this, e3, true, 23, 4);
    }, Buffer$1.prototype.readFloatBE = function(e3, t3) {
      return e3 >>>= 0, t3 || checkOffset(e3, 4, this.length), read(this, e3, false, 23, 4);
    }, Buffer$1.prototype.readDoubleLE = function(e3, t3) {
      return e3 >>>= 0, t3 || checkOffset(e3, 8, this.length), read(this, e3, true, 52, 8);
    }, Buffer$1.prototype.readDoubleBE = function(e3, t3) {
      return e3 >>>= 0, t3 || checkOffset(e3, 8, this.length), read(this, e3, false, 52, 8);
    }, Buffer$1.prototype.writeUintLE = Buffer$1.prototype.writeUIntLE = function(e3, t3, i3, a3) {
      if (e3 = +e3, t3 >>>= 0, i3 >>>= 0, !a3) {
        checkInt(this, e3, t3, i3, Math.pow(2, 8 * i3) - 1, 0);
      }
      let s3 = 1, n3 = 0;
      for (this[t3] = 255 & e3; ++n3 < i3 && (s3 *= 256); ) this[t3 + n3] = e3 / s3 & 255;
      return t3 + i3;
    }, Buffer$1.prototype.writeUintBE = Buffer$1.prototype.writeUIntBE = function(e3, t3, i3, a3) {
      if (e3 = +e3, t3 >>>= 0, i3 >>>= 0, !a3) {
        checkInt(this, e3, t3, i3, Math.pow(2, 8 * i3) - 1, 0);
      }
      let s3 = i3 - 1, n3 = 1;
      for (this[t3 + s3] = 255 & e3; --s3 >= 0 && (n3 *= 256); ) this[t3 + s3] = e3 / n3 & 255;
      return t3 + i3;
    }, Buffer$1.prototype.writeUint8 = Buffer$1.prototype.writeUInt8 = function(e3, t3, i3) {
      return e3 = +e3, t3 >>>= 0, i3 || checkInt(this, e3, t3, 1, 255, 0), this[t3] = 255 & e3, t3 + 1;
    }, Buffer$1.prototype.writeUint16LE = Buffer$1.prototype.writeUInt16LE = function(e3, t3, i3) {
      return e3 = +e3, t3 >>>= 0, i3 || checkInt(this, e3, t3, 2, 65535, 0), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, t3 + 2;
    }, Buffer$1.prototype.writeUint16BE = Buffer$1.prototype.writeUInt16BE = function(e3, t3, i3) {
      return e3 = +e3, t3 >>>= 0, i3 || checkInt(this, e3, t3, 2, 65535, 0), this[t3] = e3 >>> 8, this[t3 + 1] = 255 & e3, t3 + 2;
    }, Buffer$1.prototype.writeUint32LE = Buffer$1.prototype.writeUInt32LE = function(e3, t3, i3) {
      return e3 = +e3, t3 >>>= 0, i3 || checkInt(this, e3, t3, 4, 4294967295, 0), this[t3 + 3] = e3 >>> 24, this[t3 + 2] = e3 >>> 16, this[t3 + 1] = e3 >>> 8, this[t3] = 255 & e3, t3 + 4;
    }, Buffer$1.prototype.writeUint32BE = Buffer$1.prototype.writeUInt32BE = function(e3, t3, i3) {
      return e3 = +e3, t3 >>>= 0, i3 || checkInt(this, e3, t3, 4, 4294967295, 0), this[t3] = e3 >>> 24, this[t3 + 1] = e3 >>> 16, this[t3 + 2] = e3 >>> 8, this[t3 + 3] = 255 & e3, t3 + 4;
    }, Buffer$1.prototype.writeBigUInt64LE = defineBigIntMethod(function(e3, t3 = 0) {
      return wrtBigUInt64LE(this, e3, t3, BigInt(0), BigInt("0xffffffffffffffff"));
    }), Buffer$1.prototype.writeBigUInt64BE = defineBigIntMethod(function(e3, t3 = 0) {
      return wrtBigUInt64BE(this, e3, t3, BigInt(0), BigInt("0xffffffffffffffff"));
    }), Buffer$1.prototype.writeIntLE = function(e3, t3, i3, a3) {
      if (e3 = +e3, t3 >>>= 0, !a3) {
        const a4 = Math.pow(2, 8 * i3 - 1);
        checkInt(this, e3, t3, i3, a4 - 1, -a4);
      }
      let s3 = 0, n3 = 1, r3 = 0;
      for (this[t3] = 255 & e3; ++s3 < i3 && (n3 *= 256); ) e3 < 0 && 0 === r3 && 0 !== this[t3 + s3 - 1] && (r3 = 1), this[t3 + s3] = Math.trunc(e3 / n3) - r3 & 255;
      return t3 + i3;
    }, Buffer$1.prototype.writeIntBE = function(e3, t3, i3, a3) {
      if (e3 = +e3, t3 >>>= 0, !a3) {
        const a4 = Math.pow(2, 8 * i3 - 1);
        checkInt(this, e3, t3, i3, a4 - 1, -a4);
      }
      let s3 = i3 - 1, n3 = 1, r3 = 0;
      for (this[t3 + s3] = 255 & e3; --s3 >= 0 && (n3 *= 256); ) e3 < 0 && 0 === r3 && 0 !== this[t3 + s3 + 1] && (r3 = 1), this[t3 + s3] = Math.trunc(e3 / n3) - r3 & 255;
      return t3 + i3;
    }, Buffer$1.prototype.writeInt8 = function(e3, t3, i3) {
      return e3 = +e3, t3 >>>= 0, i3 || checkInt(this, e3, t3, 1, 127, -128), e3 < 0 && (e3 = 255 + e3 + 1), this[t3] = 255 & e3, t3 + 1;
    }, Buffer$1.prototype.writeInt16LE = function(e3, t3, i3) {
      return e3 = +e3, t3 >>>= 0, i3 || checkInt(this, e3, t3, 2, 32767, -32768), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, t3 + 2;
    }, Buffer$1.prototype.writeInt16BE = function(e3, t3, i3) {
      return e3 = +e3, t3 >>>= 0, i3 || checkInt(this, e3, t3, 2, 32767, -32768), this[t3] = e3 >>> 8, this[t3 + 1] = 255 & e3, t3 + 2;
    }, Buffer$1.prototype.writeInt32LE = function(e3, t3, i3) {
      return e3 = +e3, t3 >>>= 0, i3 || checkInt(this, e3, t3, 4, 2147483647, -2147483648), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, this[t3 + 2] = e3 >>> 16, this[t3 + 3] = e3 >>> 24, t3 + 4;
    }, Buffer$1.prototype.writeInt32BE = function(e3, t3, i3) {
      return e3 = +e3, t3 >>>= 0, i3 || checkInt(this, e3, t3, 4, 2147483647, -2147483648), e3 < 0 && (e3 = 4294967295 + e3 + 1), this[t3] = e3 >>> 24, this[t3 + 1] = e3 >>> 16, this[t3 + 2] = e3 >>> 8, this[t3 + 3] = 255 & e3, t3 + 4;
    }, Buffer$1.prototype.writeBigInt64LE = defineBigIntMethod(function(e3, t3 = 0) {
      return wrtBigUInt64LE(this, e3, t3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), Buffer$1.prototype.writeBigInt64BE = defineBigIntMethod(function(e3, t3 = 0) {
      return wrtBigUInt64BE(this, e3, t3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), Buffer$1.prototype.writeFloatLE = function(e3, t3, i3) {
      return writeFloat(this, e3, t3, true, i3);
    }, Buffer$1.prototype.writeFloatBE = function(e3, t3, i3) {
      return writeFloat(this, e3, t3, false, i3);
    }, Buffer$1.prototype.writeDoubleLE = function(e3, t3, i3) {
      return writeDouble(this, e3, t3, true, i3);
    }, Buffer$1.prototype.writeDoubleBE = function(e3, t3, i3) {
      return writeDouble(this, e3, t3, false, i3);
    }, Buffer$1.prototype.copy = function(e3, t3, i3, a3) {
      if (!Buffer$1.isBuffer(e3)) throw new TypeError("argument should be a Buffer");
      if (i3 || (i3 = 0), a3 || 0 === a3 || (a3 = this.length), t3 >= e3.length && (t3 = e3.length), t3 || (t3 = 0), a3 > 0 && a3 < i3 && (a3 = i3), a3 === i3) return 0;
      if (0 === e3.length || 0 === this.length) return 0;
      if (t3 < 0) throw new RangeError("targetStart out of bounds");
      if (i3 < 0 || i3 >= this.length) throw new RangeError("Index out of range");
      if (a3 < 0) throw new RangeError("sourceEnd out of bounds");
      a3 > this.length && (a3 = this.length), e3.length - t3 < a3 - i3 && (a3 = e3.length - t3 + i3);
      const s3 = a3 - i3;
      return this === e3 && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(t3, i3, a3) : Uint8Array.prototype.set.call(e3, this.subarray(i3, a3), t3), s3;
    }, Buffer$1.prototype.fill = function(e3, t3, i3, a3) {
      if ("string" == typeof e3) {
        if ("string" == typeof t3 ? (a3 = t3, t3 = 0, i3 = this.length) : "string" == typeof i3 && (a3 = i3, i3 = this.length), void 0 !== a3 && "string" != typeof a3) throw new TypeError("encoding must be a string");
        if ("string" == typeof a3 && !Buffer$1.isEncoding(a3)) throw new TypeError("Unknown encoding: " + a3);
        if (1 === e3.length) {
          const t4 = e3.charCodeAt(0);
          ("utf8" === a3 && t4 < 128 || "latin1" === a3) && (e3 = t4);
        }
      } else "number" == typeof e3 ? e3 &= 255 : "boolean" == typeof e3 && (e3 = Number(e3));
      if (t3 < 0 || this.length < t3 || this.length < i3) throw new RangeError("Out of range index");
      if (i3 <= t3) return this;
      let s3;
      if (t3 >>>= 0, i3 = void 0 === i3 ? this.length : i3 >>> 0, e3 || (e3 = 0), "number" == typeof e3) for (s3 = t3; s3 < i3; ++s3) this[s3] = e3;
      else {
        const n3 = Buffer$1.isBuffer(e3) ? e3 : Buffer$1.from(e3, a3), r3 = n3.length;
        if (0 === r3) throw new TypeError('The value "' + e3 + '" is invalid for argument "value"');
        for (s3 = 0; s3 < i3 - t3; ++s3) this[s3 + t3] = n3[s3 % r3];
      }
      return this;
    };
    Wt = {};
    E("ERR_BUFFER_OUT_OF_BOUNDS", function(e3) {
      return e3 ? `${e3} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError), E("ERR_INVALID_ARG_TYPE", function(e3, t3) {
      return `The "${e3}" argument must be of type number. Received type ${typeof t3}`;
    }, TypeError), E("ERR_OUT_OF_RANGE", function(e3, t3, i3) {
      let a3 = `The value of "${e3}" is out of range.`, s3 = i3;
      return Number.isInteger(i3) && Math.abs(i3) > 2 ** 32 ? s3 = addNumericalSeparator(String(i3)) : "bigint" == typeof i3 && (s3 = String(i3), (i3 > BigInt(2) ** BigInt(32) || i3 < -(BigInt(2) ** BigInt(32))) && (s3 = addNumericalSeparator(s3)), s3 += "n"), a3 += ` It must be ${t3}. Received ${s3}`, a3;
    }, RangeError);
    jt = /[^\w+/-]/g;
    Xt = function() {
      const e3 = "0123456789abcdef", t3 = Array.from({ length: 256 });
      for (let i3 = 0; i3 < 16; ++i3) {
        const a3 = 16 * i3;
        for (let s3 = 0; s3 < 16; ++s3) t3[a3 + s3] = e3[i3] + e3[s3];
      }
      return t3;
    }();
    Vt = globalThis.Buffer || Buffer$1;
    notImplemented("buffer.resolveObjectURL"), notImplemented("buffer.transcode"), notImplemented("buffer.isUtf8"), notImplemented("buffer.isAscii");
    Zt = globalThis.Writable || class extends Ht {
      constructor(e3) {
        super();
        __publicField(this, "__unenv__", true);
        __publicField(this, "writable", true);
        __publicField(this, "writableEnded", false);
        __publicField(this, "writableFinished", false);
        __publicField(this, "writableHighWaterMark", 0);
        __publicField(this, "writableLength", 0);
        __publicField(this, "writableObjectMode", false);
        __publicField(this, "writableCorked", 0);
        __publicField(this, "closed", false);
        __publicField(this, "errored", null);
        __publicField(this, "writableNeedDrain", false);
        __publicField(this, "destroyed", false);
        __publicField(this, "_data");
        __publicField(this, "_encoding", "utf-8");
      }
      pipe(e3, t3) {
        return {};
      }
      _write(e3, t3, i3) {
        if (this.writableEnded) i3 && i3();
        else {
          if (void 0 === this._data) this._data = e3;
          else {
            const i4 = "string" == typeof this._data ? Vt.from(this._data, this._encoding || t3 || "utf8") : this._data, a3 = "string" == typeof e3 ? Vt.from(e3, t3 || this._encoding || "utf8") : e3;
            this._data = Vt.concat([i4, a3]);
          }
          this._encoding = t3, i3 && i3();
        }
      }
      _writev(e3, t3) {
      }
      _destroy(e3, t3) {
      }
      _final(e3) {
      }
      write(e3, t3, i3) {
        const a3 = "string" == typeof t3 ? this._encoding : "utf-8", s3 = "function" == typeof t3 ? t3 : "function" == typeof i3 ? i3 : void 0;
        return this._write(e3, a3, s3), true;
      }
      setDefaultEncoding(e3) {
        return this;
      }
      end(e3, t3, i3) {
        const a3 = "function" == typeof e3 ? e3 : "function" == typeof t3 ? t3 : "function" == typeof i3 ? i3 : void 0;
        if (this.writableEnded) return a3 && a3(), this;
        const s3 = e3 === a3 ? void 0 : e3;
        if (s3) {
          const e4 = t3 === a3 ? void 0 : t3;
          this.write(s3, e4, a3);
        }
        return this.writableEnded = true, this.writableFinished = true, this.emit("close"), this.emit("finish"), this;
      }
      cork() {
      }
      uncork() {
      }
      destroy(e3) {
        return this.destroyed = true, delete this._data, this.removeAllListeners(), this;
      }
      compose(e3, t3) {
        throw new Error("[h3] Method not implemented.");
      }
    };
    zt = class {
      constructor(e3 = new Tt(), t3 = new Zt()) {
        __publicField(this, "allowHalfOpen", true);
        __publicField(this, "_destroy");
        Object.assign(this, e3), Object.assign(this, t3), this._destroy = /* @__PURE__ */ function(...e4) {
          return function(...t4) {
            for (const i3 of e4) i3(...t4);
          };
        }(e3._destroy, t3._destroy);
      }
    };
    $t = getDuplex();
    eA = globalThis.Duplex || $t;
    Socket = class extends eA {
      constructor(e3) {
        super();
        __publicField(this, "__unenv__", true);
        __publicField(this, "bufferSize", 0);
        __publicField(this, "bytesRead", 0);
        __publicField(this, "bytesWritten", 0);
        __publicField(this, "connecting", false);
        __publicField(this, "destroyed", false);
        __publicField(this, "pending", false);
        __publicField(this, "localAddress", "");
        __publicField(this, "localPort", 0);
        __publicField(this, "remoteAddress", "");
        __publicField(this, "remoteFamily", "");
        __publicField(this, "remotePort", 0);
        __publicField(this, "autoSelectFamilyAttemptedAddresses", []);
        __publicField(this, "readyState", "readOnly");
      }
      write(e3, t3, i3) {
        return false;
      }
      connect(e3, t3, i3) {
        return this;
      }
      end(e3, t3, i3) {
        return this;
      }
      setEncoding(e3) {
        return this;
      }
      pause() {
        return this;
      }
      resume() {
        return this;
      }
      setTimeout(e3, t3) {
        return this;
      }
      setNoDelay(e3) {
        return this;
      }
      setKeepAlive(e3, t3) {
        return this;
      }
      address() {
        return {};
      }
      unref() {
        return this;
      }
      ref() {
        return this;
      }
      destroySoon() {
        this.destroy();
      }
      resetAndDestroy() {
        const e3 = new Error("ERR_SOCKET_CLOSED");
        return e3.code = "ERR_SOCKET_CLOSED", this.destroy(e3), this;
      }
    };
    IncomingMessage = class extends Tt {
      constructor(e3) {
        super();
        __publicField(this, "__unenv__", {});
        __publicField(this, "aborted", false);
        __publicField(this, "httpVersion", "1.1");
        __publicField(this, "httpVersionMajor", 1);
        __publicField(this, "httpVersionMinor", 1);
        __publicField(this, "complete", true);
        __publicField(this, "connection");
        __publicField(this, "socket");
        __publicField(this, "headers", {});
        __publicField(this, "trailers", {});
        __publicField(this, "method", "GET");
        __publicField(this, "url", "/");
        __publicField(this, "statusCode", 200);
        __publicField(this, "statusMessage", "");
        __publicField(this, "closed", false);
        __publicField(this, "errored", null);
        __publicField(this, "readable", false);
        this.socket = this.connection = e3 || new Socket();
      }
      get rawHeaders() {
        return function(e3) {
          const t3 = [];
          for (const i3 in e3) if (Array.isArray(e3[i3])) for (const a3 of e3[i3]) t3.push(i3, a3);
          else t3.push(i3, e3[i3]);
          return t3;
        }(this.headers);
      }
      get rawTrailers() {
        return [];
      }
      setTimeout(e3, t3) {
        return this;
      }
      get headersDistinct() {
        return _distinct(this.headers);
      }
      get trailersDistinct() {
        return _distinct(this.trailers);
      }
    };
    ServerResponse = class extends Zt {
      constructor(e3) {
        super();
        __publicField(this, "__unenv__", true);
        __publicField(this, "statusCode", 200);
        __publicField(this, "statusMessage", "");
        __publicField(this, "upgrading", false);
        __publicField(this, "chunkedEncoding", false);
        __publicField(this, "shouldKeepAlive", false);
        __publicField(this, "useChunkedEncodingByDefault", false);
        __publicField(this, "sendDate", false);
        __publicField(this, "finished", false);
        __publicField(this, "headersSent", false);
        __publicField(this, "strictContentLength", false);
        __publicField(this, "connection", null);
        __publicField(this, "socket", null);
        __publicField(this, "req");
        __publicField(this, "_headers", {});
        this.req = e3;
      }
      assignSocket(e3) {
        e3._httpMessage = this, this.socket = e3, this.connection = e3, this.emit("socket", e3), this._flush();
      }
      _flush() {
        this.flushHeaders();
      }
      detachSocket(e3) {
      }
      writeContinue(e3) {
      }
      writeHead(e3, t3, i3) {
        e3 && (this.statusCode = e3), "string" == typeof t3 && (this.statusMessage = t3, t3 = void 0);
        const a3 = i3 || t3;
        if (a3) if (Array.isArray(a3)) ;
        else for (const e4 in a3) this.setHeader(e4, a3[e4]);
        return this.headersSent = true, this;
      }
      writeProcessing() {
      }
      setTimeout(e3, t3) {
        return this;
      }
      appendHeader(e3, t3) {
        e3 = e3.toLowerCase();
        const i3 = this._headers[e3], a3 = [...Array.isArray(i3) ? i3 : [i3], ...Array.isArray(t3) ? t3 : [t3]].filter(Boolean);
        return this._headers[e3] = a3.length > 1 ? a3 : a3[0], this;
      }
      setHeader(e3, t3) {
        return this._headers[e3.toLowerCase()] = t3, this;
      }
      getHeader(e3) {
        return this._headers[e3.toLowerCase()];
      }
      getHeaders() {
        return this._headers;
      }
      getHeaderNames() {
        return Object.keys(this._headers);
      }
      hasHeader(e3) {
        return e3.toLowerCase() in this._headers;
      }
      removeHeader(e3) {
        delete this._headers[e3.toLowerCase()];
      }
      addTrailers(e3) {
      }
      flushHeaders() {
      }
      writeEarlyHints(e3, t3) {
        "function" == typeof t3 && t3();
      }
    };
    tA = notImplemented("http.createServer");
    AA = notImplemented("http.request");
    iA = notImplemented("http.get");
    aA = e.__createMock__("http.Server");
    sA = e.__createMock__("http.OutgoingMessage");
    nA = e.__createMock__("http.ClientRequest");
    rA = e.__createMock__("http.Agent");
    oA = new rA();
    gA = notImplemented("http.validateHeaderName");
    cA = notImplemented("http.validateHeaderValue");
    hA = notImplemented("http.setMaxIdleHTTPParsers");
    lA = { ...vt, IncomingMessage, ServerResponse, createServer: tA, request: AA, get: iA, Server: aA, OutgoingMessage: sA, ClientRequest: nA, Agent: rA, globalAgent: oA, validateHeaderName: gA, validateHeaderValue: cA, setMaxIdleHTTPParsers: hA };
    IA = Object.freeze({ __proto__: null, Agent: rA, ClientRequest: nA, IncomingMessage, METHODS: Mt, OutgoingMessage: sA, STATUS_CODES: Gt, Server: aA, ServerResponse, createServer: tA, default: lA, get: iA, globalAgent: oA, maxHeaderSize: 16384, request: AA, setMaxIdleHTTPParsers: hA, validateHeaderName: gA, validateHeaderValue: cA });
    dA = { exports: {} };
    BA = dA.exports;
    uA = requireProxy();
    QA = _mergeNamespaces({ __proto__: null, default: getDefaultExportFromCjs(uA) }, [uA]);
    EA = globalThis.URL;
    fA = globalThis.URLSearchParams;
    parse = function(e3, t3, i3) {
      const a3 = new EA(e3);
      if (!t3 && !i3) return a3;
      throw new Error("parseQueryString and slashesDenoteHost are unsupported");
    };
    resolve = function(e3, t3) {
      const i3 = new EA(t3, new EA(e3, "resolve://"));
      if ("resolve:" === i3.protocol) {
        const { pathname: e4, search: t4, hash: a3 } = i3;
        return e4 + t4 + a3;
      }
      return i3.toString();
    };
    urlToHttpOptions = function(e3) {
      return { protocol: e3.protocol, hostname: e3.hostname, hash: e3.hash, search: e3.search, pathname: e3.pathname, path: e3.pathname + e3.search || "", href: e3.href, port: e3.port, auth: e3.username && e3.username + e3.password ? ":" + e3.password : "" };
    };
    format = function(e3, t3) {
      let i3;
      if ("string" == typeof e3) i3 = new EA(e3);
      else {
        if (!(e3 instanceof EA)) throw new TypeError("format urlObject is not supported");
        i3 = e3;
      }
      return t3 && (false === t3.auth && (i3.username = "", i3.password = ""), false === t3.fragment && (i3.hash = ""), false === t3.search && (i3.search = "")), i3.toString();
    };
    domainToASCII = function(e3) {
      return e3;
    };
    domainToUnicode = function(e3) {
      return e3;
    };
    pathToFileURL = function(e3) {
      return new EA(e3);
    };
    fileURLToPath = function(e3) {
      return "string" == typeof e3 && (e3 = new EA(e3)), e3.pathname;
    };
    pA = { URL: EA, URLSearchParams: fA, domainToASCII, domainToUnicode, fileURLToPath, format, parse, pathToFileURL, resolve, urlToHttpOptions };
    mA = Object.freeze({ __proto__: null, URL: EA, URLSearchParams: fA, default: pA, domainToASCII, domainToUnicode, fileURLToPath, format, parse, pathToFileURL, resolve, urlToHttpOptions });
    yA = { d: (e3, t3) => {
      for (var i3 in t3) yA.o(t3, i3) && !yA.o(e3, i3) && Object.defineProperty(e3, i3, { enumerable: true, get: t3[i3] });
    }, o: (e3, t3) => Object.prototype.hasOwnProperty.call(e3, t3) };
    wA = globalThis.pdfjsWorker = {};
    yA.d(wA, { WorkerMessageHandler: () => WorkerMessageHandler });
    bA = "undefined" == typeof document;
    DA = [1, 0, 0, 1, 0, 0];
    SA = [1e-3, 0, 0, 1e-3, 0, 0];
    FA = 1.35;
    kA = 0.35;
    RA = 0.25925925925925924;
    xA = 1;
    NA = 2;
    MA = 4;
    GA = 8;
    vA = 16;
    LA = 64;
    UA = 128;
    HA = 256;
    TA = "pdfjs_internal_editor_";
    JA = 3;
    YA = 9;
    PA = 13;
    OA = 15;
    KA = { PRINT: 4, MODIFY_CONTENTS: 8, COPY: 16, MODIFY_ANNOTATIONS: 32, FILL_INTERACTIVE_FORMS: 256, COPY_FOR_ACCESSIBILITY: 512, ASSEMBLE: 1024, PRINT_HIGH_QUALITY: 2048 };
    qA = 0;
    _A = 4;
    WA = 1;
    jA = 2;
    XA = 3;
    VA = 1;
    ZA = 2;
    zA = 3;
    $A = 4;
    ei = 5;
    ti = 6;
    Ai = 7;
    ii = 8;
    ai = 9;
    si = 10;
    ni = 11;
    ri = 12;
    oi = 13;
    gi = 14;
    ci = 15;
    hi = 16;
    li = 17;
    Ii = 20;
    Ci = "Group";
    di = "R";
    Bi = 1;
    ui = 2;
    Qi = 4;
    Ei = 16;
    fi = 32;
    pi = 128;
    mi = 512;
    yi = 1;
    wi = 2;
    bi = 4096;
    Di = 8192;
    Si = 32768;
    Fi = 65536;
    ki = 131072;
    Ri = 1048576;
    xi = 2097152;
    Ni = 8388608;
    Mi = 16777216;
    Gi = 1;
    vi = 2;
    Hi = 3;
    Ti = 4;
    Ji = 5;
    Yi = { E: "Mouse Enter", X: "Mouse Exit", D: "Mouse Down", U: "Mouse Up", Fo: "Focus", Bl: "Blur", PO: "PageOpen", PC: "PageClose", PV: "PageVisible", PI: "PageInvisible", K: "Keystroke", F: "Format", V: "Validate", C: "Calculate" };
    Pi = { WC: "WillClose", WS: "WillSave", DS: "DidSave", WP: "WillPrint", DP: "DidPrint" };
    Oi = { O: "PageOpen", C: "PageClose" };
    Ki = 1;
    qi = 5;
    _i = 0;
    Wi = 1;
    ji = 1;
    Xi = 2;
    Vi = 3;
    Zi = 4;
    zi = 5;
    $i = 6;
    ea = 7;
    ta = 8;
    Aa = 9;
    ia = 10;
    aa = 11;
    sa = 12;
    na = 13;
    ra = 14;
    oa = 15;
    ga = 16;
    ca = 17;
    ha = 18;
    la = 19;
    Ia = 20;
    Ca = 21;
    da = 22;
    Ba = 23;
    ua = 24;
    Qa = 25;
    Ea = 26;
    fa = 27;
    pa = 28;
    ma = 29;
    ya = 30;
    wa = 31;
    ba = 32;
    Da = 33;
    Sa = 34;
    Fa = 35;
    ka = 36;
    Ra = 37;
    xa = 38;
    Na = 39;
    Ma = 40;
    Ga = 41;
    va = 42;
    La = 43;
    Ua = 44;
    Ha = 45;
    Ta = 46;
    Ja = 47;
    Ya = 48;
    Pa = 49;
    Oa = 50;
    Ka = 51;
    qa = 52;
    _a = 53;
    Wa = 54;
    ja = 55;
    Xa = 56;
    Va = 57;
    Za = 58;
    za = 59;
    $a = 60;
    es = 61;
    ts = 62;
    As = 63;
    is = 64;
    as = 65;
    ss = 66;
    ns = 67;
    rs = 68;
    os = 69;
    gs = 70;
    cs = 71;
    hs = 72;
    ls = 73;
    Is = 74;
    Cs = 75;
    ds = 76;
    Bs = 77;
    us = 80;
    Qs = 81;
    Es = 83;
    fs = 84;
    ps = 85;
    ms = 86;
    ys = 87;
    ws = 88;
    bs = 89;
    Ds = 90;
    Ss = 91;
    Fs = 92;
    ks = 93;
    Rs = 1;
    xs = 2;
    Ns = Ki;
    Ms = function() {
      function BaseException(e3, t3) {
        this.message = e3, this.name = t3;
      }
      return BaseException.prototype = new Error(), BaseException.constructor = BaseException, BaseException;
    }();
    PasswordException = class extends Ms {
      constructor(e3, t3) {
        super(e3, "PasswordException"), this.code = t3;
      }
    };
    UnknownErrorException = class extends Ms {
      constructor(e3, t3) {
        super(e3, "UnknownErrorException"), this.details = t3;
      }
    };
    InvalidPDFException = class extends Ms {
      constructor(e3) {
        super(e3, "InvalidPDFException");
      }
    };
    MissingPDFException = class extends Ms {
      constructor(e3) {
        super(e3, "MissingPDFException");
      }
    };
    UnexpectedResponseException = class extends Ms {
      constructor(e3, t3) {
        super(e3, "UnexpectedResponseException"), this.status = t3;
      }
    };
    FormatError = class extends Ms {
      constructor(e3) {
        super(e3, "FormatError");
      }
    };
    AbortException = class extends Ms {
      constructor(e3) {
        super(e3, "AbortException");
      }
    };
    FeatureTest = class {
      static get isLittleEndian() {
        return shadow(this, "isLittleEndian", function() {
          const e3 = new Uint8Array(4);
          return e3[0] = 1, 1 === new Uint32Array(e3.buffer, 0, 1)[0];
        }());
      }
      static get isEvalSupported() {
        return shadow(this, "isEvalSupported", function() {
          try {
            return new Function(""), true;
          } catch {
            return false;
          }
        }());
      }
      static get isOffscreenCanvasSupported() {
        return shadow(this, "isOffscreenCanvasSupported", "undefined" != typeof OffscreenCanvas);
      }
      static get platform() {
        return "undefined" != typeof navigator && "string" == typeof navigator?.platform ? shadow(this, "platform", { isMac: navigator.platform.includes("Mac") }) : shadow(this, "platform", { isMac: false });
      }
      static get isCSSRoundSupported() {
        return shadow(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
      }
    };
    Gs = Array.from(Array(256).keys(), (e3) => e3.toString(16).padStart(2, "0"));
    Util = class {
      static makeHexColor(e3, t3, i3) {
        return `#${Gs[e3]}${Gs[t3]}${Gs[i3]}`;
      }
      static scaleMinMax(e3, t3) {
        let i3;
        e3[0] ? (e3[0] < 0 && (i3 = t3[0], t3[0] = t3[2], t3[2] = i3), t3[0] *= e3[0], t3[2] *= e3[0], e3[3] < 0 && (i3 = t3[1], t3[1] = t3[3], t3[3] = i3), t3[1] *= e3[3], t3[3] *= e3[3]) : (i3 = t3[0], t3[0] = t3[1], t3[1] = i3, i3 = t3[2], t3[2] = t3[3], t3[3] = i3, e3[1] < 0 && (i3 = t3[1], t3[1] = t3[3], t3[3] = i3), t3[1] *= e3[1], t3[3] *= e3[1], e3[2] < 0 && (i3 = t3[0], t3[0] = t3[2], t3[2] = i3), t3[0] *= e3[2], t3[2] *= e3[2]), t3[0] += e3[4], t3[1] += e3[5], t3[2] += e3[4], t3[3] += e3[5];
      }
      static transform(e3, t3) {
        return [e3[0] * t3[0] + e3[2] * t3[1], e3[1] * t3[0] + e3[3] * t3[1], e3[0] * t3[2] + e3[2] * t3[3], e3[1] * t3[2] + e3[3] * t3[3], e3[0] * t3[4] + e3[2] * t3[5] + e3[4], e3[1] * t3[4] + e3[3] * t3[5] + e3[5]];
      }
      static applyTransform(e3, t3) {
        return [e3[0] * t3[0] + e3[1] * t3[2] + t3[4], e3[0] * t3[1] + e3[1] * t3[3] + t3[5]];
      }
      static applyInverseTransform(e3, t3) {
        const i3 = t3[0] * t3[3] - t3[1] * t3[2];
        return [(e3[0] * t3[3] - e3[1] * t3[2] + t3[2] * t3[5] - t3[4] * t3[3]) / i3, (-e3[0] * t3[1] + e3[1] * t3[0] + t3[4] * t3[1] - t3[5] * t3[0]) / i3];
      }
      static getAxialAlignedBoundingBox(e3, t3) {
        const i3 = this.applyTransform(e3, t3), a3 = this.applyTransform(e3.slice(2, 4), t3), s3 = this.applyTransform([e3[0], e3[3]], t3), n3 = this.applyTransform([e3[2], e3[1]], t3);
        return [Math.min(i3[0], a3[0], s3[0], n3[0]), Math.min(i3[1], a3[1], s3[1], n3[1]), Math.max(i3[0], a3[0], s3[0], n3[0]), Math.max(i3[1], a3[1], s3[1], n3[1])];
      }
      static inverseTransform(e3) {
        const t3 = e3[0] * e3[3] - e3[1] * e3[2];
        return [e3[3] / t3, -e3[1] / t3, -e3[2] / t3, e3[0] / t3, (e3[2] * e3[5] - e3[4] * e3[3]) / t3, (e3[4] * e3[1] - e3[5] * e3[0]) / t3];
      }
      static singularValueDecompose2dScale(e3) {
        const t3 = [e3[0], e3[2], e3[1], e3[3]], i3 = e3[0] * t3[0] + e3[1] * t3[2], a3 = e3[0] * t3[1] + e3[1] * t3[3], s3 = e3[2] * t3[0] + e3[3] * t3[2], n3 = e3[2] * t3[1] + e3[3] * t3[3], r3 = (i3 + n3) / 2, o3 = Math.sqrt((i3 + n3) ** 2 - 4 * (i3 * n3 - s3 * a3)) / 2, g3 = r3 + o3 || 1, c3 = r3 - o3 || 1;
        return [Math.sqrt(g3), Math.sqrt(c3)];
      }
      static normalizeRect(e3) {
        const t3 = e3.slice(0);
        return e3[0] > e3[2] && (t3[0] = e3[2], t3[2] = e3[0]), e3[1] > e3[3] && (t3[1] = e3[3], t3[3] = e3[1]), t3;
      }
      static intersect(e3, t3) {
        const i3 = Math.max(Math.min(e3[0], e3[2]), Math.min(t3[0], t3[2])), a3 = Math.min(Math.max(e3[0], e3[2]), Math.max(t3[0], t3[2]));
        if (i3 > a3) return null;
        const s3 = Math.max(Math.min(e3[1], e3[3]), Math.min(t3[1], t3[3])), n3 = Math.min(Math.max(e3[1], e3[3]), Math.max(t3[1], t3[3]));
        return s3 > n3 ? null : [i3, s3, a3, n3];
      }
      static bezierBoundingBox(e3, t3, i3, a3, s3, n3, r3, o3, g3) {
        return g3 ? (g3[0] = Math.min(g3[0], e3, r3), g3[1] = Math.min(g3[1], t3, o3), g3[2] = Math.max(g3[2], e3, r3), g3[3] = Math.max(g3[3], t3, o3)) : g3 = [Math.min(e3, r3), Math.min(t3, o3), Math.max(e3, r3), Math.max(t3, o3)], __privateMethod(this, _Util_static, t_fn).call(this, e3, i3, s3, r3, t3, a3, n3, o3, 3 * (3 * (i3 - s3) - e3 + r3), 6 * (e3 - 2 * i3 + s3), 3 * (i3 - e3), g3), __privateMethod(this, _Util_static, t_fn).call(this, e3, i3, s3, r3, t3, a3, n3, o3, 3 * (3 * (a3 - n3) - t3 + o3), 6 * (t3 - 2 * a3 + n3), 3 * (a3 - t3), g3), g3;
      }
    };
    _Util_static = new WeakSet();
    e_fn = function(e3, t3, i3, a3, s3, n3, r3, o3, g3, c3) {
      if (g3 <= 0 || g3 >= 1) return;
      const h3 = 1 - g3, l3 = g3 * g3, C3 = l3 * g3, d3 = h3 * (h3 * (h3 * e3 + 3 * g3 * t3) + 3 * l3 * i3) + C3 * a3, u3 = h3 * (h3 * (h3 * s3 + 3 * g3 * n3) + 3 * l3 * r3) + C3 * o3;
      c3[0] = Math.min(c3[0], d3), c3[1] = Math.min(c3[1], u3), c3[2] = Math.max(c3[2], d3), c3[3] = Math.max(c3[3], u3);
    };
    t_fn = function(e3, t3, i3, a3, s3, n3, r3, o3, g3, c3, h3, l3) {
      if (Math.abs(g3) < 1e-12) return void (Math.abs(c3) >= 1e-12 && __privateMethod(this, _Util_static, e_fn).call(this, e3, t3, i3, a3, s3, n3, r3, o3, -h3 / c3, l3));
      const C3 = c3 ** 2 - 4 * h3 * g3;
      if (C3 < 0) return;
      const d3 = Math.sqrt(C3), u3 = 2 * g3;
      __privateMethod(this, _Util_static, e_fn).call(this, e3, t3, i3, a3, s3, n3, r3, o3, (-c3 + d3) / u3, l3), __privateMethod(this, _Util_static, e_fn).call(this, e3, t3, i3, a3, s3, n3, r3, o3, (-c3 - d3) / u3, l3);
    };
    __privateAdd(Util, _Util_static);
    vs = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
    Ls = null;
    Us = null;
    Hs = 0;
    Ts = 1;
    Js = 2;
    Ys = 3;
    Os = 4;
    Ks = 5;
    qs = 6;
    _s = 7;
    Ws = 8;
    js = Symbol("CIRCULAR_REF");
    Xs = Symbol("EOF");
    Vs = /* @__PURE__ */ Object.create(null);
    Zs = /* @__PURE__ */ Object.create(null);
    zs = /* @__PURE__ */ Object.create(null);
    Name = class _Name {
      constructor(e3) {
        this.name = e3;
      }
      static get(e3) {
        return Zs[e3] || (Zs[e3] = new _Name(e3));
      }
    };
    Cmd = class _Cmd {
      constructor(e3) {
        this.cmd = e3;
      }
      static get(e3) {
        return Vs[e3] || (Vs[e3] = new _Cmd(e3));
      }
    };
    nonSerializable = function() {
      return nonSerializable;
    };
    Dict = class _Dict {
      constructor(e3 = null) {
        this._map = /* @__PURE__ */ Object.create(null), this.xref = e3, this.objId = null, this.suppressEncryption = false, this.__nonSerializable__ = nonSerializable;
      }
      assignXref(e3) {
        this.xref = e3;
      }
      get size() {
        return Object.keys(this._map).length;
      }
      get(e3, t3, i3) {
        let a3 = this._map[e3];
        return void 0 === a3 && void 0 !== t3 && (a3 = this._map[t3], void 0 === a3 && void 0 !== i3 && (a3 = this._map[i3])), a3 instanceof Ref && this.xref ? this.xref.fetch(a3, this.suppressEncryption) : a3;
      }
      async getAsync(e3, t3, i3) {
        let a3 = this._map[e3];
        return void 0 === a3 && void 0 !== t3 && (a3 = this._map[t3], void 0 === a3 && void 0 !== i3 && (a3 = this._map[i3])), a3 instanceof Ref && this.xref ? this.xref.fetchAsync(a3, this.suppressEncryption) : a3;
      }
      getArray(e3, t3, i3) {
        let a3 = this._map[e3];
        if (void 0 === a3 && void 0 !== t3 && (a3 = this._map[t3], void 0 === a3 && void 0 !== i3 && (a3 = this._map[i3])), a3 instanceof Ref && this.xref && (a3 = this.xref.fetch(a3, this.suppressEncryption)), Array.isArray(a3)) {
          a3 = a3.slice();
          for (let e4 = 0, t4 = a3.length; e4 < t4; e4++) a3[e4] instanceof Ref && this.xref && (a3[e4] = this.xref.fetch(a3[e4], this.suppressEncryption));
        }
        return a3;
      }
      getRaw(e3) {
        return this._map[e3];
      }
      getKeys() {
        return Object.keys(this._map);
      }
      getRawValues() {
        return Object.values(this._map);
      }
      set(e3, t3) {
        this._map[e3] = t3;
      }
      has(e3) {
        return void 0 !== this._map[e3];
      }
      forEach(e3) {
        for (const t3 in this._map) e3(t3, this.get(t3));
      }
      static get empty() {
        const e3 = new _Dict(null);
        return e3.set = (e4, t3) => {
          unreachable("Should not call `set` on the empty dictionary.");
        }, shadow(this, "empty", e3);
      }
      static merge({ xref: e3, dictArray: t3, mergeSubDicts: i3 = false }) {
        const a3 = new _Dict(e3), s3 = /* @__PURE__ */ new Map();
        for (const e4 of t3) if (e4 instanceof _Dict) for (const [t4, a4] of Object.entries(e4._map)) {
          let e5 = s3.get(t4);
          if (void 0 === e5) e5 = [], s3.set(t4, e5);
          else if (!(i3 && a4 instanceof _Dict)) continue;
          e5.push(a4);
        }
        for (const [t4, i4] of s3) {
          if (1 === i4.length || !(i4[0] instanceof _Dict)) {
            a3._map[t4] = i4[0];
            continue;
          }
          const s4 = new _Dict(e3);
          for (const e4 of i4) for (const [t5, i5] of Object.entries(e4._map)) void 0 === s4._map[t5] && (s4._map[t5] = i5);
          s4.size > 0 && (a3._map[t4] = s4);
        }
        return s3.clear(), a3.size > 0 ? a3 : _Dict.empty;
      }
      clone() {
        const e3 = new _Dict(this.xref);
        for (const t3 of this.getKeys()) e3.set(t3, this.getRaw(t3));
        return e3;
      }
      delete(e3) {
        delete this._map[e3];
      }
    };
    Ref = class _Ref {
      constructor(e3, t3) {
        this.num = e3, this.gen = t3;
      }
      toString() {
        return 0 === this.gen ? `${this.num}R` : `${this.num}R${this.gen}`;
      }
      static fromString(e3) {
        const t3 = zs[e3];
        if (t3) return t3;
        const i3 = /^(\d+)R(\d*)$/.exec(e3);
        return i3 && "0" !== i3[1] ? zs[e3] = new _Ref(parseInt(i3[1]), i3[2] ? parseInt(i3[2]) : 0) : null;
      }
      static get(e3, t3) {
        const i3 = 0 === t3 ? `${e3}R` : `${e3}R${t3}`;
        return zs[i3] || (zs[i3] = new _Ref(e3, t3));
      }
    };
    RefSet = class {
      constructor(e3 = null) {
        this._set = new Set(e3?._set);
      }
      has(e3) {
        return this._set.has(e3.toString());
      }
      put(e3) {
        this._set.add(e3.toString());
      }
      remove(e3) {
        this._set.delete(e3.toString());
      }
      [Symbol.iterator]() {
        return this._set.values();
      }
      clear() {
        this._set.clear();
      }
    };
    RefSetCache = class {
      constructor() {
        this._map = /* @__PURE__ */ new Map();
      }
      get size() {
        return this._map.size;
      }
      get(e3) {
        return this._map.get(e3.toString());
      }
      has(e3) {
        return this._map.has(e3.toString());
      }
      put(e3, t3) {
        this._map.set(e3.toString(), t3);
      }
      putAlias(e3, t3) {
        this._map.set(e3.toString(), this.get(t3));
      }
      [Symbol.iterator]() {
        return this._map.values();
      }
      clear() {
        this._map.clear();
      }
      *items() {
        for (const [e3, t3] of this._map) yield [Ref.fromString(e3), t3];
      }
    };
    BaseStream = class {
      get length() {
        unreachable("Abstract getter `length` accessed");
      }
      get isEmpty() {
        unreachable("Abstract getter `isEmpty` accessed");
      }
      get isDataLoaded() {
        return shadow(this, "isDataLoaded", true);
      }
      getByte() {
        unreachable("Abstract method `getByte` called");
      }
      getBytes(e3) {
        unreachable("Abstract method `getBytes` called");
      }
      async getImageData(e3, t3) {
        return this.getBytes(e3, t3);
      }
      async asyncGetBytes() {
        unreachable("Abstract method `asyncGetBytes` called");
      }
      get isAsync() {
        return false;
      }
      get canAsyncDecodeImageFromBuffer() {
        return false;
      }
      peekByte() {
        const e3 = this.getByte();
        return -1 !== e3 && this.pos--, e3;
      }
      peekBytes(e3) {
        const t3 = this.getBytes(e3);
        return this.pos -= t3.length, t3;
      }
      getUint16() {
        const e3 = this.getByte(), t3 = this.getByte();
        return -1 === e3 || -1 === t3 ? -1 : (e3 << 8) + t3;
      }
      getInt32() {
        return (this.getByte() << 24) + (this.getByte() << 16) + (this.getByte() << 8) + this.getByte();
      }
      getByteRange(e3, t3) {
        unreachable("Abstract method `getByteRange` called");
      }
      getString(e3) {
        return bytesToString(this.getBytes(e3));
      }
      skip(e3) {
        this.pos += e3 || 1;
      }
      reset() {
        unreachable("Abstract method `reset` called");
      }
      moveStart() {
        unreachable("Abstract method `moveStart` called");
      }
      makeSubStream(e3, t3, i3 = null) {
        unreachable("Abstract method `makeSubStream` called");
      }
      getBaseStreams() {
        return null;
      }
    };
    $s = /^[1-9]\.\d$/;
    MissingDataException = class extends Ms {
      constructor(e3, t3) {
        super(`Missing data [${e3}, ${t3})`, "MissingDataException"), this.begin = e3, this.end = t3;
      }
    };
    ParserEOFException = class extends Ms {
      constructor(e3) {
        super(e3, "ParserEOFException");
      }
    };
    XRefEntryException = class extends Ms {
      constructor(e3) {
        super(e3, "XRefEntryException");
      }
    };
    XRefParseException = class extends Ms {
      constructor(e3) {
        super(e3, "XRefParseException");
      }
    };
    en = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
    tn = { 60: "&lt;", 62: "&gt;", 38: "&amp;", 34: "&quot;", 39: "&apos;" };
    Stream = class _Stream extends BaseStream {
      constructor(e3, t3, i3, a3) {
        super(), this.bytes = e3 instanceof Uint8Array ? e3 : new Uint8Array(e3), this.start = t3 || 0, this.pos = this.start, this.end = t3 + i3 || this.bytes.length, this.dict = a3;
      }
      get length() {
        return this.end - this.start;
      }
      get isEmpty() {
        return 0 === this.length;
      }
      getByte() {
        return this.pos >= this.end ? -1 : this.bytes[this.pos++];
      }
      getBytes(e3) {
        const t3 = this.bytes, i3 = this.pos, a3 = this.end;
        if (!e3) return t3.subarray(i3, a3);
        let s3 = i3 + e3;
        return s3 > a3 && (s3 = a3), this.pos = s3, t3.subarray(i3, s3);
      }
      getByteRange(e3, t3) {
        return e3 < 0 && (e3 = 0), t3 > this.end && (t3 = this.end), this.bytes.subarray(e3, t3);
      }
      reset() {
        this.pos = this.start;
      }
      moveStart() {
        this.start = this.pos;
      }
      makeSubStream(e3, t3, i3 = null) {
        return new _Stream(this.bytes.buffer, e3, t3, i3);
      }
    };
    StringStream = class extends Stream {
      constructor(e3) {
        super(stringToBytes(e3));
      }
    };
    NullStream = class extends Stream {
      constructor() {
        super(new Uint8Array(0));
      }
    };
    ChunkedStream = class extends Stream {
      constructor(e3, t3, i3) {
        super(new Uint8Array(e3), 0, e3, null), this.chunkSize = t3, this._loadedChunks = /* @__PURE__ */ new Set(), this.numChunks = Math.ceil(e3 / t3), this.manager = i3, this.progressiveDataLength = 0, this.lastSuccessfulEnsureByteChunk = -1;
      }
      getMissingChunks() {
        const e3 = [];
        for (let t3 = 0, i3 = this.numChunks; t3 < i3; ++t3) this._loadedChunks.has(t3) || e3.push(t3);
        return e3;
      }
      get numChunksLoaded() {
        return this._loadedChunks.size;
      }
      get isDataLoaded() {
        return this.numChunksLoaded === this.numChunks;
      }
      onReceiveData(e3, t3) {
        const i3 = this.chunkSize;
        if (e3 % i3 != 0) throw new Error(`Bad begin offset: ${e3}`);
        const a3 = e3 + t3.byteLength;
        if (a3 % i3 != 0 && a3 !== this.bytes.length) throw new Error(`Bad end offset: ${a3}`);
        this.bytes.set(new Uint8Array(t3), e3);
        const s3 = Math.floor(e3 / i3), n3 = Math.floor((a3 - 1) / i3) + 1;
        for (let e4 = s3; e4 < n3; ++e4) this._loadedChunks.add(e4);
      }
      onReceiveProgressiveData(e3) {
        let t3 = this.progressiveDataLength;
        const i3 = Math.floor(t3 / this.chunkSize);
        this.bytes.set(new Uint8Array(e3), t3), t3 += e3.byteLength, this.progressiveDataLength = t3;
        const a3 = t3 >= this.end ? this.numChunks : Math.floor(t3 / this.chunkSize);
        for (let e4 = i3; e4 < a3; ++e4) this._loadedChunks.add(e4);
      }
      ensureByte(e3) {
        if (e3 < this.progressiveDataLength) return;
        const t3 = Math.floor(e3 / this.chunkSize);
        if (!(t3 > this.numChunks) && t3 !== this.lastSuccessfulEnsureByteChunk) {
          if (!this._loadedChunks.has(t3)) throw new MissingDataException(e3, e3 + 1);
          this.lastSuccessfulEnsureByteChunk = t3;
        }
      }
      ensureRange(e3, t3) {
        if (e3 >= t3) return;
        if (t3 <= this.progressiveDataLength) return;
        const i3 = Math.floor(e3 / this.chunkSize);
        if (i3 > this.numChunks) return;
        const a3 = Math.min(Math.floor((t3 - 1) / this.chunkSize) + 1, this.numChunks);
        for (let s3 = i3; s3 < a3; ++s3) if (!this._loadedChunks.has(s3)) throw new MissingDataException(e3, t3);
      }
      nextEmptyChunk(e3) {
        const t3 = this.numChunks;
        for (let i3 = 0; i3 < t3; ++i3) {
          const a3 = (e3 + i3) % t3;
          if (!this._loadedChunks.has(a3)) return a3;
        }
        return null;
      }
      hasChunk(e3) {
        return this._loadedChunks.has(e3);
      }
      getByte() {
        const e3 = this.pos;
        return e3 >= this.end ? -1 : (e3 >= this.progressiveDataLength && this.ensureByte(e3), this.bytes[this.pos++]);
      }
      getBytes(e3) {
        const t3 = this.bytes, i3 = this.pos, a3 = this.end;
        if (!e3) return a3 > this.progressiveDataLength && this.ensureRange(i3, a3), t3.subarray(i3, a3);
        let s3 = i3 + e3;
        return s3 > a3 && (s3 = a3), s3 > this.progressiveDataLength && this.ensureRange(i3, s3), this.pos = s3, t3.subarray(i3, s3);
      }
      getByteRange(e3, t3) {
        return e3 < 0 && (e3 = 0), t3 > this.end && (t3 = this.end), t3 > this.progressiveDataLength && this.ensureRange(e3, t3), this.bytes.subarray(e3, t3);
      }
      makeSubStream(e3, t3, i3 = null) {
        function ChunkedStreamSubstream() {
        }
        t3 ? e3 + t3 > this.progressiveDataLength && this.ensureRange(e3, e3 + t3) : e3 >= this.progressiveDataLength && this.ensureByte(e3), ChunkedStreamSubstream.prototype = Object.create(this), ChunkedStreamSubstream.prototype.getMissingChunks = function() {
          const e4 = this.chunkSize, t4 = Math.floor(this.start / e4), i4 = Math.floor((this.end - 1) / e4) + 1, a4 = [];
          for (let e5 = t4; e5 < i4; ++e5) this._loadedChunks.has(e5) || a4.push(e5);
          return a4;
        }, Object.defineProperty(ChunkedStreamSubstream.prototype, "isDataLoaded", { get() {
          return this.numChunksLoaded === this.numChunks || 0 === this.getMissingChunks().length;
        }, configurable: true });
        const a3 = new ChunkedStreamSubstream();
        return a3.pos = a3.start = e3, a3.end = e3 + t3 || this.end, a3.dict = i3, a3;
      }
      getBaseStreams() {
        return [this];
      }
    };
    ChunkedStreamManager = class {
      constructor(e3, t3) {
        this.length = t3.length, this.chunkSize = t3.rangeChunkSize, this.stream = new ChunkedStream(this.length, this.chunkSize, this), this.pdfNetworkStream = e3, this.disableAutoFetch = t3.disableAutoFetch, this.msgHandler = t3.msgHandler, this.currRequestId = 0, this._chunksNeededByRequest = /* @__PURE__ */ new Map(), this._requestsByChunk = /* @__PURE__ */ new Map(), this._promisesByRequest = /* @__PURE__ */ new Map(), this.progressiveDataLength = 0, this.aborted = false, this._loadedStreamCapability = Promise.withResolvers();
      }
      sendRequest(e3, t3) {
        const i3 = this.pdfNetworkStream.getRangeReader(e3, t3);
        i3.isStreamingSupported || (i3.onProgress = this.onProgress.bind(this));
        let a3 = [], s3 = 0;
        return new Promise((e4, t4) => {
          const readChunk = ({ value: n3, done: r3 }) => {
            try {
              if (r3) {
                const t5 = arrayBuffersToBytes(a3);
                return a3 = null, void e4(t5);
              }
              s3 += n3.byteLength, i3.isStreamingSupported && this.onProgress({ loaded: s3 }), a3.push(n3), i3.read().then(readChunk, t4);
            } catch (e5) {
              t4(e5);
            }
          };
          i3.read().then(readChunk, t4);
        }).then((t4) => {
          this.aborted || this.onReceiveData({ chunk: t4, begin: e3 });
        });
      }
      requestAllChunks(e3 = false) {
        if (!e3) {
          const e4 = this.stream.getMissingChunks();
          this._requestChunks(e4);
        }
        return this._loadedStreamCapability.promise;
      }
      _requestChunks(e3) {
        const t3 = this.currRequestId++, i3 = /* @__PURE__ */ new Set();
        this._chunksNeededByRequest.set(t3, i3);
        for (const t4 of e3) this.stream.hasChunk(t4) || i3.add(t4);
        if (0 === i3.size) return Promise.resolve();
        const a3 = Promise.withResolvers();
        this._promisesByRequest.set(t3, a3);
        const s3 = [];
        for (const e4 of i3) {
          let i4 = this._requestsByChunk.get(e4);
          i4 || (i4 = [], this._requestsByChunk.set(e4, i4), s3.push(e4)), i4.push(t3);
        }
        if (s3.length > 0) {
          const e4 = this.groupChunks(s3);
          for (const t4 of e4) {
            const e5 = t4.beginChunk * this.chunkSize, i4 = Math.min(t4.endChunk * this.chunkSize, this.length);
            this.sendRequest(e5, i4).catch(a3.reject);
          }
        }
        return a3.promise.catch((e4) => {
          if (!this.aborted) throw e4;
        });
      }
      getStream() {
        return this.stream;
      }
      requestRange(e3, t3) {
        t3 = Math.min(t3, this.length);
        const i3 = this.getBeginChunk(e3), a3 = this.getEndChunk(t3), s3 = [];
        for (let e4 = i3; e4 < a3; ++e4) s3.push(e4);
        return this._requestChunks(s3);
      }
      requestRanges(e3 = []) {
        const t3 = [];
        for (const i3 of e3) {
          const e4 = this.getBeginChunk(i3.begin), a3 = this.getEndChunk(i3.end);
          for (let i4 = e4; i4 < a3; ++i4) t3.includes(i4) || t3.push(i4);
        }
        return t3.sort(function(e4, t4) {
          return e4 - t4;
        }), this._requestChunks(t3);
      }
      groupChunks(e3) {
        const t3 = [];
        let i3 = -1, a3 = -1;
        for (let s3 = 0, n3 = e3.length; s3 < n3; ++s3) {
          const n4 = e3[s3];
          i3 < 0 && (i3 = n4), a3 >= 0 && a3 + 1 !== n4 && (t3.push({ beginChunk: i3, endChunk: a3 + 1 }), i3 = n4), s3 + 1 === e3.length && t3.push({ beginChunk: i3, endChunk: n4 + 1 }), a3 = n4;
        }
        return t3;
      }
      onProgress(e3) {
        this.msgHandler.send("DocProgress", { loaded: this.stream.numChunksLoaded * this.chunkSize + e3.loaded, total: this.length });
      }
      onReceiveData(e3) {
        const t3 = e3.chunk, i3 = void 0 === e3.begin, a3 = i3 ? this.progressiveDataLength : e3.begin, s3 = a3 + t3.byteLength, n3 = Math.floor(a3 / this.chunkSize), r3 = s3 < this.length ? Math.floor(s3 / this.chunkSize) : Math.ceil(s3 / this.chunkSize);
        i3 ? (this.stream.onReceiveProgressiveData(t3), this.progressiveDataLength = s3) : this.stream.onReceiveData(a3, t3), this.stream.isDataLoaded && this._loadedStreamCapability.resolve(this.stream);
        const o3 = [];
        for (let e4 = n3; e4 < r3; ++e4) {
          const t4 = this._requestsByChunk.get(e4);
          if (t4) {
            this._requestsByChunk.delete(e4);
            for (const i4 of t4) {
              const t5 = this._chunksNeededByRequest.get(i4);
              t5.has(e4) && t5.delete(e4), t5.size > 0 || o3.push(i4);
            }
          }
        }
        if (!this.disableAutoFetch && 0 === this._requestsByChunk.size) {
          let e4;
          if (1 === this.stream.numChunksLoaded) {
            const t4 = this.stream.numChunks - 1;
            this.stream.hasChunk(t4) || (e4 = t4);
          } else e4 = this.stream.nextEmptyChunk(r3);
          Number.isInteger(e4) && this._requestChunks([e4]);
        }
        for (const e4 of o3) {
          const t4 = this._promisesByRequest.get(e4);
          this._promisesByRequest.delete(e4), t4.resolve();
        }
        this.msgHandler.send("DocProgress", { loaded: this.stream.numChunksLoaded * this.chunkSize, total: this.length });
      }
      onError(e3) {
        this._loadedStreamCapability.reject(e3);
      }
      getBeginChunk(e3) {
        return Math.floor(e3 / this.chunkSize);
      }
      getEndChunk(e3) {
        return Math.floor((e3 - 1) / this.chunkSize) + 1;
      }
      abort(e3) {
        this.aborted = true, this.pdfNetworkStream?.cancelAllRequests(e3);
        for (const t3 of this._promisesByRequest.values()) t3.reject(e3);
      }
    };
    ColorSpace = class _ColorSpace {
      constructor(e3, t3) {
        this.name = e3, this.numComps = t3;
      }
      getRgb(e3, t3) {
        const i3 = new Uint8ClampedArray(3);
        return this.getRgbItem(e3, t3, i3, 0), i3;
      }
      getRgbItem(e3, t3, i3, a3) {
        unreachable("Should not call ColorSpace.getRgbItem");
      }
      getRgbBuffer(e3, t3, i3, a3, s3, n3, r3) {
        unreachable("Should not call ColorSpace.getRgbBuffer");
      }
      getOutputLength(e3, t3) {
        unreachable("Should not call ColorSpace.getOutputLength");
      }
      isPassthrough(e3) {
        return false;
      }
      isDefaultDecode(e3, t3) {
        return _ColorSpace.isDefaultDecode(e3, this.numComps);
      }
      fillRgb(e3, t3, i3, a3, s3, n3, r3, o3, g3) {
        const c3 = t3 * i3;
        let h3 = null;
        const l3 = 1 << r3, C3 = i3 !== s3 || t3 !== a3;
        if (this.isPassthrough(r3)) h3 = o3;
        else if (1 === this.numComps && c3 > l3 && "DeviceGray" !== this.name && "DeviceRGB" !== this.name) {
          const t4 = r3 <= 8 ? new Uint8Array(l3) : new Uint16Array(l3);
          for (let e4 = 0; e4 < l3; e4++) t4[e4] = e4;
          const i4 = new Uint8ClampedArray(3 * l3);
          if (this.getRgbBuffer(t4, 0, l3, i4, 0, r3, 0), C3) {
            h3 = new Uint8Array(3 * c3);
            let e4 = 0;
            for (let t5 = 0; t5 < c3; ++t5) {
              const a4 = 3 * o3[t5];
              h3[e4++] = i4[a4], h3[e4++] = i4[a4 + 1], h3[e4++] = i4[a4 + 2];
            }
          } else {
            let t5 = 0;
            for (let a4 = 0; a4 < c3; ++a4) {
              const s4 = 3 * o3[a4];
              e3[t5++] = i4[s4], e3[t5++] = i4[s4 + 1], e3[t5++] = i4[s4 + 2], t5 += g3;
            }
          }
        } else C3 ? (h3 = new Uint8ClampedArray(3 * c3), this.getRgbBuffer(o3, 0, c3, h3, 0, r3, 0)) : this.getRgbBuffer(o3, 0, a3 * n3, e3, 0, r3, g3);
        if (h3) if (C3) !function(e4, t4, i4, a4, s4, n4, r4) {
          r4 = 1 !== r4 ? 0 : r4;
          const o4 = i4 / s4, g4 = a4 / n4;
          let c4, h4 = 0;
          const l4 = new Uint16Array(s4), C4 = 3 * i4;
          for (let e5 = 0; e5 < s4; e5++) l4[e5] = 3 * Math.floor(e5 * o4);
          for (let i5 = 0; i5 < n4; i5++) {
            const a5 = Math.floor(i5 * g4) * C4;
            for (let i6 = 0; i6 < s4; i6++) c4 = a5 + l4[i6], t4[h4++] = e4[c4++], t4[h4++] = e4[c4++], t4[h4++] = e4[c4++], h4 += r4;
          }
        }(h3, e3, t3, i3, a3, s3, g3);
        else {
          let t4 = 0, i4 = 0;
          for (let s4 = 0, r4 = a3 * n3; s4 < r4; s4++) e3[t4++] = h3[i4++], e3[t4++] = h3[i4++], e3[t4++] = h3[i4++], t4 += g3;
        }
      }
      get usesZeroToOneRange() {
        return shadow(this, "usesZeroToOneRange", true);
      }
      static _cache(e3, t3, i3, a3) {
        if (!i3) throw new Error('ColorSpace._cache - expected "localColorSpaceCache" argument.');
        if (!a3) throw new Error('ColorSpace._cache - expected "parsedColorSpace" argument.');
        let s3, n3;
        e3 instanceof Ref && (n3 = e3, e3 = t3.fetch(e3)), e3 instanceof Name && (s3 = e3.name), (s3 || n3) && i3.set(s3, n3, a3);
      }
      static getCached(e3, t3, i3) {
        if (!i3) throw new Error('ColorSpace.getCached - expected "localColorSpaceCache" argument.');
        if (e3 instanceof Ref) {
          const a3 = i3.getByRef(e3);
          if (a3) return a3;
          try {
            e3 = t3.fetch(e3);
          } catch (e4) {
            if (e4 instanceof MissingDataException) throw e4;
          }
        }
        if (e3 instanceof Name) {
          const t4 = i3.getByName(e3.name);
          if (t4) return t4;
        }
        return null;
      }
      static async parseAsync({ cs: e3, xref: t3, resources: i3 = null, pdfFunctionFactory: a3, localColorSpaceCache: s3 }) {
        const n3 = this._parse(e3, t3, i3, a3);
        return this._cache(e3, t3, s3, n3), n3;
      }
      static parse({ cs: e3, xref: t3, resources: i3 = null, pdfFunctionFactory: a3, localColorSpaceCache: s3 }) {
        const n3 = this.getCached(e3, t3, s3);
        if (n3) return n3;
        const r3 = this._parse(e3, t3, i3, a3);
        return this._cache(e3, t3, s3, r3), r3;
      }
      static _parse(e3, t3, i3 = null, a3) {
        if ((e3 = t3.fetchIfRef(e3)) instanceof Name) switch (e3.name) {
          case "G":
          case "DeviceGray":
            return this.singletons.gray;
          case "RGB":
          case "DeviceRGB":
            return this.singletons.rgb;
          case "DeviceRGBA":
            return this.singletons.rgba;
          case "CMYK":
          case "DeviceCMYK":
            return this.singletons.cmyk;
          case "Pattern":
            return new PatternCS(null);
          default:
            if (i3 instanceof Dict) {
              const s3 = i3.get("ColorSpace");
              if (s3 instanceof Dict) {
                const n3 = s3.get(e3.name);
                if (n3) {
                  if (n3 instanceof Name) return this._parse(n3, t3, i3, a3);
                  e3 = n3;
                  break;
                }
              }
            }
            return warn(`Unrecognized ColorSpace: ${e3.name}`), this.singletons.gray;
        }
        if (Array.isArray(e3)) {
          const s3 = t3.fetchIfRef(e3[0]).name;
          let n3, r3, o3, g3, c3, h3;
          switch (s3) {
            case "G":
            case "DeviceGray":
              return this.singletons.gray;
            case "RGB":
            case "DeviceRGB":
              return this.singletons.rgb;
            case "CMYK":
            case "DeviceCMYK":
              return this.singletons.cmyk;
            case "CalGray":
              return n3 = t3.fetchIfRef(e3[1]), g3 = n3.getArray("WhitePoint"), c3 = n3.getArray("BlackPoint"), h3 = n3.get("Gamma"), new CalGrayCS(g3, c3, h3);
            case "CalRGB":
              n3 = t3.fetchIfRef(e3[1]), g3 = n3.getArray("WhitePoint"), c3 = n3.getArray("BlackPoint"), h3 = n3.getArray("Gamma");
              const l3 = n3.getArray("Matrix");
              return new CalRGBCS(g3, c3, h3, l3);
            case "ICCBased":
              const C3 = t3.fetchIfRef(e3[1]).dict;
              r3 = C3.get("N");
              const d3 = C3.get("Alternate");
              if (d3) {
                const e4 = this._parse(d3, t3, i3, a3);
                if (e4.numComps === r3) return e4;
                warn("ICCBased color space: Ignoring incorrect /Alternate entry.");
              }
              if (1 === r3) return this.singletons.gray;
              if (3 === r3) return this.singletons.rgb;
              if (4 === r3) return this.singletons.cmyk;
              break;
            case "Pattern":
              return o3 = e3[1] || null, o3 && (o3 = this._parse(o3, t3, i3, a3)), new PatternCS(o3);
            case "I":
            case "Indexed":
              o3 = this._parse(e3[1], t3, i3, a3);
              const u3 = t3.fetchIfRef(e3[2]) + 1, Q3 = t3.fetchIfRef(e3[3]);
              return new IndexedCS(o3, u3, Q3);
            case "Separation":
            case "DeviceN":
              const f3 = t3.fetchIfRef(e3[1]);
              r3 = Array.isArray(f3) ? f3.length : 1, o3 = this._parse(e3[2], t3, i3, a3);
              const p3 = a3.create(e3[3]);
              return new AlternateCS(r3, o3, p3);
            case "Lab":
              n3 = t3.fetchIfRef(e3[1]), g3 = n3.getArray("WhitePoint"), c3 = n3.getArray("BlackPoint");
              const m3 = n3.getArray("Range");
              return new LabCS(g3, c3, m3);
            default:
              return warn(`Unimplemented ColorSpace object: ${s3}`), this.singletons.gray;
          }
        }
        return warn(`Unrecognized ColorSpace object: ${e3}`), this.singletons.gray;
      }
      static isDefaultDecode(e3, t3) {
        if (!Array.isArray(e3)) return true;
        if (2 * t3 !== e3.length) return warn("The decode map is not the correct length"), true;
        for (let t4 = 0, i3 = e3.length; t4 < i3; t4 += 2) if (0 !== e3[t4] || 1 !== e3[t4 + 1]) return false;
        return true;
      }
      static get singletons() {
        return shadow(this, "singletons", { get gray() {
          return shadow(this, "gray", new DeviceGrayCS());
        }, get rgb() {
          return shadow(this, "rgb", new DeviceRgbCS());
        }, get rgba() {
          return shadow(this, "rgba", new DeviceRgbaCS());
        }, get cmyk() {
          return shadow(this, "cmyk", new DeviceCmykCS());
        } });
      }
    };
    AlternateCS = class extends ColorSpace {
      constructor(e3, t3, i3) {
        super("Alternate", e3), this.base = t3, this.tintFn = i3, this.tmpBuf = new Float32Array(t3.numComps);
      }
      getRgbItem(e3, t3, i3, a3) {
        const s3 = this.tmpBuf;
        this.tintFn(e3, t3, s3, 0), this.base.getRgbItem(s3, 0, i3, a3);
      }
      getRgbBuffer(e3, t3, i3, a3, s3, n3, r3) {
        const o3 = this.tintFn, g3 = this.base, c3 = 1 / ((1 << n3) - 1), h3 = g3.numComps, l3 = g3.usesZeroToOneRange, C3 = (g3.isPassthrough(8) || !l3) && 0 === r3;
        let d3 = C3 ? s3 : 0;
        const u3 = C3 ? a3 : new Uint8ClampedArray(h3 * i3), Q3 = this.numComps, f3 = new Float32Array(Q3), p3 = new Float32Array(h3);
        let m3, y3;
        for (m3 = 0; m3 < i3; m3++) {
          for (y3 = 0; y3 < Q3; y3++) f3[y3] = e3[t3++] * c3;
          if (o3(f3, 0, p3, 0), l3) for (y3 = 0; y3 < h3; y3++) u3[d3++] = 255 * p3[y3];
          else g3.getRgbItem(p3, 0, u3, d3), d3 += h3;
        }
        C3 || g3.getRgbBuffer(u3, 0, i3, a3, s3, 8, r3);
      }
      getOutputLength(e3, t3) {
        return this.base.getOutputLength(e3 * this.base.numComps / this.numComps, t3);
      }
    };
    PatternCS = class extends ColorSpace {
      constructor(e3) {
        super("Pattern", null), this.base = e3;
      }
      isDefaultDecode(e3, t3) {
        unreachable("Should not call PatternCS.isDefaultDecode");
      }
    };
    IndexedCS = class extends ColorSpace {
      constructor(e3, t3, i3) {
        super("Indexed", 1), this.base = e3, this.highVal = t3;
        const a3 = e3.numComps * t3;
        if (this.lookup = new Uint8Array(a3), i3 instanceof BaseStream) {
          const e4 = i3.getBytes(a3);
          this.lookup.set(e4);
        } else {
          if ("string" != typeof i3) throw new FormatError(`IndexedCS - unrecognized lookup table: ${i3}`);
          for (let e4 = 0; e4 < a3; ++e4) this.lookup[e4] = 255 & i3.charCodeAt(e4);
        }
      }
      getRgbItem(e3, t3, i3, a3) {
        const s3 = this.base.numComps, n3 = e3[t3] * s3;
        this.base.getRgbBuffer(this.lookup, n3, 1, i3, a3, 8, 0);
      }
      getRgbBuffer(e3, t3, i3, a3, s3, n3, r3) {
        const o3 = this.base, g3 = o3.numComps, c3 = o3.getOutputLength(g3, r3), h3 = this.lookup;
        for (let n4 = 0; n4 < i3; ++n4) {
          const i4 = e3[t3++] * g3;
          o3.getRgbBuffer(h3, i4, 1, a3, s3, 8, r3), s3 += c3;
        }
      }
      getOutputLength(e3, t3) {
        return this.base.getOutputLength(e3 * this.base.numComps, t3);
      }
      isDefaultDecode(e3, t3) {
        return !Array.isArray(e3) || (2 !== e3.length ? (warn("Decode map length is not correct"), true) : !Number.isInteger(t3) || t3 < 1 ? (warn("Bits per component is not correct"), true) : 0 === e3[0] && e3[1] === (1 << t3) - 1);
      }
    };
    DeviceGrayCS = class extends ColorSpace {
      constructor() {
        super("DeviceGray", 1);
      }
      getRgbItem(e3, t3, i3, a3) {
        const s3 = 255 * e3[t3];
        i3[a3] = i3[a3 + 1] = i3[a3 + 2] = s3;
      }
      getRgbBuffer(e3, t3, i3, a3, s3, n3, r3) {
        const o3 = 255 / ((1 << n3) - 1);
        let g3 = t3, c3 = s3;
        for (let t4 = 0; t4 < i3; ++t4) {
          const t5 = o3 * e3[g3++];
          a3[c3++] = t5, a3[c3++] = t5, a3[c3++] = t5, c3 += r3;
        }
      }
      getOutputLength(e3, t3) {
        return e3 * (3 + t3);
      }
    };
    DeviceRgbCS = class extends ColorSpace {
      constructor() {
        super("DeviceRGB", 3);
      }
      getRgbItem(e3, t3, i3, a3) {
        i3[a3] = 255 * e3[t3], i3[a3 + 1] = 255 * e3[t3 + 1], i3[a3 + 2] = 255 * e3[t3 + 2];
      }
      getRgbBuffer(e3, t3, i3, a3, s3, n3, r3) {
        if (8 === n3 && 0 === r3) return void a3.set(e3.subarray(t3, t3 + 3 * i3), s3);
        const o3 = 255 / ((1 << n3) - 1);
        let g3 = t3, c3 = s3;
        for (let t4 = 0; t4 < i3; ++t4) a3[c3++] = o3 * e3[g3++], a3[c3++] = o3 * e3[g3++], a3[c3++] = o3 * e3[g3++], c3 += r3;
      }
      getOutputLength(e3, t3) {
        return e3 * (3 + t3) / 3 | 0;
      }
      isPassthrough(e3) {
        return 8 === e3;
      }
    };
    DeviceRgbaCS = class extends ColorSpace {
      constructor() {
        super("DeviceRGBA", 4);
      }
      getOutputLength(e3, t3) {
        return 4 * e3;
      }
      isPassthrough(e3) {
        return 8 === e3;
      }
    };
    DeviceCmykCS = class extends ColorSpace {
      constructor() {
        super("DeviceCMYK", 4);
        __privateAdd(this, _DeviceCmykCS_instances);
      }
      getRgbItem(e3, t3, i3, a3) {
        __privateMethod(this, _DeviceCmykCS_instances, A_fn).call(this, e3, t3, 1, i3, a3);
      }
      getRgbBuffer(e3, t3, i3, a3, s3, n3, r3) {
        const o3 = 1 / ((1 << n3) - 1);
        for (let n4 = 0; n4 < i3; n4++) __privateMethod(this, _DeviceCmykCS_instances, A_fn).call(this, e3, t3, o3, a3, s3), t3 += 4, s3 += 3 + r3;
      }
      getOutputLength(e3, t3) {
        return e3 / 4 * (3 + t3) | 0;
      }
    };
    _DeviceCmykCS_instances = new WeakSet();
    A_fn = function(e3, t3, i3, a3, s3) {
      const n3 = e3[t3] * i3, r3 = e3[t3 + 1] * i3, o3 = e3[t3 + 2] * i3, g3 = e3[t3 + 3] * i3;
      a3[s3] = 255 + n3 * (-4.387332384609988 * n3 + 54.48615194189176 * r3 + 18.82290502165302 * o3 + 212.25662451639585 * g3 - 285.2331026137004) + r3 * (1.7149763477362134 * r3 - 5.6096736904047315 * o3 + -17.873870861415444 * g3 - 5.497006427196366) + o3 * (-2.5217340131683033 * o3 - 21.248923337353073 * g3 + 17.5119270841813) + g3 * (-21.86122147463605 * g3 - 189.48180835922747), a3[s3 + 1] = 255 + n3 * (8.841041422036149 * n3 + 60.118027045597366 * r3 + 6.871425592049007 * o3 + 31.159100130055922 * g3 - 79.2970844816548) + r3 * (-15.310361306967817 * r3 + 17.575251261109482 * o3 + 131.35250912493976 * g3 - 190.9453302588951) + o3 * (4.444339102852739 * o3 + 9.8632861493405 * g3 - 24.86741582555878) + g3 * (-20.737325471181034 * g3 - 187.80453709719578), a3[s3 + 2] = 255 + n3 * (0.8842522430003296 * n3 + 8.078677503112928 * r3 + 30.89978309703729 * o3 - 0.23883238689178934 * g3 - 14.183576799673286) + r3 * (10.49593273432072 * r3 + 63.02378494754052 * o3 + 50.606957656360734 * g3 - 112.23884253719248) + o3 * (0.03296041114873217 * o3 + 115.60384449646641 * g3 - 193.58209356861505) + g3 * (-22.33816807309886 * g3 - 180.12613974708367);
    };
    CalGrayCS = class extends ColorSpace {
      constructor(e3, t3, i3) {
        super("CalGray", 1);
        __privateAdd(this, _CalGrayCS_instances);
        if (!e3) throw new FormatError("WhitePoint missing - required for color space CalGray");
        if ([this.XW, this.YW, this.ZW] = e3, [this.XB, this.YB, this.ZB] = t3 || [0, 0, 0], this.G = i3 || 1, this.XW < 0 || this.ZW < 0 || 1 !== this.YW) throw new FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
        (this.XB < 0 || this.YB < 0 || this.ZB < 0) && (info(`Invalid BlackPoint for ${this.name}, falling back to default.`), this.XB = this.YB = this.ZB = 0), 0 === this.XB && 0 === this.YB && 0 === this.ZB || warn(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`), this.G < 1 && (info(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`), this.G = 1);
      }
      getRgbItem(e3, t3, i3, a3) {
        __privateMethod(this, _CalGrayCS_instances, A_fn2).call(this, e3, t3, i3, a3, 1);
      }
      getRgbBuffer(e3, t3, i3, a3, s3, n3, r3) {
        const o3 = 1 / ((1 << n3) - 1);
        for (let n4 = 0; n4 < i3; ++n4) __privateMethod(this, _CalGrayCS_instances, A_fn2).call(this, e3, t3, a3, s3, o3), t3 += 1, s3 += 3 + r3;
      }
      getOutputLength(e3, t3) {
        return e3 * (3 + t3);
      }
    };
    _CalGrayCS_instances = new WeakSet();
    A_fn2 = function(e3, t3, i3, a3, s3) {
      const n3 = (e3[t3] * s3) ** this.G, r3 = this.YW * n3, o3 = Math.max(295.8 * r3 ** 0.3333333333333333 - 40.8, 0);
      i3[a3] = o3, i3[a3 + 1] = o3, i3[a3 + 2] = o3;
    };
    _CalRGBCS = class _CalRGBCS extends ColorSpace {
      constructor(e3, t3, i3, a3) {
        super("CalRGB", 3);
        __privateAdd(this, _CalRGBCS_instances);
        if (!e3) throw new FormatError("WhitePoint missing - required for color space CalRGB");
        const [s3, n3, r3] = this.whitePoint = e3, [o3, g3, c3] = this.blackPoint = t3 || new Float32Array(3);
        if ([this.GR, this.GG, this.GB] = i3 || new Float32Array([1, 1, 1]), [this.MXA, this.MYA, this.MZA, this.MXB, this.MYB, this.MZB, this.MXC, this.MYC, this.MZC] = a3 || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), s3 < 0 || r3 < 0 || 1 !== n3) throw new FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
        (o3 < 0 || g3 < 0 || c3 < 0) && (info(`Invalid BlackPoint for ${this.name} [${o3}, ${g3}, ${c3}], falling back to default.`), this.blackPoint = new Float32Array(3)), (this.GR < 0 || this.GG < 0 || this.GB < 0) && (info(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`), this.GR = this.GG = this.GB = 1);
      }
      getRgbItem(e3, t3, i3, a3) {
        __privateMethod(this, _CalRGBCS_instances, A_fn3).call(this, e3, t3, i3, a3, 1);
      }
      getRgbBuffer(e3, t3, i3, a3, s3, n3, r3) {
        const o3 = 1 / ((1 << n3) - 1);
        for (let n4 = 0; n4 < i3; ++n4) __privateMethod(this, _CalRGBCS_instances, A_fn3).call(this, e3, t3, a3, s3, o3), t3 += 3, s3 += 3 + r3;
      }
      getOutputLength(e3, t3) {
        return e3 * (3 + t3) / 3 | 0;
      }
    };
    _i2 = new WeakMap();
    _a2 = new WeakMap();
    _s2 = new WeakMap();
    _n = new WeakMap();
    _r = new WeakMap();
    _o = new WeakMap();
    _g = new WeakMap();
    _c = new WeakMap();
    _CalRGBCS_instances = new WeakSet();
    h_fn = function(e3, t3, i3) {
      i3[0] = e3[0] * t3[0] + e3[1] * t3[1] + e3[2] * t3[2], i3[1] = e3[3] * t3[0] + e3[4] * t3[1] + e3[5] * t3[2], i3[2] = e3[6] * t3[0] + e3[7] * t3[1] + e3[8] * t3[2];
    };
    l_fn = function(e3, t3, i3) {
      i3[0] = 1 * t3[0] / e3[0], i3[1] = 1 * t3[1] / e3[1], i3[2] = 1 * t3[2] / e3[2];
    };
    I_fn = function(e3, t3, i3) {
      i3[0] = 0.95047 * t3[0] / e3[0], i3[1] = 1 * t3[1] / e3[1], i3[2] = 1.08883 * t3[2] / e3[2];
    };
    C_fn = function(e3) {
      return e3 <= 31308e-7 ? __privateMethod(this, _CalRGBCS_instances, d_fn).call(this, 0, 1, 12.92 * e3) : e3 >= 0.99554525 ? 1 : __privateMethod(this, _CalRGBCS_instances, d_fn).call(this, 0, 1, 1.055 * e3 ** (1 / 2.4) - 0.055);
    };
    d_fn = function(e3, t3, i3) {
      return Math.max(e3, Math.min(t3, i3));
    };
    B_fn = function(e3) {
      return e3 < 0 ? -__privateMethod(this, _CalRGBCS_instances, B_fn).call(this, -e3) : e3 > 8 ? ((e3 + 16) / 116) ** 3 : e3 * __privateGet(_CalRGBCS, _c);
    };
    u_fn = function(e3, t3, i3) {
      if (0 === e3[0] && 0 === e3[1] && 0 === e3[2]) return i3[0] = t3[0], i3[1] = t3[1], void (i3[2] = t3[2]);
      const a3 = __privateMethod(this, _CalRGBCS_instances, B_fn).call(this, 0), s3 = (1 - a3) / (1 - __privateMethod(this, _CalRGBCS_instances, B_fn).call(this, e3[0])), n3 = 1 - s3, r3 = (1 - a3) / (1 - __privateMethod(this, _CalRGBCS_instances, B_fn).call(this, e3[1])), o3 = 1 - r3, g3 = (1 - a3) / (1 - __privateMethod(this, _CalRGBCS_instances, B_fn).call(this, e3[2])), c3 = 1 - g3;
      i3[0] = t3[0] * s3 + n3, i3[1] = t3[1] * r3 + o3, i3[2] = t3[2] * g3 + c3;
    };
    Q_fn = function(e3, t3, i3) {
      if (1 === e3[0] && 1 === e3[2]) return i3[0] = t3[0], i3[1] = t3[1], void (i3[2] = t3[2]);
      const a3 = i3;
      __privateMethod(this, _CalRGBCS_instances, h_fn).call(this, __privateGet(_CalRGBCS, _i2), t3, a3);
      const s3 = __privateGet(_CalRGBCS, _r);
      __privateMethod(this, _CalRGBCS_instances, l_fn).call(this, e3, a3, s3), __privateMethod(this, _CalRGBCS_instances, h_fn).call(this, __privateGet(_CalRGBCS, _a2), s3, i3);
    };
    E_fn = function(e3, t3, i3) {
      const a3 = i3;
      __privateMethod(this, _CalRGBCS_instances, h_fn).call(this, __privateGet(_CalRGBCS, _i2), t3, a3);
      const s3 = __privateGet(_CalRGBCS, _r);
      __privateMethod(this, _CalRGBCS_instances, I_fn).call(this, e3, a3, s3), __privateMethod(this, _CalRGBCS_instances, h_fn).call(this, __privateGet(_CalRGBCS, _a2), s3, i3);
    };
    A_fn3 = function(e3, t3, i3, a3, s3) {
      const n3 = __privateMethod(this, _CalRGBCS_instances, d_fn).call(this, 0, 1, e3[t3] * s3), r3 = __privateMethod(this, _CalRGBCS_instances, d_fn).call(this, 0, 1, e3[t3 + 1] * s3), o3 = __privateMethod(this, _CalRGBCS_instances, d_fn).call(this, 0, 1, e3[t3 + 2] * s3), g3 = 1 === n3 ? 1 : n3 ** this.GR, c3 = 1 === r3 ? 1 : r3 ** this.GG, h3 = 1 === o3 ? 1 : o3 ** this.GB, l3 = this.MXA * g3 + this.MXB * c3 + this.MXC * h3, C3 = this.MYA * g3 + this.MYB * c3 + this.MYC * h3, d3 = this.MZA * g3 + this.MZB * c3 + this.MZC * h3, u3 = __privateGet(_CalRGBCS, _o);
      u3[0] = l3, u3[1] = C3, u3[2] = d3;
      const Q3 = __privateGet(_CalRGBCS, _g);
      __privateMethod(this, _CalRGBCS_instances, Q_fn).call(this, this.whitePoint, u3, Q3);
      const f3 = __privateGet(_CalRGBCS, _o);
      __privateMethod(this, _CalRGBCS_instances, u_fn).call(this, this.blackPoint, Q3, f3);
      const p3 = __privateGet(_CalRGBCS, _g);
      __privateMethod(this, _CalRGBCS_instances, E_fn).call(this, __privateGet(_CalRGBCS, _n), f3, p3);
      const m3 = __privateGet(_CalRGBCS, _o);
      __privateMethod(this, _CalRGBCS_instances, h_fn).call(this, __privateGet(_CalRGBCS, _s2), p3, m3), i3[a3] = 255 * __privateMethod(this, _CalRGBCS_instances, C_fn).call(this, m3[0]), i3[a3 + 1] = 255 * __privateMethod(this, _CalRGBCS_instances, C_fn).call(this, m3[1]), i3[a3 + 2] = 255 * __privateMethod(this, _CalRGBCS_instances, C_fn).call(this, m3[2]);
    };
    __privateAdd(_CalRGBCS, _i2, new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]));
    __privateAdd(_CalRGBCS, _a2, new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -85287e-7, 0.0400428, 0.9684867]));
    __privateAdd(_CalRGBCS, _s2, new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.969266, 1.8760108, 0.041556, 0.0556434, -0.2040259, 1.0572252]));
    __privateAdd(_CalRGBCS, _n, new Float32Array([1, 1, 1]));
    __privateAdd(_CalRGBCS, _r, new Float32Array(3));
    __privateAdd(_CalRGBCS, _o, new Float32Array(3));
    __privateAdd(_CalRGBCS, _g, new Float32Array(3));
    __privateAdd(_CalRGBCS, _c, (24 / 116) ** 3 / 8);
    CalRGBCS = _CalRGBCS;
    LabCS = class extends ColorSpace {
      constructor(e3, t3, i3) {
        super("Lab", 3);
        __privateAdd(this, _LabCS_instances);
        if (!e3) throw new FormatError("WhitePoint missing - required for color space Lab");
        if ([this.XW, this.YW, this.ZW] = e3, [this.amin, this.amax, this.bmin, this.bmax] = i3 || [-100, 100, -100, 100], [this.XB, this.YB, this.ZB] = t3 || [0, 0, 0], this.XW < 0 || this.ZW < 0 || 1 !== this.YW) throw new FormatError("Invalid WhitePoint components, no fallback available");
        (this.XB < 0 || this.YB < 0 || this.ZB < 0) && (info("Invalid BlackPoint, falling back to default"), this.XB = this.YB = this.ZB = 0), (this.amin > this.amax || this.bmin > this.bmax) && (info("Invalid Range, falling back to defaults"), this.amin = -100, this.amax = 100, this.bmin = -100, this.bmax = 100);
      }
      getRgbItem(e3, t3, i3, a3) {
        __privateMethod(this, _LabCS_instances, A_fn4).call(this, e3, t3, false, i3, a3);
      }
      getRgbBuffer(e3, t3, i3, a3, s3, n3, r3) {
        const o3 = (1 << n3) - 1;
        for (let n4 = 0; n4 < i3; n4++) __privateMethod(this, _LabCS_instances, A_fn4).call(this, e3, t3, o3, a3, s3), t3 += 3, s3 += 3 + r3;
      }
      getOutputLength(e3, t3) {
        return e3 * (3 + t3) / 3 | 0;
      }
      isDefaultDecode(e3, t3) {
        return true;
      }
      get usesZeroToOneRange() {
        return shadow(this, "usesZeroToOneRange", false);
      }
    };
    _LabCS_instances = new WeakSet();
    f_fn = function(e3) {
      return e3 >= 6 / 29 ? e3 ** 3 : 108 / 841 * (e3 - 4 / 29);
    };
    p_fn = function(e3, t3, i3, a3) {
      return i3 + e3 * (a3 - i3) / t3;
    };
    A_fn4 = function(e3, t3, i3, a3, s3) {
      let n3 = e3[t3], r3 = e3[t3 + 1], o3 = e3[t3 + 2];
      false !== i3 && (n3 = __privateMethod(this, _LabCS_instances, p_fn).call(this, n3, i3, 0, 100), r3 = __privateMethod(this, _LabCS_instances, p_fn).call(this, r3, i3, this.amin, this.amax), o3 = __privateMethod(this, _LabCS_instances, p_fn).call(this, o3, i3, this.bmin, this.bmax)), r3 > this.amax ? r3 = this.amax : r3 < this.amin && (r3 = this.amin), o3 > this.bmax ? o3 = this.bmax : o3 < this.bmin && (o3 = this.bmin);
      const g3 = (n3 + 16) / 116, c3 = g3 + r3 / 500, h3 = g3 - o3 / 200, l3 = this.XW * __privateMethod(this, _LabCS_instances, f_fn).call(this, c3), C3 = this.YW * __privateMethod(this, _LabCS_instances, f_fn).call(this, g3), d3 = this.ZW * __privateMethod(this, _LabCS_instances, f_fn).call(this, h3);
      let u3, Q3, f3;
      this.ZW < 1 ? (u3 = 3.1339 * l3 + -1.617 * C3 + -0.4906 * d3, Q3 = -0.9785 * l3 + 1.916 * C3 + 0.0333 * d3, f3 = 0.072 * l3 + -0.229 * C3 + 1.4057 * d3) : (u3 = 3.2406 * l3 + -1.5372 * C3 + -0.4986 * d3, Q3 = -0.9689 * l3 + 1.8758 * C3 + 0.0415 * d3, f3 = 0.0557 * l3 + -0.204 * C3 + 1.057 * d3), a3[s3] = 255 * Math.sqrt(u3), a3[s3 + 1] = 255 * Math.sqrt(Q3), a3[s3 + 2] = 255 * Math.sqrt(f3);
    };
    An = 16;
    BinaryCMapStream = class {
      constructor(e3) {
        this.buffer = e3, this.pos = 0, this.end = e3.length, this.tmpBuf = new Uint8Array(19);
      }
      readByte() {
        return this.pos >= this.end ? -1 : this.buffer[this.pos++];
      }
      readNumber() {
        let e3, t3 = 0;
        do {
          const i3 = this.readByte();
          if (i3 < 0) throw new FormatError("unexpected EOF in bcmap");
          e3 = !(128 & i3), t3 = t3 << 7 | 127 & i3;
        } while (!e3);
        return t3;
      }
      readSigned() {
        const e3 = this.readNumber();
        return 1 & e3 ? ~(e3 >>> 1) : e3 >>> 1;
      }
      readHex(e3, t3) {
        e3.set(this.buffer.subarray(this.pos, this.pos + t3 + 1)), this.pos += t3 + 1;
      }
      readHexNumber(e3, t3) {
        let i3;
        const a3 = this.tmpBuf;
        let s3 = 0;
        do {
          const e4 = this.readByte();
          if (e4 < 0) throw new FormatError("unexpected EOF in bcmap");
          i3 = !(128 & e4), a3[s3++] = 127 & e4;
        } while (!i3);
        let n3 = t3, r3 = 0, o3 = 0;
        for (; n3 >= 0; ) {
          for (; o3 < 8 && a3.length > 0; ) r3 |= a3[--s3] << o3, o3 += 7;
          e3[n3] = 255 & r3, n3--, r3 >>= 8, o3 -= 8;
        }
      }
      readHexSigned(e3, t3) {
        this.readHexNumber(e3, t3);
        const i3 = 1 & e3[t3] ? 255 : 0;
        let a3 = 0;
        for (let s3 = 0; s3 <= t3; s3++) a3 = (1 & a3) << 8 | e3[s3], e3[s3] = a3 >> 1 ^ i3;
      }
      readString() {
        const e3 = this.readNumber(), t3 = new Array(e3);
        for (let i3 = 0; i3 < e3; i3++) t3[i3] = this.readNumber();
        return String.fromCharCode(...t3);
      }
    };
    BinaryCMapReader = class {
      async process(e3, t3, i3) {
        const a3 = new BinaryCMapStream(e3), s3 = a3.readByte();
        t3.vertical = !!(1 & s3);
        let n3 = null;
        const r3 = new Uint8Array(An), o3 = new Uint8Array(An), g3 = new Uint8Array(An), c3 = new Uint8Array(An), h3 = new Uint8Array(An);
        let l3, C3;
        for (; (C3 = a3.readByte()) >= 0; ) {
          const e4 = C3 >> 5;
          if (7 === e4) {
            switch (31 & C3) {
              case 0:
                a3.readString();
                break;
              case 1:
                n3 = a3.readString();
            }
            continue;
          }
          const i4 = !!(16 & C3), s4 = 15 & C3;
          if (s4 + 1 > An) throw new Error("BinaryCMapReader.process: Invalid dataSize.");
          const d3 = 1, u3 = a3.readNumber();
          switch (e4) {
            case 0:
              a3.readHex(r3, s4), a3.readHexNumber(o3, s4), addHex(o3, r3, s4), t3.addCodespaceRange(s4 + 1, hexToInt(r3, s4), hexToInt(o3, s4));
              for (let e5 = 1; e5 < u3; e5++) incHex(o3, s4), a3.readHexNumber(r3, s4), addHex(r3, o3, s4), a3.readHexNumber(o3, s4), addHex(o3, r3, s4), t3.addCodespaceRange(s4 + 1, hexToInt(r3, s4), hexToInt(o3, s4));
              break;
            case 1:
              a3.readHex(r3, s4), a3.readHexNumber(o3, s4), addHex(o3, r3, s4), a3.readNumber();
              for (let e5 = 1; e5 < u3; e5++) incHex(o3, s4), a3.readHexNumber(r3, s4), addHex(r3, o3, s4), a3.readHexNumber(o3, s4), addHex(o3, r3, s4), a3.readNumber();
              break;
            case 2:
              a3.readHex(g3, s4), l3 = a3.readNumber(), t3.mapOne(hexToInt(g3, s4), l3);
              for (let e5 = 1; e5 < u3; e5++) incHex(g3, s4), i4 || (a3.readHexNumber(h3, s4), addHex(g3, h3, s4)), l3 = a3.readSigned() + (l3 + 1), t3.mapOne(hexToInt(g3, s4), l3);
              break;
            case 3:
              a3.readHex(r3, s4), a3.readHexNumber(o3, s4), addHex(o3, r3, s4), l3 = a3.readNumber(), t3.mapCidRange(hexToInt(r3, s4), hexToInt(o3, s4), l3);
              for (let e5 = 1; e5 < u3; e5++) incHex(o3, s4), i4 ? r3.set(o3) : (a3.readHexNumber(r3, s4), addHex(r3, o3, s4)), a3.readHexNumber(o3, s4), addHex(o3, r3, s4), l3 = a3.readNumber(), t3.mapCidRange(hexToInt(r3, s4), hexToInt(o3, s4), l3);
              break;
            case 4:
              a3.readHex(g3, d3), a3.readHex(c3, s4), t3.mapOne(hexToInt(g3, d3), hexToStr(c3, s4));
              for (let e5 = 1; e5 < u3; e5++) incHex(g3, d3), i4 || (a3.readHexNumber(h3, d3), addHex(g3, h3, d3)), incHex(c3, s4), a3.readHexSigned(h3, s4), addHex(c3, h3, s4), t3.mapOne(hexToInt(g3, d3), hexToStr(c3, s4));
              break;
            case 5:
              a3.readHex(r3, d3), a3.readHexNumber(o3, d3), addHex(o3, r3, d3), a3.readHex(c3, s4), t3.mapBfRange(hexToInt(r3, d3), hexToInt(o3, d3), hexToStr(c3, s4));
              for (let e5 = 1; e5 < u3; e5++) incHex(o3, d3), i4 ? r3.set(o3) : (a3.readHexNumber(r3, d3), addHex(r3, o3, d3)), a3.readHexNumber(o3, d3), addHex(o3, r3, d3), a3.readHex(c3, s4), t3.mapBfRange(hexToInt(r3, d3), hexToInt(o3, d3), hexToStr(c3, s4));
              break;
            default:
              throw new Error(`BinaryCMapReader.process - unknown type: ${e4}`);
          }
        }
        return n3 ? i3(n3) : t3;
      }
    };
    an = new Uint8Array(0);
    DecodeStream = class extends BaseStream {
      constructor(e3) {
        if (super(), this._rawMinBufferLength = e3 || 0, this.pos = 0, this.bufferLength = 0, this.eof = false, this.buffer = an, this.minBufferLength = 512, e3) for (; this.minBufferLength < e3; ) this.minBufferLength *= 2;
      }
      get isEmpty() {
        for (; !this.eof && 0 === this.bufferLength; ) this.readBlock();
        return 0 === this.bufferLength;
      }
      ensureBuffer(e3) {
        const t3 = this.buffer;
        if (e3 <= t3.byteLength) return t3;
        let i3 = this.minBufferLength;
        for (; i3 < e3; ) i3 *= 2;
        const a3 = new Uint8Array(i3);
        return a3.set(t3), this.buffer = a3;
      }
      getByte() {
        const e3 = this.pos;
        for (; this.bufferLength <= e3; ) {
          if (this.eof) return -1;
          this.readBlock();
        }
        return this.buffer[this.pos++];
      }
      getBytes(e3, t3 = null) {
        const i3 = this.pos;
        let a3;
        if (e3) {
          for (this.ensureBuffer(i3 + e3), a3 = i3 + e3; !this.eof && this.bufferLength < a3; ) this.readBlock(t3);
          const s3 = this.bufferLength;
          a3 > s3 && (a3 = s3);
        } else {
          for (; !this.eof; ) this.readBlock(t3);
          a3 = this.bufferLength;
        }
        return this.pos = a3, this.buffer.subarray(i3, a3);
      }
      async getImageData(e3, t3 = null) {
        if (!this.canAsyncDecodeImageFromBuffer) return this.getBytes(e3, t3);
        const i3 = await this.stream.asyncGetBytes();
        return this.decodeImage(i3, t3);
      }
      reset() {
        this.pos = 0;
      }
      makeSubStream(e3, t3, i3 = null) {
        if (void 0 === t3) for (; !this.eof; ) this.readBlock();
        else {
          const i4 = e3 + t3;
          for (; this.bufferLength <= i4 && !this.eof; ) this.readBlock();
        }
        return new Stream(this.buffer, e3, t3, i3);
      }
      getBaseStreams() {
        return this.str ? this.str.getBaseStreams() : null;
      }
    };
    StreamsSequenceStream = class extends DecodeStream {
      constructor(e3, t3 = null) {
        let i3 = 0;
        for (const t4 of e3) i3 += t4 instanceof DecodeStream ? t4._rawMinBufferLength : t4.length;
        super(i3), this.streams = e3, this._onError = t3;
      }
      readBlock() {
        const e3 = this.streams;
        if (0 === e3.length) return void (this.eof = true);
        const t3 = e3.shift();
        let i3;
        try {
          i3 = t3.getBytes();
        } catch (e4) {
          if (this._onError) return void this._onError(e4, t3.dict?.objId);
          throw e4;
        }
        const a3 = this.bufferLength, s3 = a3 + i3.length;
        this.ensureBuffer(s3).set(i3, a3), this.bufferLength = s3;
      }
      getBaseStreams() {
        const e3 = [];
        for (const t3 of this.streams) {
          const i3 = t3.getBaseStreams();
          i3 && e3.push(...i3);
        }
        return e3.length > 0 ? e3 : null;
      }
    };
    Ascii85Stream = class extends DecodeStream {
      constructor(e3, t3) {
        t3 && (t3 *= 0.8), super(t3), this.str = e3, this.dict = e3.dict, this.input = new Uint8Array(5);
      }
      readBlock() {
        const e3 = this.str;
        let t3 = e3.getByte();
        for (; isWhiteSpace(t3); ) t3 = e3.getByte();
        if (-1 === t3 || 126 === t3) return void (this.eof = true);
        const i3 = this.bufferLength;
        let a3, s3;
        if (122 === t3) {
          for (a3 = this.ensureBuffer(i3 + 4), s3 = 0; s3 < 4; ++s3) a3[i3 + s3] = 0;
          this.bufferLength += 4;
        } else {
          const n3 = this.input;
          for (n3[0] = t3, s3 = 1; s3 < 5; ++s3) {
            for (t3 = e3.getByte(); isWhiteSpace(t3); ) t3 = e3.getByte();
            if (n3[s3] = t3, -1 === t3 || 126 === t3) break;
          }
          if (a3 = this.ensureBuffer(i3 + s3 - 1), this.bufferLength += s3 - 1, s3 < 5) {
            for (; s3 < 5; ++s3) n3[s3] = 117;
            this.eof = true;
          }
          let r3 = 0;
          for (s3 = 0; s3 < 5; ++s3) r3 = 85 * r3 + (n3[s3] - 33);
          for (s3 = 3; s3 >= 0; --s3) a3[i3 + s3] = 255 & r3, r3 >>= 8;
        }
      }
    };
    AsciiHexStream = class extends DecodeStream {
      constructor(e3, t3) {
        t3 && (t3 *= 0.5), super(t3), this.str = e3, this.dict = e3.dict, this.firstDigit = -1;
      }
      readBlock() {
        const e3 = this.str.getBytes(8e3);
        if (!e3.length) return void (this.eof = true);
        const t3 = e3.length + 1 >> 1, i3 = this.ensureBuffer(this.bufferLength + t3);
        let a3 = this.bufferLength, s3 = this.firstDigit;
        for (const t4 of e3) {
          let e4;
          if (t4 >= 48 && t4 <= 57) e4 = 15 & t4;
          else {
            if (!(t4 >= 65 && t4 <= 70 || t4 >= 97 && t4 <= 102)) {
              if (62 === t4) {
                this.eof = true;
                break;
              }
              continue;
            }
            e4 = 9 + (15 & t4);
          }
          s3 < 0 ? s3 = e4 : (i3[a3++] = s3 << 4 | e4, s3 = -1);
        }
        s3 >= 0 && this.eof && (i3[a3++] = s3 << 4, s3 = -1), this.firstDigit = s3, this.bufferLength = a3;
      }
    };
    sn = -1;
    nn = [[-1, -1], [-1, -1], [7, 8], [7, 7], [6, 6], [6, 6], [6, 5], [6, 5], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]];
    rn = [[-1, -1], [12, -2], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]];
    on = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]];
    gn = [[-1, -1], [-1, -1], [12, -2], [12, -2], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]];
    cn = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]];
    hn = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];
    CCITTFaxDecoder = class {
      constructor(e3, t3 = {}) {
        if (!e3 || "function" != typeof e3.next) throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
        let i3;
        for (this.source = e3, this.eof = false, this.encoding = t3.K || 0, this.eoline = t3.EndOfLine || false, this.byteAlign = t3.EncodedByteAlign || false, this.columns = t3.Columns || 1728, this.rows = t3.Rows || 0, this.eoblock = t3.EndOfBlock ?? true, this.black = t3.BlackIs1 || false, this.codingLine = new Uint32Array(this.columns + 1), this.refLine = new Uint32Array(this.columns + 2), this.codingLine[0] = this.columns, this.codingPos = 0, this.row = 0, this.nextLine2D = this.encoding < 0, this.inputBits = 0, this.inputBuf = 0, this.outputBits = 0, this.rowsDone = false; 0 === (i3 = this._lookBits(12)); ) this._eatBits(1);
        1 === i3 && this._eatBits(12), this.encoding > 0 && (this.nextLine2D = !this._lookBits(1), this._eatBits(1));
      }
      readNextChar() {
        if (this.eof) return -1;
        const e3 = this.refLine, t3 = this.codingLine, i3 = this.columns;
        let a3, s3, n3, r3, o3;
        if (0 === this.outputBits) {
          if (this.rowsDone && (this.eof = true), this.eof) return -1;
          let n4, o4, g3;
          if (this.err = false, this.nextLine2D) {
            for (r3 = 0; t3[r3] < i3; ++r3) e3[r3] = t3[r3];
            for (e3[r3++] = i3, e3[r3] = i3, t3[0] = 0, this.codingPos = 0, a3 = 0, s3 = 0; t3[this.codingPos] < i3; ) switch (n4 = this._getTwoDimCode(), n4) {
              case 0:
                this._addPixels(e3[a3 + 1], s3), e3[a3 + 1] < i3 && (a3 += 2);
                break;
              case 1:
                if (n4 = o4 = 0, s3) {
                  do {
                    n4 += g3 = this._getBlackCode();
                  } while (g3 >= 64);
                  do {
                    o4 += g3 = this._getWhiteCode();
                  } while (g3 >= 64);
                } else {
                  do {
                    n4 += g3 = this._getWhiteCode();
                  } while (g3 >= 64);
                  do {
                    o4 += g3 = this._getBlackCode();
                  } while (g3 >= 64);
                }
                for (this._addPixels(t3[this.codingPos] + n4, s3), t3[this.codingPos] < i3 && this._addPixels(t3[this.codingPos] + o4, 1 ^ s3); e3[a3] <= t3[this.codingPos] && e3[a3] < i3; ) a3 += 2;
                break;
              case 7:
                if (this._addPixels(e3[a3] + 3, s3), s3 ^= 1, t3[this.codingPos] < i3) for (++a3; e3[a3] <= t3[this.codingPos] && e3[a3] < i3; ) a3 += 2;
                break;
              case 5:
                if (this._addPixels(e3[a3] + 2, s3), s3 ^= 1, t3[this.codingPos] < i3) for (++a3; e3[a3] <= t3[this.codingPos] && e3[a3] < i3; ) a3 += 2;
                break;
              case 3:
                if (this._addPixels(e3[a3] + 1, s3), s3 ^= 1, t3[this.codingPos] < i3) for (++a3; e3[a3] <= t3[this.codingPos] && e3[a3] < i3; ) a3 += 2;
                break;
              case 2:
                if (this._addPixels(e3[a3], s3), s3 ^= 1, t3[this.codingPos] < i3) for (++a3; e3[a3] <= t3[this.codingPos] && e3[a3] < i3; ) a3 += 2;
                break;
              case 8:
                if (this._addPixelsNeg(e3[a3] - 3, s3), s3 ^= 1, t3[this.codingPos] < i3) for (a3 > 0 ? --a3 : ++a3; e3[a3] <= t3[this.codingPos] && e3[a3] < i3; ) a3 += 2;
                break;
              case 6:
                if (this._addPixelsNeg(e3[a3] - 2, s3), s3 ^= 1, t3[this.codingPos] < i3) for (a3 > 0 ? --a3 : ++a3; e3[a3] <= t3[this.codingPos] && e3[a3] < i3; ) a3 += 2;
                break;
              case 4:
                if (this._addPixelsNeg(e3[a3] - 1, s3), s3 ^= 1, t3[this.codingPos] < i3) for (a3 > 0 ? --a3 : ++a3; e3[a3] <= t3[this.codingPos] && e3[a3] < i3; ) a3 += 2;
                break;
              case sn:
                this._addPixels(i3, 0), this.eof = true;
                break;
              default:
                info("bad 2d code"), this._addPixels(i3, 0), this.err = true;
            }
          } else for (t3[0] = 0, this.codingPos = 0, s3 = 0; t3[this.codingPos] < i3; ) {
            if (n4 = 0, s3) do {
              n4 += g3 = this._getBlackCode();
            } while (g3 >= 64);
            else do {
              n4 += g3 = this._getWhiteCode();
            } while (g3 >= 64);
            this._addPixels(t3[this.codingPos] + n4, s3), s3 ^= 1;
          }
          let c3 = false;
          if (this.byteAlign && (this.inputBits &= -8), this.eoblock || this.row !== this.rows - 1) {
            if (n4 = this._lookBits(12), this.eoline) for (; n4 !== sn && 1 !== n4; ) this._eatBits(1), n4 = this._lookBits(12);
            else for (; 0 === n4; ) this._eatBits(1), n4 = this._lookBits(12);
            1 === n4 ? (this._eatBits(12), c3 = true) : n4 === sn && (this.eof = true);
          } else this.rowsDone = true;
          if (!this.eof && this.encoding > 0 && !this.rowsDone && (this.nextLine2D = !this._lookBits(1), this._eatBits(1)), this.eoblock && c3 && this.byteAlign) {
            if (n4 = this._lookBits(12), 1 === n4) {
              if (this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1)), this.encoding >= 0) for (r3 = 0; r3 < 4; ++r3) n4 = this._lookBits(12), 1 !== n4 && info("bad rtc code: " + n4), this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1));
              this.eof = true;
            }
          } else if (this.err && this.eoline) {
            for (; ; ) {
              if (n4 = this._lookBits(13), n4 === sn) return this.eof = true, -1;
              if (n4 >> 1 == 1) break;
              this._eatBits(1);
            }
            this._eatBits(12), this.encoding > 0 && (this._eatBits(1), this.nextLine2D = !(1 & n4));
          }
          this.outputBits = t3[0] > 0 ? t3[this.codingPos = 0] : t3[this.codingPos = 1], this.row++;
        }
        if (this.outputBits >= 8) o3 = 1 & this.codingPos ? 0 : 255, this.outputBits -= 8, 0 === this.outputBits && t3[this.codingPos] < i3 && (this.codingPos++, this.outputBits = t3[this.codingPos] - t3[this.codingPos - 1]);
        else {
          n3 = 8, o3 = 0;
          do {
            if ("number" != typeof this.outputBits) throw new FormatError('Invalid /CCITTFaxDecode data, "outputBits" must be a number.');
            this.outputBits > n3 ? (o3 <<= n3, 1 & this.codingPos || (o3 |= 255 >> 8 - n3), this.outputBits -= n3, n3 = 0) : (o3 <<= this.outputBits, 1 & this.codingPos || (o3 |= 255 >> 8 - this.outputBits), n3 -= this.outputBits, this.outputBits = 0, t3[this.codingPos] < i3 ? (this.codingPos++, this.outputBits = t3[this.codingPos] - t3[this.codingPos - 1]) : n3 > 0 && (o3 <<= n3, n3 = 0));
          } while (n3);
        }
        return this.black && (o3 ^= 255), o3;
      }
      _addPixels(e3, t3) {
        const i3 = this.codingLine;
        let a3 = this.codingPos;
        e3 > i3[a3] && (e3 > this.columns && (info("row is wrong length"), this.err = true, e3 = this.columns), 1 & a3 ^ t3 && ++a3, i3[a3] = e3), this.codingPos = a3;
      }
      _addPixelsNeg(e3, t3) {
        const i3 = this.codingLine;
        let a3 = this.codingPos;
        if (e3 > i3[a3]) e3 > this.columns && (info("row is wrong length"), this.err = true, e3 = this.columns), 1 & a3 ^ t3 && ++a3, i3[a3] = e3;
        else if (e3 < i3[a3]) {
          for (e3 < 0 && (info("invalid code"), this.err = true, e3 = 0); a3 > 0 && e3 < i3[a3 - 1]; ) --a3;
          i3[a3] = e3;
        }
        this.codingPos = a3;
      }
      _findTableCode(e3, t3, i3, a3) {
        const s3 = a3 || 0;
        for (let a4 = e3; a4 <= t3; ++a4) {
          let e4 = this._lookBits(a4);
          if (e4 === sn) return [true, 1, false];
          if (a4 < t3 && (e4 <<= t3 - a4), !s3 || e4 >= s3) {
            const t4 = i3[e4 - s3];
            if (t4[0] === a4) return this._eatBits(a4), [true, t4[1], true];
          }
        }
        return [false, 0, false];
      }
      _getTwoDimCode() {
        let e3, t3 = 0;
        if (this.eoblock) {
          if (t3 = this._lookBits(7), e3 = nn[t3], e3?.[0] > 0) return this._eatBits(e3[0]), e3[1];
        } else {
          const e4 = this._findTableCode(1, 7, nn);
          if (e4[0] && e4[2]) return e4[1];
        }
        return info("Bad two dim code"), sn;
      }
      _getWhiteCode() {
        let e3, t3 = 0;
        if (this.eoblock) {
          if (t3 = this._lookBits(12), t3 === sn) return 1;
          if (e3 = t3 >> 5 ? on[t3 >> 3] : rn[t3], e3[0] > 0) return this._eatBits(e3[0]), e3[1];
        } else {
          let e4 = this._findTableCode(1, 9, on);
          if (e4[0]) return e4[1];
          if (e4 = this._findTableCode(11, 12, rn), e4[0]) return e4[1];
        }
        return info("bad white code"), this._eatBits(1), 1;
      }
      _getBlackCode() {
        let e3, t3;
        if (this.eoblock) {
          if (e3 = this._lookBits(13), e3 === sn) return 1;
          if (t3 = e3 >> 7 ? !(e3 >> 9) && e3 >> 7 ? cn[(e3 >> 1) - 64] : hn[e3 >> 7] : gn[e3], t3[0] > 0) return this._eatBits(t3[0]), t3[1];
        } else {
          let e4 = this._findTableCode(2, 6, hn);
          if (e4[0]) return e4[1];
          if (e4 = this._findTableCode(7, 12, cn, 64), e4[0]) return e4[1];
          if (e4 = this._findTableCode(10, 13, gn), e4[0]) return e4[1];
        }
        return info("bad black code"), this._eatBits(1), 1;
      }
      _lookBits(e3) {
        let t3;
        for (; this.inputBits < e3; ) {
          if (-1 === (t3 = this.source.next())) return 0 === this.inputBits ? sn : this.inputBuf << e3 - this.inputBits & 65535 >> 16 - e3;
          this.inputBuf = this.inputBuf << 8 | t3, this.inputBits += 8;
        }
        return this.inputBuf >> this.inputBits - e3 & 65535 >> 16 - e3;
      }
      _eatBits(e3) {
        (this.inputBits -= e3) < 0 && (this.inputBits = 0);
      }
    };
    CCITTFaxStream = class extends DecodeStream {
      constructor(e3, t3, i3) {
        super(t3), this.str = e3, this.dict = e3.dict, i3 instanceof Dict || (i3 = Dict.empty);
        const a3 = { next: () => e3.getByte() };
        this.ccittFaxDecoder = new CCITTFaxDecoder(a3, { K: i3.get("K"), EndOfLine: i3.get("EndOfLine"), EncodedByteAlign: i3.get("EncodedByteAlign"), Columns: i3.get("Columns"), Rows: i3.get("Rows"), EndOfBlock: i3.get("EndOfBlock"), BlackIs1: i3.get("BlackIs1") });
      }
      readBlock() {
        for (; !this.eof; ) {
          const e3 = this.ccittFaxDecoder.readNextChar();
          if (-1 === e3) return void (this.eof = true);
          this.ensureBuffer(this.bufferLength + 1), this.buffer[this.bufferLength++] = e3;
        }
      }
    };
    ln = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    In = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]);
    Cn = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]);
    dn = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9];
    Bn = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
    FlateStream = class extends DecodeStream {
      constructor(e3, t3) {
        super(t3);
        __privateAdd(this, _FlateStream_instances);
        this.str = e3, this.dict = e3.dict;
        const i3 = e3.getByte(), a3 = e3.getByte();
        if (-1 === i3 || -1 === a3) throw new FormatError(`Invalid header in flate stream: ${i3}, ${a3}`);
        if (8 != (15 & i3)) throw new FormatError(`Unknown compression method in flate stream: ${i3}, ${a3}`);
        if (((i3 << 8) + a3) % 31 != 0) throw new FormatError(`Bad FCHECK in flate stream: ${i3}, ${a3}`);
        if (32 & a3) throw new FormatError(`FDICT bit set in flate stream: ${i3}, ${a3}`);
        this.codeSize = 0, this.codeBuf = 0;
      }
      async getImageData(e3, t3) {
        const i3 = await this.asyncGetBytes();
        return i3?.subarray(0, e3) || this.getBytes(e3);
      }
      async asyncGetBytes() {
        this.str.reset();
        const e3 = this.str.getBytes();
        try {
          const { readable: t3, writable: i3 } = new DecompressionStream("deflate"), a3 = i3.getWriter();
          a3.write(e3), a3.close();
          const s3 = [];
          let n3 = 0;
          for await (const e4 of t3) s3.push(e4), n3 += e4.byteLength;
          const r3 = new Uint8Array(n3);
          let o3 = 0;
          for (const e4 of s3) r3.set(e4, o3), o3 += e4.byteLength;
          return r3;
        } catch {
          return this.str = new Stream(e3, 2, e3.length, this.str.dict), this.reset(), null;
        }
      }
      get isAsync() {
        return true;
      }
      getBits(e3) {
        const t3 = this.str;
        let i3, a3 = this.codeSize, s3 = this.codeBuf;
        for (; a3 < e3; ) {
          if (-1 === (i3 = t3.getByte())) throw new FormatError("Bad encoding in flate stream");
          s3 |= i3 << a3, a3 += 8;
        }
        return i3 = s3 & (1 << e3) - 1, this.codeBuf = s3 >> e3, this.codeSize = a3 -= e3, i3;
      }
      getCode(e3) {
        const t3 = this.str, i3 = e3[0], a3 = e3[1];
        let s3, n3 = this.codeSize, r3 = this.codeBuf;
        for (; n3 < a3 && -1 !== (s3 = t3.getByte()); ) r3 |= s3 << n3, n3 += 8;
        const o3 = i3[r3 & (1 << a3) - 1], g3 = o3 >> 16, c3 = 65535 & o3;
        if (g3 < 1 || n3 < g3) throw new FormatError("Bad encoding in flate stream");
        return this.codeBuf = r3 >> g3, this.codeSize = n3 - g3, c3;
      }
      generateHuffmanTable(e3) {
        const t3 = e3.length;
        let i3, a3 = 0;
        for (i3 = 0; i3 < t3; ++i3) e3[i3] > a3 && (a3 = e3[i3]);
        const s3 = 1 << a3, n3 = new Int32Array(s3);
        for (let r3 = 1, o3 = 0, g3 = 2; r3 <= a3; ++r3, o3 <<= 1, g3 <<= 1) for (let a4 = 0; a4 < t3; ++a4) if (e3[a4] === r3) {
          let e4 = 0, t4 = o3;
          for (i3 = 0; i3 < r3; ++i3) e4 = e4 << 1 | 1 & t4, t4 >>= 1;
          for (i3 = e4; i3 < s3; i3 += g3) n3[i3] = r3 << 16 | a4;
          ++o3;
        }
        return [n3, a3];
      }
      readBlock() {
        let e3, t3, i3;
        const a3 = this.str;
        try {
          t3 = this.getBits(3);
        } catch (e4) {
          return void __privateMethod(this, _FlateStream_instances, m_fn).call(this, e4.message);
        }
        if (1 & t3 && (this.eof = true), t3 >>= 1, 0 === t3) {
          let t4;
          if (-1 === (t4 = a3.getByte())) return void __privateMethod(this, _FlateStream_instances, m_fn).call(this, "Bad block header in flate stream");
          let i4 = t4;
          if (-1 === (t4 = a3.getByte())) return void __privateMethod(this, _FlateStream_instances, m_fn).call(this, "Bad block header in flate stream");
          if (i4 |= t4 << 8, -1 === (t4 = a3.getByte())) return void __privateMethod(this, _FlateStream_instances, m_fn).call(this, "Bad block header in flate stream");
          let s4 = t4;
          if (-1 === (t4 = a3.getByte())) return void __privateMethod(this, _FlateStream_instances, m_fn).call(this, "Bad block header in flate stream");
          if (s4 |= t4 << 8, s4 !== (65535 & ~i4) && (0 !== i4 || 0 !== s4)) throw new FormatError("Bad uncompressed block length in flate stream");
          this.codeBuf = 0, this.codeSize = 0;
          const n4 = this.bufferLength, r4 = n4 + i4;
          if (e3 = this.ensureBuffer(r4), this.bufferLength = r4, 0 === i4) -1 === a3.peekByte() && (this.eof = true);
          else {
            const t5 = a3.getBytes(i4);
            e3.set(t5, n4), t5.length < i4 && (this.eof = true);
          }
          return;
        }
        let s3, n3;
        if (1 === t3) s3 = dn, n3 = Bn;
        else {
          if (2 !== t3) throw new FormatError("Unknown block type in flate stream");
          {
            const e4 = this.getBits(5) + 257, t4 = this.getBits(5) + 1, a4 = this.getBits(4) + 4, r4 = new Uint8Array(ln.length);
            let o4;
            for (o4 = 0; o4 < a4; ++o4) r4[ln[o4]] = this.getBits(3);
            const g3 = this.generateHuffmanTable(r4);
            i3 = 0, o4 = 0;
            const c3 = e4 + t4, h3 = new Uint8Array(c3);
            let l3, C3, d3;
            for (; o4 < c3; ) {
              const e5 = this.getCode(g3);
              if (16 === e5) l3 = 2, C3 = 3, d3 = i3;
              else if (17 === e5) l3 = 3, C3 = 3, d3 = i3 = 0;
              else {
                if (18 !== e5) {
                  h3[o4++] = i3 = e5;
                  continue;
                }
                l3 = 7, C3 = 11, d3 = i3 = 0;
              }
              let t5 = this.getBits(l3) + C3;
              for (; t5-- > 0; ) h3[o4++] = d3;
            }
            s3 = this.generateHuffmanTable(h3.subarray(0, e4)), n3 = this.generateHuffmanTable(h3.subarray(e4, c3));
          }
        }
        e3 = this.buffer;
        let r3 = e3 ? e3.length : 0, o3 = this.bufferLength;
        for (; ; ) {
          let t4 = this.getCode(s3);
          if (t4 < 256) {
            o3 + 1 >= r3 && (e3 = this.ensureBuffer(o3 + 1), r3 = e3.length), e3[o3++] = t4;
            continue;
          }
          if (256 === t4) return void (this.bufferLength = o3);
          t4 -= 257, t4 = In[t4];
          let a4 = t4 >> 16;
          a4 > 0 && (a4 = this.getBits(a4)), i3 = (65535 & t4) + a4, t4 = this.getCode(n3), t4 = Cn[t4], a4 = t4 >> 16, a4 > 0 && (a4 = this.getBits(a4));
          const g3 = (65535 & t4) + a4;
          o3 + i3 >= r3 && (e3 = this.ensureBuffer(o3 + i3), r3 = e3.length);
          for (let t5 = 0; t5 < i3; ++t5, ++o3) e3[o3] = e3[o3 - g3];
        }
      }
    };
    _FlateStream_instances = new WeakSet();
    m_fn = function(e3) {
      info(e3), this.eof = true;
    };
    un = [{ qe: 22017, nmps: 1, nlps: 1, switchFlag: 1 }, { qe: 13313, nmps: 2, nlps: 6, switchFlag: 0 }, { qe: 6145, nmps: 3, nlps: 9, switchFlag: 0 }, { qe: 2753, nmps: 4, nlps: 12, switchFlag: 0 }, { qe: 1313, nmps: 5, nlps: 29, switchFlag: 0 }, { qe: 545, nmps: 38, nlps: 33, switchFlag: 0 }, { qe: 22017, nmps: 7, nlps: 6, switchFlag: 1 }, { qe: 21505, nmps: 8, nlps: 14, switchFlag: 0 }, { qe: 18433, nmps: 9, nlps: 14, switchFlag: 0 }, { qe: 14337, nmps: 10, nlps: 14, switchFlag: 0 }, { qe: 12289, nmps: 11, nlps: 17, switchFlag: 0 }, { qe: 9217, nmps: 12, nlps: 18, switchFlag: 0 }, { qe: 7169, nmps: 13, nlps: 20, switchFlag: 0 }, { qe: 5633, nmps: 29, nlps: 21, switchFlag: 0 }, { qe: 22017, nmps: 15, nlps: 14, switchFlag: 1 }, { qe: 21505, nmps: 16, nlps: 14, switchFlag: 0 }, { qe: 20737, nmps: 17, nlps: 15, switchFlag: 0 }, { qe: 18433, nmps: 18, nlps: 16, switchFlag: 0 }, { qe: 14337, nmps: 19, nlps: 17, switchFlag: 0 }, { qe: 13313, nmps: 20, nlps: 18, switchFlag: 0 }, { qe: 12289, nmps: 21, nlps: 19, switchFlag: 0 }, { qe: 10241, nmps: 22, nlps: 19, switchFlag: 0 }, { qe: 9217, nmps: 23, nlps: 20, switchFlag: 0 }, { qe: 8705, nmps: 24, nlps: 21, switchFlag: 0 }, { qe: 7169, nmps: 25, nlps: 22, switchFlag: 0 }, { qe: 6145, nmps: 26, nlps: 23, switchFlag: 0 }, { qe: 5633, nmps: 27, nlps: 24, switchFlag: 0 }, { qe: 5121, nmps: 28, nlps: 25, switchFlag: 0 }, { qe: 4609, nmps: 29, nlps: 26, switchFlag: 0 }, { qe: 4353, nmps: 30, nlps: 27, switchFlag: 0 }, { qe: 2753, nmps: 31, nlps: 28, switchFlag: 0 }, { qe: 2497, nmps: 32, nlps: 29, switchFlag: 0 }, { qe: 2209, nmps: 33, nlps: 30, switchFlag: 0 }, { qe: 1313, nmps: 34, nlps: 31, switchFlag: 0 }, { qe: 1089, nmps: 35, nlps: 32, switchFlag: 0 }, { qe: 673, nmps: 36, nlps: 33, switchFlag: 0 }, { qe: 545, nmps: 37, nlps: 34, switchFlag: 0 }, { qe: 321, nmps: 38, nlps: 35, switchFlag: 0 }, { qe: 273, nmps: 39, nlps: 36, switchFlag: 0 }, { qe: 133, nmps: 40, nlps: 37, switchFlag: 0 }, { qe: 73, nmps: 41, nlps: 38, switchFlag: 0 }, { qe: 37, nmps: 42, nlps: 39, switchFlag: 0 }, { qe: 21, nmps: 43, nlps: 40, switchFlag: 0 }, { qe: 9, nmps: 44, nlps: 41, switchFlag: 0 }, { qe: 5, nmps: 45, nlps: 42, switchFlag: 0 }, { qe: 1, nmps: 45, nlps: 43, switchFlag: 0 }, { qe: 22017, nmps: 46, nlps: 46, switchFlag: 0 }];
    ArithmeticDecoder = class {
      constructor(e3, t3, i3) {
        this.data = e3, this.bp = t3, this.dataEnd = i3, this.chigh = e3[t3], this.clow = 0, this.byteIn(), this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127, this.clow = this.clow << 7 & 65535, this.ct -= 7, this.a = 32768;
      }
      byteIn() {
        const e3 = this.data;
        let t3 = this.bp;
        255 === e3[t3] ? e3[t3 + 1] > 143 ? (this.clow += 65280, this.ct = 8) : (t3++, this.clow += e3[t3] << 9, this.ct = 7, this.bp = t3) : (t3++, this.clow += t3 < this.dataEnd ? e3[t3] << 8 : 65280, this.ct = 8, this.bp = t3), this.clow > 65535 && (this.chigh += this.clow >> 16, this.clow &= 65535);
      }
      readBit(e3, t3) {
        let i3 = e3[t3] >> 1, a3 = 1 & e3[t3];
        const s3 = un[i3], n3 = s3.qe;
        let r3, o3 = this.a - n3;
        if (this.chigh < n3) o3 < n3 ? (o3 = n3, r3 = a3, i3 = s3.nmps) : (o3 = n3, r3 = 1 ^ a3, 1 === s3.switchFlag && (a3 = r3), i3 = s3.nlps);
        else {
          if (this.chigh -= n3, 32768 & o3) return this.a = o3, a3;
          o3 < n3 ? (r3 = 1 ^ a3, 1 === s3.switchFlag && (a3 = r3), i3 = s3.nlps) : (r3 = a3, i3 = s3.nmps);
        }
        do {
          0 === this.ct && this.byteIn(), o3 <<= 1, this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1, this.clow = this.clow << 1 & 65535, this.ct--;
        } while (!(32768 & o3));
        return this.a = o3, e3[t3] = i3 << 1 | a3, r3;
      }
    };
    Jbig2Error = class extends Ms {
      constructor(e3) {
        super(e3, "Jbig2Error");
      }
    };
    ContextCache = class {
      getContexts(e3) {
        return e3 in this ? this[e3] : this[e3] = new Int8Array(65536);
      }
    };
    DecodingContext = class {
      constructor(e3, t3, i3) {
        this.data = e3, this.start = t3, this.end = i3;
      }
      get decoder() {
        return shadow(this, "decoder", new ArithmeticDecoder(this.data, this.start, this.end));
      }
      get contextCache() {
        return shadow(this, "contextCache", new ContextCache());
      }
    };
    Qn = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"];
    En = [[{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: -4, y: 0 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: 2, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -3, y: -1 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -4, y: 0 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }]];
    pn = [{ coding: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }], reference: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }, { x: 0, y: 0 }, { x: 1, y: 0 }, { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }] }, { coding: [{ x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }], reference: [{ x: 0, y: -1 }, { x: -1, y: 0 }, { x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }] }];
    mn = [39717, 1941, 229, 405];
    yn = 17;
    SimpleSegmentVisitor = class {
      onPageInformation(e3) {
        this.currentPageInfo = e3;
        const t3 = e3.width + 7 >> 3, i3 = new Uint8ClampedArray(t3 * e3.height);
        e3.defaultPixelValue && i3.fill(255), this.buffer = i3;
      }
      drawBitmap(e3, t3) {
        const i3 = this.currentPageInfo, a3 = e3.width, s3 = e3.height, n3 = i3.width + 7 >> 3, r3 = i3.combinationOperatorOverride ? e3.combinationOperator : i3.combinationOperator, o3 = this.buffer, g3 = 128 >> (7 & e3.x);
        let c3, h3, l3, C3, d3 = e3.y * n3 + (e3.x >> 3);
        switch (r3) {
          case 0:
            for (c3 = 0; c3 < s3; c3++) {
              for (l3 = g3, C3 = d3, h3 = 0; h3 < a3; h3++) t3[c3][h3] && (o3[C3] |= l3), l3 >>= 1, l3 || (l3 = 128, C3++);
              d3 += n3;
            }
            break;
          case 2:
            for (c3 = 0; c3 < s3; c3++) {
              for (l3 = g3, C3 = d3, h3 = 0; h3 < a3; h3++) t3[c3][h3] && (o3[C3] ^= l3), l3 >>= 1, l3 || (l3 = 128, C3++);
              d3 += n3;
            }
            break;
          default:
            throw new Jbig2Error(`operator ${r3} is not supported`);
        }
      }
      onImmediateGenericRegion(e3, t3, i3, a3) {
        const s3 = e3.info, n3 = new DecodingContext(t3, i3, a3), r3 = decodeBitmap(e3.mmr, s3.width, s3.height, e3.template, e3.prediction, null, e3.at, n3);
        this.drawBitmap(s3, r3);
      }
      onImmediateLosslessGenericRegion() {
        this.onImmediateGenericRegion(...arguments);
      }
      onSymbolDictionary(e3, t3, i3, a3, s3, n3) {
        let r3, o3;
        e3.huffman && (r3 = function(e4, t4, i4) {
          let a4, s4, n4, r4, o4 = 0;
          switch (e4.huffmanDHSelector) {
            case 0:
            case 1:
              a4 = getStandardTable(e4.huffmanDHSelector + 4);
              break;
            case 3:
              a4 = getCustomHuffmanTable(o4, t4, i4), o4++;
              break;
            default:
              throw new Jbig2Error("invalid Huffman DH selector");
          }
          switch (e4.huffmanDWSelector) {
            case 0:
            case 1:
              s4 = getStandardTable(e4.huffmanDWSelector + 2);
              break;
            case 3:
              s4 = getCustomHuffmanTable(o4, t4, i4), o4++;
              break;
            default:
              throw new Jbig2Error("invalid Huffman DW selector");
          }
          e4.bitmapSizeSelector ? (n4 = getCustomHuffmanTable(o4, t4, i4), o4++) : n4 = getStandardTable(1);
          r4 = e4.aggregationInstancesSelector ? getCustomHuffmanTable(o4, t4, i4) : getStandardTable(1);
          return { tableDeltaHeight: a4, tableDeltaWidth: s4, tableBitmapSize: n4, tableAggregateInstances: r4 };
        }(e3, i3, this.customTables), o3 = new Reader(a3, s3, n3));
        let g3 = this.symbols;
        g3 || (this.symbols = g3 = {});
        const c3 = [];
        for (const e4 of i3) {
          const t4 = g3[e4];
          t4 && c3.push(...t4);
        }
        const h3 = new DecodingContext(a3, s3, n3);
        g3[t3] = function(e4, t4, i4, a4, s4, n4, r4, o4, g4, c4, h4, l3) {
          if (e4 && t4) throw new Jbig2Error("symbol refinement with Huffman is not supported");
          const C3 = [];
          let d3 = 0, u3 = log2(i4.length + a4);
          const Q3 = h4.decoder, f3 = h4.contextCache;
          let p3, m3;
          for (e4 && (p3 = getStandardTable(1), m3 = [], u3 = Math.max(u3, 1)); C3.length < a4; ) {
            d3 += e4 ? n4.tableDeltaHeight.decode(l3) : decodeInteger(f3, "IADH", Q3);
            let a5 = 0, s5 = 0;
            const p4 = e4 ? m3.length : 0;
            for (; ; ) {
              const p5 = e4 ? n4.tableDeltaWidth.decode(l3) : decodeInteger(f3, "IADW", Q3);
              if (null === p5) break;
              let y4;
              if (a5 += p5, s5 += a5, t4) {
                const s6 = decodeInteger(f3, "IAAI", Q3);
                if (s6 > 1) y4 = decodeTextRegion(e4, t4, a5, d3, 0, s6, 1, i4.concat(C3), u3, 0, 0, 1, 0, n4, g4, c4, h4, 0, l3);
                else {
                  const e5 = decodeIAID(f3, Q3, u3), t5 = decodeInteger(f3, "IARDX", Q3), s7 = decodeInteger(f3, "IARDY", Q3);
                  y4 = decodeRefinement(a5, d3, g4, e5 < i4.length ? i4[e5] : C3[e5 - i4.length], t5, s7, 0, c4, h4);
                }
                C3.push(y4);
              } else e4 ? m3.push(a5) : (y4 = decodeBitmap(false, a5, d3, r4, false, null, o4, h4), C3.push(y4));
            }
            if (e4 && !t4) {
              const e5 = n4.tableBitmapSize.decode(l3);
              let t5;
              if (l3.byteAlign(), 0 === e5) t5 = readUncompressedBitmap(l3, s5, d3);
              else {
                const i6 = l3.end, a6 = l3.position + e5;
                l3.end = a6, t5 = decodeMMRBitmap(l3, s5, d3, false), l3.end = i6, l3.position = a6;
              }
              const i5 = m3.length;
              if (p4 === i5 - 1) C3.push(t5);
              else {
                let e6, a6, s6, n5, r5, o5 = 0;
                for (e6 = p4; e6 < i5; e6++) {
                  for (n5 = m3[e6], s6 = o5 + n5, r5 = [], a6 = 0; a6 < d3; a6++) r5.push(t5[a6].subarray(o5, s6));
                  C3.push(r5), o5 = s6;
                }
              }
            }
          }
          const y3 = [], w3 = [];
          let b3, D3, S3 = false;
          const F3 = i4.length + a4;
          for (; w3.length < F3; ) {
            let t5 = e4 ? p3.decode(l3) : decodeInteger(f3, "IAEX", Q3);
            for (; t5--; ) w3.push(S3);
            S3 = !S3;
          }
          for (b3 = 0, D3 = i4.length; b3 < D3; b3++) w3[b3] && y3.push(i4[b3]);
          for (let e5 = 0; e5 < a4; b3++, e5++) w3[b3] && y3.push(C3[e5]);
          return y3;
        }(e3.huffman, e3.refinement, c3, e3.numberOfNewSymbols, e3.numberOfExportedSymbols, r3, e3.template, e3.at, e3.refinementTemplate, e3.refinementAt, h3, o3);
      }
      onImmediateTextRegion(e3, t3, i3, a3, s3) {
        const n3 = e3.info;
        let r3, o3;
        const g3 = this.symbols, c3 = [];
        for (const e4 of t3) {
          const t4 = g3[e4];
          t4 && c3.push(...t4);
        }
        const h3 = log2(c3.length);
        e3.huffman && (o3 = new Reader(i3, a3, s3), r3 = function(e4, t4, i4, a4, s4) {
          const n4 = [];
          for (let e5 = 0; e5 <= 34; e5++) {
            const t5 = s4.readBits(4);
            n4.push(new HuffmanLine([e5, t5, 0, 0]));
          }
          const r4 = new HuffmanTable(n4, false);
          n4.length = 0;
          for (let e5 = 0; e5 < a4; ) {
            const t5 = r4.decode(s4);
            if (t5 >= 32) {
              let i5, a5, r5;
              switch (t5) {
                case 32:
                  if (0 === e5) throw new Jbig2Error("no previous value in symbol ID table");
                  a5 = s4.readBits(2) + 3, i5 = n4[e5 - 1].prefixLength;
                  break;
                case 33:
                  a5 = s4.readBits(3) + 3, i5 = 0;
                  break;
                case 34:
                  a5 = s4.readBits(7) + 11, i5 = 0;
                  break;
                default:
                  throw new Jbig2Error("invalid code length in symbol ID table");
              }
              for (r5 = 0; r5 < a5; r5++) n4.push(new HuffmanLine([e5, i5, 0, 0])), e5++;
            } else n4.push(new HuffmanLine([e5, t5, 0, 0])), e5++;
          }
          s4.byteAlign();
          const o4 = new HuffmanTable(n4, false);
          let g4, c4, h4, l4 = 0;
          switch (e4.huffmanFS) {
            case 0:
            case 1:
              g4 = getStandardTable(e4.huffmanFS + 6);
              break;
            case 3:
              g4 = getCustomHuffmanTable(l4, t4, i4), l4++;
              break;
            default:
              throw new Jbig2Error("invalid Huffman FS selector");
          }
          switch (e4.huffmanDS) {
            case 0:
            case 1:
            case 2:
              c4 = getStandardTable(e4.huffmanDS + 8);
              break;
            case 3:
              c4 = getCustomHuffmanTable(l4, t4, i4), l4++;
              break;
            default:
              throw new Jbig2Error("invalid Huffman DS selector");
          }
          switch (e4.huffmanDT) {
            case 0:
            case 1:
            case 2:
              h4 = getStandardTable(e4.huffmanDT + 11);
              break;
            case 3:
              h4 = getCustomHuffmanTable(l4, t4, i4), l4++;
              break;
            default:
              throw new Jbig2Error("invalid Huffman DT selector");
          }
          if (e4.refinement) throw new Jbig2Error("refinement with Huffman is not supported");
          return { symbolIDTable: o4, tableFirstS: g4, tableDeltaS: c4, tableDeltaT: h4 };
        }(e3, t3, this.customTables, c3.length, o3));
        const l3 = new DecodingContext(i3, a3, s3), C3 = decodeTextRegion(e3.huffman, e3.refinement, n3.width, n3.height, e3.defaultPixelValue, e3.numberOfSymbolInstances, e3.stripSize, c3, h3, e3.transposed, e3.dsOffset, e3.referenceCorner, e3.combinationOperator, r3, e3.refinementTemplate, e3.refinementAt, l3, e3.logStripSize, o3);
        this.drawBitmap(n3, C3);
      }
      onImmediateLosslessTextRegion() {
        this.onImmediateTextRegion(...arguments);
      }
      onPatternDictionary(e3, t3, i3, a3, s3) {
        let n3 = this.patterns;
        n3 || (this.patterns = n3 = {});
        const r3 = new DecodingContext(i3, a3, s3);
        n3[t3] = function(e4, t4, i4, a4, s4, n4) {
          const r4 = [];
          e4 || (r4.push({ x: -t4, y: 0 }), 0 === s4 && r4.push({ x: -3, y: -1 }, { x: 2, y: -2 }, { x: -2, y: -2 }));
          const o3 = decodeBitmap(e4, (a4 + 1) * t4, i4, s4, false, null, r4, n4), g3 = [];
          for (let e5 = 0; e5 <= a4; e5++) {
            const a5 = [], s5 = t4 * e5, n5 = s5 + t4;
            for (let e6 = 0; e6 < i4; e6++) a5.push(o3[e6].subarray(s5, n5));
            g3.push(a5);
          }
          return g3;
        }(e3.mmr, e3.patternWidth, e3.patternHeight, e3.maxPatternIndex, e3.template, r3);
      }
      onImmediateHalftoneRegion(e3, t3, i3, a3, s3) {
        const n3 = this.patterns[t3[0]], r3 = e3.info, o3 = new DecodingContext(i3, a3, s3), g3 = function(e4, t4, i4, a4, s4, n4, r4, o4, g4, c3, h3, l3, C3, d3, u3) {
          if (r4) throw new Jbig2Error("skip is not supported");
          if (0 !== o4) throw new Jbig2Error(`operator "${o4}" is not supported in halftone region`);
          const Q3 = [];
          let f3, p3, m3;
          for (f3 = 0; f3 < s4; f3++) {
            if (m3 = new Uint8Array(a4), n4) for (p3 = 0; p3 < a4; p3++) m3[p3] = n4;
            Q3.push(m3);
          }
          const y3 = t4.length, w3 = t4[0], b3 = w3[0].length, D3 = w3.length, S3 = log2(y3), F3 = [];
          e4 || (F3.push({ x: i4 <= 1 ? 3 : 2, y: -1 }), 0 === i4 && F3.push({ x: -3, y: -1 }, { x: 2, y: -2 }, { x: -2, y: -2 }));
          const k3 = [];
          let R3, x3, N3, M3, G3, v3, L3, U3, H3, T3, J3;
          for (e4 && (R3 = new Reader(u3.data, u3.start, u3.end)), f3 = S3 - 1; f3 >= 0; f3--) x3 = e4 ? decodeMMRBitmap(R3, g4, c3, true) : decodeBitmap(false, g4, c3, i4, false, null, F3, u3), k3[f3] = x3;
          for (N3 = 0; N3 < c3; N3++) for (M3 = 0; M3 < g4; M3++) {
            for (G3 = 0, v3 = 0, p3 = S3 - 1; p3 >= 0; p3--) G3 ^= k3[p3][N3][M3], v3 |= G3 << p3;
            if (L3 = t4[v3], U3 = h3 + N3 * d3 + M3 * C3 >> 8, H3 = l3 + N3 * C3 - M3 * d3 >> 8, U3 >= 0 && U3 + b3 <= a4 && H3 >= 0 && H3 + D3 <= s4) for (f3 = 0; f3 < D3; f3++) for (J3 = Q3[H3 + f3], T3 = L3[f3], p3 = 0; p3 < b3; p3++) J3[U3 + p3] |= T3[p3];
            else {
              let e5, t5;
              for (f3 = 0; f3 < D3; f3++) if (t5 = H3 + f3, !(t5 < 0 || t5 >= s4)) for (J3 = Q3[t5], T3 = L3[f3], p3 = 0; p3 < b3; p3++) e5 = U3 + p3, e5 >= 0 && e5 < a4 && (J3[e5] |= T3[p3]);
            }
          }
          return Q3;
        }(e3.mmr, n3, e3.template, r3.width, r3.height, e3.defaultPixelValue, e3.enableSkip, e3.combinationOperator, e3.gridWidth, e3.gridHeight, e3.gridOffsetX, e3.gridOffsetY, e3.gridVectorX, e3.gridVectorY, o3);
        this.drawBitmap(r3, g3);
      }
      onImmediateLosslessHalftoneRegion() {
        this.onImmediateHalftoneRegion(...arguments);
      }
      onTables(e3, t3, i3, a3) {
        let s3 = this.customTables;
        s3 || (this.customTables = s3 = {}), s3[e3] = function(e4, t4, i4) {
          const a4 = e4[t4], s4 = 4294967295 & readUint32(e4, t4 + 1), n3 = 4294967295 & readUint32(e4, t4 + 5), r3 = new Reader(e4, t4 + 9, i4), o3 = 1 + (a4 >> 1 & 7), g3 = 1 + (a4 >> 4 & 7), c3 = [];
          let h3, l3, C3 = s4;
          do {
            h3 = r3.readBits(o3), l3 = r3.readBits(g3), c3.push(new HuffmanLine([C3, h3, l3, 0])), C3 += 1 << l3;
          } while (C3 < n3);
          h3 = r3.readBits(o3), c3.push(new HuffmanLine([s4 - 1, h3, 32, 0, "lower"])), h3 = r3.readBits(o3), c3.push(new HuffmanLine([n3, h3, 32, 0])), 1 & a4 && (h3 = r3.readBits(o3), c3.push(new HuffmanLine([h3, 0])));
          return new HuffmanTable(c3, false);
        }(t3, i3, a3);
      }
    };
    HuffmanLine = class {
      constructor(e3) {
        2 === e3.length ? (this.isOOB = true, this.rangeLow = 0, this.prefixLength = e3[0], this.rangeLength = 0, this.prefixCode = e3[1], this.isLowerRange = false) : (this.isOOB = false, this.rangeLow = e3[0], this.prefixLength = e3[1], this.rangeLength = e3[2], this.prefixCode = e3[3], this.isLowerRange = "lower" === e3[4]);
      }
    };
    HuffmanTreeNode = class _HuffmanTreeNode {
      constructor(e3) {
        this.children = [], e3 ? (this.isLeaf = true, this.rangeLength = e3.rangeLength, this.rangeLow = e3.rangeLow, this.isLowerRange = e3.isLowerRange, this.isOOB = e3.isOOB) : this.isLeaf = false;
      }
      buildTree(e3, t3) {
        const i3 = e3.prefixCode >> t3 & 1;
        if (t3 <= 0) this.children[i3] = new _HuffmanTreeNode(e3);
        else {
          let a3 = this.children[i3];
          a3 || (this.children[i3] = a3 = new _HuffmanTreeNode(null)), a3.buildTree(e3, t3 - 1);
        }
      }
      decodeNode(e3) {
        if (this.isLeaf) {
          if (this.isOOB) return null;
          const t4 = e3.readBits(this.rangeLength);
          return this.rangeLow + (this.isLowerRange ? -t4 : t4);
        }
        const t3 = this.children[e3.readBit()];
        if (!t3) throw new Jbig2Error("invalid Huffman data");
        return t3.decodeNode(e3);
      }
    };
    HuffmanTable = class {
      constructor(e3, t3) {
        t3 || this.assignPrefixCodes(e3), this.rootNode = new HuffmanTreeNode(null);
        for (let t4 = 0, i3 = e3.length; t4 < i3; t4++) {
          const i4 = e3[t4];
          i4.prefixLength > 0 && this.rootNode.buildTree(i4, i4.prefixLength - 1);
        }
      }
      decode(e3) {
        return this.rootNode.decodeNode(e3);
      }
      assignPrefixCodes(e3) {
        const t3 = e3.length;
        let i3 = 0;
        for (let a4 = 0; a4 < t3; a4++) i3 = Math.max(i3, e3[a4].prefixLength);
        const a3 = new Uint32Array(i3 + 1);
        for (let i4 = 0; i4 < t3; i4++) a3[e3[i4].prefixLength]++;
        let s3, n3, r3, o3 = 1, g3 = 0;
        for (a3[0] = 0; o3 <= i3; ) {
          for (g3 = g3 + a3[o3 - 1] << 1, s3 = g3, n3 = 0; n3 < t3; ) r3 = e3[n3], r3.prefixLength === o3 && (r3.prefixCode = s3, s3++), n3++;
          o3++;
        }
      }
    };
    wn = {};
    Reader = class {
      constructor(e3, t3, i3) {
        this.data = e3, this.start = t3, this.end = i3, this.position = t3, this.shift = -1, this.currentByte = 0;
      }
      readBit() {
        if (this.shift < 0) {
          if (this.position >= this.end) throw new Jbig2Error("end of data while reading bit");
          this.currentByte = this.data[this.position++], this.shift = 7;
        }
        const e3 = this.currentByte >> this.shift & 1;
        return this.shift--, e3;
      }
      readBits(e3) {
        let t3, i3 = 0;
        for (t3 = e3 - 1; t3 >= 0; t3--) i3 |= this.readBit() << t3;
        return i3;
      }
      byteAlign() {
        this.shift = -1;
      }
      next() {
        return this.position >= this.end ? -1 : this.data[this.position++];
      }
    };
    Jbig2Image = class {
      parseChunks(e3) {
        return function(e4) {
          const t3 = new SimpleSegmentVisitor();
          for (let i3 = 0, a3 = e4.length; i3 < a3; i3++) {
            const a4 = e4[i3];
            processSegments(readSegments({}, a4.data, a4.start, a4.end), t3);
          }
          return t3.buffer;
        }(e3);
      }
      parse(e3) {
        throw new Error("Not implemented: Jbig2Image.parse");
      }
    };
    Jbig2Stream = class extends DecodeStream {
      constructor(e3, t3, i3) {
        super(t3), this.stream = e3, this.dict = e3.dict, this.maybeLength = t3, this.params = i3;
      }
      get bytes() {
        return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
      }
      ensureBuffer(e3) {
      }
      readBlock() {
        this.decodeImage();
      }
      decodeImage(e3) {
        if (this.eof) return this.buffer;
        e3 || (e3 = this.bytes);
        const t3 = new Jbig2Image(), i3 = [];
        if (this.params instanceof Dict) {
          const e4 = this.params.get("JBIG2Globals");
          if (e4 instanceof BaseStream) {
            const t4 = e4.getBytes();
            i3.push({ data: t4, start: 0, end: t4.length });
          }
        }
        i3.push({ data: e3, start: 0, end: e3.length });
        const a3 = t3.parseChunks(i3), s3 = a3.length;
        for (let e4 = 0; e4 < s3; e4++) a3[e4] ^= 255;
        return this.buffer = a3, this.bufferLength = s3, this.eof = true, this.buffer;
      }
      get canAsyncDecodeImageFromBuffer() {
        return this.stream.isAsync;
      }
    };
    JpegError = class extends Ms {
      constructor(e3) {
        super(e3, "JpegError");
      }
    };
    DNLMarkerError = class extends Ms {
      constructor(e3, t3) {
        super(e3, "DNLMarkerError"), this.scanLines = t3;
      }
    };
    EOIMarkerError = class extends Ms {
      constructor(e3) {
        super(e3, "EOIMarkerError");
      }
    };
    bn = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
    Dn = 4017;
    Sn = 799;
    Fn = 3406;
    kn = 2276;
    Rn = 1567;
    xn = 3784;
    Nn = 5793;
    Mn = 2896;
    JpegImage = class {
      constructor({ decodeTransform: e3 = null, colorTransform: t3 = -1 } = {}) {
        this._decodeTransform = e3, this._colorTransform = t3;
      }
      parse(e3, { dnlScanLines: t3 = null } = {}) {
        function readDataBlock() {
          const t4 = readUint16(e3, s3);
          s3 += 2;
          let i4 = s3 + t4 - 2;
          const a4 = findNextFileMarker(e3, i4, s3);
          a4?.invalid && (warn("readDataBlock - incorrect length, current marker is: " + a4.invalid), i4 = a4.offset);
          const n4 = e3.subarray(s3, i4);
          return s3 += n4.length, n4;
        }
        function prepareComponents(e4) {
          const t4 = Math.ceil(e4.samplesPerLine / 8 / e4.maxH), i4 = Math.ceil(e4.scanLines / 8 / e4.maxV);
          for (const a4 of e4.components) {
            const s4 = Math.ceil(Math.ceil(e4.samplesPerLine / 8) * a4.h / e4.maxH), n4 = Math.ceil(Math.ceil(e4.scanLines / 8) * a4.v / e4.maxV), r4 = t4 * a4.h, o4 = 64 * (i4 * a4.v) * (r4 + 1);
            a4.blockData = new Int16Array(o4), a4.blocksPerLine = s4, a4.blocksPerColumn = n4;
          }
          e4.mcusPerLine = t4, e4.mcusPerColumn = i4;
        }
        let i3, a3, s3 = 0, n3 = null, r3 = null, o3 = 0;
        const g3 = [], c3 = [], h3 = [];
        let l3 = readUint16(e3, s3);
        if (s3 += 2, 65496 !== l3) throw new JpegError("SOI not found");
        l3 = readUint16(e3, s3), s3 += 2;
        e: for (; 65497 !== l3; ) {
          let C3, d3, u3;
          switch (l3) {
            case 65504:
            case 65505:
            case 65506:
            case 65507:
            case 65508:
            case 65509:
            case 65510:
            case 65511:
            case 65512:
            case 65513:
            case 65514:
            case 65515:
            case 65516:
            case 65517:
            case 65518:
            case 65519:
            case 65534:
              const Q3 = readDataBlock();
              65504 === l3 && 74 === Q3[0] && 70 === Q3[1] && 73 === Q3[2] && 70 === Q3[3] && 0 === Q3[4] && (n3 = { version: { major: Q3[5], minor: Q3[6] }, densityUnits: Q3[7], xDensity: Q3[8] << 8 | Q3[9], yDensity: Q3[10] << 8 | Q3[11], thumbWidth: Q3[12], thumbHeight: Q3[13], thumbData: Q3.subarray(14, 14 + 3 * Q3[12] * Q3[13]) }), 65518 === l3 && 65 === Q3[0] && 100 === Q3[1] && 111 === Q3[2] && 98 === Q3[3] && 101 === Q3[4] && (r3 = { version: Q3[5] << 8 | Q3[6], flags0: Q3[7] << 8 | Q3[8], flags1: Q3[9] << 8 | Q3[10], transformCode: Q3[11] });
              break;
            case 65499:
              const f3 = readUint16(e3, s3);
              s3 += 2;
              const p3 = f3 + s3 - 2;
              let m3;
              for (; s3 < p3; ) {
                const t4 = e3[s3++], i4 = new Uint16Array(64);
                if (t4 >> 4) {
                  if (t4 >> 4 != 1) throw new JpegError("DQT - invalid table spec");
                  for (d3 = 0; d3 < 64; d3++) m3 = bn[d3], i4[m3] = readUint16(e3, s3), s3 += 2;
                } else for (d3 = 0; d3 < 64; d3++) m3 = bn[d3], i4[m3] = e3[s3++];
                g3[15 & t4] = i4;
              }
              break;
            case 65472:
            case 65473:
            case 65474:
              if (i3) throw new JpegError("Only single frame JPEGs supported");
              s3 += 2, i3 = {}, i3.extended = 65473 === l3, i3.progressive = 65474 === l3, i3.precision = e3[s3++];
              const y3 = readUint16(e3, s3);
              s3 += 2, i3.scanLines = t3 || y3, i3.samplesPerLine = readUint16(e3, s3), s3 += 2, i3.components = [], i3.componentIds = {};
              const w3 = e3[s3++];
              let b3 = 0, D3 = 0;
              for (C3 = 0; C3 < w3; C3++) {
                const t4 = e3[s3], a4 = e3[s3 + 1] >> 4, n4 = 15 & e3[s3 + 1];
                b3 < a4 && (b3 = a4), D3 < n4 && (D3 = n4);
                const r4 = e3[s3 + 2];
                u3 = i3.components.push({ h: a4, v: n4, quantizationId: r4, quantizationTable: null }), i3.componentIds[t4] = u3 - 1, s3 += 3;
              }
              i3.maxH = b3, i3.maxV = D3, prepareComponents(i3);
              break;
            case 65476:
              const S3 = readUint16(e3, s3);
              for (s3 += 2, C3 = 2; C3 < S3; ) {
                const t4 = e3[s3++], i4 = new Uint8Array(16);
                let a4 = 0;
                for (d3 = 0; d3 < 16; d3++, s3++) a4 += i4[d3] = e3[s3];
                const n4 = new Uint8Array(a4);
                for (d3 = 0; d3 < a4; d3++, s3++) n4[d3] = e3[s3];
                C3 += 17 + a4, (t4 >> 4 ? c3 : h3)[15 & t4] = buildHuffmanTable(i4, n4);
              }
              break;
            case 65501:
              s3 += 2, a3 = readUint16(e3, s3), s3 += 2;
              break;
            case 65498:
              const F3 = 1 == ++o3 && !t3;
              s3 += 2;
              const k3 = e3[s3++], R3 = [];
              for (C3 = 0; C3 < k3; C3++) {
                const t4 = e3[s3++], a4 = i3.componentIds[t4], n4 = i3.components[a4];
                n4.index = t4;
                const r4 = e3[s3++];
                n4.huffmanTableDC = h3[r4 >> 4], n4.huffmanTableAC = c3[15 & r4], R3.push(n4);
              }
              const x3 = e3[s3++], N3 = e3[s3++], M3 = e3[s3++];
              try {
                const t4 = decodeScan(e3, s3, i3, R3, a3, x3, N3, M3 >> 4, 15 & M3, F3);
                s3 += t4;
              } catch (t4) {
                if (t4 instanceof DNLMarkerError) return warn(`${t4.message} -- attempting to re-parse the JPEG image.`), this.parse(e3, { dnlScanLines: t4.scanLines });
                if (t4 instanceof EOIMarkerError) {
                  warn(`${t4.message} -- ignoring the rest of the image data.`);
                  break e;
                }
                throw t4;
              }
              break;
            case 65500:
              s3 += 4;
              break;
            case 65535:
              255 !== e3[s3] && s3--;
              break;
            default:
              const G3 = findNextFileMarker(e3, s3 - 2, s3 - 3);
              if (G3?.invalid) {
                warn("JpegImage.parse - unexpected data, current marker is: " + G3.invalid), s3 = G3.offset;
                break;
              }
              if (!G3 || s3 >= e3.length - 1) {
                warn("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
                break e;
              }
              throw new JpegError("JpegImage.parse - unknown marker: " + l3.toString(16));
          }
          l3 = readUint16(e3, s3), s3 += 2;
        }
        if (!i3) throw new JpegError("JpegImage.parse - no frame data found.");
        this.width = i3.samplesPerLine, this.height = i3.scanLines, this.jfif = n3, this.adobe = r3, this.components = [];
        for (const e4 of i3.components) {
          const t4 = g3[e4.quantizationId];
          t4 && (e4.quantizationTable = t4), this.components.push({ index: e4.index, output: buildComponentData(0, e4), scaleX: e4.h / i3.maxH, scaleY: e4.v / i3.maxV, blocksPerLine: e4.blocksPerLine, blocksPerColumn: e4.blocksPerColumn });
        }
        this.numComponents = this.components.length;
      }
      _getLinearizedBlockData(e3, t3, i3 = false) {
        const a3 = this.width / e3, s3 = this.height / t3;
        let n3, r3, o3, g3, c3, h3, l3, C3, d3, u3, Q3, f3 = 0;
        const p3 = this.components.length, m3 = e3 * t3 * p3, y3 = new Uint8ClampedArray(m3), w3 = new Uint32Array(e3), b3 = 4294967288;
        let D3;
        for (l3 = 0; l3 < p3; l3++) {
          if (n3 = this.components[l3], r3 = n3.scaleX * a3, o3 = n3.scaleY * s3, f3 = l3, Q3 = n3.output, g3 = n3.blocksPerLine + 1 << 3, r3 !== D3) {
            for (c3 = 0; c3 < e3; c3++) C3 = 0 | c3 * r3, w3[c3] = (C3 & b3) << 3 | 7 & C3;
            D3 = r3;
          }
          for (h3 = 0; h3 < t3; h3++) for (C3 = 0 | h3 * o3, u3 = g3 * (C3 & b3) | (7 & C3) << 3, c3 = 0; c3 < e3; c3++) y3[f3] = Q3[u3 + w3[c3]], f3 += p3;
        }
        let S3 = this._decodeTransform;
        if (i3 || 4 !== p3 || S3 || (S3 = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255])), S3) for (l3 = 0; l3 < m3; ) for (C3 = 0, d3 = 0; C3 < p3; C3++, l3++, d3 += 2) y3[l3] = (y3[l3] * S3[d3] >> 8) + S3[d3 + 1];
        return y3;
      }
      get _isColorConversionNeeded() {
        return this.adobe ? !!this.adobe.transformCode : 3 === this.numComponents ? 0 !== this._colorTransform && (82 !== this.components[0].index || 71 !== this.components[1].index || 66 !== this.components[2].index) : 1 === this._colorTransform;
      }
      _convertYccToRgb(e3) {
        let t3, i3, a3;
        for (let s3 = 0, n3 = e3.length; s3 < n3; s3 += 3) t3 = e3[s3], i3 = e3[s3 + 1], a3 = e3[s3 + 2], e3[s3] = t3 - 179.456 + 1.402 * a3, e3[s3 + 1] = t3 + 135.459 - 0.344 * i3 - 0.714 * a3, e3[s3 + 2] = t3 - 226.816 + 1.772 * i3;
        return e3;
      }
      _convertYccToRgba(e3, t3) {
        for (let i3 = 0, a3 = 0, s3 = e3.length; i3 < s3; i3 += 3, a3 += 4) {
          const s4 = e3[i3], n3 = e3[i3 + 1], r3 = e3[i3 + 2];
          t3[a3] = s4 - 179.456 + 1.402 * r3, t3[a3 + 1] = s4 + 135.459 - 0.344 * n3 - 0.714 * r3, t3[a3 + 2] = s4 - 226.816 + 1.772 * n3, t3[a3 + 3] = 255;
        }
        return t3;
      }
      _convertYcckToRgb(e3) {
        let t3, i3, a3, s3, n3 = 0;
        for (let r3 = 0, o3 = e3.length; r3 < o3; r3 += 4) t3 = e3[r3], i3 = e3[r3 + 1], a3 = e3[r3 + 2], s3 = e3[r3 + 3], e3[n3++] = i3 * (-660635669420364e-19 * i3 + 437130475926232e-18 * a3 - 54080610064599e-18 * t3 + 48449797120281e-17 * s3 - 0.154362151871126) - 122.67195406894 + a3 * (-957964378445773e-18 * a3 + 817076911346625e-18 * t3 - 0.00477271405408747 * s3 + 1.53380253221734) + t3 * (961250184130688e-18 * t3 - 0.00266257332283933 * s3 + 0.48357088451265) + s3 * (-336197177618394e-18 * s3 + 0.484791561490776), e3[n3++] = 107.268039397724 + i3 * (219927104525741e-19 * i3 - 640992018297945e-18 * a3 + 659397001245577e-18 * t3 + 426105652938837e-18 * s3 - 0.176491792462875) + a3 * (-778269941513683e-18 * a3 + 0.00130872261408275 * t3 + 770482631801132e-18 * s3 - 0.151051492775562) + t3 * (0.00126935368114843 * t3 - 0.00265090189010898 * s3 + 0.25802910206845) + s3 * (-318913117588328e-18 * s3 - 0.213742400323665), e3[n3++] = i3 * (-570115196973677e-18 * i3 - 263409051004589e-19 * a3 + 0.0020741088115012 * t3 - 0.00288260236853442 * s3 + 0.814272968359295) - 20.810012546947 + a3 * (-153496057440975e-19 * a3 - 132689043961446e-18 * t3 + 560833691242812e-18 * s3 - 0.195152027534049) + t3 * (0.00174418132927582 * t3 - 0.00255243321439347 * s3 + 0.116935020465145) + s3 * (-343531996510555e-18 * s3 + 0.24165260232407);
        return e3.subarray(0, n3);
      }
      _convertYcckToRgba(e3) {
        for (let t3 = 0, i3 = e3.length; t3 < i3; t3 += 4) {
          const i4 = e3[t3], a3 = e3[t3 + 1], s3 = e3[t3 + 2], n3 = e3[t3 + 3];
          e3[t3] = a3 * (-660635669420364e-19 * a3 + 437130475926232e-18 * s3 - 54080610064599e-18 * i4 + 48449797120281e-17 * n3 - 0.154362151871126) - 122.67195406894 + s3 * (-957964378445773e-18 * s3 + 817076911346625e-18 * i4 - 0.00477271405408747 * n3 + 1.53380253221734) + i4 * (961250184130688e-18 * i4 - 0.00266257332283933 * n3 + 0.48357088451265) + n3 * (-336197177618394e-18 * n3 + 0.484791561490776), e3[t3 + 1] = 107.268039397724 + a3 * (219927104525741e-19 * a3 - 640992018297945e-18 * s3 + 659397001245577e-18 * i4 + 426105652938837e-18 * n3 - 0.176491792462875) + s3 * (-778269941513683e-18 * s3 + 0.00130872261408275 * i4 + 770482631801132e-18 * n3 - 0.151051492775562) + i4 * (0.00126935368114843 * i4 - 0.00265090189010898 * n3 + 0.25802910206845) + n3 * (-318913117588328e-18 * n3 - 0.213742400323665), e3[t3 + 2] = a3 * (-570115196973677e-18 * a3 - 263409051004589e-19 * s3 + 0.0020741088115012 * i4 - 0.00288260236853442 * n3 + 0.814272968359295) - 20.810012546947 + s3 * (-153496057440975e-19 * s3 - 132689043961446e-18 * i4 + 560833691242812e-18 * n3 - 0.195152027534049) + i4 * (0.00174418132927582 * i4 - 0.00255243321439347 * n3 + 0.116935020465145) + n3 * (-343531996510555e-18 * n3 + 0.24165260232407), e3[t3 + 3] = 255;
        }
        return e3;
      }
      _convertYcckToCmyk(e3) {
        let t3, i3, a3;
        for (let s3 = 0, n3 = e3.length; s3 < n3; s3 += 4) t3 = e3[s3], i3 = e3[s3 + 1], a3 = e3[s3 + 2], e3[s3] = 434.456 - t3 - 1.402 * a3, e3[s3 + 1] = 119.541 - t3 + 0.344 * i3 + 0.714 * a3, e3[s3 + 2] = 481.816 - t3 - 1.772 * i3;
        return e3;
      }
      _convertCmykToRgb(e3) {
        let t3, i3, a3, s3, n3 = 0;
        for (let r3 = 0, o3 = e3.length; r3 < o3; r3 += 4) t3 = e3[r3], i3 = e3[r3 + 1], a3 = e3[r3 + 2], s3 = e3[r3 + 3], e3[n3++] = 255 + t3 * (-6747147073602441e-20 * t3 + 8379262121013727e-19 * i3 + 2894718188643294e-19 * a3 + 0.003264231057537806 * s3 - 1.1185611867203937) + i3 * (26374107616089405e-21 * i3 - 8626949158638572e-20 * a3 - 2748769067499491e-19 * s3 - 0.02155688794978967) + a3 * (-3878099212869363e-20 * a3 - 3267808279485286e-19 * s3 + 0.0686742238595345) - s3 * (3361971776183937e-19 * s3 + 0.7430659151342254), e3[n3++] = 255 + t3 * (13596372813588848e-20 * t3 + 924537132573585e-18 * i3 + 10567359618683593e-20 * a3 + 4791864687436512e-19 * s3 - 0.3109689587515875) + i3 * (-23545346108370344e-20 * i3 + 2702845253534714e-19 * a3 + 0.0020200308977307156 * s3 - 0.7488052167015494) + a3 * (6834815998235662e-20 * a3 + 15168452363460973e-20 * s3 - 0.09751927774728933) - s3 * (3189131175883281e-19 * s3 + 0.7364883807733168), e3[n3++] = 255 + t3 * (13598650411385307e-21 * t3 + 12423956175490851e-20 * i3 + 4751985097583589e-19 * a3 - 36729317476630422e-22 * s3 - 0.05562186980264034) + i3 * (16141380598724676e-20 * i3 + 9692239130725186e-19 * a3 + 7782692450036253e-19 * s3 - 0.44015232367526463) + a3 * (5068882914068769e-22 * a3 + 0.0017778369011375071 * s3 - 0.7591454649749609) - s3 * (3435319965105553e-19 * s3 + 0.7063770186160144);
        return e3.subarray(0, n3);
      }
      _convertCmykToRgba(e3) {
        for (let t3 = 0, i3 = e3.length; t3 < i3; t3 += 4) {
          const i4 = e3[t3], a3 = e3[t3 + 1], s3 = e3[t3 + 2], n3 = e3[t3 + 3];
          e3[t3] = 255 + i4 * (-6747147073602441e-20 * i4 + 8379262121013727e-19 * a3 + 2894718188643294e-19 * s3 + 0.003264231057537806 * n3 - 1.1185611867203937) + a3 * (26374107616089405e-21 * a3 - 8626949158638572e-20 * s3 - 2748769067499491e-19 * n3 - 0.02155688794978967) + s3 * (-3878099212869363e-20 * s3 - 3267808279485286e-19 * n3 + 0.0686742238595345) - n3 * (3361971776183937e-19 * n3 + 0.7430659151342254), e3[t3 + 1] = 255 + i4 * (13596372813588848e-20 * i4 + 924537132573585e-18 * a3 + 10567359618683593e-20 * s3 + 4791864687436512e-19 * n3 - 0.3109689587515875) + a3 * (-23545346108370344e-20 * a3 + 2702845253534714e-19 * s3 + 0.0020200308977307156 * n3 - 0.7488052167015494) + s3 * (6834815998235662e-20 * s3 + 15168452363460973e-20 * n3 - 0.09751927774728933) - n3 * (3189131175883281e-19 * n3 + 0.7364883807733168), e3[t3 + 2] = 255 + i4 * (13598650411385307e-21 * i4 + 12423956175490851e-20 * a3 + 4751985097583589e-19 * s3 - 36729317476630422e-22 * n3 - 0.05562186980264034) + a3 * (16141380598724676e-20 * a3 + 9692239130725186e-19 * s3 + 7782692450036253e-19 * n3 - 0.44015232367526463) + s3 * (5068882914068769e-22 * s3 + 0.0017778369011375071 * n3 - 0.7591454649749609) - n3 * (3435319965105553e-19 * n3 + 0.7063770186160144), e3[t3 + 3] = 255;
        }
        return e3;
      }
      getData({ width: e3, height: t3, forceRGBA: i3 = false, forceRGB: a3 = false, isSourcePDF: s3 = false }) {
        if (this.numComponents > 4) throw new JpegError("Unsupported color mode");
        const n3 = this._getLinearizedBlockData(e3, t3, s3);
        if (1 === this.numComponents && (i3 || a3)) {
          const e4 = n3.length * (i3 ? 4 : 3), t4 = new Uint8ClampedArray(e4);
          let a4 = 0;
          if (i3) !function(e5, t5) {
            if (FeatureTest.isLittleEndian) for (let i4 = 0, a5 = e5.length; i4 < a5; i4++) t5[i4] = 65793 * e5[i4] | 4278190080;
            else for (let i4 = 0, a5 = e5.length; i4 < a5; i4++) t5[i4] = 16843008 * e5[i4] | 255;
          }(n3, new Uint32Array(t4.buffer));
          else for (const e5 of n3) t4[a4++] = e5, t4[a4++] = e5, t4[a4++] = e5;
          return t4;
        }
        if (3 === this.numComponents && this._isColorConversionNeeded) {
          if (i3) {
            const e4 = new Uint8ClampedArray(n3.length / 3 * 4);
            return this._convertYccToRgba(n3, e4);
          }
          return this._convertYccToRgb(n3);
        }
        if (4 === this.numComponents) {
          if (this._isColorConversionNeeded) return i3 ? this._convertYcckToRgba(n3) : a3 ? this._convertYcckToRgb(n3) : this._convertYcckToCmyk(n3);
          if (i3) return this._convertCmykToRgba(n3);
          if (a3) return this._convertCmykToRgb(n3);
        }
        return n3;
      }
    };
    JpegStream = class extends DecodeStream {
      constructor(e3, t3, i3) {
        super(t3), this.stream = e3, this.dict = e3.dict, this.maybeLength = t3, this.params = i3;
      }
      get bytes() {
        return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
      }
      ensureBuffer(e3) {
      }
      readBlock() {
        this.decodeImage();
      }
      decodeImage(e3) {
        if (this.eof) return this.buffer;
        e3 || (e3 = this.bytes);
        for (let t4 = 0, i4 = e3.length - 1; t4 < i4; t4++) if (255 === e3[t4] && 216 === e3[t4 + 1]) {
          t4 > 0 && (e3 = e3.subarray(t4));
          break;
        }
        const t3 = { decodeTransform: void 0, colorTransform: void 0 }, i3 = this.dict.getArray("D", "Decode");
        if ((this.forceRGBA || this.forceRGB) && Array.isArray(i3)) {
          const e4 = this.dict.get("BPC", "BitsPerComponent") || 8, a4 = i3.length, s4 = new Int32Array(a4);
          let n3 = false;
          const r3 = (1 << e4) - 1;
          for (let e5 = 0; e5 < a4; e5 += 2) s4[e5] = 256 * (i3[e5 + 1] - i3[e5]) | 0, s4[e5 + 1] = i3[e5] * r3 | 0, 256 === s4[e5] && 0 === s4[e5 + 1] || (n3 = true);
          n3 && (t3.decodeTransform = s4);
        }
        if (this.params instanceof Dict) {
          const e4 = this.params.get("ColorTransform");
          Number.isInteger(e4) && (t3.colorTransform = e4);
        }
        const a3 = new JpegImage(t3);
        a3.parse(e3);
        const s3 = a3.getData({ width: this.drawWidth, height: this.drawHeight, forceRGBA: this.forceRGBA, forceRGB: this.forceRGB, isSourcePDF: true });
        return this.buffer = s3, this.bufferLength = s3.length, this.eof = true, this.buffer;
      }
      get canAsyncDecodeImageFromBuffer() {
        return this.stream.isAsync;
      }
    };
    vn = (Gn = "undefined" != typeof document ? document.currentScript?.src : void 0, function(e3 = {}) {
      var t3, i3, a3 = e3;
      new Promise((e4, a4) => {
        t3 = e4, i3 = a4;
      }), a3.decode = function(e4, { numComponents: t4 = 4, isIndexedColormap: i4 = false, smaskInData: s4 = false }) {
        const n4 = e4.length, r4 = a3._malloc(n4);
        a3.HEAPU8.set(e4, r4);
        const o4 = a3._jp2_decode(r4, n4, t4 > 0 ? t4 : 0, !!i4, !!s4);
        if (a3._free(r4), o4) {
          const { errorMessages: e5 } = a3;
          return e5 ? (delete a3.errorMessages, e5) : "Unknown error";
        }
        const { imageData: g4 } = a3;
        return a3.imageData = null, g4;
      };
      var s3 = Object.assign({}, a3), n3 = "./this.program", r3 = "";
      "undefined" != typeof document && document.currentScript && (r3 = document.currentScript.src), Gn && (r3 = Gn), r3 = r3.startsWith("blob:") ? "" : r3.substr(0, r3.replace(/[?#].*/, "").lastIndexOf("/") + 1);
      var o3, g3, c3, h3, l3, C3 = a3.print || console.log.bind(console), d3 = a3.printErr || console.error.bind(console);
      function tryParseAsDataURI(e4) {
        if (isDataURI(e4)) return function(e5) {
          for (var t4 = atob(e5), i4 = new Uint8Array(t4.length), a4 = 0; a4 < t4.length; ++a4) i4[a4] = t4.charCodeAt(a4);
          return i4;
        }(e4.slice(w3.length));
      }
      function updateMemoryViews() {
        var e4 = g3.buffer;
        a3.HEAP8 = c3 = new Int8Array(e4), a3.HEAP16 = new Int16Array(e4), a3.HEAPU8 = h3 = new Uint8Array(e4), a3.HEAPU16 = new Uint16Array(e4), a3.HEAP32 = new Int32Array(e4), a3.HEAPU32 = l3 = new Uint32Array(e4), a3.HEAPF32 = new Float32Array(e4), a3.HEAPF64 = new Float64Array(e4);
      }
      Object.assign(a3, s3), s3 = null, a3.arguments && a3.arguments, a3.thisProgram && (n3 = a3.thisProgram), a3.quit && a3.quit, a3.wasmBinary && (o3 = a3.wasmBinary);
      var u3, Q3 = [], f3 = [], p3 = [], m3 = 0, y3 = null, w3 = "data:application/octet-stream;base64,", isDataURI = (e4) => e4.startsWith(w3);
      function instantiateSync(e4, t4) {
        var i4, a4 = function(e5) {
          if (e5 == u3 && o3) return new Uint8Array(o3);
          var t5 = tryParseAsDataURI(e5);
          if (t5) return t5;
          throw 'sync fetching of the wasm failed: you can preload it to Module["wasmBinary"] manually, or emcc.py will do that for you when generating HTML (but not JS)';
        }(e4);
        return i4 = new WebAssembly.Module(a4), [new WebAssembly.Instance(i4, t4), i4];
      }
      var callRuntimeCallbacks = (e4) => {
        for (; e4.length > 0; ) e4.shift()(a3);
      };
      a3.noExitRuntime;
      var b3, growMemory = (e4) => {
        var t4 = (e4 - g3.buffer.byteLength + 65535) / 65536;
        try {
          return g3.grow(t4), updateMemoryViews(), 1;
        } catch (e5) {
        }
      }, D3 = {}, getEnvStrings = () => {
        if (!getEnvStrings.strings) {
          var e4 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: n3 || "./this.program" };
          for (var t4 in D3) void 0 === D3[t4] ? delete e4[t4] : e4[t4] = D3[t4];
          var i4 = [];
          for (var t4 in e4) i4.push(`${t4}=${e4[t4]}`);
          getEnvStrings.strings = i4;
        }
        return getEnvStrings.strings;
      }, S3 = [null, [], []], F3 = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, UTF8ArrayToString = (e4, t4, i4) => {
        for (var a4 = t4 + i4, s4 = t4; e4[s4] && !(s4 >= a4); ) ++s4;
        if (s4 - t4 > 16 && e4.buffer && F3) return F3.decode(e4.subarray(t4, s4));
        for (var n4 = ""; t4 < s4; ) {
          var r4 = e4[t4++];
          if (128 & r4) {
            var o4 = 63 & e4[t4++];
            if (192 != (224 & r4)) {
              var g4 = 63 & e4[t4++];
              if ((r4 = 224 == (240 & r4) ? (15 & r4) << 12 | o4 << 6 | g4 : (7 & r4) << 18 | o4 << 12 | g4 << 6 | 63 & e4[t4++]) < 65536) n4 += String.fromCharCode(r4);
              else {
                var c4 = r4 - 65536;
                n4 += String.fromCharCode(55296 | c4 >> 10, 56320 | 1023 & c4);
              }
            } else n4 += String.fromCharCode((31 & r4) << 6 | o4);
          } else n4 += String.fromCharCode(r4);
        }
        return n4;
      }, UTF8ToString = (e4, t4) => e4 ? UTF8ArrayToString(h3, e4, t4) : "", k3 = { c: (e4, t4, i4) => h3.copyWithin(e4, t4, t4 + i4), g: function(e4, t4) {
        e4 >>= 2;
        const i4 = a3.imageData = new Uint8ClampedArray(t4), s4 = a3.HEAP32.subarray(e4, e4 + t4);
        i4.set(s4);
      }, f: function(e4, t4, i4, s4) {
        e4 >>= 2, t4 >>= 2, i4 >>= 2;
        const n4 = a3.imageData = new Uint8ClampedArray(3 * s4), r4 = a3.HEAP32.subarray(e4, e4 + s4), o4 = a3.HEAP32.subarray(t4, t4 + s4), g4 = a3.HEAP32.subarray(i4, i4 + s4);
        for (let e5 = 0; e5 < s4; e5++) n4[3 * e5] = r4[e5], n4[3 * e5 + 1] = o4[e5], n4[3 * e5 + 2] = g4[e5];
      }, e: function(e4, t4, i4, s4, n4) {
        e4 >>= 2, t4 >>= 2, i4 >>= 2, s4 >>= 2;
        const r4 = a3.imageData = new Uint8ClampedArray(4 * n4), o4 = a3.HEAP32.subarray(e4, e4 + n4), g4 = a3.HEAP32.subarray(t4, t4 + n4), c4 = a3.HEAP32.subarray(i4, i4 + n4), h4 = a3.HEAP32.subarray(s4, s4 + n4);
        for (let e5 = 0; e5 < n4; e5++) r4[4 * e5] = o4[e5], r4[4 * e5 + 1] = g4[e5], r4[4 * e5 + 2] = c4[e5], r4[4 * e5 + 3] = h4[e5];
      }, k: (e4) => {
        var t4 = h3.length, i4 = 2147483648;
        if ((e4 >>>= 0) > i4) return false;
        for (var a4, s4, n4 = 1; n4 <= 4; n4 *= 2) {
          var r4 = t4 * (1 + 0.2 / n4);
          r4 = Math.min(r4, e4 + 100663296);
          var o4 = Math.min(i4, (a4 = Math.max(e4, r4)) + ((s4 = 65536) - a4 % s4) % s4);
          if (growMemory(o4)) return true;
        }
        return false;
      }, l: (e4, t4) => {
        var i4 = 0;
        return getEnvStrings().forEach((a4, s4) => {
          var n4 = t4 + i4;
          l3[e4 + 4 * s4 >> 2] = n4, ((e5, t5) => {
            for (var i5 = 0; i5 < e5.length; ++i5) c3[t5++] = e5.charCodeAt(i5);
            c3[t5] = 0;
          })(a4, n4), i4 += a4.length + 1;
        }), 0;
      }, m: (e4, t4) => {
        var i4 = getEnvStrings();
        l3[e4 >> 2] = i4.length;
        var a4 = 0;
        return i4.forEach((e5) => a4 += e5.length + 1), l3[t4 >> 2] = a4, 0;
      }, n: (e4) => 52, j: function(e4, t4, i4, a4, s4) {
        return 70;
      }, b: (e4, t4, i4, a4) => {
        for (var s4, n4, r4, o4 = 0, g4 = 0; g4 < i4; g4++) {
          var c4 = l3[t4 >> 2], u4 = l3[t4 + 4 >> 2];
          t4 += 8;
          for (var Q4 = 0; Q4 < u4; Q4++) s4 = e4, n4 = h3[c4 + Q4], r4 = void 0, r4 = S3[s4], 0 === n4 || 10 === n4 ? ((1 === s4 ? C3 : d3)(UTF8ArrayToString(r4, 0)), r4.length = 0) : r4.push(n4);
          o4 += u4;
        }
        return l3[a4 >> 2] = o4, 0;
      }, o: function(e4, t4) {
        e4 >>= 2;
        const i4 = a3.imageData = new Uint8ClampedArray(4 * t4), s4 = a3.HEAP32.subarray(e4, e4 + t4);
        for (let e5 = 0; e5 < t4; e5++) i4[4 * e5] = i4[4 * e5 + 1] = i4[4 * e5 + 2] = s4[e5], i4[4 * e5 + 3] = 255;
      }, i: function(e4, t4, i4) {
        e4 >>= 2, t4 >>= 2;
        const s4 = a3.imageData = new Uint8ClampedArray(4 * i4), n4 = a3.HEAP32.subarray(e4, e4 + i4), r4 = a3.HEAP32.subarray(t4, t4 + i4);
        for (let e5 = 0; e5 < i4; e5++) s4[4 * e5] = s4[4 * e5 + 1] = s4[4 * e5 + 2] = n4[e5], s4[4 * e5 + 3] = r4[e5];
      }, d: function(e4) {
        const t4 = UTF8ToString(e4);
        (a3.warn || console.warn)(`OpenJPEG: ${t4}`);
      }, h: function(e4, t4, i4, s4) {
        e4 >>= 2, t4 >>= 2, i4 >>= 2;
        const n4 = a3.imageData = new Uint8ClampedArray(4 * s4), r4 = a3.HEAP32.subarray(e4, e4 + s4), o4 = a3.HEAP32.subarray(t4, t4 + s4), g4 = a3.HEAP32.subarray(i4, i4 + s4);
        for (let e5 = 0; e5 < s4; e5++) n4[4 * e5] = r4[e5], n4[4 * e5 + 1] = o4[e5], n4[4 * e5 + 2] = g4[e5], n4[4 * e5 + 3] = 255;
      }, a: function(e4) {
        const t4 = UTF8ToString(e4);
        a3.errorMessages ? a3.errorMessages += "\n" + t4 : a3.errorMessages = t4;
      } }, R3 = function() {
        var e4 = { a: k3 };
        function receiveInstance(e5, t4) {
          var i4;
          return R3 = e5.exports, g3 = R3.p, updateMemoryViews(), i4 = R3.q, f3.unshift(i4), function() {
            if (m3--, a3.monitorRunDependencies?.(m3), 0 == m3 && y3) {
              var e6 = y3;
              y3 = null, e6();
            }
          }(), R3;
        }
        if (m3++, a3.monitorRunDependencies?.(m3), a3.instantiateWasm) try {
          return a3.instantiateWasm(e4, receiveInstance);
        } catch (e5) {
          d3(`Module.instantiateWasm callback failed with error: ${e5}`), i3(e5);
        }
        return u3 || (u3 = "data:application/octet-stream;base64,AGFzbQEAAAABzgEaYAN/f38Bf2AEf39/fwF/YAF/AGACf38AYAF/AX9gA39/fwBgAn9/AX9gBH9/f38AYAN/fn8BfmAFf39/f38Bf2ACfn8Bf2ACfn8BfmAFf39/f38AYAN/fn8Bf2AAAX9gB39/f39/f38Bf2AJf39/f39/f39/AX9gC39/f39/f39/f39/AX9gBn9/f39/fwF/YAZ/fH9/f38Bf2AIf39/f39/f38AYAh/f39/f39/fwF/YAAAYAZ/f39/f38AYAd/f39/f39/AGACfH8BfAJbDwFhAWEAAgFhAWIAAQFhAWMABQFhAWQAAgFhAWUADAFhAWYABwFhAWcAAwFhAWgABwFhAWkABQFhAWoACQFhAWsABAFhAWwABgFhAW0ABgFhAW4ABAFhAW8AAwPAAb4BBwIFAAYEAAUGBAUBBAwFFAYCAgICAAYQEQQCChICBQIEBwQCDgICDQYCFQMHAAAEAwEWCQkDAAkGAQQEBQUODwEBAwADBgIQBBcYAgcGAwcHAQECAAQZBAYHBA8MAAQCAgIABgAGAQEBAQEBAQEAAAAAAAYDAgICAwMDAwMAAxMIBA4EAAgDAwkECAoLCAAAAQEBAQEBAQENAQAEBAUJDwESEQEAAAYDAwEFBQUFBQUFBQELAQEBAQEBAQEBCgQFAXABbm4FBwEBggKAgAIGCAF/AUGQ2QULBxsGAXACAAFxAEEBcgCYAQFzABABdAEAAXUAlwEJvQEBAEEBC21RzAHCAXNzNqcBnAGZAYsBigGJAYgBhwGGAYUBhAFSgQGAAX9+fXx7enl4d3Z1ywHKAckByAHHAcYBQMUBxAFAQMMBwQHAAb8BvgG9AbwBuwG6AbkBswGoAaYBpQGkAaMBogGhAaABnwGeAZ0BmwGaAUlKTFJIgwFTOFCCAU9FRk4rJ6sBqgGsAbQBuAG1Aa8BqQGtAa4BtgG3AXCwAbEBsgFRlgGVAYwBjgGNAZIBkwGUAZABjwEKkZoOvgGCAgEDfyMAQZAEayIEJAACQCAARQ0AAkACQAJAAkAgAUEBaw4EAAEEAgQLIABBDGohAQwCCyAAQRBqIQEgAEEEaiEADAELIABBFGohASAAQQhqIQALIAEoAgAiBUUNACACRQ0AIAAoAgAhBiAEQQBBgAQQFSIBIAM2AowEIwBBoAFrIgAkACAAIAE2ApQBIABB/wM2ApgBIABBAEGQARAVIgBBfzYCTCAAQeYANgIkIABBfzYCUCAAIABBnwFqNgIsIAAgAEGUAWo2AlQgAUEAOgAAIAAgAiADQecAQegAEGsgAEGgAWokACABQQA6AP8DIAEgBiAFEQMACyAEQZAEaiQAC9ACAQV/IAAEQCAAQQRrIgMoAgAiBCEBIAMhAiAAQQhrKAIAIgAgAEF+cSIARwRAIAIgAGsiAigCBCIBIAIoAggiBTYCCCAFIAE2AgQgACAEaiEBCyADIARqIgAoAgAiAyAAIANqQQRrKAIARwRAIAAoAgQiBCAAKAIIIgA2AgggACAENgIEIAEgA2ohAQsgAiABNgIAIAIgAUF8cWpBBGsgAUEBcjYCACACAn8gAigCAEEIayIAQf8ATQRAIABBA3ZBAWsMAQsgAGchAyAAQR0gA2t2QQRzIANBAnRrQe4AaiAAQf8fTQ0AGkE/IABBHiADa3ZBAnMgA0EBdGtBxwBqIgAgAEE/TxsLIgFBBHQiAEGgxwFqNgIEIAIgAEGoxwFqIgAoAgA2AgggACACNgIAIAIoAgggAjYCBEGozwFBqM8BKQMAQgEgAa2GhDcDAAsLyQIBBH8gAUEANgIAAkAgAkUNACABIAJqIQMCQCACQRBJBEAgACEBDAELAkAgACACaiABTQ0AIAAgA08NACAAIQEMAQsgA0EQayEGIAAgAkFwcSIFaiEBIAMgBWshAwNAIAYgBGsgACAEav0AAAD9DAAAAAAAAAAAAAAAAAAAAAD9DQ8ODQwLCgkIBwYFBAMCAQD9CwAAIARBEGoiBCAFRw0ACyACIAVGDQELAkAgAkEDcSIGRQRAIAUhBAwBC0EAIQAgBSEEA0AgA0EBayIDIAEtAAA6AAAgBEEBaiEEIAFBAWohASAAQQFqIgAgBkcNAAsLIAUgAmtBfEsNAANAIANBAWsgAS0AADoAACADQQJrIAEtAAE6AAAgA0EDayABLQACOgAAIANBBGsiAyABLQADOgAAIAFBBGohASAEQQRqIgQgAkcNAAsLC4AEAQN/IAJBgARPBEAgACABIAIQAiAADwsgACACaiEDAkAgACABc0EDcUUEQAJAIABBA3FFBEAgACECDAELIAJFBEAgACECDAELIAAhAgNAIAIgAS0AADoAACABQQFqIQEgAkEBaiICQQNxRQ0BIAIgA0kNAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgACADQQRrIgRLBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAswAQF/AkAgAEUNACABRQ0AQQggACABbCIBECUiAARAIABBACABEBUaCyAAIQILIAILEQAgAEUEQEEADwtBCCAAECUL8gICAn8BfgJAIAJFDQAgACABOgAAIAAgAmoiA0EBayABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBA2sgAToAACADQQJrIAE6AAAgAkEHSQ0AIAAgAToAAyADQQRrIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBBGsgATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQQhrIAE2AgAgAkEMayABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkEQayABNgIAIAJBFGsgATYCACACQRhrIAE2AgAgAkEcayABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa1CgYCAgBB+IQUgAyAEaiEBA0AgASAFNwMYIAEgBTcDECABIAU3AwggASAFNwMAIAFBIGohASACQSBrIgJBH0sNAAsLIAALJwEBfyMAQRBrIgMkACADIAI2AgwgACABIAJBAEEAEGsgA0EQaiQAC+gFAQl/IAFFBEBBAA8LAn8gAEUE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ACAEIE5BCmpBAiAFEBpBAkcEQCAFQQFBAiAAKAK4ARtBlhJBABAPIAAoArgBRSFnDAELIE5BCmogTkEMakECEBEgTigCDCIBQZD/A0YNACABQdn/A0YEQCAAQYACNgIIIABBADYCzAEMAQsgBCkDCCKGAVAEfkIABSCGASAEKQM4fQtQBEAgAEHAADYCCCAFQQJBrD9BABAPDAELQQAhZyAFQQFB7D5BABAPCyBOQRBqJAAgZwsLACAABEAgABAQCwu0AQEBfyAAKAIMRQRAIAIgACgCJCABEQMADwsCQEEIEBQiA0UNACADIAI2AgQgAyABNgIAQQgQFCIBRQRAIAMQEA8LIAEgAzYCACAAIAAoAgRB5ABsIgI2AigDQCAAKAIYIAJKDQALIAEgACgCFDYCBCAAIAE2AhQgACAAKAIYQQFqNgIYIAAoAhwiAUUNACABKAIAQQA2AgggACABKAIENgIcIAAgACgCIEEBazYCICABEBALC/oCAQR/AkAgAEUNACAAKAKsKCIBBEAgACgCqCgiAgRAQQAhAQNAIAAoAqwoIAFBA3RqKAIAIgMEQCADEBAgACgCqCghAgsgAUEBaiIBIAJJDQALIAAoAqwoIQELIABBADYCqCggARAQIABBADYCrCgLIAAoArQoIgEEQCABEBAgAEEANgK0KAsgACgC0CsiAQRAIAEQECAAQQA2AtArCyAAKALsKyIBBEAgARAQIABBADYC7CsLIAAoAugrIgEEQCABEBAgAEEANgLoKwsgACgC/CsiAQRAIAEQECAAQQA2AoQsIABCADcC/CsLIAAoAvArIgEEQCAAKAL0KyIDBH9BACECA0AgASgCDCIEBEAgBBAQIAFBADYCDCAAKAL0KyEDCyABQRRqIQEgAkEBaiICIANJDQALIAAoAvArBSABCxAQIABBADYC8CsLIAAoAuQrIgEEQCABEBAgAEEANgLkKwsgACgC3CsiAUUNACABEBAgAEIANwLcKwsLyAcCEX8BfiAAKAIQIghBIE8EQCAAKQMIpw8LAkAgACgCFCIDQQROBEAgACgCACICQQNrKAIAIQEgACADQQRrIgM2AhQgACACQQRrNgIADAELIANBAEwEQAwBCyADQQFxIQ0gACgCACECAkAgA0EBRgRAQRghBAwBCyADQf7///8HcSEJQRghBANAIAAgAkEB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IABBADYCiAEgACgCZBAQIABBADYCZCAALQC8AUECcUUEQCAAKAKoARAQCyAAQdAAakEAQfAAEBUaIAAoAsABEDIgAEEANgLAASAAKALEARAyIABBADYCwAEgACgCyAEiAQRAIAEoAhwiAgRAIAIQECABQQA2AhwLIAEoAigiAgRAIAEoAiQEQANAIAIgBUEobCIDaigCJCIEBEAgBBAQIAEoAigiAiADakEANgIkCyACIANqKAIQIgQEQCAEEBAgASgCKCICIANqQQA2AhALIAIgA2ooAhgiBARAIAQQECABKAIoIgIgA2pBADYCGAsgBUEBaiIFIAEoAiRJDQALCyACEBAgAUEANgIoCyABEBALIABBADYCyAEgACgCSBAhIABBADYCSCAAKAJMECEgAEEANgJMIAAoAtQBIgMEQAJAIAMoAghFDQAgAygCDARAIANBADYCKANAIAMoAhhBAEoNAAsLIANBATYCECADKAIAEBAgAygCHCICRQ0AA0AgAigCBCEBIAIQECADIAE2AhwgASICDQALCyADKAIkIgIEQCACKAIEIgVBAEoEQEEAIQEDQCACKAIAIAFBDGxqIgQoAggiBgRAIAQoAgQgBhECACACKAIEIQULIAFBAWoiASAFSA0ACwsgAigCABAQIAIQEAsgAxAQCyAAQQA2AtQBIAAQEAsL5gMCCH8EfiAAKAIUKAIAKAIUIAFBzABsaiIJKAIMIgggACgCGCgCGCABQTRsaiIKNQIEIhBCAX0iEiAANQI8fCAQgKciCyAIIAtJGyEMIAkoAggiCCAKNQIAIhFCAX0iEyAANQI4fCARgKciCiAIIApJGyEKIAkoAgQiCCASIAA1AjR8IBCApyILIAggC0sbIQsgCSgCACIIIBMgADUCMHwgEYCnIg0gCCANSxshDUEAIQggACgCICgC0CsgAUG4CGxqKAIUIQ4CQCAJKAIUQQAgAmtBfyACG2oiAkUEQCAKIQAgDSEIIAshAQwBCyADQQFxIAJBAWsiD3QiCSANSQRAIA0gCWutQn8gAq0iEIZCf4V8IBCIpyEIC0EAIQBBACEBIANBAXYgD3QiAyALSQRAIAsgA2utQn8gAq0iEIZCf4V8IBCIpyEBCyAJIApJBEAgCiAJa61CfyACrSIQhkJ/hXwgEIinIQALIAMgDE8EQEEAIQwMAQsgDCAD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IABBADYCPCAAQucHNwI0IABBADYCLCAAQucHNwIkIABBADYCHCAAQucHNwIUIABBADYCDCAAQucHNwIEIABBQGshACACQQRqIgIgA0cNAAsLIAFBA3EiAUUNAEEAIQIDQCAAQQA2AgwgAELnBzcCBCAAQRBqIQAgAkEBaiICIAFHDQALCwv7BQEQfyMAQYACayIIJAACf0EBQRQQEyIGRQRAIAJBAUH0MEEAEA9BAAwBCyAGIAE2AgQgBiAANgIAIAggATYCACAIIAA2AoABA0AgCCAFIg1BAWoiBUECdCIHaiABQQFqQQJtIgM2AgAgCEGAAWogB2ogAEEBakECbSIHNgIAIAQgACABbCIJaiEEIAMhASAHIQAgCUEBSw0ACyAGIAQ2AgggBEUEQCAGEBBBAAwBCyAGIARBEBATIgM2AgwgA0UEQCACQQFB2hpBABAPIAYQEEEADAELIAYgBigCCCILQQR0NgIQIAMhACANBEAgAyAGKAIEIAYoAgBsQQR0aiIEIQEDQAJAIAggDkECdCICaigCACIJQQBMDQAgCUEBayEMQQAhBwJAIAhBgAFqIAJqKAIAIgJBAEwEQEEAIQUgCUEBRwRAIAlB/v///wdxIQoDQCAFIAxGIQ8gBUECaiEFIAEgBCAPGyIEIQEgB0ECaiIHIApHDQALCyAJQQFxDQEgBCEBDAILA0AgBCEFIAIhBANAAkAgACABNgIAIARBAUYEQCAAQRBqIQAgAUEQaiEBDAELIAAgATYCECABQRBqIQEgAEEgaiEAIARBAkohECAEQQJrIQQgEA0BCwsgASAFIAJBBHRqIAcgByAMRnJBAXEiChshBCABIAUgChshASAHQQFqIgcgCUcNAAsMAQsgASAEIAJBBHRqIAUgBSAMRnJBAXEiBRshESABIAQgBRshASARIQQLIA5BAWoiDiANRw0ACwsgAEEANgIAAkAgC0UNACALQQRPBEAgC0F8cSEAQQAhAQNAIANBADYCPCADQucHNwI0IANBADYCLCADQucHNwIkIANBADYCHCADQucHNwIUIANBADYCDCADQucHNwIEIANBQGshAyABQQRqIgEgAEcNAAsLIAtBA3EiAEUNAEEAIQEDQCADQQA2AgwgA0LnBzcCBCADQRBqIQMgAUEBaiIBIABHDQALCyAGCyESIAhBgAJqJAAgEgtTAQF/An8gAC0ADEH/AUYEQCAAQoD+g4DwADcCDEEAIAAoAggiASAAKAIETw0BGiAAIAFBAWo2AgggACABLQAAQYD+A3I2AgwLIABBADYCEEEBCwt+AgF/AX4gAL0iA0I0iKdB/w9xIgJB/w9HBHwgAkUEQCABIABEAAAAAAAAAABhBH9BAAUgAEQAAAAAAADwQ6IgARBlIQAgASgCAEFAags2AgAgAA8LIAEgAkH+B2s2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLSQEBfwJAQQFBLBATIgEEQCABQQA2AhACQCAAQQBMBEAgAUEBQQgQEyIANgIkIABFDQEMAwsgAUEANgIMCyABEBALQQAhAQsgAQuRAgAgAEUEQEEADwsCfwJAIAFB/wBNDQACQEGU0AEoAgAoAgBFBEAgAUGAf3FBgL8DRg0CDAELIAFB/w9NBEAgACABQT9xQYABcjoAASAAIAFBBnZBwAFyOgAAQQIMAwsgAUGAQHFBgMADRyABQYCwA09xRQRAIAAgAUE/cUGAAXI6AAIgACABQQx2QeABcjoAACAAIAFBBnZBP3FBgAFyOgABQQMMAwsgAUGAgARrQf//P00EQCAAIAFBP3FBgAFyOgADIAAgAUESdkHwAXI6AAAgACABQQZ2QT9xQYABcjoAAiAAIAFBDHZBP3FBgAFyOgABQQQMAwsLQZTHAUEZNgIAQX8MAQsgACABOgAAQQELC7wCAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4SAAgJCggJAQIDBAoJCgoICQUGBwsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRAwALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC3MBBn8gACgCACIDLAAAQTBrIgFBCUsE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AyAAQRh2NgIUIAMgBDYCECADIABBCHZB/wFxNgIcIAMgAEEQdkH/AXE2AhggAkEBQc31ACADQRBqEA8MBwsgBSAITQRAIAYhBAwECyAFIQggBiAFEBciBA0DIAYQECACQQFB/w9BABAPQQAMBwsgBEECcUUEQCACQQFBwg9BABAPIAYQEEEADAcLIAAgBEH/////B3I2AmQgASAHIAVrrSINIAIgASgCKBEIACANUQ0DIAAtAGRBCHFFDQEgAkECQZIcQQAQDwsgBhAQQQEMBQsgAkEBQZIcQQAQDyAGEBBBAAwECyABIAQgBSACEBogBUcEQCACQQFBxBxBABAPIAQQEEEADAQLIAAgBCIGIAUgAiAKKAIEEQEADQALIAQQEEEADAILIAJBAUGiJUEAEA9BAAwBCyAGEBBBAAshDCADQfAAaiQAIAwL5gEBBn8gACgCCEE1IAIQJARAAkAgACgCCCIGKAIAIQMgBigCCCEFAkACQAJ/AkAgAwRAQQEhBCADQQFxIQcgA0EBRw0BQQAMAgsgBkEANgIADAILIANBfnEhAwNAAn9BACAERQ0AGkEAIAAgASACIAUoAgARAABFDQAaIAAgASACIAUoAgQRAABBAEcLIQQgBUEIaiEFIAhBAmoiCCADRw0ACyAERQshAyAHBEAgAw0CIAAgASACIAUoAgARAABBAEchBAsgBkEANgIAIARFDQILIAAoAgAaQQEPCyAGQQA2AgALC0EACwoAIAAoAgAaQQALFAAgACgCACIABEAgACABNgK4AQsLIQAgACgCACABEFMgAEEAOgB8IAAgASgCuEBBAXE2AoABCzIAIAJFBEBBAA8LIAAoAgAgASACIAMQSEUEQCADQQFBqS9BABAPQQAPCyAAIAIgAxBxC2kCAn8BfCMAQRBrIgMkACACBEADQCAAIANBCGoQRCABAn8gAysDCCIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAs2AgAgAUEEaiEBIABBCGohACAEQQFqIgQgAkcNAAsLIANBEGokAAuEAQICfwF9IwBBEGsiAyQAIAIEQANAIAMgAC0AADoADyADIAAtAAE6AA4gAyAALQACOgANIAMgAC0AAzoADCABAn8gAyoCDCIFi0MAAABPXQRAIAWoDAELQYCAgIB4CzYCACABQQRqIQEgAEEEaiEAIARBAWoiBCACRw0ACwsgA0EQaiQAC0sBAn8jAEEQayIDJAAgAgRAA0AgACADQQxqQQQQESABIAMoAgw2AgAgAUEEaiEBIABBBGohACAEQQFqIgQgAkcNAAsLIANBEGokAAtLAQJ/IwBBEGsiAyQAIAIEQANAIAAgA0EMakECEBEgASADKAIMNgIAIAFBBGohASAAQQJqIQAgBEEBaiIEIAJHDQALCyADQRBqJAALSgECfyMAQRBrIgMkACACBEADQCAAIANBCGoQRCABIAMrAwi2OAIAIAFBBGohASAAQQhqIQAgBEEBaiIEIAJHDQALCyADQRBqJAALaAECfyMAQRBrIgMkACACBEADQCADIAAtAAA6AA8gAyAALQABOgAOIAMgAC0AAjoADSADIAAtAAM6AAwgASADKgIMOAIAIAFBBGohASAAQQRqIQAgBEEBaiIEIAJHDQALCyADQRBqJAALTAECfyMAQRBrIgMkACACBEADQCAAIANBDGpBBBARIAEgAygCDLM4AgAgAUEEaiEBIABBBGohACAEQQFqIgQgAkcNAAsLIANBEGokAAtMAQJ/IwBBEGsiAyQAIAIEQANAIAAgA0EMakECEBEgASADKAIMszgCACABQQRqIQEgAEECaiEAIARBAWoiBCACRw0ACwsgA0EQaiQAC6oIAg1/AXsjAEEQayIIJAACfyAAKAIIQRBGBEAgACgCnAEgACgCzAFBjCxsagwBCyAAKAIMCyEJAkAgAkUEQCADQQFB8B9BABAPDAELIAAoAkghBkEBIQQgASAIQQhqQQEQESAIKAIIIgVBAk8EQCADQQJBxsgAQQAQDwwBCyACIAVBAWpHBEBBACEEIANBAkHwH0EAEA8MAQsCQCAGKAIQIgNFDQAgCSgC0CshBCADQQhPBEAgA0F4cSEGQQAhAgNAIARBADYCvEMgBEEANgKEOyAEQQA2AswyIARBADYClCogBEEANgLcISAEQQA2AqQZIARBADYC7BAgBEEANgK0CCAEQcDDAGohBCACQQhqIgIgBkcNAAsLIANBB3EiA0UNAEEAIQIDQCAEQQA2ArQIIARBuAhqIQQgAkEBaiICIANHDQALCyAJKALoKyICBH8gAhAQIAlBADYC6CsgCCgCCAUgBQtFBEBBASEEDAELA0AgAUEBaiIBIAhBDGpBARARAkAgCSgCgCxF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KT0ALgAobnVsbCkAKCVkLCVkKSAAJXN9CgAJCSB9CgBbREVWXSBEdW1wIGFuIGltYWdlX2NvbXBfaGVhZGVyIHN0cnVjdCB7CgBbREVWXSBEdW1wIGFuIGltYWdlX2hlYWRlciBzdHJ1Y3QgewoASW1hZ2UgaW5mbyB7CgAJIGRlZmF1bHQgdGlsZSB7CgAlcwkgY29tcG9uZW50ICVkIHsKAAkJIGNvbXAgJWQgewoACSBUaWxlIGluZGV4OiB7CgAJIE1hcmtlciBsaXN0OiB7CgBDb2Rlc3RyZWFtIGluZGV4IGZyb20gbWFpbiBoZWFkZXI6IHsKAENvZGVzdHJlYW0gaW5mbyBmcm9tIG1haW4gaGVhZGVyOiB7CgBTdHJlYW0gZXJyb3Igd2hpbGUgcmVhZGluZyBKUDIgSGVhZGVyIGJveAoARm91bmQgYSBtaXNwbGFjZWQgJyVjJWMlYyVjJyBib3ggb3V0c2lkZSBqcDJoIGJveAoATWFsZm9ybWVkIEpQMiBmaWxlIGZvcm1hdDogZmlyc3QgYm94IG11c3QgYmUgSlBFRyAyMDAwIHNpZ25hdHVyZSBib3gKAE1hbGZvcm1lZCBKUDIgZmlsZSBmb3JtYXQ6IHNlY29uZCBib3ggbXVzdCBiZSBmaWxlIHR5cGUgYm94CgBOb3QgZW5vdWdoIG1lbW9yeSB0byBoYW5kbGUganBlZzIwMDAgYm94CgBOb3QgZW5vdWdoIG1lbW9yeSB3aXRoIEZUWVAgQm94CgBBIG1hcmtlciBJRCB3YXMgZXhwZWN0ZWQgKDB4ZmYtLSkgaW5zdGVhZCBvZiAlLjh4CgAJCSBtY3Q9JXgKAAkJCSBjYmxrc3R5PSUjeAoACQkJIGNzdHk9JSN4CgAJCSBwcmc9JSN4CgBJbnRlZ2VyIG92ZXJmbG93CgAJIHRkeD0ldSwgdGR5PSV1CgAJIHR3PSV1LCB0aD0ldQoACSB0eDA9JXUsIHR5MD0ldQoASW52YWxpZCBjb21wb25lbnQgaW5kZXg6ICV1CgBTdHJlYW0gdG9vIHNob3J0CgBNYXJrZXIgaGFuZGxlciBmdW5jdGlvbiBmYWlsZWQgdG8gcmVhZCB0aGUgbWFya2VyIHNlZ21lbnQKAE5vdCBlbm91Z2ggbWVtb3J5IGZvciBjdXJyZW50IHByZWNpbmN0IGNvZGVibG9jayBlbGVtZW50CgBFcnJvciByZWFkaW5nIFNQQ29kIFNQQ29jIGVsZW1lbnQKAEVycm9yIHJlYWRpbmcgU1FjZCBvciBTUWNjIGVsZW1lbnQKAEEgQlBDQyBoZWFkZXIgYm94IGlzIGF2YWlsYWJsZSBhbHRob3VnaCBCUEMgZ2l2ZW4gYnkgdGhlIElIRFIgYm94ICglZCkgaW5kaWNhdGUgY29tcG9uZW50cyBiaXQgZGVwdGggaXMgY29uc3RhbnQKAEVycm9yIHdpdGggU0laIG1hcmtlcjogaWxsZWdhbCB0aWxlIG9mZnNldAoASW52YWxpZCBwcmVjaW5jdAoATm90IGVub3VnaCBtZW1vcnkgdG8gaGFuZGxlIGJhbmQgcHJlY2ludHMKAEZhaWxlZCB0byBkZWNvZGUgYWxsIHVzZWQgY29tcG9uZW50cwoAU2l6ZSBvZiBjb2RlIGJsb2NrIGRhdGEgZXhjZWVkcyBzeXN0ZW0gbGltaXRzCgBTaXplIG9mIHRpbGUgZGF0YSBleGNlZWRzIHN5c3RlbSBsaW1pdHMKAENhbm5vdCB0YWtlIGluIGNoYXJnZSBtdWx0aXBsZSBNQ1QgbWFya2VycwoAQ29ycnVwdGVkIFBQTSBtYXJrZXJzCgBOb3QgZW5vdWdoIG1lbW9yeSBmb3IgdGlsZSByZXNvbHV0aW9ucwoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIG11bHRpcGxlIGNvbGxlY3Rpb25zCgBJbnZhbGlkIFBDTFIgYm94LiBSZXBvcnRzIDAgcGFsZXR0ZSBjb2x1bW5zCgBXZSBkbyBub3Qgc3VwcG9ydCBST0kgaW4gZGVjb2RpbmcgSFQgY29kZWJsb2NrcwoAQ2Fubm90IGhhbmRsZSBib3ggb2YgdW5kZWZpbmVkIHNpemVzCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgY29sbGVjdGlvbnMgd2l0aG91dCBzYW1lIG51bWJlciBvZiBpbmRpeGVzCgBJbnZhbGlkIHRpbGVjLT53aW5feHh4IHZhbHVlcwoAQ2Fubm90IGhhbmRsZSBib3ggb2YgbGVzcyB0aGFuIDggYnl0ZXMKAENhbm5vdCBoYW5kbGUgWEwgYm94IG9mIGxlc3MgdGhhbiAxNiBieXRlcwoAQ29tcG9uZW50IGluZGV4ICV1IHVzZWQgc2V2ZXJhbCB0aW1lcwoASW52YWxpZCBQQ0xSIGJveC4gUmVwb3J0cyAlZCBlbnRyaWVzCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBjcmVhdGUgVGFnLXRyZWUgbm9kZXMKAENhbm5vdCB0YWtlIGluIGNoYXJnZSBtY3QgZGF0YSB3aXRoaW4gbXVsdGlwbGUgTUNUIHJlY29yZHMKAENhbm5vdCBkZWNvZGUgdGlsZSwgbWVtb3J5IGVycm9yCgBvcGpfajJrX2FwcGx5X25iX3RpbGVfcGFydHNfY29ycmVjdGlvbiBlcnJvcgoAUHJvYmxlbSB3aXRoIHNraXBwaW5nIEpQRUcyMDAwIGJveCwgc3RyZWFtIGVycm9yCgBQcm9ibGVtIHdpdGggcmVhZGluZyBKUEVHMjAwMCBib3gsIHN0cmVhbSBlcnJvcgoAVW5rbm93biBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGFkZCB0bCBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGFkZCBtaCBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHRha2UgaW4gY2hhcmdlIFNJWiBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUFBUIG1hcmtlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gcmVhZCBQUFQgbWFya2VyCgBFcnJvciByZWFkaW5nIFNPVCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUExUIG1hcmtlcgoARXJyb3IgcmVhZGluZyBNQ1QgbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWFkIE1DVCBtYXJrZXIKAE5vdCBlbm91Z2ggc3BhY2UgZm9yIGV4cGVjdGVkIFNPUCBtYXJrZXIKAEV4cGVjdGVkIFNPUCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgTUNPIG1hcmtlcgoARXJyb3IgcmVhZGluZyBSR04gbWFya2VyCgBFcnJvciByZWFkaW5nIFBQTSBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlYWQgUFBNIG1hcmtlcgoARXJyb3IgcmVhZGluZyBUTE0gbWFya2VyCgBFcnJvciByZWFkaW5nIFBMTSBtYXJrZXIKAE5vdCBlbm91Z2ggc3BhY2UgZm9yIGV4cGVjdGVkIEVQSCBtYXJrZXIKAEV4cGVjdGVkIEVQSCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgQ1JHIG1hcmtlcgoAVW5rbm93biBwcm9ncmVzc2lvbiBvcmRlciBpbiBDT0QgbWFya2VyCgBVbmtub3duIFNjb2QgdmFsdWUgaW4gQ09EIG1hcmtlcgoARXJyb3IgcmVhZGluZyBDT0QgbWFya2VyCgBFcnJvciByZWFkaW5nIFFDRCBtYXJrZXIKAENycm9yIHJlYWRpbmcgQ0JEIG1hcmtlcgoARXJyb3IgcmVhZGluZyBQT0MgbWFya2VyCgBFcnJvciByZWFkaW5nIENPQyBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUUNDIG1hcmtlcgoARXJyb3IgcmVhZGluZyBNQ0MgbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWFkIE1DQyBtYXJrZXIKAHJlcXVpcmVkIFNJWiBtYXJrZXIgbm90IGZvdW5kIGluIG1haW4gaGVhZGVyCgByZXF1aXJlZCBDT0QgbWFya2VyIG5vdCBmb3VuZCBpbiBtYWluIGhlYWRlcgoAcmVxdWlyZWQgUUNEIG1hcmtlciBub3QgZm91bmQgaW4gbWFpbiBoZWFkZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGhhbmRsZSBqcGVnMjAwMCBmaWxlIGhlYWRlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gcmVhZCBoZWFkZXIKAEVycm9yIHdpdGggSlAgU2lnbmF0dXJlIDogYmFkIG1hZ2ljIG51bWJlcgoASW4gU09UIG1hcmtlciwgVFBTb3QgKCVkKSBpcyBub3QgdmFsaWQgcmVnYXJkcyB0byB0aGUgY3VycmVudCBudW1iZXIgb2YgdGlsZS1wYXJ0ICglZCksIGdpdmluZyB1cAoASW4gU09UIG1hcmtlciwgVFBTb3QgKCVkKSBpcyBub3QgdmFsaWQgcmVnYXJkcyB0byB0aGUgcHJldmlvdXMgbnVtYmVyIG9mIHRpbGUtcGFydCAoJWQpLCBnaXZpbmcgdXAKAEluIFNPVCBtYXJrZXIsIFRQU290ICglZCkgaXMgbm90IHZhbGlkIHJlZ2FyZHMgdG8gdGhlIGN1cnJlbnQgbnVtYmVyIG9mIHRpbGUtcGFydCAoaGVhZGVyKSAoJWQpLCBnaXZpbmcgdXAKAHRpbGVzIHJlcXVpcmUgYXQgbGVhc3Qgb25lIHJlc29sdXRpb24KAE1hcmtlciBpcyBub3QgY29tcGxpYW50IHdpdGggaXRzIHBvc2l0aW9uCgBQcm9ibGVtIHdpdGggc2VlayBmdW5jdGlvbgoARXJyb3IgcmVhZGluZyBTUENvZCBTUENvYyBlbGVtZW50LCBJbnZhbGlkIGNibGt3L2NibGtoIGNvbWJpbmF0aW9uCgBJbnZhbGlkIG11bHRpcGxlIGNvbXBvbmVudCB0cmFuc2Zvcm1hdGlvbgoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIGNvbGxlY3Rpb25zIG90aGVyIHRoYW4gYXJyYXkgZGVjb3JyZWxhdGlvbgoAVG9vIGxhcmdlIHZhbHVlIGZvciBOcHBtCgBOb3QgZW5vdWdoIGJ5dGVzIHRvIHJlYWQgTnBwbQoAYmFkIHBsYWNlZCBqcGVnIGNvZGVzdHJlYW0KAAkgTWFpbiBoZWFkZXIgc3RhcnQgcG9zaXRpb249JWxsaQoJIE1haW4gaGVhZGVyIGVuZCBwb3NpdGlvbj0lbGxpCgBNYXJrZXIgc2l6ZSBpbmNvbnNpc3RlbnQgd2l0aCBzdHJlYW0gbGVuZ3RoCgBUaWxlIHBhcnQgbGVuZ3RoIHNpemUgaW5jb25zaXN0ZW50IHdpdGggc3RyZWFtIGxlbmd0aAoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIG11bHRpcGxlIGRhdGEgc3Bhbm5pbmcKAFdyb25nIGZsYWcKAEVycm9yIHdpdGggRlRZUCBzaWduYXR1cmUgQm94IHNpemUKAEVycm9yIHdpdGggSlAgc2lnbmF0dXJlIEJveCBzaXplCgBJbnZhbGlkIHByZWNpbmN0IHNpemUKAEluY29uc2lzdGVudCBtYXJrZXIgc2l6ZQoASW52YWxpZCBtYXJrZXIgc2l6ZQoARXJyb3Igd2l0aCBTSVogbWFya2VyIHNpemUKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGFkZCBhIG5ldyB2YWxpZGF0aW9uIHByb2NlZHVyZQoATm90IGVub3VnaCBtZW1vcnkgdG8gZGVjb2RlIHRpbGUKAEZhaWxlZCB0byBkZWNvZGUgdGhlIGNvZGVzdHJlYW0gaW4gdGhlIEpQMiBmaWxlCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgY29sbGVjdGlvbnMgd2l0aCBpbmRpeCBzaHVmZmxlCgBDYW5ub3QgYWxsb2NhdGUgVGllciAxIGhhbmRsZQoATm8gZGVjb2RlZCBhcmVhIHBhcmFtZXRlcnMsIHNldCB0aGUgZGVjb2RlZCBhcmVhIHRvIHRoZSB3aG9sZSBpbWFnZQoATm90IGVub3VnaCBtZW1vcnkgdG8gY3JlYXRlIFRhZy10cmVlCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWluaXRpYWxpemUgdGhlIHRhZyB0cmVlCgBFcnJvciByZWFkaW5nIFNQQ29kIFNQQ29jIGVsZW1lbnQsIEludmFsaWQgdHJhbnNmb3JtYXRpb24gZm91bmQKAEVycm9yIHJlYWRpbmcgU1BDb2QgU1BDb2MgZWxlbWVudC4gVW5zdXBwb3J0ZWQgTWl4ZWQgSFQgY29kZS1ibG9jayBzdHlsZSBmb3VuZAoAVGlsZSBZIGNvb3JkaW5hdGVzIGFyZSBub3Qgc3VwcG9ydGVkCgBUaWxlIFggY29vcmRpbmF0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQKAEltYWdlIGNvb3JkaW5hdGVzIGFib3ZlIElOVF9NQVggYXJlIG5vdCBzdXBwb3J0ZWQKAEpQRUcyMDAwIEhlYWRlciBib3ggbm90IHJlYWQgeWV0LCAnJWMlYyVjJWMnIGJveCB3aWxsIGJlIGlnbm9yZWQKAG9wal9qMmtfbWVyZ2VfcHB0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlYWQgU09UIG1hcmtlci4gVGlsZSBpbmRleCBhbGxvY2F0aW9uIGZhaWxlZAoASWdub3JpbmcgaWhkciBib3guIEZpcnN0IGloZHIgYm94IGFscmVhZHkgcmVhZAoAWnBwdCAldSBhbHJlYWR5IHJlYWQKAFpwcG0gJXUgYWxyZWFkeSByZWFkCgBQVEVSTSBjaGVjayBmYWlsdXJlOiAlZCBzeW50aGV0aXplZCAweEZGIG1hcmtlcnMgcmVhZAoACQkJIGNibGt3PTJeJWQKAAkJCSBjYmxraD0yXiVkCgAJCQkgcW50c3R5PSVkCgAlcyBkeD0lZCwgZHk9JWQKAAkJCSByb2lzaGlmdD0lZAoACQkJIG51bWdiaXRzPSVkCgAJCSBudW1sYXllcnM9JWQKACVzIG51bWNvbXBzPSVkCgBvcGpfanAyX2FwcGx5X2NkZWY6IGFjbj0lZCwgbnVtY29tcHM9JWQKAG9wal9qcDJfYXBwbHlfY2RlZjogY249JWQsIG51bWNvbXBzPSVkCgAJCQkgbnVtcmVzb2x1dGlvbnM9JWQKAAkJIHR5cGU9JSN4LCBwb3M9JWxsaSwgbGVuPSVkCgAlcyBzZ25kPSVkCgAJCQkgcW1mYmlkPSVkCgAlcyBwcmVjPSVkCgAJCSBuYiBvZiB0aWxlLXBhcnQgaW4gdGlsZSBbJWRdPSVkCgAlcyB4MT0lZCwgeTE9JWQKACVzIHgwPSVkLCB5MD0lZAoARmFpbGVkIHRvIGRlY29kZSB0aWxlICVkLyVkCgBTZXR0aW5nIGRlY29kaW5nIGFyZWEgdG8gJWQsJWQsJWQsJWQKAEZhaWxlZCB0byBkZWNvZGUgY29tcG9uZW50ICVkCgBJbnZhbGlkIHZhbHVlIGZvciBudW1yZXNvbHV0aW9ucyA6ICVkLCBtYXggdmFsdWUgaXMgc2V0IGluIG9wZW5qcGVnLmggYXQgJWQKAEludmFsaWQgY29tcG9uZW50IG51bWJlcjogJWQsIHJlZ2FyZGluZyB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgJWQKAFRvbyBtYW55IFBPQ3MgJWQKAEludmFsaWQgdGlsZSBudW1iZXIgJWQKAEludmFsaWQgdGlsZSBwYXJ0IGluZGV4IGZvciB0aWxlIG51bWJlciAlZC4gR290ICVkLCBleHBlY3RlZCAlZAoARXJyb3Igd2l0aCBTSVogbWFya2VyOiBudW1iZXIgb2YgY29tcG9uZW50IGlzIGlsbGVnYWwgLT4gJWQKAE5vdCBlbm91Z2ggbWVtb3J5IGZvciBjaWVsYWIKAENhbm5vdCBhbGxvY2F0ZSBjYmxrLT5kZWNvZGVkX2RhdGEKAEZhaWxlZCB0byBtZXJnZSBQUFQgZGF0YQoARmFpbGVkIHRvIG1lcmdlIFBQTSBkYXRhCgBJbnZhbGlkIG51bWJlciBvZiBsYXllcnMgaW4gQ09EIG1hcmtlciA6ICVkIG5vdCBpbiByYW5nZSBbMS02NTUzNV0KACVzOiVkOmNvbG9yX2NteWtfdG9fcmdiCglDQU4gTk9UIENPTlZFUlQKACVzOiVkOmNvbG9yX2VzeWNjX3RvX3JnYgoJQ0FOIE5PVCBDT05WRVJUCgAlczolZDpjb2xvcl9zeWNjX3RvX3JnYgoJQ0FOIE5PVCBDT05WRVJUCgBTdHJlYW0gdG9vIHNob3J0LCBleHBlY3RlZCBTT1QKAFVuYWJsZSB0byBzZXQgdDEgaGFuZGxlIGFzIFRMUwoAU3RyZWFtIGRvZXMgbm90IGVuZCB3aXRoIEVPQwoAQ2Fubm90IGhhbmRsZSBib3ggc2l6ZXMgaGlnaGVyIHRoYW4gMl4zMgoAb3BqX3BpX25leHRfbHJjcCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfcmxjcCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfY3BybCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfcGNybCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfcnBjbCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3QxX2RlY29kZV9jYmxrKCk6IHVuc3VwcG9ydGVkIGJwbm9fcGx1c19vbmUgPSAlZCA+PSAzMQoARmFpbGVkIHRvIGRlY29kZSB0aWxlIDEvMQoASW5zdWZmaWNpZW50IGRhdGEgZm9yIENNQVAgYm94LgoATmVlZCB0byByZWFkIGEgUENMUiBib3ggYmVmb3JlIHRoZSBDTUFQIGJveC4KAEluc3VmZmljaWVudCBkYXRhIGZvciBDREVGIGJveC4KAE51bWJlciBvZiBjaGFubmVsIGRlc2NyaXB0aW9uIGlzIGVxdWFsIHRvIHplcm8gaW4gQ0RFRiBib3guCgBTdHJlYW0gZXJyb3Igd2hpbGUgcmVhZGluZyBKUDIgSGVhZGVyIGJveDogbm8gJ2loZHInIGJveC4KAE5vbiBjb25mb3JtYW50IGNvZGVzdHJlYW0gVFBzb3Q9PVROc290LgoAU3RyZWFtIGVycm9yIHdoaWxlIHJlYWRpbmcgSlAyIEhlYWRlciBib3g6IGJveCBsZW5ndGggaXMgaW5jb25zaXN0ZW50LgoAQm94IGxlbmd0aCBpcyBpbmNvbnNpc3RlbnQuCgBSZXNvbHV0aW9uIGZhY3RvciBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gcmVzb2x1dGlvbiBpbiB0aGUgY29tcG9uZW50LgoAQ29tcG9uZW50IG1hcHBpbmcgc2VlbXMgd3JvbmcuIFRyeWluZyB0byBjb3JyZWN0LgoASW5jb21wbGV0ZSBjaGFubmVsIGRlZmluaXRpb25zLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gSW52YWxpZCBjb2RlYmxvY2sgbGVuZ3RoIHZhbHVlcy4KAFdlIGRvIG5vdCBzdXBwb3J0IG1vcmUgdGhhbiAzIGNvZGluZyBwYXNzZXMgaW4gYW4gSFQgY29kZWJsb2NrOyBUaGlzIGNvZGVibG9ja3MgaGFzICVkIHBhc3Nlcy4KAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIERlY29kaW5nIHRoaXMgY29kZWJsb2NrIGlzIHN0b3BwZWQuIFRoZXJlIGFyZSAlZCB6ZXJvIGJpdHBsYW5lcyBpbiAlZCBiaXRwbGFuZXMuCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgbXVsdGlwbGUgdHJhbnNmb3JtYXRpb24gc3RhZ2VzLgoAVW5rbm93biBtYXJrZXIgaGFzIGJlZW4gZGV0ZWN0ZWQgYW5kIGdlbmVyYXRlZCBlcnJvci4KAENvZGVjIHByb3ZpZGVkIHRvIHRoZSBvcGpfc2V0dXBfZGVjb2RlciBmdW5jdGlvbiBpcyBub3QgYSBkZWNvbXByZXNzb3IgaGFuZGxlci4KAENvZGVjIHByb3ZpZGVkIHRvIHRoZSBvcGpfcmVhZF9oZWFkZXIgZnVuY3Rpb24gaXMgbm90IGEgZGVjb21wcmVzc29yIGhhbmRsZXIuCgBUaWxlcyBkb24ndCBhbGwgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb24uIFNraXAgdGhlIE1DVCBzdGVwLgoATnVtYmVyIG9mIGNvbXBvbmVudHMgKCVkKSBpcyBpbmNvbnNpc3RlbnQgd2l0aCBhIE1DVC4gU2tpcCB0aGUgTUNUIHN0ZXAuCgBKUDIgYm94IHdoaWNoIGFyZSBhZnRlciB0aGUgY29kZXN0cmVhbSB3aWxsIG5vdCBiZSByZWFkIGJ5IHRoaXMgZnVuY3Rpb24uCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBXaGVuIHRoZSBudW1iZXIgb2YgemVybyBwbGFuZXMgYml0cGxhbmVzIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgYml0cGxhbmVzLCBvbmx5IHRoZSBjbGVhbnVwIHBhc3MgbWFrZXMgc2Vuc2UsIGJ1dCB3ZSBoYXZlICVkIHBhc3NlcyBpbiB0aGlzIGNvZGVibG9jay4gVGhlcmVmb3JlLCBvbmx5IHRoZSBjbGVhbnVwIHBhc3Mgd2lsbCBiZSBkZWNvZGVkLiBUaGlzIG1lc3NhZ2Ugd2lsbCBub3QgYmUgZGlzcGxheWVkIGFnYWluLgoASW1hZ2UgaGFzIGxlc3MgY29tcG9uZW50cyB0aGFuIGNvZGVzdHJlYW0uCgBOZWVkIHRvIGRlY29kZSB0aGUgbWFpbiBoZWFkZXIgYmVmb3JlIGJlZ2luIHRvIGRlY29kZSB0aGUgcmVtYWluaW5nIGNvZGVzdHJlYW0uCgBQc290IHZhbHVlIG9mIHRoZSBjdXJyZW50IHRpbGUtcGFydCBpcyBlcXVhbCB0byB6ZXJvLCB3ZSBhc3N1bWluZyBpdCBpcyB0aGUgbGFzdCB0aWxlLXBhcnQgb2YgdGhlIGNvZGVzdHJlYW0uCgBBIG1hbGZvcm1lZCBjb2RlYmxvY2sgdGhhdCBoYXMgbW9yZSB0aGFuIG9uZSBjb2RpbmcgcGFzcywgYnV0IHplcm8gbGVuZ3RoIGZvciAybmQgYW5kIHBvdGVudGlhbGx5IHRoZSAzcmQgcGFzcyBpbiBhbiBIVCBjb2RlYmxvY2suCgAJCQkgdGlsZS1wYXJ0WyVkXTogc3Rhcl9wb3M9JWxsaSwgZW5kX2hlYWRlcj0lbGxpLCBlbmRfcG9zPSVsbGkuCgBUaWxlICV1IGhhcyBUUHNvdCA9PSAwIGFuZCBUTnNvdCA9PSAwLCBidXQgbm8gb3RoZXIgdGlsZS1wYXJ0cyB3ZXJlIGZvdW5kLiBFT0MgaXMgYWxzbyBtaXNzaW5nLgoAQ29tcG9uZW50ICVkIGRvZXNuJ3QgaGF2ZSBhIG1hcHBpbmcuCgBBIGNvbmZvcm1pbmcgSlAyIHJlYWRlciBzaGFsbCBpZ25vcmUgYWxsIENvbG91ciBTcGVjaWZpY2F0aW9uIGJveGVzIGFmdGVyIHRoZSBmaXJzdCwgc28gd2UgaWdub3JlIHRoaXMgb25lLgoAVGhlIHNpZ25hdHVyZSBib3ggbXVzdCBiZSB0aGUgZmlyc3QgYm94IGluIHRoZSBmaWxlLgoAVGhlICBib3ggbXVzdCBiZSB0aGUgZmlyc3QgYm94IGluIHRoZSBmaWxlLgoAVGhlIGZ0eXAgYm94IG11c3QgYmUgdGhlIHNlY29uZCBib3ggaW4gdGhlIGZpbGUuCgBGYWlsZWQgdG8gZGVjb2RlLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gSW5jb3JyZWN0IE1FTCBzZWdtZW50IHNlcXVlbmNlLgoAQ29tcG9uZW50ICVkIGlzIG1hcHBlZCB0d2ljZS4KAE9ubHkgb25lIENNQVAgYm94IGlzIGFsbG93ZWQuCgBXZSBuZWVkIGFuIGltYWdlIHByZXZpb3VzbHkgY3JlYXRlZC4KAElIRFIgYm94X21pc3NpbmcuIFJlcXVpcmVkLgoASlAySCBib3ggbWlzc2luZy4gUmVxdWlyZWQuCgBOb3Qgc3VyZSBob3cgdGhhdCBoYXBwZW5lZC4KAE1haW4gaGVhZGVyIGhhcyBiZWVuIGNvcnJlY3RseSBkZWNvZGVkLgoAVGlsZSAlZC8lZCBoYXMgYmVlbiBkZWNvZGVkLgoASGVhZGVyIG9mIHRpbGUgJWQgLyAlZCBoYXMgYmVlbiByZWFkLgoARW1wdHkgU09UIG1hcmtlciBkZXRlY3RlZDogUHNvdD0lZC4KAERpcmVjdCB1c2UgYXQgIyVkIGhvd2V2ZXIgcGNvbD0lZC4KAEltcGxlbWVudGF0aW9uIGxpbWl0YXRpb246IGZvciBwYWxldHRlIG1hcHBpbmcsIHBjb2xbJWRdIHNob3VsZCBiZSBlcXVhbCB0byAlZCwgYnV0IGlzIGVxdWFsIHRvICVkLgoASW52YWxpZCBjb21wb25lbnQvcGFsZXR0ZSBpbmRleCBmb3IgZGlyZWN0IG1hcHBpbmcgJWQuCgBJbnZhbGlkIHZhbHVlIGZvciBjbWFwWyVkXS5tdHlwID0gJWQuCgBQc290IHZhbHVlIGlzIG5vdCBjb3JyZWN0IHJlZ2FyZHMgdG8gdGhlIEpQRUcyMDAwIG5vcm06ICVkLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gVkxDIGNvZGUgcHJvZHVjZXMgc2lnbmlmaWNhbnQgc2FtcGxlcyBvdXRzaWRlIHRoZSBjb2RlYmxvY2sgYXJlYS4KAFVuZXhwZWN0ZWQgT09NLgoAMzIgYml0cyBhcmUgbm90IGVub3VnaCB0byBkZWNvZGUgdGhpcyBjb2RlYmxvY2ssIHNpbmNlIHRoZSBudW1iZXIgb2YgYml0cGxhbmUsICVkLCBpcyBsYXJnZXIgdGhhbiAzMC4KAEJvdHRvbSBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feTE9JWQpIHNob3VsZCBiZSA+IDAuCgBSaWdodCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDE9JWQpIHNob3VsZCBiZSA+IDAuCgBVcCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feTA9JWQpIHNob3VsZCBiZSA+PSAwLgoATGVmdCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDA9JWQpIHNob3VsZCBiZSA+PSAwLgoARXJyb3IgcmVhZGluZyBQUFQgbWFya2VyOiBwYWNrZXQgaGVhZGVyIGhhdmUgYmVlbiBwcmV2aW91c2x5IGZvdW5kIGluIHRoZSBtYWluIGhlYWRlciAoUFBNIG1hcmtlcikuCgBTdGFydCB0byByZWFkIGoyayBtYWluIGhlYWRlciAoJWxsZCkuCgBCb3R0b20gcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3kxPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChZc2l6PSVkKS4KAFVwIHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl95MD0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWXNpej0lZCkuCgBSaWdodCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDE9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhzaXo9JWQpLgoATGVmdCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDA9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhzaXo9JWQpLgoAQm90dG9tIHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl95MT0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWU9zaXo9JWQpLgoAVXAgcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3kwPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChZT3Npej0lZCkuCgBSaWdodCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDE9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhPc2l6PSVkKS4KAExlZnQgcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3gwPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChYT3Npej0lZCkuCgBTaXplIHggb2YgdGhlIGRlY29kZWQgY29tcG9uZW50IGltYWdlIGlzIGluY29ycmVjdCAoY29tcFslZF0udz0lZCkuCgBTaXplIHkgb2YgdGhlIGRlY29kZWQgY29tcG9uZW50IGltYWdlIGlzIGluY29ycmVjdCAoY29tcFslZF0uaD0lZCkuCgBUaWxlIHJlYWQsIGRlY29kZWQgYW5kIHVwZGF0ZWQgaXMgbm90IHRoZSBkZXNpcmVkIG9uZSAoJWQgdnMgJWQpLgoASW52YWxpZCBjb21wb25lbnQgaW5kZXggJWQgKD49ICVkKS4KAG9wal9yZWFkX2hlYWRlcigpIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIG9wal9zZXRfZGVjb2RlZF9jb21wb25lbnRzKCkuCgBNZW1vcnkgYWxsb2NhdGlvbiBmYWlsdXJlIGluIG9wal9qcDJfYXBwbHlfcGNscigpLgoAaW1hZ2UtPmNvbXBzWyVkXS5kYXRhID09IE5VTEwgaW4gb3BqX2pwMl9hcHBseV9wY2xyKCkuCgBpbnZhbGlkIGJveCBzaXplICVkICgleCkKAEZhaWwgdG8gcmVhZCB0aGUgY3VycmVudCBtYXJrZXIgc2VnbWVudCAoJSN4KQoARXJyb3Igd2l0aCBTSVogbWFya2VyOiBJSERSIHcoJXUpIGgoJXUpIHZzLiBTSVogdygldSkgaCgldSkKAEVycm9yIHJlYWRpbmcgQ09DIG1hcmtlciAoYmFkIG51bWJlciBvZiBjb21wb25lbnRzKQoASW52YWxpZCBudW1iZXIgb2YgdGlsZXMgOiAldSB4ICV1IChtYXhpbXVtIGZpeGVkIGJ5IGpwZWcyMDAwIG5vcm0gaXMgNjU1MzUgdGlsZXMpCgBJbnZhbGlkIG51bWJlciBvZiBjb21wb25lbnRzIChpaGRyKQoATm90IGVub3VnaCBtZW1vcnkgdG8gaGFuZGxlIGltYWdlIGhlYWRlciAoaWhkcikKAFdyb25nIHZhbHVlcyBmb3I6IHcoJWQpIGgoJWQpIG51bWNvbXBzKCVkKSAoaWhkcikKAEludmFsaWQgdmFsdWVzIGZvciBjb21wID0gJWQgOiBkeD0ldSBkeT0ldSAoc2hvdWxkIGJlIGJldHdlZW4gMSBhbmQgMjU1IGFjY29yZGluZyB0byB0aGUgSlBFRzIwMDAgbm9ybSkKAEJhZCBpbWFnZSBoZWFkZXIgYm94IChiYWQgc2l6ZSkKAEJhZCBDT0xSIGhlYWRlciBib3ggKGJhZCBzaXplKQoAQmFkIEJQQ0MgaGVhZGVyIGJveCAoYmFkIHNpemUpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IG5lZ2F0aXZlIG9yIHplcm8gaW1hZ2Ugc2l6ZSAoJWxsZCB4ICVsbGQpCgBza2lwOiBzZWdtZW50IHRvbyBsb25nICglZCkgd2l0aCBtYXggKCVkKSBmb3IgY29kZWJsb2NrICVkIChwPSVkLCBiPSVkLCByPSVkLCBjPSVkKQoAcmVhZDogc2VnbWVudCB0b28gbG9uZyAoJWQpIHdpdGggbWF4ICglZCkgZm9yIGNvZGVibG9jayAlZCAocD0lZCwgYj0lZCwgcj0lZCwgYz0lZCkKAERlc3BpdGUgSlAyIEJQQyE9MjU1LCBwcmVjaXNpb24gYW5kL29yIHNnbmQgdmFsdWVzIGZvciBjb21wWyVkXSBpcyBkaWZmZXJlbnQgdGhhbiBjb21wWzBdOgogICAgICAgIFswXSBwcmVjKCVkKSBzZ25kKCVkKSBbJWRdIHByZWMoJWQpIHNnbmQoJWQpCgBiYWQgY29tcG9uZW50IG51bWJlciBpbiBSR04gKCVkIHdoZW4gdGhlcmUgYXJlIG9ubHkgJWQpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IG51bWJlciBvZiBjb21wb25lbnQgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgcmVtYWluaW5nIG51bWJlciBvZiBwYXJhbWV0ZXJzICggJWQgdnMgJWQpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IGludmFsaWQgdGlsZSBzaXplICh0ZHg6ICVkLCB0ZHk6ICVkKQoAQmFkIENPTFIgaGVhZGVyIGJveCAoYmFkIHNpemU6ICVkKQoAQmFkIENPTFIgaGVhZGVyIGJveCAoQ0lFTGFiLCBiYWQgc2l6ZTogJWQpCgBQVEVSTSBjaGVjayBmYWlsdXJlOiAlZCByZW1haW5pbmcgYnl0ZXMgaW4gY29kZSBibG9jayAoJWQgdXNlZCAvICVkKQoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gT25lIG9mIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQ6IDIgPD0gU2N1cCA8PSBtaW4oTGN1cCwgNDA3OSkKAEludmFsaWQgdmFsdWVzIGZvciBjb21wID0gJWQgOiBwcmVjPSV1IChzaG91bGQgYmUgYmV0d2VlbiAxIGFuZCAzOCBhY2NvcmRpbmcgdG8gdGhlIEpQRUcyMDAwIG5vcm0uIE9wZW5KcGVnIG9ubHkgc3VwcG9ydHMgdXAgdG8gMzEpCgBJbnZhbGlkIGJpdCBudW1iZXIgJWQgaW4gb3BqX3QyX3JlYWRfcGFja2V0X2hlYWRlcigpCgBTdHJlYW0gZXJyb3IhCgBFcnJvciBvbiB3cml0aW5nIHN0cmVhbSEKAFN0cmVhbSByZWFjaGVkIGl0cyBlbmQgIQoARXhwZWN0ZWQgYSBTT0MgbWFya2VyIAoASW52YWxpZCBib3ggc2l6ZSAlZCBmb3IgYm94ICclYyVjJWMlYycuIE5lZWQgJWQgYnl0ZXMsICVkIGJ5dGVzIHJlbWFpbmluZyAKAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIERlY29kaW5nIHRoaXMgY29kZWJsb2NrIGlzIHN0b3BwZWQuIFVfcSBpcyBsYXJnZXIgdGhhbiB6ZXJvIGJpdHBsYW5lcyArIDEgCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBEZWNvZGluZyB0aGlzIGNvZGVibG9jayBpcyBzdG9wcGVkLiBVX3EgaXNsYXJnZXIgdGhhbiBiaXRwbGFuZXMgKyAxIAoAQ09MUiBCT1ggbWV0aCB2YWx1ZSBpcyBub3QgYSByZWd1bGFyIHZhbHVlICglZCksIHNvIHdlIHdpbGwgaWdub3JlIHRoZSBlbnRpcmUgQ29sb3VyIFNwZWNpZmljYXRpb24gYm94LiAKAFdoaWxlIHJlYWRpbmcgQ0NQX1FOVFNUWSBlbGVtZW50IGluc2lkZSBRQ0Qgb3IgUUNDIG1hcmtlciBzZWdtZW50LCBudW1iZXIgb2Ygc3ViYmFuZHMgKCVkKSBpcyBncmVhdGVyIHRvIE9QSl9KMktfTUFYQkFORFMgKCVkKS4gU28gd2UgbGltaXQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBzdG9yZWQgdG8gT1BKX0oyS19NQVhCQU5EUyAoJWQpIGFuZCBza2lwIHRoZSByZXN0LiAKAEpQMiBJSERSIGJveDogY29tcHJlc3Npb24gdHlwZSBpbmRpY2F0ZSB0aGF0IHRoZSBmaWxlIGlzIG5vdCBhIGNvbmZvcm1pbmcgSlAyIGZpbGUgKCVkKSAKAFRpbGUgaW5kZXggcHJvdmlkZWQgYnkgdGhlIHVzZXIgaXMgaW5jb3JyZWN0ICVkIChtYXggPSAlZCkgCgBFcnJvciBkZWNvZGluZyBjb21wb25lbnQgJWQuClRoZSBudW1iZXIgb2YgcmVzb2x1dGlvbnMgdG8gcmVtb3ZlICglZCkgaXMgZ3JlYXRlciBvciBlcXVhbCB0aGFuIHRoZSBudW1iZXIgb2YgcmVzb2x1dGlvbnMgb2YgdGhpcyBjb21wb25lbnQg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AAABVAAAAQAAAABQAADAUAAAAUgAAAAAAAAQUAAAsFAAAAFIAAABAAAAIFAAAMBQAAABOAAAAAAAADBQAACwUAAAATgAAAEAAABAUAAAwFAAAAEwAAAAAAAAUFAAABBRAAABMAAAAQAAAGBQAAAgUQAAASQAAAAAAABwUAAAMFEAAAEkAAABAAAAgFAAAEBRAAABHAAAAAAAAJBQAABwUQAAARwAAAEAAACgUAAAgFEAAAEWAAAAAAAAkFIAAJBRAAABFgAAAQAAAKBSAACgUQAAAVYAAAAAAADQUAAAwFAAAAFWAAABAAAA4FAAALBQAAABVAAAAAAAAPBQAACwUAAAAVQAAAEAAAAAUQAAwFAAAAFRAAAAAAAAEFEAANBQAAABUQAAAQAAACBRAADgUAAAAUgAAAAAAAAwUQAA8FAAAAFIAAABAAAAQFEAAABRAAABOAAAAAAAAFBRAAAQUQAAATgAAAEAAABgUQAAIFEAAAE0AAAAAAAAcFEAADBRAAABNAAAAQAAAIBRAABAUQAAATAAAAAAAACQUQAAUFEAAAEwAAABAAAAoFEAAGBRAAABKAAAAAAAALBRAABQUQAAASgAAAEAAADAUQAAYFEAAAEkAAAAAAAA0FEAAHBRAAABJAAAAQAAAOBRAACAUQAAASIAAAAAAADwUQAAkFEAAAEiAAABAAAAAFIAAKBRAAABHAAAAAAAABBSAACwUQAAARwAAAEAAAAgUgAAwFEAAAEYAAAAAAAAMFIAANBRAAABGAAAAQAAAEBSAADgUQAAARYAAAAAAABQUgAA8FEAAAEWAAABAAAAYFIAAABSAAABFAAAAAAAAHBSAAAQUgAAARQAAAEAAACAUgAAIFIAAAESAAAAAAAAkFIAADBSAAABEgAAAQAAAKBSAABAUgAAAREAAAAAAACwUgAAUFIAAAERAAABAAAAwFIAAGBSAADBCgAAAAAAANBSAABwUgAAwQoAAAEAAADgUgAAgFIAAMEJAAAAAAAA8FIAAJBSAADBCQAAAQAAAABTAACgUgAAoQgAAAAAAAAQUwAAsFIAAKEIAAABAAAAIFMAAMBSAAAhBQAAAAAAADBTAADQUgAAIQUAAAEAAABAUwAA4FIAAEEEAAAAAAAAUFMAAPBSAABBBAAAAQAAAGBTAAAAUwAAoQIAAAAAAABwUwAAEFMAAKECAAABAAAAgFMAACBTAAAhAgAAAAAAAJBTAAAwUwAAIQIAAAEAAACgUwAAQFMAAEEBAAAAAAAAsFMAAFBTAABBAQAAAQAAAMBTAABgUwAAEQEAAAAAAADQUwAAcFMAABEBAAABAAAA4FMAAIBTAACFAAAAAAAAAPBTAACQUwAAhQAAAAEAAAAAVAAAoFMAAEkAAAAAAAAAEFQAALBTAABJAAAAAQAAACBUAADAUwAAJQAAAAAAAAAwVAAA0FMAACUAAAABAAAAQFQAAOBTAAAVAAAAAAAAAFBUAADwUwAAFQAAAAEAAABgVAAAAFQAAAkAAAAAAAAAcFQAABBUAAAJAAAAAQAAAIBUAAAgVAAABQAAAAAAAACQVAAAMFQAAAUAAAABAAAAoFQAAEBUAAABAAAAAAAAAJBUAABQVAAAAQAAAAEAAACgVAAAYFQAAAFWAAAAAAAAsFQAALBUAAABVgAAAQAAAMBUAADAVAAAAAEDAwECAwMFBgcHBgYHBwABAwMBAgMDBQYHBwYGBwcFBgcHBgYHBwgICAgICAgIBQYHBwYGBwcICAgICAgICAECAwMCAgMDBgYHBwYGBwcBAgMDAgIDAwYGBwcGBgcHBgYHBwYGBwcICAgICAgICAYGBwcGBgcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAECAwMCAgMDBgYHBwYGBwcBAgMDAgIDAwYGBwcGBgcHBgYHBwYGBwcICAgICAgICAYGBwcGBgcHCAgICAgICAgCAgMDAgIDAwYGBwcGBgcHAgIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgAAQUGAQIGBgMDBwcDAwcHAAEFBgECBgYDAwcHAwMHBwMDBwcDAwcHBAQHBwQEBwcDAwcHAwMHBwQEBwcEBAcHAQIGBgICBgYDAwcHAwMHBwECBgYCAgYGAwMHBwMDBwcDAwcHAwMHBwQEBwcEBAcHAwMHBwMDBwcEBAcHBAQHBwUGCAgGBggIBwcICAcHCAgFBggIBgYICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgGBggIBgYICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIAQIGBgICBgYDAwcHAwMHBwECBgYCAgYGAwMHBwMDBwcDAwcHAwMHBwQEBwcEBAcHAwMHBwMDBwcEBAcHBAQHBwICBgYCAgYGAwMHBwMDBwcCAgYGAgIGBgMDBwcDAwcHAwMHBwMDBwcEBAcHBAQHBwMDBwcDAwcHBAQHBwQEBwcGBggIBgYICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAYGCAgGBggIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAABAwMBAgMDBQYHBwYGBwcAAQMDAQIDAwUGBwcGBgcHBQYHBwYGBwcICAgICAgICAUGBwcGBgcHCAgICAgICAgBAgMDAgIDAwYGBwcGBgcHAQIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgBAgMDAgIDAwYGBwcGBgcHAQIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAgIDAwICAwMGBgcHBgYHBwICAwMCAgMDBgYHBwYGBwcGBgcHBgYHBwgICAgICAgIBgYHBwYGBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAAMBBAMGBAcBBAIFBAcFBwADAQQDBgQHAQQCBQQHBQcBBAIFBAcFBwIFAgUFBwUHAQQCBQQHBQcCBQIFBQcFBwMGBAcGCAcIBAcFBwcIBwgDBgQHBggHCAQHBQcHCAcIBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgBBAIFBAcFBwIFAgUFBwUHAQQCBQQHBQcCBQIFBQcFBwIFAgUFBwUHAgUCBQUHBQcCBQIFBQcFBwIFAgUFBwUHBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAMGBAcGCAcIBAcFBwcIBwgDBgQHBggHCAQHBQcHCAcIBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgGCAcICAgICAcIBwgICAgIBggHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgJCQoKCQkKCgwMDQsMDA0LCQkKCgkJCgoMDAsNDAwLDQwMDQ0MDAsLDAkNCgkMCgsMDAsLDAwNDQwJCwoJDAoNCQkKCgkJCgoMDA0LDAwNCwkJCgoJCQoKDAwLDQwMCw0MDA0NDAwLCwwJDQoJDAoLDAwLCwwMDQ0MCQsKCQwKDQoKCgoKCgoKDQsNCw0LDQsKCgkJCgoJCQ0LDAwNCwwMDQ0NDQsLCwsNCg0KCgsKCw0NDAwLCwwMDQoMCQoLCQwKCgkJCgoJCQsNDAwLDQwMCgoKCgoKCgoLDQsNCw0LDQsLDAwNDQwMCwoMCQoNCQwLCwsLDQ0NDQsKCwoKDQoNAEHZuwELNwEAAQABAAEAAAEBAAABAQABAAEAAQABAAAAAAEBAQEAAAAAAAEAAQAAAAABAQEBAAAAAQABAQEAQZm8AQs3AQABAAEAAQAAAQEAAAEBAAEAAQABAAEAAAAAAQEBAQAAAAAAAQABAAAAAAEBAQEAAAABAAEBAQBB2bwBCwcBAAEAAQABAEHpvAELlQIBAAEAAQABAAAAAAEBAQEAAAAAAAEAAQAAAAABAQEBAAAAAAABAAEBAQAAAQEAAAABAAEAAQABAQEBAQEBAQEAAQABAAEAAQAAAAABAQEBAAEAAAEBAAEAAAAAAQEBAQABAAEBAQEBAgAAAAQAAAAEAAAACAAAAJD/AAAMAAAAGAAAAFL/AAAUAAAAGQAAAFP/AAAUAAAAGgAAAF7/AAAUAAAAGwAAAFz/AAAUAAAAHAAAAF3/AAAUAAAAHQAAAF//AAAUAAAAHgAAAFH/AAACAAAAHwAAAFX/AAAEAAAAIAAAAFf/AAAEAAAAIQAAAFj/AAAQAAAAIgAAAGD/AAAEAAAAIwAAAGH/AAAQAAAAJAAAAJH/AEGIvwELZWP/AAAEAAAAJQAAAGT/AAAUAAAAJgAAAHT/AAAUAAAAJwAAAHj/AAAEAAAAKAAAAFD/AAAEAAAAKQAAAFn/AAAEAAAAKgAAAHX/AAAUAAAAKwAAAHf/AAAUAAAALAAAAAAAAAAUAEGAwAELNS0AAAAuAAAALwAAADAAAAAxAAAAMgAAADMAAAA0AAAAICBQajYAAABweXRmNwAAAGgycGo4AEHAwAELMnJkaGk5AAAAcmxvYzoAAABjY3BiOwAAAHJsY3A8AAAAcGFtYz0AAABmZWRjPgAAAPhiAEGAwQELQRkACwAZGRkAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAGQAKChkZGQMKBwABAAkLGAAACQYLAAALAAYZAAAAGRkZAEHRwQELIQ4AAAAAAAAAABkACw0ZGRkADQAAAgAJDgAAAAkADgAADgBBi8IBCwEMAEGXwgELFRMAAAAAEwAAAAAJDAAAAAAADAAADABBxcIBCwEQAEHRwgELFQ8AAAAEDwAAAAAJEAAAAAAAEAAAEABB/8IBCwESAEGLwwELHhEAAAAAEQAAAAAJEgAAAAAAEgAAEgAAGgAAABoaGgBBwsMBCw4aAAAAGhoaAAAAAAAACQBB88MBCwEUAEH/wwELFRcAAAAAFwAAAAAJFAAAAAAAFAAAFABBrcQBCwEWAEG5xAELJxUAAAAAFQAAAAAJFgAAAAAAFgAAFgAAMDEyMzQ1Njc4OUFCQ0RFRgBB4MQBCwmQbAEAAAAAAAUAQfTEAQsBaQBBjMUBCwpqAAAAawAAAHhoAEGkxQELAQIAQbTFAQsI//////////8AQfjFAQsBBQBBhMYBCwFsAEGcxgELDmoAAABtAAAAiGgAAAAEAEG0xgELAQEAQcTGAQsF/////wo="), receiveInstance(instantiateSync(u3, e4)[0]);
      }();
      function run() {
        function doRun() {
          b3 || (b3 = true, a3.calledRun = true, callRuntimeCallbacks(f3), t3(a3), a3.onRuntimeInitialized && a3.onRuntimeInitialized(), function() {
            if (a3.postRun) for ("function" == typeof a3.postRun && (a3.postRun = [a3.postRun]); a3.postRun.length; ) e4 = a3.postRun.shift(), p3.unshift(e4);
            var e4;
            callRuntimeCallbacks(p3);
          }());
        }
        m3 > 0 || (function() {
          if (a3.preRun) for ("function" == typeof a3.preRun && (a3.preRun = [a3.preRun]); a3.preRun.length; ) e4 = a3.preRun.shift(), Q3.unshift(e4);
          var e4;
          callRuntimeCallbacks(Q3);
        }(), m3 > 0 || (a3.setStatus ? (a3.setStatus("Running..."), setTimeout(function() {
          setTimeout(function() {
            a3.setStatus("");
          }, 1), doRun();
        }, 1)) : doRun()));
      }
      if (R3.q, a3._malloc = R3.r, a3._free = R3.s, a3._jp2_decode = R3.u, y3 = function runCaller() {
        b3 || run(), b3 || (y3 = runCaller);
      }, a3.preInit) for ("function" == typeof a3.preInit && (a3.preInit = [a3.preInit]); a3.preInit.length > 0; ) a3.preInit.pop()();
      return run(), a3;
    });
    Ln = vn;
    JpxError = class extends Ms {
      constructor(e3) {
        super(e3, "JpxError");
      }
    };
    JpxImage = class {
      static decode(e3, t3) {
        t3 || (t3 = {}), __privateGet(this, _y) || __privateSet(this, _y, Ln({ warn }));
        const i3 = __privateGet(this, _y).decode(e3, t3);
        if ("string" == typeof i3) throw new JpxError(i3);
        return i3;
      }
      static cleanup() {
        __privateSet(this, _y, null);
      }
      static parseImageProperties(e3) {
        let t3 = e3.getByte();
        for (; t3 >= 0; ) {
          const i3 = t3;
          t3 = e3.getByte();
          if (65361 === (i3 << 8 | t3)) {
            e3.skip(4);
            const t4 = e3.getInt32() >>> 0, i4 = e3.getInt32() >>> 0, a3 = e3.getInt32() >>> 0, s3 = e3.getInt32() >>> 0;
            e3.skip(16);
            return { width: t4 - a3, height: i4 - s3, bitsPerComponent: 8, componentsCount: e3.getUint16() };
          }
        }
        throw new JpxError("No size marker found in JPX stream");
      }
    };
    _y = new WeakMap();
    __privateAdd(JpxImage, _y, null);
    JpxStream = class extends DecodeStream {
      constructor(e3, t3, i3) {
        super(t3), this.stream = e3, this.dict = e3.dict, this.maybeLength = t3, this.params = i3;
      }
      get bytes() {
        return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
      }
      ensureBuffer(e3) {
      }
      readBlock(e3) {
        this.decodeImage(null, e3);
      }
      decodeImage(e3, t3) {
        return this.eof || (e3 || (e3 = this.bytes), this.buffer = JpxImage.decode(e3, t3), this.bufferLength = this.buffer.length, this.eof = true), this.buffer;
      }
      get canAsyncDecodeImageFromBuffer() {
        return this.stream.isAsync;
      }
    };
    LZWStream = class extends DecodeStream {
      constructor(e3, t3, i3) {
        super(t3), this.str = e3, this.dict = e3.dict, this.cachedData = 0, this.bitsCached = 0;
        const a3 = 4096, s3 = { earlyChange: i3, codeLength: 9, nextCode: 258, dictionaryValues: new Uint8Array(a3), dictionaryLengths: new Uint16Array(a3), dictionaryPrevCodes: new Uint16Array(a3), currentSequence: new Uint8Array(a3), currentSequenceLength: 0 };
        for (let e4 = 0; e4 < 256; ++e4) s3.dictionaryValues[e4] = e4, s3.dictionaryLengths[e4] = 1;
        this.lzwState = s3;
      }
      readBits(e3) {
        let t3 = this.bitsCached, i3 = this.cachedData;
        for (; t3 < e3; ) {
          const e4 = this.str.getByte();
          if (-1 === e4) return this.eof = true, null;
          i3 = i3 << 8 | e4, t3 += 8;
        }
        return this.bitsCached = t3 -= e3, this.cachedData = i3, this.lastCode = null, i3 >>> t3 & (1 << e3) - 1;
      }
      readBlock() {
        let e3, t3, i3, a3 = 1024;
        const s3 = this.lzwState;
        if (!s3) return;
        const n3 = s3.earlyChange;
        let r3 = s3.nextCode;
        const o3 = s3.dictionaryValues, g3 = s3.dictionaryLengths, c3 = s3.dictionaryPrevCodes;
        let h3 = s3.codeLength, l3 = s3.prevCode;
        const C3 = s3.currentSequence;
        let d3 = s3.currentSequenceLength, u3 = 0, Q3 = this.bufferLength, f3 = this.ensureBuffer(this.bufferLength + a3);
        for (e3 = 0; e3 < 512; e3++) {
          const e4 = this.readBits(h3), s4 = d3 > 0;
          if (e4 < 256) C3[0] = e4, d3 = 1;
          else {
            if (!(e4 >= 258)) {
              if (256 === e4) {
                h3 = 9, r3 = 258, d3 = 0;
                continue;
              }
              this.eof = true, delete this.lzwState;
              break;
            }
            if (e4 < r3) for (d3 = g3[e4], t3 = d3 - 1, i3 = e4; t3 >= 0; t3--) C3[t3] = o3[i3], i3 = c3[i3];
            else C3[d3++] = C3[0];
          }
          if (s4 && (c3[r3] = l3, g3[r3] = g3[l3] + 1, o3[r3] = C3[0], r3++, h3 = r3 + n3 & r3 + n3 - 1 ? h3 : 0 | Math.min(Math.log(r3 + n3) / 0.6931471805599453 + 1, 12)), l3 = e4, u3 += d3, a3 < u3) {
            do {
              a3 += 512;
            } while (a3 < u3);
            f3 = this.ensureBuffer(this.bufferLength + a3);
          }
          for (t3 = 0; t3 < d3; t3++) f3[Q3++] = C3[t3];
        }
        s3.nextCode = r3, s3.codeLength = h3, s3.prevCode = l3, s3.currentSequenceLength = d3, this.bufferLength = Q3;
      }
    };
    PredictorStream = class extends DecodeStream {
      constructor(e3, t3, i3) {
        if (super(t3), !(i3 instanceof Dict)) return e3;
        const a3 = this.predictor = i3.get("Predictor") || 1;
        if (a3 <= 1) return e3;
        if (2 !== a3 && (a3 < 10 || a3 > 15)) throw new FormatError(`Unsupported predictor: ${a3}`);
        this.readBlock = 2 === a3 ? this.readBlockTiff : this.readBlockPng, this.str = e3, this.dict = e3.dict;
        const s3 = this.colors = i3.get("Colors") || 1, n3 = this.bits = i3.get("BPC", "BitsPerComponent") || 8, r3 = this.columns = i3.get("Columns") || 1;
        return this.pixBytes = s3 * n3 + 7 >> 3, this.rowBytes = r3 * s3 * n3 + 7 >> 3, this;
      }
      readBlockTiff() {
        const e3 = this.rowBytes, t3 = this.bufferLength, i3 = this.ensureBuffer(t3 + e3), a3 = this.bits, s3 = this.colors, n3 = this.str.getBytes(e3);
        if (this.eof = !n3.length, this.eof) return;
        let r3, o3 = 0, g3 = 0, c3 = 0, h3 = 0, l3 = t3;
        if (1 === a3 && 1 === s3) for (r3 = 0; r3 < e3; ++r3) {
          let e4 = n3[r3] ^ o3;
          e4 ^= e4 >> 1, e4 ^= e4 >> 2, e4 ^= e4 >> 4, o3 = (1 & e4) << 7, i3[l3++] = e4;
        }
        else if (8 === a3) {
          for (r3 = 0; r3 < s3; ++r3) i3[l3++] = n3[r3];
          for (; r3 < e3; ++r3) i3[l3] = i3[l3 - s3] + n3[r3], l3++;
        } else if (16 === a3) {
          const t4 = 2 * s3;
          for (r3 = 0; r3 < t4; ++r3) i3[l3++] = n3[r3];
          for (; r3 < e3; r3 += 2) {
            const e4 = ((255 & n3[r3]) << 8) + (255 & n3[r3 + 1]) + ((255 & i3[l3 - t4]) << 8) + (255 & i3[l3 - t4 + 1]);
            i3[l3++] = e4 >> 8 & 255, i3[l3++] = 255 & e4;
          }
        } else {
          const e4 = new Uint8Array(s3 + 1), l4 = (1 << a3) - 1;
          let C3 = 0, d3 = t3;
          const u3 = this.columns;
          for (r3 = 0; r3 < u3; ++r3) for (let t4 = 0; t4 < s3; ++t4) c3 < a3 && (o3 = o3 << 8 | 255 & n3[C3++], c3 += 8), e4[t4] = e4[t4] + (o3 >> c3 - a3) & l4, c3 -= a3, g3 = g3 << a3 | e4[t4], h3 += a3, h3 >= 8 && (i3[d3++] = g3 >> h3 - 8 & 255, h3 -= 8);
          h3 > 0 && (i3[d3++] = (g3 << 8 - h3) + (o3 & (1 << 8 - h3) - 1));
        }
        this.bufferLength += e3;
      }
      readBlockPng() {
        const e3 = this.rowBytes, t3 = this.pixBytes, i3 = this.str.getByte(), a3 = this.str.getBytes(e3);
        if (this.eof = !a3.length, this.eof) return;
        const s3 = this.bufferLength, n3 = this.ensureBuffer(s3 + e3);
        let r3 = n3.subarray(s3 - e3, s3);
        0 === r3.length && (r3 = new Uint8Array(e3));
        let o3, g3, c3, h3 = s3;
        switch (i3) {
          case 0:
            for (o3 = 0; o3 < e3; ++o3) n3[h3++] = a3[o3];
            break;
          case 1:
            for (o3 = 0; o3 < t3; ++o3) n3[h3++] = a3[o3];
            for (; o3 < e3; ++o3) n3[h3] = n3[h3 - t3] + a3[o3] & 255, h3++;
            break;
          case 2:
            for (o3 = 0; o3 < e3; ++o3) n3[h3++] = r3[o3] + a3[o3] & 255;
            break;
          case 3:
            for (o3 = 0; o3 < t3; ++o3) n3[h3++] = (r3[o3] >> 1) + a3[o3];
            for (; o3 < e3; ++o3) n3[h3] = (r3[o3] + n3[h3 - t3] >> 1) + a3[o3] & 255, h3++;
            break;
          case 4:
            for (o3 = 0; o3 < t3; ++o3) g3 = r3[o3], c3 = a3[o3], n3[h3++] = g3 + c3;
            for (; o3 < e3; ++o3) {
              g3 = r3[o3];
              const e4 = r3[o3 - t3], i4 = n3[h3 - t3], s4 = i4 + g3 - e4;
              let l3 = s4 - i4;
              l3 < 0 && (l3 = -l3);
              let C3 = s4 - g3;
              C3 < 0 && (C3 = -C3);
              let d3 = s4 - e4;
              d3 < 0 && (d3 = -d3), c3 = a3[o3], n3[h3++] = l3 <= C3 && l3 <= d3 ? i4 + c3 : C3 <= d3 ? g3 + c3 : e4 + c3;
            }
            break;
          default:
            throw new FormatError(`Unsupported predictor: ${i3}`);
        }
        this.bufferLength += e3;
      }
    };
    RunLengthStream = class extends DecodeStream {
      constructor(e3, t3) {
        super(t3), this.str = e3, this.dict = e3.dict;
      }
      readBlock() {
        const e3 = this.str.getBytes(2);
        if (!e3 || e3.length < 2 || 128 === e3[0]) return void (this.eof = true);
        let t3, i3 = this.bufferLength, a3 = e3[0];
        if (a3 < 128) {
          if (t3 = this.ensureBuffer(i3 + a3 + 1), t3[i3++] = e3[1], a3 > 0) {
            const e4 = this.str.getBytes(a3);
            t3.set(e4, i3), i3 += a3;
          }
        } else {
          a3 = 257 - a3;
          const s3 = e3[1];
          t3 = this.ensureBuffer(i3 + a3 + 1);
          for (let e4 = 0; e4 < a3; e4++) t3[i3++] = s3;
        }
        this.bufferLength = i3;
      }
    };
    Parser = class {
      constructor({ lexer: e3, xref: t3, allowStreams: i3 = false, recoveryMode: a3 = false }) {
        __privateAdd(this, _Parser_instances);
        this.lexer = e3, this.xref = t3, this.allowStreams = i3, this.recoveryMode = a3, this.imageCache = /* @__PURE__ */ Object.create(null), this._imageId = 0, this.refill();
      }
      refill() {
        this.buf1 = this.lexer.getObj(), this.buf2 = this.lexer.getObj();
      }
      shift() {
        this.buf2 instanceof Cmd && "ID" === this.buf2.cmd ? (this.buf1 = this.buf2, this.buf2 = null) : (this.buf1 = this.buf2, this.buf2 = this.lexer.getObj());
      }
      tryShift() {
        try {
          return this.shift(), true;
        } catch (e3) {
          if (e3 instanceof MissingDataException) throw e3;
          return false;
        }
      }
      getObj(e3 = null) {
        const t3 = this.buf1;
        if (this.shift(), t3 instanceof Cmd) switch (t3.cmd) {
          case "BI":
            return this.makeInlineImage(e3);
          case "[":
            const i3 = [];
            for (; !isCmd(this.buf1, "]") && this.buf1 !== Xs; ) i3.push(this.getObj(e3));
            if (this.buf1 === Xs) {
              if (this.recoveryMode) return i3;
              throw new ParserEOFException("End of file inside array.");
            }
            return this.shift(), i3;
          case "<<":
            const a3 = new Dict(this.xref);
            for (; !isCmd(this.buf1, ">>") && this.buf1 !== Xs; ) {
              if (!(this.buf1 instanceof Name)) {
                info("Malformed dictionary: key must be a name object"), this.shift();
                continue;
              }
              const t4 = this.buf1.name;
              if (this.shift(), this.buf1 === Xs) break;
              a3.set(t4, this.getObj(e3));
            }
            if (this.buf1 === Xs) {
              if (this.recoveryMode) return a3;
              throw new ParserEOFException("End of file inside dictionary.");
            }
            return isCmd(this.buf2, "stream") ? this.allowStreams ? this.makeStream(a3, e3) : a3 : (this.shift(), a3);
          default:
            return t3;
        }
        if (Number.isInteger(t3)) {
          if (Number.isInteger(this.buf1) && isCmd(this.buf2, "R")) {
            const e4 = Ref.get(t3, this.buf1);
            return this.shift(), this.shift(), e4;
          }
          return t3;
        }
        return "string" == typeof t3 && e3 ? e3.decryptString(t3) : t3;
      }
      findDefaultInlineStreamEnd(e3) {
        const { knownCommands: t3 } = this.lexer, i3 = e3.pos;
        let a3, s3, n3 = 0;
        for (; -1 !== (a3 = e3.getByte()); ) if (0 === n3) n3 = 69 === a3 ? 1 : 0;
        else if (1 === n3) n3 = 73 === a3 ? 2 : 0;
        else if (32 === a3 || 10 === a3 || 13 === a3) {
          s3 = e3.pos;
          const i4 = e3.peekBytes(15), r4 = i4.length;
          if (0 === r4) break;
          for (let e4 = 0; e4 < r4; e4++) if (a3 = i4[e4], (0 !== a3 || 0 === i4[e4 + 1]) && 10 !== a3 && 13 !== a3 && (a3 < 32 || a3 > 127)) {
            n3 = 0;
            break;
          }
          if (2 !== n3) continue;
          if (!t3) {
            warn("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
            continue;
          }
          const o3 = new Lexer(new Stream(i4.slice()), t3);
          o3._hexStringWarn = () => {
          };
          let g3 = 0;
          for (; ; ) {
            const e4 = o3.getObj();
            if (e4 === Xs) {
              n3 = 0;
              break;
            }
            if (e4 instanceof Cmd) {
              const i5 = t3[e4.cmd];
              if (!i5) {
                n3 = 0;
                break;
              }
              if (i5.variableArgs ? g3 <= i5.numArgs : g3 === i5.numArgs) break;
              g3 = 0;
            } else g3++;
          }
          if (2 === n3) break;
        } else n3 = 0;
        -1 === a3 && (warn("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker"), s3 && (warn('... trying to recover by using the last "EI" occurrence.'), e3.skip(-(e3.pos - s3))));
        let r3 = 4;
        return e3.skip(-r3), a3 = e3.peekByte(), e3.skip(r3), isWhiteSpace(a3) || r3--, e3.pos - r3 - i3;
      }
      findDCTDecodeInlineStreamEnd(e3) {
        const t3 = e3.pos;
        let i3, a3, s3 = false;
        for (; -1 !== (i3 = e3.getByte()); ) if (255 === i3) {
          switch (e3.getByte()) {
            case 0:
              break;
            case 255:
              e3.skip(-1);
              break;
            case 217:
              s3 = true;
              break;
            case 192:
            case 193:
            case 194:
            case 195:
            case 197:
            case 198:
            case 199:
            case 201:
            case 202:
            case 203:
            case 205:
            case 206:
            case 207:
            case 196:
            case 204:
            case 218:
            case 219:
            case 220:
            case 221:
            case 222:
            case 223:
            case 224:
            case 225:
            case 226:
            case 227:
            case 228:
            case 229:
            case 230:
            case 231:
            case 232:
            case 233:
            case 234:
            case 235:
            case 236:
            case 237:
            case 238:
            case 239:
            case 254:
              a3 = e3.getUint16(), a3 > 2 ? e3.skip(a3 - 2) : e3.skip(-2);
          }
          if (s3) break;
        }
        const n3 = e3.pos - t3;
        return -1 === i3 ? (warn("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead."), e3.skip(-n3), this.findDefaultInlineStreamEnd(e3)) : (this.inlineStreamSkipEI(e3), n3);
      }
      findASCII85DecodeInlineStreamEnd(e3) {
        const t3 = e3.pos;
        let i3;
        for (; -1 !== (i3 = e3.getByte()); ) if (126 === i3) {
          const t4 = e3.pos;
          for (i3 = e3.peekByte(); isWhiteSpace(i3); ) e3.skip(), i3 = e3.peekByte();
          if (62 === i3) {
            e3.skip();
            break;
          }
          if (e3.pos > t4) {
            const t5 = e3.peekBytes(2);
            if (69 === t5[0] && 73 === t5[1]) break;
          }
        }
        const a3 = e3.pos - t3;
        return -1 === i3 ? (warn("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead."), e3.skip(-a3), this.findDefaultInlineStreamEnd(e3)) : (this.inlineStreamSkipEI(e3), a3);
      }
      findASCIIHexDecodeInlineStreamEnd(e3) {
        const t3 = e3.pos;
        let i3;
        for (; -1 !== (i3 = e3.getByte()) && 62 !== i3; ) ;
        const a3 = e3.pos - t3;
        return -1 === i3 ? (warn("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead."), e3.skip(-a3), this.findDefaultInlineStreamEnd(e3)) : (this.inlineStreamSkipEI(e3), a3);
      }
      inlineStreamSkipEI(e3) {
        let t3, i3 = 0;
        for (; -1 !== (t3 = e3.getByte()); ) if (0 === i3) i3 = 69 === t3 ? 1 : 0;
        else if (1 === i3) i3 = 73 === t3 ? 2 : 0;
        else if (2 === i3) break;
      }
      makeInlineImage(e3) {
        const t3 = this.lexer, i3 = t3.stream, a3 = /* @__PURE__ */ Object.create(null);
        let s3;
        for (; !isCmd(this.buf1, "ID") && this.buf1 !== Xs; ) {
          if (!(this.buf1 instanceof Name)) throw new FormatError("Dictionary key must be a name object");
          const t4 = this.buf1.name;
          if (this.shift(), this.buf1 === Xs) break;
          a3[t4] = this.getObj(e3);
        }
        -1 !== t3.beginInlineImagePos && (s3 = i3.pos - t3.beginInlineImagePos);
        const n3 = this.xref.fetchIfRef(a3.F || a3.Filter);
        let r3;
        if (n3 instanceof Name) r3 = n3.name;
        else if (Array.isArray(n3)) {
          const e4 = this.xref.fetchIfRef(n3[0]);
          e4 instanceof Name && (r3 = e4.name);
        }
        const o3 = i3.pos;
        let g3, c3;
        switch (r3) {
          case "DCT":
          case "DCTDecode":
            g3 = this.findDCTDecodeInlineStreamEnd(i3);
            break;
          case "A85":
          case "ASCII85Decode":
            g3 = this.findASCII85DecodeInlineStreamEnd(i3);
            break;
          case "AHx":
          case "ASCIIHexDecode":
            g3 = this.findASCIIHexDecodeInlineStreamEnd(i3);
            break;
          default:
            g3 = this.findDefaultInlineStreamEnd(i3);
        }
        if (g3 < 1e3 && s3 > 0) {
          const e4 = i3.pos;
          i3.pos = t3.beginInlineImagePos, c3 = function(e5) {
            const t4 = [], i4 = e5.length;
            let a5 = 0;
            for (; a5 < i4 - 1; ) t4.push(e5[a5++] << 8 | e5[a5++]);
            return a5 < i4 && t4.push(e5[a5]), i4 + "_" + String.fromCharCode.apply(null, t4);
          }(i3.getBytes(s3 + g3)), i3.pos = e4;
          const a4 = this.imageCache[c3];
          if (void 0 !== a4) return this.buf2 = Cmd.get("EI"), this.shift(), a4.reset(), a4;
        }
        const h3 = new Dict(this.xref);
        for (const e4 in a3) h3.set(e4, a3[e4]);
        let l3 = i3.makeSubStream(o3, g3, h3);
        return e3 && (l3 = e3.createStream(l3, g3)), l3 = this.filter(l3, h3, g3), l3.dict = h3, void 0 !== c3 && (l3.cacheKey = "inline_img_" + ++this._imageId, this.imageCache[c3] = l3), this.buf2 = Cmd.get("EI"), this.shift(), l3;
      }
      makeStream(e3, t3) {
        const i3 = this.lexer;
        let a3 = i3.stream;
        i3.skipToNextLine();
        const s3 = a3.pos - 1;
        let n3 = e3.get("Length");
        if (Number.isInteger(n3) || (info(`Bad length "${n3 && n3.toString()}" in stream.`), n3 = 0), a3.pos = s3 + n3, i3.nextChar(), this.tryShift() && isCmd(this.buf2, "endstream")) this.shift();
        else {
          if (n3 = __privateMethod(this, _Parser_instances, w_fn).call(this, s3), n3 < 0) throw new FormatError("Missing endstream command.");
          i3.nextChar(), this.shift(), this.shift();
        }
        return this.shift(), a3 = a3.makeSubStream(s3, n3, e3), t3 && (a3 = t3.createStream(a3, n3)), a3 = this.filter(a3, e3, n3), a3.dict = e3, a3;
      }
      filter(e3, t3, i3) {
        let a3 = t3.get("F", "Filter"), s3 = t3.get("DP", "DecodeParms");
        if (a3 instanceof Name) return Array.isArray(s3) && warn("/DecodeParms should not be an Array, when /Filter is a Name."), this.makeFilter(e3, a3.name, i3, s3);
        let n3 = i3;
        if (Array.isArray(a3)) {
          const t4 = a3, i4 = s3;
          for (let r3 = 0, o3 = t4.length; r3 < o3; ++r3) {
            if (a3 = this.xref.fetchIfRef(t4[r3]), !(a3 instanceof Name)) throw new FormatError(`Bad filter name "${a3}"`);
            s3 = null, Array.isArray(i4) && r3 in i4 && (s3 = this.xref.fetchIfRef(i4[r3])), e3 = this.makeFilter(e3, a3.name, n3, s3), n3 = null;
          }
        }
        return e3;
      }
      makeFilter(e3, t3, i3, a3) {
        if (0 === i3) return warn(`Empty "${t3}" stream.`), new NullStream();
        try {
          switch (t3) {
            case "Fl":
            case "FlateDecode":
              return a3 ? new PredictorStream(new FlateStream(e3, i3), i3, a3) : new FlateStream(e3, i3);
            case "LZW":
            case "LZWDecode":
              let t4 = 1;
              return a3 ? (a3.has("EarlyChange") && (t4 = a3.get("EarlyChange")), new PredictorStream(new LZWStream(e3, i3, t4), i3, a3)) : new LZWStream(e3, i3, t4);
            case "DCT":
            case "DCTDecode":
              return new JpegStream(e3, i3, a3);
            case "JPX":
            case "JPXDecode":
              return new JpxStream(e3, i3, a3);
            case "A85":
            case "ASCII85Decode":
              return new Ascii85Stream(e3, i3);
            case "AHx":
            case "ASCIIHexDecode":
              return new AsciiHexStream(e3, i3);
            case "CCF":
            case "CCITTFaxDecode":
              return new CCITTFaxStream(e3, i3, a3);
            case "RL":
            case "RunLengthDecode":
              return new RunLengthStream(e3, i3);
            case "JBIG2Decode":
              return new Jbig2Stream(e3, i3, a3);
          }
          return warn(`Filter "${t3}" is not supported.`), e3;
        } catch (e4) {
          if (e4 instanceof MissingDataException) throw e4;
          return warn(`Invalid stream: "${e4}"`), new NullStream();
        }
      }
    };
    _Parser_instances = new WeakSet();
    w_fn = function(e3) {
      const { stream: t3 } = this.lexer;
      t3.pos = e3;
      const i3 = new Uint8Array([101, 110, 100]), a3 = i3.length, s3 = [new Uint8Array([115, 116, 114, 101, 97, 109]), new Uint8Array([115, 116, 101, 97, 109]), new Uint8Array([115, 116, 114, 101, 97])], n3 = 9 - a3;
      for (; t3.pos < t3.end; ) {
        const r3 = t3.peekBytes(2048), o3 = r3.length - 9;
        if (o3 <= 0) break;
        let g3 = 0;
        for (; g3 < o3; ) {
          let o4 = 0;
          for (; o4 < a3 && r3[g3 + o4] === i3[o4]; ) o4++;
          if (o4 >= a3) {
            let a4 = false;
            for (const e4 of s3) {
              const t4 = e4.length;
              let s4 = 0;
              for (; s4 < t4 && r3[g3 + o4 + s4] === e4[s4]; ) s4++;
              if (s4 >= n3) {
                a4 = true;
                break;
              }
              if (s4 >= t4) {
                isWhiteSpace(r3[g3 + o4 + s4]) && (info(`Found "${bytesToString([...i3, ...e4])}" when searching for endstream command.`), a4 = true);
                break;
              }
            }
            if (a4) return t3.pos += g3, t3.pos - e3;
          }
          g3++;
        }
        t3.pos += o3;
      }
      return -1;
    };
    Un = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    Lexer = class {
      constructor(e3, t3 = null) {
        this.stream = e3, this.nextChar(), this.strBuf = [], this.knownCommands = t3, this._hexStringNumWarn = 0, this.beginInlineImagePos = -1;
      }
      nextChar() {
        return this.currentChar = this.stream.getByte();
      }
      peekChar() {
        return this.stream.peekByte();
      }
      getNumber() {
        let e3 = this.currentChar, t3 = false, i3 = 0, a3 = 1;
        if (45 === e3 ? (a3 = -1, e3 = this.nextChar(), 45 === e3 && (e3 = this.nextChar())) : 43 === e3 && (e3 = this.nextChar()), 10 === e3 || 13 === e3) do {
          e3 = this.nextChar();
        } while (10 === e3 || 13 === e3);
        if (46 === e3 && (i3 = 10, e3 = this.nextChar()), e3 < 48 || e3 > 57) {
          const t4 = `Invalid number: ${String.fromCharCode(e3)} (charCode ${e3})`;
          if (isWhiteSpace(e3) || -1 === e3) return info(`Lexer.getNumber - "${t4}".`), 0;
          throw new FormatError(t4);
        }
        let s3 = e3 - 48, n3 = 0, r3 = 1;
        for (; (e3 = this.nextChar()) >= 0; ) if (e3 >= 48 && e3 <= 57) {
          const a4 = e3 - 48;
          t3 ? n3 = 10 * n3 + a4 : (0 !== i3 && (i3 *= 10), s3 = 10 * s3 + a4);
        } else if (46 === e3) {
          if (0 !== i3) break;
          i3 = 1;
        } else if (45 === e3) warn("Badly formatted number: minus sign in the middle");
        else {
          if (69 !== e3 && 101 !== e3) break;
          if (e3 = this.peekChar(), 43 === e3 || 45 === e3) r3 = 45 === e3 ? -1 : 1, this.nextChar();
          else if (e3 < 48 || e3 > 57) break;
          t3 = true;
        }
        return 0 !== i3 && (s3 /= i3), t3 && (s3 *= 10 ** (r3 * n3)), a3 * s3;
      }
      getString() {
        let e3 = 1, t3 = false;
        const i3 = this.strBuf;
        i3.length = 0;
        let a3 = this.nextChar();
        for (; ; ) {
          let s3 = false;
          switch (0 | a3) {
            case -1:
              warn("Unterminated string"), t3 = true;
              break;
            case 40:
              ++e3, i3.push("(");
              break;
            case 41:
              0 == --e3 ? (this.nextChar(), t3 = true) : i3.push(")");
              break;
            case 92:
              switch (a3 = this.nextChar(), a3) {
                case -1:
                  warn("Unterminated string"), t3 = true;
                  break;
                case 110:
                  i3.push("\n");
                  break;
                case 114:
                  i3.push("\r");
                  break;
                case 116:
                  i3.push("	");
                  break;
                case 98:
                  i3.push("\b");
                  break;
                case 102:
                  i3.push("\f");
                  break;
                case 92:
                case 40:
                case 41:
                  i3.push(String.fromCharCode(a3));
                  break;
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                  let e4 = 15 & a3;
                  a3 = this.nextChar(), s3 = true, a3 >= 48 && a3 <= 55 && (e4 = (e4 << 3) + (15 & a3), a3 = this.nextChar(), a3 >= 48 && a3 <= 55 && (s3 = false, e4 = (e4 << 3) + (15 & a3))), i3.push(String.fromCharCode(e4));
                  break;
                case 13:
                  10 === this.peekChar() && this.nextChar();
                  break;
                case 10:
                  break;
                default:
                  i3.push(String.fromCharCode(a3));
              }
              break;
            default:
              i3.push(String.fromCharCode(a3));
          }
          if (t3) break;
          s3 || (a3 = this.nextChar());
        }
        return i3.join("");
      }
      getName() {
        let e3, t3;
        const i3 = this.strBuf;
        for (i3.length = 0; (e3 = this.nextChar()) >= 0 && !Un[e3]; ) if (35 === e3) {
          if (e3 = this.nextChar(), Un[e3]) {
            warn("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number."), i3.push("#");
            break;
          }
          const a3 = toHexDigit(e3);
          if (-1 !== a3) {
            t3 = e3, e3 = this.nextChar();
            const s3 = toHexDigit(e3);
            if (-1 === s3) {
              if (warn(`Lexer_getName: Illegal digit (${String.fromCharCode(e3)}) in hexadecimal number.`), i3.push("#", String.fromCharCode(t3)), Un[e3]) break;
              i3.push(String.fromCharCode(e3));
              continue;
            }
            i3.push(String.fromCharCode(a3 << 4 | s3));
          } else i3.push("#", String.fromCharCode(e3));
        } else i3.push(String.fromCharCode(e3));
        return i3.length > 127 && warn(`Name token is longer than allowed by the spec: ${i3.length}`), Name.get(i3.join(""));
      }
      _hexStringWarn(e3) {
        5 != this._hexStringNumWarn++ ? this._hexStringNumWarn > 5 || warn(`getHexString - ignoring invalid character: ${e3}`) : warn("getHexString - ignoring additional invalid characters.");
      }
      getHexString() {
        const e3 = this.strBuf;
        e3.length = 0;
        let t3 = this.currentChar, i3 = -1, a3 = -1;
        for (this._hexStringNumWarn = 0; ; ) {
          if (t3 < 0) {
            warn("Unterminated hex string");
            break;
          }
          if (62 === t3) {
            this.nextChar();
            break;
          }
          1 !== Un[t3] ? (a3 = toHexDigit(t3), -1 === a3 ? this._hexStringWarn(t3) : -1 === i3 ? i3 = a3 : (e3.push(String.fromCharCode(i3 << 4 | a3)), i3 = -1), t3 = this.nextChar()) : t3 = this.nextChar();
        }
        return -1 !== i3 && e3.push(String.fromCharCode(i3 << 4)), e3.join("");
      }
      getObj() {
        let e3 = false, t3 = this.currentChar;
        for (; ; ) {
          if (t3 < 0) return Xs;
          if (e3) 10 !== t3 && 13 !== t3 || (e3 = false);
          else if (37 === t3) e3 = true;
          else if (1 !== Un[t3]) break;
          t3 = this.nextChar();
        }
        switch (0 | t3) {
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
          case 43:
          case 45:
          case 46:
            return this.getNumber();
          case 40:
            return this.getString();
          case 47:
            return this.getName();
          case 91:
            return this.nextChar(), Cmd.get("[");
          case 93:
            return this.nextChar(), Cmd.get("]");
          case 60:
            return t3 = this.nextChar(), 60 === t3 ? (this.nextChar(), Cmd.get("<<")) : this.getHexString();
          case 62:
            return t3 = this.nextChar(), 62 === t3 ? (this.nextChar(), Cmd.get(">>")) : Cmd.get(">");
          case 123:
            return this.nextChar(), Cmd.get("{");
          case 125:
            return this.nextChar(), Cmd.get("}");
          case 41:
            throw this.nextChar(), new FormatError(`Illegal character: ${t3}`);
        }
        let i3 = String.fromCharCode(t3);
        if (t3 < 32 || t3 > 127) {
          const e4 = this.peekChar();
          if (e4 >= 32 && e4 <= 127) return this.nextChar(), Cmd.get(i3);
        }
        const a3 = this.knownCommands;
        let s3 = void 0 !== a3?.[i3];
        for (; (t3 = this.nextChar()) >= 0 && !Un[t3]; ) {
          const e4 = i3 + String.fromCharCode(t3);
          if (s3 && void 0 === a3[e4]) break;
          if (128 === i3.length) throw new FormatError(`Command token too long: ${i3.length}`);
          i3 = e4, s3 = void 0 !== a3?.[i3];
        }
        return "true" === i3 || "false" !== i3 && ("null" === i3 ? null : ("BI" === i3 && (this.beginInlineImagePos = this.stream.pos), Cmd.get(i3)));
      }
      skipToNextLine() {
        let e3 = this.currentChar;
        for (; e3 >= 0; ) {
          if (13 === e3) {
            e3 = this.nextChar(), 10 === e3 && this.nextChar();
            break;
          }
          if (10 === e3) {
            this.nextChar();
            break;
          }
          e3 = this.nextChar();
        }
      }
    };
    Linearization = class {
      static create(e3) {
        function getInt(e4, t4, i4 = false) {
          const a4 = e4.get(t4);
          if (Number.isInteger(a4) && (i4 ? a4 >= 0 : a4 > 0)) return a4;
          throw new Error(`The "${t4}" parameter in the linearization dictionary is invalid.`);
        }
        const t3 = new Parser({ lexer: new Lexer(e3), xref: null }), i3 = t3.getObj(), a3 = t3.getObj(), s3 = t3.getObj(), n3 = t3.getObj();
        let r3, o3;
        if (!(Number.isInteger(i3) && Number.isInteger(a3) && isCmd(s3, "obj") && n3 instanceof Dict && "number" == typeof (r3 = n3.get("Linearized")) && r3 > 0)) return null;
        if ((o3 = getInt(n3, "L")) !== e3.length) throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
        return { length: o3, hints: function(e4) {
          const t4 = e4.get("H");
          let i4;
          if (Array.isArray(t4) && (2 === (i4 = t4.length) || 4 === i4)) {
            for (let e5 = 0; e5 < i4; e5++) {
              const i5 = t4[e5];
              if (!(Number.isInteger(i5) && i5 > 0)) throw new Error(`Hint (${e5}) in the linearization dictionary is invalid.`);
            }
            return t4;
          }
          throw new Error("Hint array in the linearization dictionary is invalid.");
        }(n3), objectNumberFirst: getInt(n3, "O"), endFirst: getInt(n3, "E"), numPages: getInt(n3, "N"), mainXRefEntriesOffset: getInt(n3, "T"), pageFirst: n3.has("P") ? getInt(n3, "P", true) : 0 };
      }
    };
    Hn = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"];
    Tn = 2 ** 24 - 1;
    CMap = class {
      constructor(e3 = false) {
        this.codespaceRanges = [[], [], [], []], this.numCodespaceRanges = 0, this._map = [], this.name = "", this.vertical = false, this.useCMap = null, this.builtInCMap = e3;
      }
      addCodespaceRange(e3, t3, i3) {
        this.codespaceRanges[e3 - 1].push(t3, i3), this.numCodespaceRanges++;
      }
      mapCidRange(e3, t3, i3) {
        if (t3 - e3 > Tn) throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
        for (; e3 <= t3; ) this._map[e3++] = i3++;
      }
      mapBfRange(e3, t3, i3) {
        if (t3 - e3 > Tn) throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
        const a3 = i3.length - 1;
        for (; e3 <= t3; ) {
          this._map[e3++] = i3;
          const t4 = i3.charCodeAt(a3) + 1;
          t4 > 255 ? i3 = i3.substring(0, a3 - 1) + String.fromCharCode(i3.charCodeAt(a3 - 1) + 1) + "\0" : i3 = i3.substring(0, a3) + String.fromCharCode(t4);
        }
      }
      mapBfRangeToArray(e3, t3, i3) {
        if (t3 - e3 > Tn) throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
        const a3 = i3.length;
        let s3 = 0;
        for (; e3 <= t3 && s3 < a3; ) this._map[e3] = i3[s3++], ++e3;
      }
      mapOne(e3, t3) {
        this._map[e3] = t3;
      }
      lookup(e3) {
        return this._map[e3];
      }
      contains(e3) {
        return void 0 !== this._map[e3];
      }
      forEach(e3) {
        const t3 = this._map, i3 = t3.length;
        if (i3 <= 65536) for (let a3 = 0; a3 < i3; a3++) void 0 !== t3[a3] && e3(a3, t3[a3]);
        else for (const i4 in t3) e3(i4, t3[i4]);
      }
      charCodeOf(e3) {
        const t3 = this._map;
        if (t3.length <= 65536) return t3.indexOf(e3);
        for (const i3 in t3) if (t3[i3] === e3) return 0 | i3;
        return -1;
      }
      getMap() {
        return this._map;
      }
      readCharCode(e3, t3, i3) {
        let a3 = 0;
        const s3 = this.codespaceRanges;
        for (let n3 = 0, r3 = s3.length; n3 < r3; n3++) {
          a3 = (a3 << 8 | e3.charCodeAt(t3 + n3)) >>> 0;
          const r4 = s3[n3];
          for (let e4 = 0, t4 = r4.length; e4 < t4; ) {
            const t5 = r4[e4++], s4 = r4[e4++];
            if (a3 >= t5 && a3 <= s4) return i3.charcode = a3, void (i3.length = n3 + 1);
          }
        }
        i3.charcode = 0, i3.length = 1;
      }
      getCharCodeLength(e3) {
        const t3 = this.codespaceRanges;
        for (let i3 = 0, a3 = t3.length; i3 < a3; i3++) {
          const a4 = t3[i3];
          for (let t4 = 0, s3 = a4.length; t4 < s3; ) {
            const s4 = a4[t4++], n3 = a4[t4++];
            if (e3 >= s4 && e3 <= n3) return i3 + 1;
          }
        }
        return 1;
      }
      get length() {
        return this._map.length;
      }
      get isIdentityCMap() {
        if ("Identity-H" !== this.name && "Identity-V" !== this.name) return false;
        if (65536 !== this._map.length) return false;
        for (let e3 = 0; e3 < 65536; e3++) if (this._map[e3] !== e3) return false;
        return true;
      }
    };
    IdentityCMap = class extends CMap {
      constructor(e3, t3) {
        super(), this.vertical = e3, this.addCodespaceRange(t3, 0, 65535);
      }
      mapCidRange(e3, t3, i3) {
        unreachable("should not call mapCidRange");
      }
      mapBfRange(e3, t3, i3) {
        unreachable("should not call mapBfRange");
      }
      mapBfRangeToArray(e3, t3, i3) {
        unreachable("should not call mapBfRangeToArray");
      }
      mapOne(e3, t3) {
        unreachable("should not call mapCidOne");
      }
      lookup(e3) {
        return Number.isInteger(e3) && e3 <= 65535 ? e3 : void 0;
      }
      contains(e3) {
        return Number.isInteger(e3) && e3 <= 65535;
      }
      forEach(e3) {
        for (let t3 = 0; t3 <= 65535; t3++) e3(t3, t3);
      }
      charCodeOf(e3) {
        return Number.isInteger(e3) && e3 <= 65535 ? e3 : -1;
      }
      getMap() {
        const e3 = new Array(65536);
        for (let t3 = 0; t3 <= 65535; t3++) e3[t3] = t3;
        return e3;
      }
      get length() {
        return 65536;
      }
      get isIdentityCMap() {
        unreachable("should not access .isIdentityCMap");
      }
    };
    CMapFactory = class {
      static async create({ encoding: e3, fetchBuiltInCMap: t3, useCMap: i3 }) {
        if (e3 instanceof Name) return createBuiltInCMap(e3.name, t3);
        if (e3 instanceof BaseStream) {
          const a3 = await parseCMap(new CMap(), new Lexer(e3), t3, i3);
          return a3.isIdentityCMap ? createBuiltInCMap(a3.name, t3) : a3;
        }
        throw new Error("Encoding required.");
      }
    };
    Jn = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
    Yn = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
    Pn = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"];
    On = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
    Kn = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""];
    qn = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];
    _n2 = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""];
    Wn = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];
    jn = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""];
    Xn = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
    Vn = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
    Zn = 391;
    zn = [null, { id: "hstem", min: 2, stackClearing: true, stem: true }, null, { id: "vstem", min: 2, stackClearing: true, stem: true }, { id: "vmoveto", min: 1, stackClearing: true }, { id: "rlineto", min: 2, resetStack: true }, { id: "hlineto", min: 1, resetStack: true }, { id: "vlineto", min: 1, resetStack: true }, { id: "rrcurveto", min: 6, resetStack: true }, null, { id: "callsubr", min: 1, undefStack: true }, { id: "return", min: 0, undefStack: true }, null, null, { id: "endchar", min: 0, stackClearing: true }, null, null, null, { id: "hstemhm", min: 2, stackClearing: true, stem: true }, { id: "hintmask", min: 0, stackClearing: true }, { id: "cntrmask", min: 0, stackClearing: true }, { id: "rmoveto", min: 2, stackClearing: true }, { id: "hmoveto", min: 1, stackClearing: true }, { id: "vstemhm", min: 2, stackClearing: true, stem: true }, { id: "rcurveline", min: 8, resetStack: true }, { id: "rlinecurve", min: 8, resetStack: true }, { id: "vvcurveto", min: 4, resetStack: true }, { id: "hhcurveto", min: 4, resetStack: true }, null, { id: "callgsubr", min: 1, undefStack: true }, { id: "vhcurveto", min: 4, resetStack: true }, { id: "hvcurveto", min: 4, resetStack: true }];
    $n = [null, null, null, { id: "and", min: 2, stackDelta: -1 }, { id: "or", min: 2, stackDelta: -1 }, { id: "not", min: 1, stackDelta: 0 }, null, null, null, { id: "abs", min: 1, stackDelta: 0 }, { id: "add", min: 2, stackDelta: -1, stackFn(e3, t3) {
      e3[t3 - 2] = e3[t3 - 2] + e3[t3 - 1];
    } }, { id: "sub", min: 2, stackDelta: -1, stackFn(e3, t3) {
      e3[t3 - 2] = e3[t3 - 2] - e3[t3 - 1];
    } }, { id: "div", min: 2, stackDelta: -1, stackFn(e3, t3) {
      e3[t3 - 2] = e3[t3 - 2] / e3[t3 - 1];
    } }, null, { id: "neg", min: 1, stackDelta: 0, stackFn(e3, t3) {
      e3[t3 - 1] = -e3[t3 - 1];
    } }, { id: "eq", min: 2, stackDelta: -1 }, null, null, { id: "drop", min: 1, stackDelta: -1 }, null, { id: "put", min: 2, stackDelta: -2 }, { id: "get", min: 1, stackDelta: 0 }, { id: "ifelse", min: 4, stackDelta: -3 }, { id: "random", min: 0, stackDelta: 1 }, { id: "mul", min: 2, stackDelta: -1, stackFn(e3, t3) {
      e3[t3 - 2] = e3[t3 - 2] * e3[t3 - 1];
    } }, null, { id: "sqrt", min: 1, stackDelta: 0 }, { id: "dup", min: 1, stackDelta: 1 }, { id: "exch", min: 2, stackDelta: 0 }, { id: "index", min: 2, stackDelta: 0 }, { id: "roll", min: 3, stackDelta: -2 }, null, null, null, { id: "hflex", min: 7, resetStack: true }, { id: "flex", min: 13, resetStack: true }, { id: "hflex1", min: 9, resetStack: true }, { id: "flex1", min: 11, resetStack: true }];
    CFFParser = class {
      constructor(e3, t3, i3) {
        this.bytes = e3.getBytes(), this.properties = t3, this.seacAnalysisEnabled = !!i3;
      }
      parse() {
        const e3 = this.properties, t3 = new CFF();
        this.cff = t3;
        const i3 = this.parseHeader(), a3 = this.parseIndex(i3.endPos), s3 = this.parseIndex(a3.endPos), n3 = this.parseIndex(s3.endPos), r3 = this.parseIndex(n3.endPos), o3 = this.parseDict(s3.obj.get(0)), g3 = this.createDict(CFFTopDict, o3, t3.strings);
        t3.header = i3.obj, t3.names = this.parseNameIndex(a3.obj), t3.strings = this.parseStringIndex(n3.obj), t3.topDict = g3, t3.globalSubrIndex = r3.obj, this.parsePrivateDict(t3.topDict), t3.isCIDFont = g3.hasName("ROS");
        const c3 = g3.getByName("CharStrings"), h3 = this.parseIndex(c3).obj, l3 = g3.getByName("FontMatrix");
        l3 && (e3.fontMatrix = l3);
        const C3 = g3.getByName("FontBBox");
        let d3, u3;
        if (C3 && (e3.ascent = Math.max(C3[3], C3[1]), e3.descent = Math.min(C3[1], C3[3]), e3.ascentScaled = true), t3.isCIDFont) {
          const e4 = this.parseIndex(g3.getByName("FDArray")).obj;
          for (let i4 = 0, a4 = e4.count; i4 < a4; ++i4) {
            const a5 = e4.get(i4), s4 = this.createDict(CFFTopDict, this.parseDict(a5), t3.strings);
            this.parsePrivateDict(s4), t3.fdArray.push(s4);
          }
          u3 = null, d3 = this.parseCharsets(g3.getByName("charset"), h3.count, t3.strings, true), t3.fdSelect = this.parseFDSelect(g3.getByName("FDSelect"), h3.count);
        } else d3 = this.parseCharsets(g3.getByName("charset"), h3.count, t3.strings, false), u3 = this.parseEncoding(g3.getByName("Encoding"), e3, t3.strings, d3.charset);
        t3.charset = d3, t3.encoding = u3;
        const Q3 = this.parseCharStrings({ charStrings: h3, localSubrIndex: g3.privateDict.subrsIndex, globalSubrIndex: r3.obj, fdSelect: t3.fdSelect, fdArray: t3.fdArray, privateDict: g3.privateDict });
        return t3.charStrings = Q3.charStrings, t3.seacs = Q3.seacs, t3.widths = Q3.widths, t3;
      }
      parseHeader() {
        let e3 = this.bytes;
        const t3 = e3.length;
        let i3 = 0;
        for (; i3 < t3 && 1 !== e3[i3]; ) ++i3;
        if (i3 >= t3) throw new FormatError("Invalid CFF header");
        0 !== i3 && (info("cff data is shifted"), e3 = e3.subarray(i3), this.bytes = e3);
        const a3 = e3[0], s3 = e3[1], n3 = e3[2], r3 = e3[3];
        return { obj: new CFFHeader(a3, s3, n3, r3), endPos: n3 };
      }
      parseDict(e3) {
        let t3 = 0;
        function parseOperand() {
          let i4 = e3[t3++];
          return 30 === i4 ? function() {
            let i5 = "";
            const a4 = 15, s4 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"], n3 = e3.length;
            for (; t3 < n3; ) {
              const n4 = e3[t3++], r3 = n4 >> 4, o3 = 15 & n4;
              if (r3 === a4) break;
              if (i5 += s4[r3], o3 === a4) break;
              i5 += s4[o3];
            }
            return parseFloat(i5);
          }() : 28 === i4 ? (i4 = e3[t3++], i4 = (i4 << 24 | e3[t3++] << 16) >> 16, i4) : 29 === i4 ? (i4 = e3[t3++], i4 = i4 << 8 | e3[t3++], i4 = i4 << 8 | e3[t3++], i4 = i4 << 8 | e3[t3++], i4) : i4 >= 32 && i4 <= 246 ? i4 - 139 : i4 >= 247 && i4 <= 250 ? 256 * (i4 - 247) + e3[t3++] + 108 : i4 >= 251 && i4 <= 254 ? -256 * (i4 - 251) - e3[t3++] - 108 : (warn('CFFParser_parseDict: "' + i4 + '" is a reserved command.'), NaN);
        }
        let i3 = [];
        const a3 = [];
        t3 = 0;
        const s3 = e3.length;
        for (; t3 < s3; ) {
          let s4 = e3[t3];
          s4 <= 21 ? (12 === s4 && (s4 = s4 << 8 | e3[++t3]), a3.push([s4, i3]), i3 = [], ++t3) : i3.push(parseOperand());
        }
        return a3;
      }
      parseIndex(e3) {
        const t3 = new CFFIndex(), i3 = this.bytes, a3 = i3[e3++] << 8 | i3[e3++], s3 = [];
        let n3, r3, o3 = e3;
        if (0 !== a3) {
          const t4 = i3[e3++], g3 = e3 + (a3 + 1) * t4 - 1;
          for (n3 = 0, r3 = a3 + 1; n3 < r3; ++n3) {
            let a4 = 0;
            for (let s4 = 0; s4 < t4; ++s4) a4 <<= 8, a4 += i3[e3++];
            s3.push(g3 + a4);
          }
          o3 = s3[a3];
        }
        for (n3 = 0, r3 = s3.length - 1; n3 < r3; ++n3) {
          const e4 = s3[n3], a4 = s3[n3 + 1];
          t3.add(i3.subarray(e4, a4));
        }
        return { obj: t3, endPos: o3 };
      }
      parseNameIndex(e3) {
        const t3 = [];
        for (let i3 = 0, a3 = e3.count; i3 < a3; ++i3) {
          const a4 = e3.get(i3);
          t3.push(bytesToString(a4));
        }
        return t3;
      }
      parseStringIndex(e3) {
        const t3 = new CFFStrings();
        for (let i3 = 0, a3 = e3.count; i3 < a3; ++i3) {
          const a4 = e3.get(i3);
          t3.add(bytesToString(a4));
        }
        return t3;
      }
      createDict(e3, t3, i3) {
        const a3 = new e3(i3);
        for (const [e4, i4] of t3) a3.setByKey(e4, i4);
        return a3;
      }
      parseCharString(e3, t3, i3, a3) {
        if (!t3 || e3.callDepth > 10) return false;
        let s3 = e3.stackSize;
        const n3 = e3.stack;
        let r3 = t3.length;
        for (let o3 = 0; o3 < r3; ) {
          const g3 = t3[o3++];
          let c3 = null;
          if (12 === g3) {
            const e4 = t3[o3++];
            0 === e4 ? (t3[o3 - 2] = 139, t3[o3 - 1] = 22, s3 = 0) : c3 = $n[e4];
          } else if (28 === g3) n3[s3] = (t3[o3] << 24 | t3[o3 + 1] << 16) >> 16, o3 += 2, s3++;
          else if (14 === g3) {
            if (s3 >= 4 && (s3 -= 4, this.seacAnalysisEnabled)) return e3.seac = n3.slice(s3, s3 + 4), false;
            c3 = zn[g3];
          } else if (g3 >= 32 && g3 <= 246) n3[s3] = g3 - 139, s3++;
          else if (g3 >= 247 && g3 <= 254) n3[s3] = g3 < 251 ? (g3 - 247 << 8) + t3[o3] + 108 : -(g3 - 251 << 8) - t3[o3] - 108, o3++, s3++;
          else if (255 === g3) n3[s3] = (t3[o3] << 24 | t3[o3 + 1] << 16 | t3[o3 + 2] << 8 | t3[o3 + 3]) / 65536, o3 += 4, s3++;
          else if (19 === g3 || 20 === g3) {
            if (e3.hints += s3 >> 1, 0 === e3.hints) {
              t3.copyWithin(o3 - 1, o3, -1), o3 -= 1, r3 -= 1;
              continue;
            }
            o3 += e3.hints + 7 >> 3, s3 %= 2, c3 = zn[g3];
          } else {
            if (10 === g3 || 29 === g3) {
              const t4 = 10 === g3 ? i3 : a3;
              if (!t4) return c3 = zn[g3], warn("Missing subrsIndex for " + c3.id), false;
              let r4 = 32768;
              t4.count < 1240 ? r4 = 107 : t4.count < 33900 && (r4 = 1131);
              const o4 = n3[--s3] + r4;
              if (o4 < 0 || o4 >= t4.count || isNaN(o4)) return c3 = zn[g3], warn("Out of bounds subrIndex for " + c3.id), false;
              e3.stackSize = s3, e3.callDepth++;
              if (!this.parseCharString(e3, t4.get(o4), i3, a3)) return false;
              e3.callDepth--, s3 = e3.stackSize;
              continue;
            }
            if (11 === g3) return e3.stackSize = s3, true;
            if (0 === g3 && o3 === t3.length) t3[o3 - 1] = 14, c3 = zn[14];
            else {
              if (9 === g3) {
                t3.copyWithin(o3 - 1, o3, -1), o3 -= 1, r3 -= 1;
                continue;
              }
              c3 = zn[g3];
            }
          }
          if (c3) {
            if (c3.stem && (e3.hints += s3 >> 1, 3 === g3 || 23 === g3 ? e3.hasVStems = true : !e3.hasVStems || 1 !== g3 && 18 !== g3 || (warn("CFF stem hints are in wrong order"), t3[o3 - 1] = 1 === g3 ? 3 : 23)), "min" in c3 && !e3.undefStack && s3 < c3.min) return warn("Not enough parameters for " + c3.id + "; actual: " + s3 + ", expected: " + c3.min), 0 === s3 && (t3[o3 - 1] = 14, true);
            e3.firstStackClearing && c3.stackClearing && (e3.firstStackClearing = false, s3 -= c3.min, s3 >= 2 && c3.stem ? s3 %= 2 : s3 > 1 && warn("Found too many parameters for stack-clearing command"), s3 > 0 && (e3.width = n3[s3 - 1])), "stackDelta" in c3 ? ("stackFn" in c3 && c3.stackFn(n3, s3), s3 += c3.stackDelta) : c3.stackClearing ? s3 = 0 : c3.resetStack ? (s3 = 0, e3.undefStack = false) : c3.undefStack && (s3 = 0, e3.undefStack = true, e3.firstStackClearing = false);
          }
        }
        return r3 < t3.length && t3.fill(14, r3), e3.stackSize = s3, true;
      }
      parseCharStrings({ charStrings: e3, localSubrIndex: t3, globalSubrIndex: i3, fdSelect: a3, fdArray: s3, privateDict: n3 }) {
        const r3 = [], o3 = [], g3 = e3.count;
        for (let c3 = 0; c3 < g3; c3++) {
          const g4 = e3.get(c3), h3 = { callDepth: 0, stackSize: 0, stack: [], undefStack: true, hints: 0, firstStackClearing: true, seac: null, width: null, hasVStems: false };
          let l3 = true, C3 = null, d3 = n3;
          if (a3 && s3.length) {
            const e4 = a3.getFDIndex(c3);
            -1 === e4 && (warn("Glyph index is not in fd select."), l3 = false), e4 >= s3.length && (warn("Invalid fd index for glyph index."), l3 = false), l3 && (d3 = s3[e4].privateDict, C3 = d3.subrsIndex);
          } else t3 && (C3 = t3);
          if (l3 && (l3 = this.parseCharString(h3, g4, C3, i3)), null !== h3.width) {
            const e4 = d3.getByName("nominalWidthX");
            o3[c3] = e4 + h3.width;
          } else {
            const e4 = d3.getByName("defaultWidthX");
            o3[c3] = e4;
          }
          null !== h3.seac && (r3[c3] = h3.seac), l3 || e3.set(c3, new Uint8Array([14]));
        }
        return { charStrings: e3, seacs: r3, widths: o3 };
      }
      emptyPrivateDictionary(e3) {
        const t3 = this.createDict(CFFPrivateDict, [], e3.strings);
        e3.setByKey(18, [0, 0]), e3.privateDict = t3;
      }
      parsePrivateDict(e3) {
        if (!e3.hasName("Private")) return void this.emptyPrivateDictionary(e3);
        const t3 = e3.getByName("Private");
        if (!Array.isArray(t3) || 2 !== t3.length) return void e3.removeByName("Private");
        const i3 = t3[0], a3 = t3[1];
        if (0 === i3 || a3 >= this.bytes.length) return void this.emptyPrivateDictionary(e3);
        const s3 = a3 + i3, n3 = this.bytes.subarray(a3, s3), r3 = this.parseDict(n3), o3 = this.createDict(CFFPrivateDict, r3, e3.strings);
        if (e3.privateDict = o3, 0 === o3.getByName("ExpansionFactor") && o3.setByName("ExpansionFactor", 0.06), !o3.getByName("Subrs")) return;
        const g3 = o3.getByName("Subrs"), c3 = a3 + g3;
        if (0 === g3 || c3 >= this.bytes.length) return void this.emptyPrivateDictionary(e3);
        const h3 = this.parseIndex(c3);
        o3.subrsIndex = h3.obj;
      }
      parseCharsets(e3, t3, i3, a3) {
        if (0 === e3) return new CFFCharset(true, Ar.ISO_ADOBE, Jn);
        if (1 === e3) return new CFFCharset(true, Ar.EXPERT, Yn);
        if (2 === e3) return new CFFCharset(true, Ar.EXPERT_SUBSET, Pn);
        const s3 = this.bytes, n3 = e3, r3 = s3[e3++], o3 = [a3 ? 0 : ".notdef"];
        let g3, c3, h3;
        switch (t3 -= 1, r3) {
          case 0:
            for (h3 = 0; h3 < t3; h3++) g3 = s3[e3++] << 8 | s3[e3++], o3.push(a3 ? g3 : i3.get(g3));
            break;
          case 1:
            for (; o3.length <= t3; ) for (g3 = s3[e3++] << 8 | s3[e3++], c3 = s3[e3++], h3 = 0; h3 <= c3; h3++) o3.push(a3 ? g3++ : i3.get(g3++));
            break;
          case 2:
            for (; o3.length <= t3; ) for (g3 = s3[e3++] << 8 | s3[e3++], c3 = s3[e3++] << 8 | s3[e3++], h3 = 0; h3 <= c3; h3++) o3.push(a3 ? g3++ : i3.get(g3++));
            break;
          default:
            throw new FormatError("Unknown charset format");
        }
        const l3 = e3, C3 = s3.subarray(n3, l3);
        return new CFFCharset(false, r3, o3, C3);
      }
      parseEncoding(e3, t3, i3, a3) {
        const s3 = /* @__PURE__ */ Object.create(null), n3 = this.bytes;
        let r3, o3, g3, c3 = false, h3 = null;
        if (0 === e3 || 1 === e3) {
          c3 = true, r3 = e3;
          const t4 = e3 ? On : _n2;
          for (o3 = 0, g3 = a3.length; o3 < g3; o3++) {
            const e4 = t4.indexOf(a3[o3]);
            -1 !== e4 && (s3[e4] = o3);
          }
        } else {
          const t4 = e3;
          switch (r3 = n3[e3++], 127 & r3) {
            case 0:
              const t5 = n3[e3++];
              for (o3 = 1; o3 <= t5; o3++) s3[n3[e3++]] = o3;
              break;
            case 1:
              const i4 = n3[e3++];
              let a4 = 1;
              for (o3 = 0; o3 < i4; o3++) {
                const t6 = n3[e3++], i5 = n3[e3++];
                for (let e4 = t6; e4 <= t6 + i5; e4++) s3[e4] = a4++;
              }
              break;
            default:
              throw new FormatError(`Unknown encoding format: ${r3} in CFF`);
          }
          const g4 = e3;
          128 & r3 && (n3[t4] &= 127, function() {
            const t5 = n3[e3++];
            for (o3 = 0; o3 < t5; o3++) {
              const t6 = n3[e3++], r4 = (n3[e3++] << 8) + (255 & n3[e3++]);
              s3[t6] = a3.indexOf(i3.get(r4));
            }
          }()), h3 = n3.subarray(t4, g4);
        }
        return r3 &= 127, new CFFEncoding(c3, r3, s3, h3);
      }
      parseFDSelect(e3, t3) {
        const i3 = this.bytes, a3 = i3[e3++], s3 = [];
        let n3;
        switch (a3) {
          case 0:
            for (n3 = 0; n3 < t3; ++n3) {
              const t4 = i3[e3++];
              s3.push(t4);
            }
            break;
          case 3:
            const r3 = i3[e3++] << 8 | i3[e3++];
            for (n3 = 0; n3 < r3; ++n3) {
              let t4 = i3[e3++] << 8 | i3[e3++];
              0 === n3 && 0 !== t4 && (warn("parseFDSelect: The first range must have a first GID of 0 -- trying to recover."), t4 = 0);
              const a4 = i3[e3++], r4 = i3[e3] << 8 | i3[e3 + 1];
              for (let e4 = t4; e4 < r4; ++e4) s3.push(a4);
            }
            e3 += 2;
            break;
          default:
            throw new FormatError(`parseFDSelect: Unknown format "${a3}".`);
        }
        if (s3.length !== t3) throw new FormatError("parseFDSelect: Invalid font data.");
        return new CFFFDSelect(a3, s3);
      }
    };
    CFF = class {
      constructor() {
        this.header = null, this.names = [], this.topDict = null, this.strings = new CFFStrings(), this.globalSubrIndex = null, this.encoding = null, this.charset = null, this.charStrings = null, this.fdArray = [], this.fdSelect = null, this.isCIDFont = false;
      }
      duplicateFirstGlyph() {
        if (this.charStrings.count >= 65535) return void warn("Not enough space in charstrings to duplicate first glyph.");
        const e3 = this.charStrings.get(0);
        this.charStrings.add(e3), this.isCIDFont && this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
      }
      hasGlyphId(e3) {
        if (e3 < 0 || e3 >= this.charStrings.count) return false;
        return this.charStrings.get(e3).length > 0;
      }
    };
    CFFHeader = class {
      constructor(e3, t3, i3, a3) {
        this.major = e3, this.minor = t3, this.hdrSize = i3, this.offSize = a3;
      }
    };
    CFFStrings = class {
      constructor() {
        this.strings = [];
      }
      get(e3) {
        return e3 >= 0 && e3 <= 390 ? Vn[e3] : e3 - Zn <= this.strings.length ? this.strings[e3 - Zn] : Vn[0];
      }
      getSID(e3) {
        let t3 = Vn.indexOf(e3);
        return -1 !== t3 ? t3 : (t3 = this.strings.indexOf(e3), -1 !== t3 ? t3 + Zn : -1);
      }
      add(e3) {
        this.strings.push(e3);
      }
      get count() {
        return this.strings.length;
      }
    };
    CFFIndex = class {
      constructor() {
        this.objects = [], this.length = 0;
      }
      add(e3) {
        this.length += e3.length, this.objects.push(e3);
      }
      set(e3, t3) {
        this.length += t3.length - this.objects[e3].length, this.objects[e3] = t3;
      }
      get(e3) {
        return this.objects[e3];
      }
      get count() {
        return this.objects.length;
      }
    };
    CFFDict = class {
      constructor(e3, t3) {
        this.keyToNameMap = e3.keyToNameMap, this.nameToKeyMap = e3.nameToKeyMap, this.defaults = e3.defaults, this.types = e3.types, this.opcodes = e3.opcodes, this.order = e3.order, this.strings = t3, this.values = /* @__PURE__ */ Object.create(null);
      }
      setByKey(e3, t3) {
        if (!(e3 in this.keyToNameMap)) return false;
        if (0 === t3.length) return true;
        for (const i4 of t3) if (isNaN(i4)) return warn(`Invalid CFFDict value: "${t3}" for key "${e3}".`), true;
        const i3 = this.types[e3];
        return "num" !== i3 && "sid" !== i3 && "offset" !== i3 || (t3 = t3[0]), this.values[e3] = t3, true;
      }
      setByName(e3, t3) {
        if (!(e3 in this.nameToKeyMap)) throw new FormatError(`Invalid dictionary name "${e3}"`);
        this.values[this.nameToKeyMap[e3]] = t3;
      }
      hasName(e3) {
        return this.nameToKeyMap[e3] in this.values;
      }
      getByName(e3) {
        if (!(e3 in this.nameToKeyMap)) throw new FormatError(`Invalid dictionary name ${e3}"`);
        const t3 = this.nameToKeyMap[e3];
        return t3 in this.values ? this.values[t3] : this.defaults[t3];
      }
      removeByName(e3) {
        delete this.values[this.nameToKeyMap[e3]];
      }
      static createTables(e3) {
        const t3 = { keyToNameMap: {}, nameToKeyMap: {}, defaults: {}, types: {}, opcodes: {}, order: [] };
        for (const i3 of e3) {
          const e4 = Array.isArray(i3[0]) ? (i3[0][0] << 8) + i3[0][1] : i3[0];
          t3.keyToNameMap[e4] = i3[1], t3.nameToKeyMap[i3[1]] = e4, t3.types[e4] = i3[2], t3.defaults[e4] = i3[3], t3.opcodes[e4] = Array.isArray(i3[0]) ? i3[0] : [i3[0]], t3.order.push(e4);
        }
        return t3;
      }
    };
    er = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [1e-3, 0, 0, 1e-3, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
    CFFTopDict = class _CFFTopDict extends CFFDict {
      static get tables() {
        return shadow(this, "tables", this.createTables(er));
      }
      constructor(e3) {
        super(_CFFTopDict.tables, e3), this.privateDict = null;
      }
    };
    tr = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
    CFFPrivateDict = class _CFFPrivateDict extends CFFDict {
      static get tables() {
        return shadow(this, "tables", this.createTables(tr));
      }
      constructor(e3) {
        super(_CFFPrivateDict.tables, e3), this.subrsIndex = null;
      }
    };
    Ar = { ISO_ADOBE: 0, EXPERT: 1, EXPERT_SUBSET: 2 };
    CFFCharset = class {
      constructor(e3, t3, i3, a3) {
        this.predefined = e3, this.format = t3, this.charset = i3, this.raw = a3;
      }
    };
    CFFEncoding = class {
      constructor(e3, t3, i3, a3) {
        this.predefined = e3, this.format = t3, this.encoding = i3, this.raw = a3;
      }
    };
    CFFFDSelect = class {
      constructor(e3, t3) {
        this.format = e3, this.fdSelect = t3;
      }
      getFDIndex(e3) {
        return e3 < 0 || e3 >= this.fdSelect.length ? -1 : this.fdSelect[e3];
      }
    };
    CFFOffsetTracker = class {
      constructor() {
        this.offsets = /* @__PURE__ */ Object.create(null);
      }
      isTracking(e3) {
        return e3 in this.offsets;
      }
      track(e3, t3) {
        if (e3 in this.offsets) throw new FormatError(`Already tracking location of ${e3}`);
        this.offsets[e3] = t3;
      }
      offset(e3) {
        for (const t3 in this.offsets) this.offsets[t3] += e3;
      }
      setEntryLocation(e3, t3, i3) {
        if (!(e3 in this.offsets)) throw new FormatError(`Not tracking location of ${e3}`);
        const a3 = i3.data, s3 = this.offsets[e3];
        for (let e4 = 0, i4 = t3.length; e4 < i4; ++e4) {
          const i5 = 5 * e4 + s3, n3 = i5 + 1, r3 = i5 + 2, o3 = i5 + 3, g3 = i5 + 4;
          if (29 !== a3[i5] || 0 !== a3[n3] || 0 !== a3[r3] || 0 !== a3[o3] || 0 !== a3[g3]) throw new FormatError("writing to an offset that is not empty");
          const c3 = t3[e4];
          a3[i5] = 29, a3[n3] = c3 >> 24 & 255, a3[r3] = c3 >> 16 & 255, a3[o3] = c3 >> 8 & 255, a3[g3] = 255 & c3;
        }
      }
    };
    CFFCompiler = class _CFFCompiler {
      constructor(e3) {
        this.cff = e3;
      }
      compile() {
        const e3 = this.cff, t3 = { data: [], length: 0, add(e4) {
          try {
            this.data.push(...e4);
          } catch {
            this.data = this.data.concat(e4);
          }
          this.length = this.data.length;
        } }, i3 = this.compileHeader(e3.header);
        t3.add(i3);
        const a3 = this.compileNameIndex(e3.names);
        if (t3.add(a3), e3.isCIDFont && e3.topDict.hasName("FontMatrix")) {
          const t4 = e3.topDict.getByName("FontMatrix");
          e3.topDict.removeByName("FontMatrix");
          for (const i4 of e3.fdArray) {
            let e4 = t4.slice(0);
            i4.hasName("FontMatrix") && (e4 = Util.transform(e4, i4.getByName("FontMatrix"))), i4.setByName("FontMatrix", e4);
          }
        }
        const s3 = e3.topDict.getByName("XUID");
        s3?.length > 16 && e3.topDict.removeByName("XUID"), e3.topDict.setByName("charset", 0);
        let n3 = this.compileTopDicts([e3.topDict], t3.length, e3.isCIDFont);
        t3.add(n3.output);
        const r3 = n3.trackers[0], o3 = this.compileStringIndex(e3.strings.strings);
        t3.add(o3);
        const g3 = this.compileIndex(e3.globalSubrIndex);
        if (t3.add(g3), e3.encoding && e3.topDict.hasName("Encoding")) if (e3.encoding.predefined) r3.setEntryLocation("Encoding", [e3.encoding.format], t3);
        else {
          const i4 = this.compileEncoding(e3.encoding);
          r3.setEntryLocation("Encoding", [t3.length], t3), t3.add(i4);
        }
        const c3 = this.compileCharset(e3.charset, e3.charStrings.count, e3.strings, e3.isCIDFont);
        r3.setEntryLocation("charset", [t3.length], t3), t3.add(c3);
        const h3 = this.compileCharStrings(e3.charStrings);
        if (r3.setEntryLocation("CharStrings", [t3.length], t3), t3.add(h3), e3.isCIDFont) {
          r3.setEntryLocation("FDSelect", [t3.length], t3);
          const i4 = this.compileFDSelect(e3.fdSelect);
          t3.add(i4), n3 = this.compileTopDicts(e3.fdArray, t3.length, true), r3.setEntryLocation("FDArray", [t3.length], t3), t3.add(n3.output);
          const a4 = n3.trackers;
          this.compilePrivateDicts(e3.fdArray, a4, t3);
        }
        return this.compilePrivateDicts([e3.topDict], [r3], t3), t3.add([0]), t3.data;
      }
      encodeNumber(e3) {
        return Number.isInteger(e3) ? this.encodeInteger(e3) : this.encodeFloat(e3);
      }
      static get EncodeFloatRegExp() {
        return shadow(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
      }
      encodeFloat(e3) {
        let t3 = e3.toString();
        const i3 = _CFFCompiler.EncodeFloatRegExp.exec(t3);
        if (i3) {
          const a4 = parseFloat("1e" + ((i3[2] ? +i3[2] : 0) + i3[1].length));
          t3 = (Math.round(e3 * a4) / a4).toString();
        }
        let a3, s3, n3 = "";
        for (a3 = 0, s3 = t3.length; a3 < s3; ++a3) {
          const e4 = t3[a3];
          n3 += "e" === e4 ? "-" === t3[++a3] ? "c" : "b" : "." === e4 ? "a" : "-" === e4 ? "e" : e4;
        }
        n3 += 1 & n3.length ? "f" : "ff";
        const r3 = [30];
        for (a3 = 0, s3 = n3.length; a3 < s3; a3 += 2) r3.push(parseInt(n3.substring(a3, a3 + 2), 16));
        return r3;
      }
      encodeInteger(e3) {
        let t3;
        return t3 = e3 >= -107 && e3 <= 107 ? [e3 + 139] : e3 >= 108 && e3 <= 1131 ? [247 + ((e3 -= 108) >> 8), 255 & e3] : e3 >= -1131 && e3 <= -108 ? [251 + ((e3 = -e3 - 108) >> 8), 255 & e3] : e3 >= -32768 && e3 <= 32767 ? [28, e3 >> 8 & 255, 255 & e3] : [29, e3 >> 24 & 255, e3 >> 16 & 255, e3 >> 8 & 255, 255 & e3], t3;
      }
      compileHeader(e3) {
        return [e3.major, e3.minor, 4, e3.offSize];
      }
      compileNameIndex(e3) {
        const t3 = new CFFIndex();
        for (const i3 of e3) {
          const e4 = Math.min(i3.length, 127);
          let a3 = new Array(e4);
          for (let t4 = 0; t4 < e4; t4++) {
            let e5 = i3[t4];
            (e5 < "!" || e5 > "~" || "[" === e5 || "]" === e5 || "(" === e5 || ")" === e5 || "{" === e5 || "}" === e5 || "<" === e5 || ">" === e5 || "/" === e5 || "%" === e5) && (e5 = "_"), a3[t4] = e5;
          }
          a3 = a3.join(""), "" === a3 && (a3 = "Bad_Font_Name"), t3.add(stringToBytes(a3));
        }
        return this.compileIndex(t3);
      }
      compileTopDicts(e3, t3, i3) {
        const a3 = [];
        let s3 = new CFFIndex();
        for (const n3 of e3) {
          i3 && (n3.removeByName("CIDFontVersion"), n3.removeByName("CIDFontRevision"), n3.removeByName("CIDFontType"), n3.removeByName("CIDCount"), n3.removeByName("UIDBase"));
          const e4 = new CFFOffsetTracker(), r3 = this.compileDict(n3, e4);
          a3.push(e4), s3.add(r3), e4.offset(t3);
        }
        return s3 = this.compileIndex(s3, a3), { trackers: a3, output: s3 };
      }
      compilePrivateDicts(e3, t3, i3) {
        for (let a3 = 0, s3 = e3.length; a3 < s3; ++a3) {
          const s4 = e3[a3], n3 = s4.privateDict;
          if (!n3 || !s4.hasName("Private")) throw new FormatError("There must be a private dictionary.");
          const r3 = new CFFOffsetTracker(), o3 = this.compileDict(n3, r3);
          let g3 = i3.length;
          if (r3.offset(g3), o3.length || (g3 = 0), t3[a3].setEntryLocation("Private", [o3.length, g3], i3), i3.add(o3), n3.subrsIndex && n3.hasName("Subrs")) {
            const e4 = this.compileIndex(n3.subrsIndex);
            r3.setEntryLocation("Subrs", [o3.length], i3), i3.add(e4);
          }
        }
      }
      compileDict(e3, t3) {
        const i3 = [];
        for (const a3 of e3.order) {
          if (!(a3 in e3.values)) continue;
          let s3 = e3.values[a3], n3 = e3.types[a3];
          if (Array.isArray(n3) || (n3 = [n3]), Array.isArray(s3) || (s3 = [s3]), 0 !== s3.length) {
            for (let r3 = 0, o3 = n3.length; r3 < o3; ++r3) {
              const o4 = n3[r3], g3 = s3[r3];
              switch (o4) {
                case "num":
                case "sid":
                  i3.push(...this.encodeNumber(g3));
                  break;
                case "offset":
                  const n4 = e3.keyToNameMap[a3];
                  t3.isTracking(n4) || t3.track(n4, i3.length), i3.push(29, 0, 0, 0, 0);
                  break;
                case "array":
                case "delta":
                  i3.push(...this.encodeNumber(g3));
                  for (let e4 = 1, t4 = s3.length; e4 < t4; ++e4) i3.push(...this.encodeNumber(s3[e4]));
                  break;
                default:
                  throw new FormatError(`Unknown data type of ${o4}`);
              }
            }
            i3.push(...e3.opcodes[a3]);
          }
        }
        return i3;
      }
      compileStringIndex(e3) {
        const t3 = new CFFIndex();
        for (const i3 of e3) t3.add(stringToBytes(i3));
        return this.compileIndex(t3);
      }
      compileCharStrings(e3) {
        const t3 = new CFFIndex();
        for (let i3 = 0; i3 < e3.count; i3++) {
          const a3 = e3.get(i3);
          0 !== a3.length ? t3.add(a3) : t3.add(new Uint8Array([139, 14]));
        }
        return this.compileIndex(t3);
      }
      compileCharset(e3, t3, i3, a3) {
        let s3;
        const n3 = t3 - 1;
        if (a3) s3 = new Uint8Array([2, 0, 0, n3 >> 8 & 255, 255 & n3]);
        else {
          s3 = new Uint8Array(1 + 2 * n3), s3[0] = 0;
          let t4 = 0;
          const a4 = e3.charset.length;
          let r3 = false;
          for (let n4 = 1; n4 < s3.length; n4 += 2) {
            let o3 = 0;
            if (t4 < a4) {
              const a5 = e3.charset[t4++];
              o3 = i3.getSID(a5), -1 === o3 && (o3 = 0, r3 || (r3 = true, warn(`Couldn't find ${a5} in CFF strings`)));
            }
            s3[n4] = o3 >> 8 & 255, s3[n4 + 1] = 255 & o3;
          }
        }
        return this.compileTypedArray(s3);
      }
      compileEncoding(e3) {
        return this.compileTypedArray(e3.raw);
      }
      compileFDSelect(e3) {
        const t3 = e3.format;
        let i3, a3;
        switch (t3) {
          case 0:
            for (i3 = new Uint8Array(1 + e3.fdSelect.length), i3[0] = t3, a3 = 0; a3 < e3.fdSelect.length; a3++) i3[a3 + 1] = e3.fdSelect[a3];
            break;
          case 3:
            const s3 = 0;
            let n3 = e3.fdSelect[0];
            const r3 = [t3, 0, 0, s3 >> 8 & 255, 255 & s3, n3];
            for (a3 = 1; a3 < e3.fdSelect.length; a3++) {
              const t4 = e3.fdSelect[a3];
              t4 !== n3 && (r3.push(a3 >> 8 & 255, 255 & a3, t4), n3 = t4);
            }
            const o3 = (r3.length - 3) / 3;
            r3[1] = o3 >> 8 & 255, r3[2] = 255 & o3, r3.push(a3 >> 8 & 255, 255 & a3), i3 = new Uint8Array(r3);
        }
        return this.compileTypedArray(i3);
      }
      compileTypedArray(e3) {
        return Array.from(e3);
      }
      compileIndex(e3, t3 = []) {
        const i3 = e3.objects, a3 = i3.length;
        if (0 === a3) return [0, 0];
        const s3 = [a3 >> 8 & 255, 255 & a3];
        let n3, r3, o3 = 1;
        for (n3 = 0; n3 < a3; ++n3) o3 += i3[n3].length;
        r3 = o3 < 256 ? 1 : o3 < 65536 ? 2 : o3 < 16777216 ? 3 : 4, s3.push(r3);
        let g3 = 1;
        for (n3 = 0; n3 < a3 + 1; n3++) 1 === r3 ? s3.push(255 & g3) : 2 === r3 ? s3.push(g3 >> 8 & 255, 255 & g3) : 3 === r3 ? s3.push(g3 >> 16 & 255, g3 >> 8 & 255, 255 & g3) : s3.push(g3 >>> 24 & 255, g3 >> 16 & 255, g3 >> 8 & 255, 255 & g3), i3[n3] && (g3 += i3[n3].length);
        for (n3 = 0; n3 < a3; n3++) t3[n3] && t3[n3].offset(s3.length), s3.push(...i3[n3]);
        return s3;
      }
    };
    ir = getLookupTableFactory(function(e3) {
      e3.A = 65, e3.AE = 198, e3.AEacute = 508, e3.AEmacron = 482, e3.AEsmall = 63462, e3.Aacute = 193, e3.Aacutesmall = 63457, e3.Abreve = 258, e3.Abreveacute = 7854, e3.Abrevecyrillic = 1232, e3.Abrevedotbelow = 7862, e3.Abrevegrave = 7856, e3.Abrevehookabove = 7858, e3.Abrevetilde = 7860, e3.Acaron = 461, e3.Acircle = 9398, e3.Acircumflex = 194, e3.Acircumflexacute = 7844, e3.Acircumflexdotbelow = 7852, e3.Acircumflexgrave = 7846, e3.Acircumflexhookabove = 7848, e3.Acircumflexsmall = 63458, e3.Acircumflextilde = 7850, e3.Acute = 63177, e3.Acutesmall = 63412, e3.Acyrillic = 1040, e3.Adblgrave = 512, e3.Adieresis = 196, e3.Adieresiscyrillic = 1234, e3.Adieresismacron = 478, e3.Adieresissmall = 63460, e3.Adotbelow = 7840, e3.Adotmacron = 480, e3.Agrave = 192, e3.Agravesmall = 63456, e3.Ahookabove = 7842, e3.Aiecyrillic = 1236, e3.Ainvertedbreve = 514, e3.Alpha = 913, e3.Alphatonos = 902, e3.Amacron = 256, e3.Amonospace = 65313, e3.Aogonek = 260, e3.Aring = 197, e3.Aringacute = 506, e3.Aringbelow = 7680, e3.Aringsmall = 63461, e3.Asmall = 63329, e3.Atilde = 195, e3.Atildesmall = 63459, e3.Aybarmenian = 1329, e3.B = 66, e3.Bcircle = 9399, e3.Bdotaccent = 7682, e3.Bdotbelow = 7684, e3.Becyrillic = 1041, e3.Benarmenian = 1330, e3.Beta = 914, e3.Bhook = 385, e3.Blinebelow = 7686, e3.Bmonospace = 65314, e3.Brevesmall = 63220, e3.Bsmall = 63330, e3.Btopbar = 386, e3.C = 67, e3.Caarmenian = 1342, e3.Cacute = 262, e3.Caron = 63178, e3.Caronsmall = 63221, e3.Ccaron = 268, e3.Ccedilla = 199, e3.Ccedillaacute = 7688, e3.Ccedillasmall = 63463, e3.Ccircle = 9400, e3.Ccircumflex = 264, e3.Cdot = 266, e3.Cdotaccent = 266, e3.Cedillasmall = 63416, e3.Chaarmenian = 1353, e3.Cheabkhasiancyrillic = 1212, e3.Checyrillic = 1063, e3.Chedescenderabkhasiancyrillic = 1214, e3.Chedescendercyrillic = 1206, e3.Chedieresiscyrillic = 1268, e3.Cheharmenian = 1347, e3.Chekhakassiancyrillic = 1227, e3.Cheverticalstrokecyrillic = 1208, e3.Chi = 935, e3.Chook = 391, e3.Circumflexsmall = 63222, e3.Cmonospace = 65315, e3.Coarmenian = 1361, e3.Csmall = 63331, e3.D = 68, e3.DZ = 497, e3.DZcaron = 452, e3.Daarmenian = 1332, e3.Dafrican = 393, e3.Dcaron = 270, e3.Dcedilla = 7696, e3.Dcircle = 9401, e3.Dcircumflexbelow = 7698, e3.Dcroat = 272, e3.Ddotaccent = 7690, e3.Ddotbelow = 7692, e3.Decyrillic = 1044, e3.Deicoptic = 1006, e3.Delta = 8710, e3.Deltagreek = 916, e3.Dhook = 394, e3.Dieresis = 63179, e3.DieresisAcute = 63180, e3.DieresisGrave = 63181, e3.Dieresissmall = 63400, e3.Digammagreek = 988, e3.Djecyrillic = 1026, e3.Dlinebelow = 7694, e3.Dmonospace = 65316, e3.Dotaccentsmall = 63223, e3.Dslash = 272, e3.Dsmall = 63332, e3.Dtopbar = 395, e3.Dz = 498, e3.Dzcaron = 453, e3.Dzeabkhasiancyrillic = 1248, e3.Dzecyrillic = 1029, e3.Dzhecyrillic = 1039, e3.E = 69, e3.Eacute = 201, e3.Eacutesmall = 63465, e3.Ebreve = 276, e3.Ecaron = 282, e3.Ecedillabreve = 7708, e3.Echarmenian = 1333, e3.Ecircle = 9402, e3.Ecircumflex = 202, e3.Ecircumflexacute = 7870, e3.Ecircumflexbelow = 7704, e3.Ecircumflexdotbelow = 7878, e3.Ecircumflexgrave = 7872, e3.Ecircumflexhookabove = 7874, e3.Ecircumflexsmall = 63466, e3.Ecircumflextilde = 7876, e3.Ecyrillic = 1028, e3.Edblgrave = 516, e3.Edieresis = 203, e3.Edieresissmall = 63467, e3.Edot = 278, e3.Edotaccent = 278, e3.Edotbelow = 7864, e3.Efcyrillic = 1060, e3.Egrave = 200, e3.Egravesmall = 63464, e3.Eharmenian = 1335, e3.Ehookabove = 7866, e3.Eightroman = 8551, e3.Einvertedbreve = 518, e3.Eiotifiedcyrillic = 1124, e3.Elcyrillic = 1051, e3.Elevenroman = 8554, e3.Emacron = 274, e3.Emacronacute = 7702, e3.Emacrongrave = 7700, e3.Emcyrillic = 1052, e3.Emonospace = 65317, e3.Encyrillic = 1053, e3.Endescendercyrillic = 1186, e3.Eng = 330, e3.Enghecyrillic = 1188, e3.Enhookcyrillic = 1223, e3.Eogonek = 280, e3.Eopen = 400, e3.Epsilon = 917, e3.Epsilontonos = 904, e3.Ercyrillic = 1056, e3.Ereversed = 398, e3.Ereversedcyrillic = 1069, e3.Escyrillic = 1057, e3.Esdescendercyrillic = 1194, e3.Esh = 425, e3.Esmall = 63333, e3.Eta = 919, e3.Etarmenian = 1336, e3.Etatonos = 905, e3.Eth = 208, e3.Ethsmall = 63472, e3.Etilde = 7868, e3.Etildebelow = 7706, e3.Euro = 8364, e3.Ezh = 439, e3.Ezhcaron = 494, e3.Ezhreversed = 440, e3.F = 70, e3.Fcircle = 9403, e3.Fdotaccent = 7710, e3.Feharmenian = 1366, e3.Feicoptic = 996, e3.Fhook = 401, e3.Fitacyrillic = 1138, e3.Fiveroman = 8548, e3.Fmonospace = 65318, e3.Fourroman = 8547, e3.Fsmall = 63334, e3.G = 71, e3.GBsquare = 13191, e3.Gacute = 500, e3.Gamma = 915, e3.Gammaafrican = 404, e3.Gangiacoptic = 1002, e3.Gbreve = 286, e3.Gcaron = 486, e3.Gcedilla = 290, e3.Gcircle = 9404, e3.Gcircumflex = 284, e3.Gcommaaccent = 290, e3.Gdot = 288, e3.Gdotaccent = 288, e3.Gecyrillic = 1043, e3.Ghadarmenian = 1346, e3.Ghemiddlehookcyrillic = 1172, e3.Ghestrokecyrillic = 1170, e3.Gheupturncyrillic = 1168, e3.Ghook = 403, e3.Gimarmenian = 1331, e3.Gjecyrillic = 1027, e3.Gmacron = 7712, e3.Gmonospace = 65319, e3.Grave = 63182, e3.Gravesmall = 63328, e3.Gsmall = 63335, e3.Gsmallhook = 667, e3.Gstroke = 484, e3.H = 72, e3.H18533 = 9679, e3.H18543 = 9642, e3.H18551 = 9643, e3.H22073 = 9633, e3.HPsquare = 13259, e3.Haabkhasiancyrillic = 1192, e3.Hadescendercyrillic = 1202, e3.Hardsigncyrillic = 1066, e3.Hbar = 294, e3.Hbrevebelow = 7722, e3.Hcedilla = 7720, e3.Hcircle = 9405, e3.Hcircumflex = 292, e3.Hdieresis = 7718, e3.Hdotaccent = 7714, e3.Hdotbelow = 7716, e3.Hmonospace = 65320, e3.Hoarmenian = 1344, e3.Horicoptic = 1e3, e3.Hsmall = 63336, e3.Hungarumlaut = 63183, e3.Hungarumlautsmall = 63224, e3.Hzsquare = 13200, e3.I = 73, e3.IAcyrillic = 1071, e3.IJ = 306, e3.IUcyrillic = 1070, e3.Iacute = 205, e3.Iacutesmall = 63469, e3.Ibreve = 300, e3.Icaron = 463, e3.Icircle = 9406, e3.Icircumflex = 206, e3.Icircumflexsmall = 63470, e3.Icyrillic = 1030, e3.Idblgrave = 520, e3.Idieresis = 207, e3.Idieresisacute = 7726, e3.Idieresiscyrillic = 1252, e3.Idieresissmall = 63471, e3.Idot = 304, e3.Idotaccent = 304, e3.Idotbelow = 7882, e3.Iebrevecyrillic = 1238, e3.Iecyrillic = 1045, e3.Ifraktur = 8465, e3.Igrave = 204, e3.Igravesmall = 63468, e3.Ihookabove = 7880, e3.Iicyrillic = 1048, e3.Iinvertedbreve = 522, e3.Iishortcyrillic = 1049, e3.Imacron = 298, e3.Imacroncyrillic = 1250, e3.Imonospace = 65321, e3.Iniarmenian = 1339, e3.Iocyrillic = 1025, e3.Iogonek = 302, e3.Iota = 921, e3.Iotaafrican = 406, e3.Iotadieresis = 938, e3.Iotatonos = 906, e3.Ismall = 63337, e3.Istroke = 407, e3.Itilde = 296, e3.Itildebelow = 7724, e3.Izhitsacyrillic = 1140, e3.Izhitsadblgravecyrillic = 1142, e3.J = 74, e3.Jaarmenian = 1345, e3.Jcircle = 9407, e3.Jcircumflex = 308, e3.Jecyrillic = 1032, e3.Jheharmenian = 1355, e3.Jmonospace = 65322, e3.Jsmall = 63338, e3.K = 75, e3.KBsquare = 13189, e3.KKsquare = 13261, e3.Kabashkircyrillic = 1184, e3.Kacute = 7728, e3.Kacyrillic = 1050, e3.Kadescendercyrillic = 1178, e3.Kahookcyrillic = 1219, e3.Kappa = 922, e3.Kastrokecyrillic = 1182, e3.Kaverticalstrokecyrillic = 1180, e3.Kcaron = 488, e3.Kcedilla = 310, e3.Kcircle = 9408, e3.Kcommaaccent = 310, e3.Kdotbelow = 7730, e3.Keharmenian = 1364, e3.Kenarmenian = 1343, e3.Khacyrillic = 1061, e3.Kheicoptic = 998, e3.Khook = 408, e3.Kjecyrillic = 1036, e3.Klinebelow = 7732, e3.Kmonospace = 65323, e3.Koppacyrillic = 1152, e3.Koppagreek = 990, e3.Ksicyrillic = 1134, e3.Ksmall = 63339, e3.L = 76, e3.LJ = 455, e3.LL = 63167, e3.Lacute = 313, e3.Lambda = 923, e3.Lcaron = 317, e3.Lcedilla = 315, e3.Lcircle = 9409, e3.Lcircumflexbelow = 7740, e3.Lcommaaccent = 315, e3.Ldot = 319, e3.Ldotaccent = 319, e3.Ldotbelow = 7734, e3.Ldotbelowmacron = 7736, e3.Liwnarmenian = 1340, e3.Lj = 456, e3.Ljecyrillic = 1033, e3.Llinebelow = 7738, e3.Lmonospace = 65324, e3.Lslash = 321, e3.Lslashsmall = 63225, e3.Lsmall = 63340, e3.M = 77, e3.MBsquare = 13190, e3.Macron = 63184, e3.Macronsmall = 63407, e3.Macute = 7742, e3.Mcircle = 9410, e3.Mdotaccent = 7744, e3.Mdotbelow = 7746, e3.Menarmenian = 1348, e3.Mmonospace = 65325, e3.Msmall = 63341, e3.Mturned = 412, e3.Mu = 924, e3.N = 78, e3.NJ = 458, e3.Nacute = 323, e3.Ncaron = 327, e3.Ncedilla = 325, e3.Ncircle = 9411, e3.Ncircumflexbelow = 7754, e3.Ncommaaccent = 325, e3.Ndotaccent = 7748, e3.Ndotbelow = 7750, e3.Nhookleft = 413, e3.Nineroman = 8552, e3.Nj = 459, e3.Njecyrillic = 1034, e3.Nlinebelow = 7752, e3.Nmonospace = 65326, e3.Nowarmenian = 1350, e3.Nsmall = 63342, e3.Ntilde = 209, e3.Ntildesmall = 63473, e3.Nu = 925, e3.O = 79, e3.OE = 338, e3.OEsmall = 63226, e3.Oacute = 211, e3.Oacutesmall = 63475, e3.Obarredcyrillic = 1256, e3.Obarreddieresiscyrillic = 1258, e3.Obreve = 334, e3.Ocaron = 465, e3.Ocenteredtilde = 415, e3.Ocircle = 9412, e3.Ocircumflex = 212, e3.Ocircumflexacute = 7888, e3.Ocircumflexdotbelow = 7896, e3.Ocircumflexgrave = 7890, e3.Ocircumflexhookabove = 7892, e3.Ocircumflexsmall = 63476, e3.Ocircumflextilde = 7894, e3.Ocyrillic = 1054, e3.Odblacute = 336, e3.Odblgrave = 524, e3.Odieresis = 214, e3.Odieresiscyrillic = 1254, e3.Odieresissmall = 63478, e3.Odotbelow = 7884, e3.Ogoneksmall = 63227, e3.Ograve = 210, e3.Ogravesmall = 63474, e3.Oharmenian = 1365, e3.Ohm = 8486, e3.Ohookabove = 7886, e3.Ohorn = 416, e3.Ohornacute = 7898, e3.Ohorndotbelow = 7906, e3.Ohorngrave = 7900, e3.Ohornhookabove = 7902, e3.Ohorntilde = 7904, e3.Ohungarumlaut = 336, e3.Oi = 418, e3.Oinvertedbreve = 526, e3.Omacron = 332, e3.Omacronacute = 7762, e3.Omacrongrave = 7760, e3.Omega = 8486, e3.Omegacyrillic = 1120, e3.Omegagreek = 937, e3.Omegaroundcyrillic = 1146, e3.Omegatitlocyrillic = 1148, e3.Omegatonos = 911, e3.Omicron = 927, e3.Omicrontonos = 908, e3.Omonospace = 65327, e3.Oneroman = 8544, e3.Oogonek = 490, e3.Oogonekmacron = 492, e3.Oopen = 390, e3.Oslash = 216, e3.Oslashacute = 510, e3.Oslashsmall = 63480, e3.Osmall = 63343, e3.Ostrokeacute = 510, e3.Otcyrillic = 1150, e3.Otilde = 213, e3.Otildeacute = 7756, e3.Otildedieresis = 7758, e3.Otildesmall = 63477, e3.P = 80, e3.Pacute = 7764, e3.Pcircle = 9413, e3.Pdotaccent = 7766, e3.Pecyrillic = 1055, e3.Peharmenian = 1354, e3.Pemiddlehookcyrillic = 1190, e3.Phi = 934, e3.Phook = 420, e3.Pi = 928, e3.Piwrarmenian = 1363, e3.Pmonospace = 65328, e3.Psi = 936, e3.Psicyrillic = 1136, e3.Psmall = 63344, e3.Q = 81, e3.Qcircle = 9414, e3.Qmonospace = 65329, e3.Qsmall = 63345, e3.R = 82, e3.Raarmenian = 1356, e3.Racute = 340, e3.Rcaron = 344, e3.Rcedilla = 342, e3.Rcircle = 9415, e3.Rcommaaccent = 342, e3.Rdblgrave = 528, e3.Rdotaccent = 7768, e3.Rdotbelow = 7770, e3.Rdotbelowmacron = 7772, e3.Reharmenian = 1360, e3.Rfraktur = 8476, e3.Rho = 929, e3.Ringsmall = 63228, e3.Rinvertedbreve = 530, e3.Rlinebelow = 7774, e3.Rmonospace = 65330, e3.Rsmall = 63346, e3.Rsmallinverted = 641, e3.Rsmallinvertedsuperior = 694, e3.S = 83, e3.SF010000 = 9484, e3.SF020000 = 9492, e3.SF030000 = 9488, e3.SF040000 = 9496, e3.SF050000 = 9532, e3.SF060000 = 9516, e3.SF070000 = 9524, e3.SF080000 = 9500, e3.SF090000 = 9508, e3.SF100000 = 9472, e3.SF110000 = 9474, e3.SF190000 = 9569, e3.SF200000 = 9570, e3.SF210000 = 9558, e3.SF220000 = 9557, e3.SF230000 = 9571, e3.SF240000 = 9553, e3.SF250000 = 9559, e3.SF260000 = 9565, e3.SF270000 = 9564, e3.SF280000 = 9563, e3.SF360000 = 9566, e3.SF370000 = 9567, e3.SF380000 = 9562, e3.SF390000 = 9556, e3.SF400000 = 9577, e3.SF410000 = 9574, e3.SF420000 = 9568, e3.SF430000 = 9552, e3.SF440000 = 9580, e3.SF450000 = 9575, e3.SF460000 = 9576, e3.SF470000 = 9572, e3.SF480000 = 9573, e3.SF490000 = 9561, e3.SF500000 = 9560, e3.SF510000 = 9554, e3.SF520000 = 9555, e3.SF530000 = 9579, e3.SF540000 = 9578, e3.Sacute = 346, e3.Sacutedotaccent = 7780, e3.Sampigreek = 992, e3.Scaron = 352, e3.Scarondotaccent = 7782, e3.Scaronsmall = 63229, e3.Scedilla = 350, e3.Schwa = 399, e3.Schwacyrillic = 1240, e3.Schwadieresiscyrillic = 1242, e3.Scircle = 9416, e3.Scircumflex = 348, e3.Scommaaccent = 536, e3.Sdotaccent = 7776, e3.Sdotbelow = 7778, e3.Sdotbelowdotaccent = 7784, e3.Seharmenian = 1357, e3.Sevenroman = 8550, e3.Shaarmenian = 1351, e3.Shacyrillic = 1064, e3.Shchacyrillic = 1065, e3.Sheicoptic = 994, e3.Shhacyrillic = 1210, e3.Shimacoptic = 1004, e3.Sigma = 931, e3.Sixroman = 8549, e3.Smonospace = 65331, e3.Softsigncyrillic = 1068, e3.Ssmall = 63347, e3.Stigmagreek = 986, e3.T = 84, e3.Tau = 932, e3.Tbar = 358, e3.Tcaron = 356, e3.Tcedilla = 354, e3.Tcircle = 9417, e3.Tcircumflexbelow = 7792, e3.Tcommaaccent = 354, e3.Tdotaccent = 7786, e3.Tdotbelow = 7788, e3.Tecyrillic = 1058, e3.Tedescendercyrillic = 1196, e3.Tenroman = 8553, e3.Tetsecyrillic = 1204, e3.Theta = 920, e3.Thook = 428, e3.Thorn = 222, e3.Thornsmall = 63486, e3.Threeroman = 8546, e3.Tildesmall = 63230, e3.Tiwnarmenian = 1359, e3.Tlinebelow = 7790, e3.Tmonospace = 65332, e3.Toarmenian = 1337, e3.Tonefive = 444, e3.Tonesix = 388, e3.Tonetwo = 423, e3.Tretroflexhook = 430, e3.Tsecyrillic = 1062, e3.Tshecyrillic = 1035, e3.Tsmall = 63348, e3.Twelveroman = 8555, e3.Tworoman = 8545, e3.U = 85, e3.Uacute = 218, e3.Uacutesmall = 63482, e3.Ubreve = 364, e3.Ucaron = 467, e3.Ucircle = 9418, e3.Ucircumflex = 219, e3.Ucircumflexbelow = 7798, e3.Ucircumflexsmall = 63483, e3.Ucyrillic = 1059, e3.Udblacute = 368, e3.Udblgrave = 532, e3.Udieresis = 220, e3.Udieresisacute = 471, e3.Udieresisbelow = 7794, e3.Udieresiscaron = 473, e3.Udieresiscyrillic = 1264, e3.Udieresisgrave = 475, e3.Udieresismacron = 469, e3.Udieresissmall = 63484, e3.Udotbelow = 7908, e3.Ugrave = 217, e3.Ugravesmall = 63481, e3.Uhookabove = 7910, e3.Uhorn = 431, e3.Uhornacute = 7912, e3.Uhorndotbelow = 7920, e3.Uhorngrave = 7914, e3.Uhornhookabove = 7916, e3.Uhorntilde = 7918, e3.Uhungarumlaut = 368, e3.Uhungarumlautcyrillic = 1266, e3.Uinvertedbreve = 534, e3.Ukcyrillic = 1144, e3.Umacron = 362, e3.Umacroncyrillic = 1262, e3.Umacrondieresis = 7802, e3.Umonospace = 65333, e3.Uogonek = 370, e3.Upsilon = 933, e3.Upsilon1 = 978, e3.Upsilonacutehooksymbolgreek = 979, e3.Upsilonafrican = 433, e3.Upsilondieresis = 939, e3.Upsilondieresishooksymbolgreek = 980, e3.Upsilonhooksymbol = 978, e3.Upsilontonos = 910, e3.Uring = 366, e3.Ushortcyrillic = 1038, e3.Usmall = 63349, e3.Ustraightcyrillic = 1198, e3.Ustraightstrokecyrillic = 1200, e3.Utilde = 360, e3.Utildeacute = 7800, e3.Utildebelow = 7796, e3.V = 86, e3.Vcircle = 9419, e3.Vdotbelow = 7806, e3.Vecyrillic = 1042, e3.Vewarmenian = 1358, e3.Vhook = 434, e3.Vmonospace = 65334, e3.Voarmenian = 1352, e3.Vsmall = 63350, e3.Vtilde = 7804, e3.W = 87, e3.Wacute = 7810, e3.Wcircle = 9420, e3.Wcircumflex = 372, e3.Wdieresis = 7812, e3.Wdotaccent = 7814, e3.Wdotbelow = 7816, e3.Wgrave = 7808, e3.Wmonospace = 65335, e3.Wsmall = 63351, e3.X = 88, e3.Xcircle = 9421, e3.Xdieresis = 7820, e3.Xdotaccent = 7818, e3.Xeharmenian = 1341, e3.Xi = 926, e3.Xmonospace = 65336, e3.Xsmall = 63352, e3.Y = 89, e3.Yacute = 221, e3.Yacutesmall = 63485, e3.Yatcyrillic = 1122, e3.Ycircle = 9422, e3.Ycircumflex = 374, e3.Ydieresis = 376, e3.Ydieresissmall = 63487, e3.Ydotaccent = 7822, e3.Ydotbelow = 7924, e3.Yericyrillic = 1067, e3.Yerudieresiscyrillic = 1272, e3.Ygrave = 7922, e3.Yhook = 435, e3.Yhookabove = 7926, e3.Yiarmenian = 1349, e3.Yicyrillic = 1031, e3.Yiwnarmenian = 1362, e3.Ymonospace = 65337, e3.Ysmall = 63353, e3.Ytilde = 7928, e3.Yusbigcyrillic = 1130, e3.Yusbigiotifiedcyrillic = 1132, e3.Yuslittlecyrillic = 1126, e3.Yuslittleiotifiedcyrillic = 1128, e3.Z = 90, e3.Zaarmenian = 1334, e3.Zacute = 377, e3.Zcaron = 381, e3.Zcaronsmall = 63231, e3.Zcircle = 9423, e3.Zcircumflex = 7824, e3.Zdot = 379, e3.Zdotaccent = 379, e3.Zdotbelow = 7826, e3.Zecyrillic = 1047, e3.Zedescendercyrillic = 1176, e3.Zedieresiscyrillic = 1246, e3.Zeta = 918, e3.Zhearmenian = 1338, e3.Zhebrevecyrillic = 1217, e3.Zhecyrillic = 1046, e3.Zhedescendercyrillic = 1174, e3.Zhedieresiscyrillic = 1244, e3.Zlinebelow = 7828, e3.Zmonospace = 65338, e3.Zsmall = 63354, e3.Zstroke = 437, e3.a = 97, e3.aabengali = 2438, e3.aacute = 225, e3.aadeva = 2310, e3.aagujarati = 2694, e3.aagurmukhi = 2566, e3.aamatragurmukhi = 2622, e3.aarusquare = 13059, e3.aavowelsignbengali = 2494, e3.aavowelsigndeva = 2366, e3.aavowelsigngujarati = 2750, e3.abbreviationmarkarmenian = 1375, e3.abbreviationsigndeva = 2416, e3.abengali = 2437, e3.abopomofo = 12570, e3.abreve = 259, e3.abreveacute = 7855, e3.abrevecyrillic = 1233, e3.abrevedotbelow = 7863, e3.abrevegrave = 7857, e3.abrevehookabove = 7859, e3.abrevetilde = 7861, e3.acaron = 462, e3.acircle = 9424, e3.acircumflex = 226, e3.acircumflexacute = 7845, e3.acircumflexdotbelow = 7853, e3.acircumflexgrave = 7847, e3.acircumflexhookabove = 7849, e3.acircumflextilde = 7851, e3.acute = 180, e3.acutebelowcmb = 791, e3.acutecmb = 769, e3.acutecomb = 769, e3.acutedeva = 2388, e3.acutelowmod = 719, e3.acutetonecmb = 833, e3.acyrillic = 1072, e3.adblgrave = 513, e3.addakgurmukhi = 2673, e3.adeva = 2309, e3.adieresis = 228, e3.adieresiscyrillic = 1235, e3.adieresismacron = 479, e3.adotbelow = 7841, e3.adotmacron = 481, e3.ae = 230, e3.aeacute = 509, e3.aekorean = 12624, e3.aemacron = 483, e3.afii00208 = 8213, e3.afii08941 = 8356, e3.afii10017 = 1040, e3.afii10018 = 1041, e3.afii10019 = 1042, e3.afii10020 = 1043, e3.afii10021 = 1044, e3.afii10022 = 1045, e3.afii10023 = 1025, e3.afii10024 = 1046, e3.afii10025 = 1047, e3.afii10026 = 1048, e3.afii10027 = 1049, e3.afii10028 = 1050, e3.afii10029 = 1051, e3.afii10030 = 1052;
      e3.afii10031 = 1053, e3.afii10032 = 1054, e3.afii10033 = 1055, e3.afii10034 = 1056, e3.afii10035 = 1057, e3.afii10036 = 1058, e3.afii10037 = 1059, e3.afii10038 = 1060, e3.afii10039 = 1061, e3.afii10040 = 1062, e3.afii10041 = 1063, e3.afii10042 = 1064, e3.afii10043 = 1065, e3.afii10044 = 1066, e3.afii10045 = 1067, e3.afii10046 = 1068, e3.afii10047 = 1069, e3.afii10048 = 1070, e3.afii10049 = 1071, e3.afii10050 = 1168, e3.afii10051 = 1026, e3.afii10052 = 1027, e3.afii10053 = 1028, e3.afii10054 = 1029, e3.afii10055 = 1030, e3.afii10056 = 1031, e3.afii10057 = 1032, e3.afii10058 = 1033, e3.afii10059 = 1034, e3.afii10060 = 1035, e3.afii10061 = 1036, e3.afii10062 = 1038, e3.afii10063 = 63172, e3.afii10064 = 63173, e3.afii10065 = 1072, e3.afii10066 = 1073, e3.afii10067 = 1074, e3.afii10068 = 1075, e3.afii10069 = 1076, e3.afii10070 = 1077, e3.afii10071 = 1105, e3.afii10072 = 1078, e3.afii10073 = 1079, e3.afii10074 = 1080, e3.afii10075 = 1081, e3.afii10076 = 1082, e3.afii10077 = 1083, e3.afii10078 = 1084, e3.afii10079 = 1085, e3.afii10080 = 1086, e3.afii10081 = 1087, e3.afii10082 = 1088, e3.afii10083 = 1089, e3.afii10084 = 1090, e3.afii10085 = 1091, e3.afii10086 = 1092, e3.afii10087 = 1093, e3.afii10088 = 1094, e3.afii10089 = 1095, e3.afii10090 = 1096, e3.afii10091 = 1097, e3.afii10092 = 1098, e3.afii10093 = 1099, e3.afii10094 = 1100, e3.afii10095 = 1101, e3.afii10096 = 1102, e3.afii10097 = 1103, e3.afii10098 = 1169, e3.afii10099 = 1106, e3.afii10100 = 1107, e3.afii10101 = 1108, e3.afii10102 = 1109, e3.afii10103 = 1110, e3.afii10104 = 1111, e3.afii10105 = 1112, e3.afii10106 = 1113, e3.afii10107 = 1114, e3.afii10108 = 1115, e3.afii10109 = 1116, e3.afii10110 = 1118, e3.afii10145 = 1039, e3.afii10146 = 1122, e3.afii10147 = 1138, e3.afii10148 = 1140, e3.afii10192 = 63174, e3.afii10193 = 1119, e3.afii10194 = 1123, e3.afii10195 = 1139, e3.afii10196 = 1141, e3.afii10831 = 63175, e3.afii10832 = 63176, e3.afii10846 = 1241, e3.afii299 = 8206, e3.afii300 = 8207, e3.afii301 = 8205, e3.afii57381 = 1642, e3.afii57388 = 1548, e3.afii57392 = 1632, e3.afii57393 = 1633, e3.afii57394 = 1634, e3.afii57395 = 1635, e3.afii57396 = 1636, e3.afii57397 = 1637, e3.afii57398 = 1638, e3.afii57399 = 1639, e3.afii57400 = 1640, e3.afii57401 = 1641, e3.afii57403 = 1563, e3.afii57407 = 1567, e3.afii57409 = 1569, e3.afii57410 = 1570, e3.afii57411 = 1571, e3.afii57412 = 1572, e3.afii57413 = 1573, e3.afii57414 = 1574, e3.afii57415 = 1575, e3.afii57416 = 1576, e3.afii57417 = 1577, e3.afii57418 = 1578, e3.afii57419 = 1579, e3.afii57420 = 1580, e3.afii57421 = 1581, e3.afii57422 = 1582, e3.afii57423 = 1583, e3.afii57424 = 1584, e3.afii57425 = 1585, e3.afii57426 = 1586, e3.afii57427 = 1587, e3.afii57428 = 1588, e3.afii57429 = 1589, e3.afii57430 = 1590, e3.afii57431 = 1591, e3.afii57432 = 1592, e3.afii57433 = 1593, e3.afii57434 = 1594, e3.afii57440 = 1600, e3.afii57441 = 1601, e3.afii57442 = 1602, e3.afii57443 = 1603, e3.afii57444 = 1604, e3.afii57445 = 1605, e3.afii57446 = 1606, e3.afii57448 = 1608, e3.afii57449 = 1609, e3.afii57450 = 1610, e3.afii57451 = 1611, e3.afii57452 = 1612, e3.afii57453 = 1613, e3.afii57454 = 1614, e3.afii57455 = 1615, e3.afii57456 = 1616, e3.afii57457 = 1617, e3.afii57458 = 1618, e3.afii57470 = 1607, e3.afii57505 = 1700, e3.afii57506 = 1662, e3.afii57507 = 1670, e3.afii57508 = 1688, e3.afii57509 = 1711, e3.afii57511 = 1657, e3.afii57512 = 1672, e3.afii57513 = 1681, e3.afii57514 = 1722, e3.afii57519 = 1746, e3.afii57534 = 1749, e3.afii57636 = 8362, e3.afii57645 = 1470, e3.afii57658 = 1475, e3.afii57664 = 1488, e3.afii57665 = 1489, e3.afii57666 = 1490, e3.afii57667 = 1491, e3.afii57668 = 1492, e3.afii57669 = 1493, e3.afii57670 = 1494, e3.afii57671 = 1495, e3.afii57672 = 1496, e3.afii57673 = 1497, e3.afii57674 = 1498, e3.afii57675 = 1499, e3.afii57676 = 1500, e3.afii57677 = 1501, e3.afii57678 = 1502, e3.afii57679 = 1503, e3.afii57680 = 1504, e3.afii57681 = 1505, e3.afii57682 = 1506, e3.afii57683 = 1507, e3.afii57684 = 1508, e3.afii57685 = 1509, e3.afii57686 = 1510, e3.afii57687 = 1511, e3.afii57688 = 1512, e3.afii57689 = 1513, e3.afii57690 = 1514, e3.afii57694 = 64298, e3.afii57695 = 64299, e3.afii57700 = 64331, e3.afii57705 = 64287, e3.afii57716 = 1520, e3.afii57717 = 1521, e3.afii57718 = 1522, e3.afii57723 = 64309, e3.afii57793 = 1460, e3.afii57794 = 1461, e3.afii57795 = 1462, e3.afii57796 = 1467, e3.afii57797 = 1464, e3.afii57798 = 1463, e3.afii57799 = 1456, e3.afii57800 = 1458, e3.afii57801 = 1457, e3.afii57802 = 1459, e3.afii57803 = 1474, e3.afii57804 = 1473, e3.afii57806 = 1465, e3.afii57807 = 1468, e3.afii57839 = 1469, e3.afii57841 = 1471, e3.afii57842 = 1472, e3.afii57929 = 700, e3.afii61248 = 8453, e3.afii61289 = 8467, e3.afii61352 = 8470, e3.afii61573 = 8236, e3.afii61574 = 8237, e3.afii61575 = 8238, e3.afii61664 = 8204, e3.afii63167 = 1645, e3.afii64937 = 701, e3.agrave = 224, e3.agujarati = 2693, e3.agurmukhi = 2565, e3.ahiragana = 12354, e3.ahookabove = 7843, e3.aibengali = 2448, e3.aibopomofo = 12574, e3.aideva = 2320, e3.aiecyrillic = 1237, e3.aigujarati = 2704, e3.aigurmukhi = 2576, e3.aimatragurmukhi = 2632, e3.ainarabic = 1593, e3.ainfinalarabic = 65226, e3.aininitialarabic = 65227, e3.ainmedialarabic = 65228, e3.ainvertedbreve = 515, e3.aivowelsignbengali = 2504, e3.aivowelsigndeva = 2376, e3.aivowelsigngujarati = 2760, e3.akatakana = 12450, e3.akatakanahalfwidth = 65393, e3.akorean = 12623, e3.alef = 1488, e3.alefarabic = 1575, e3.alefdageshhebrew = 64304, e3.aleffinalarabic = 65166, e3.alefhamzaabovearabic = 1571, e3.alefhamzaabovefinalarabic = 65156, e3.alefhamzabelowarabic = 1573, e3.alefhamzabelowfinalarabic = 65160, e3.alefhebrew = 1488, e3.aleflamedhebrew = 64335, e3.alefmaddaabovearabic = 1570, e3.alefmaddaabovefinalarabic = 65154, e3.alefmaksuraarabic = 1609, e3.alefmaksurafinalarabic = 65264, e3.alefmaksurainitialarabic = 65267, e3.alefmaksuramedialarabic = 65268, e3.alefpatahhebrew = 64302, e3.alefqamatshebrew = 64303, e3.aleph = 8501, e3.allequal = 8780, e3.alpha = 945, e3.alphatonos = 940, e3.amacron = 257, e3.amonospace = 65345, e3.ampersand = 38, e3.ampersandmonospace = 65286, e3.ampersandsmall = 63270, e3.amsquare = 13250, e3.anbopomofo = 12578, e3.angbopomofo = 12580, e3.angbracketleft = 12296, e3.angbracketright = 12297, e3.angkhankhuthai = 3674, e3.angle = 8736, e3.anglebracketleft = 12296, e3.anglebracketleftvertical = 65087, e3.anglebracketright = 12297, e3.anglebracketrightvertical = 65088, e3.angleleft = 9001, e3.angleright = 9002, e3.angstrom = 8491, e3.anoteleia = 903, e3.anudattadeva = 2386, e3.anusvarabengali = 2434, e3.anusvaradeva = 2306, e3.anusvaragujarati = 2690, e3.aogonek = 261, e3.apaatosquare = 13056, e3.aparen = 9372, e3.apostrophearmenian = 1370, e3.apostrophemod = 700, e3.apple = 63743, e3.approaches = 8784, e3.approxequal = 8776, e3.approxequalorimage = 8786, e3.approximatelyequal = 8773, e3.araeaekorean = 12686, e3.araeakorean = 12685, e3.arc = 8978, e3.arighthalfring = 7834, e3.aring = 229, e3.aringacute = 507, e3.aringbelow = 7681, e3.arrowboth = 8596, e3.arrowdashdown = 8675, e3.arrowdashleft = 8672, e3.arrowdashright = 8674, e3.arrowdashup = 8673, e3.arrowdblboth = 8660, e3.arrowdbldown = 8659, e3.arrowdblleft = 8656, e3.arrowdblright = 8658, e3.arrowdblup = 8657, e3.arrowdown = 8595, e3.arrowdownleft = 8601, e3.arrowdownright = 8600, e3.arrowdownwhite = 8681, e3.arrowheaddownmod = 709, e3.arrowheadleftmod = 706, e3.arrowheadrightmod = 707, e3.arrowheadupmod = 708, e3.arrowhorizex = 63719, e3.arrowleft = 8592, e3.arrowleftdbl = 8656, e3.arrowleftdblstroke = 8653, e3.arrowleftoverright = 8646, e3.arrowleftwhite = 8678, e3.arrowright = 8594, e3.arrowrightdblstroke = 8655, e3.arrowrightheavy = 10142, e3.arrowrightoverleft = 8644, e3.arrowrightwhite = 8680, e3.arrowtableft = 8676, e3.arrowtabright = 8677, e3.arrowup = 8593, e3.arrowupdn = 8597, e3.arrowupdnbse = 8616, e3.arrowupdownbase = 8616, e3.arrowupleft = 8598, e3.arrowupleftofdown = 8645, e3.arrowupright = 8599, e3.arrowupwhite = 8679, e3.arrowvertex = 63718, e3.asciicircum = 94, e3.asciicircummonospace = 65342, e3.asciitilde = 126, e3.asciitildemonospace = 65374, e3.ascript = 593, e3.ascriptturned = 594, e3.asmallhiragana = 12353, e3.asmallkatakana = 12449, e3.asmallkatakanahalfwidth = 65383, e3.asterisk = 42, e3.asteriskaltonearabic = 1645, e3.asteriskarabic = 1645, e3.asteriskmath = 8727, e3.asteriskmonospace = 65290, e3.asterisksmall = 65121, e3.asterism = 8258, e3.asuperior = 63209, e3.asymptoticallyequal = 8771, e3.at = 64, e3.atilde = 227, e3.atmonospace = 65312, e3.atsmall = 65131, e3.aturned = 592, e3.aubengali = 2452, e3.aubopomofo = 12576, e3.audeva = 2324, e3.augujarati = 2708, e3.augurmukhi = 2580, e3.aulengthmarkbengali = 2519, e3.aumatragurmukhi = 2636, e3.auvowelsignbengali = 2508, e3.auvowelsigndeva = 2380, e3.auvowelsigngujarati = 2764, e3.avagrahadeva = 2365, e3.aybarmenian = 1377, e3.ayin = 1506, e3.ayinaltonehebrew = 64288, e3.ayinhebrew = 1506, e3.b = 98, e3.babengali = 2476, e3.backslash = 92, e3.backslashmonospace = 65340, e3.badeva = 2348, e3.bagujarati = 2732, e3.bagurmukhi = 2604, e3.bahiragana = 12400, e3.bahtthai = 3647, e3.bakatakana = 12496, e3.bar = 124, e3.barmonospace = 65372, e3.bbopomofo = 12549, e3.bcircle = 9425, e3.bdotaccent = 7683, e3.bdotbelow = 7685, e3.beamedsixteenthnotes = 9836, e3.because = 8757, e3.becyrillic = 1073, e3.beharabic = 1576, e3.behfinalarabic = 65168, e3.behinitialarabic = 65169, e3.behiragana = 12409, e3.behmedialarabic = 65170, e3.behmeeminitialarabic = 64671, e3.behmeemisolatedarabic = 64520, e3.behnoonfinalarabic = 64621, e3.bekatakana = 12505, e3.benarmenian = 1378, e3.bet = 1489, e3.beta = 946, e3.betasymbolgreek = 976, e3.betdagesh = 64305, e3.betdageshhebrew = 64305, e3.bethebrew = 1489, e3.betrafehebrew = 64332, e3.bhabengali = 2477, e3.bhadeva = 2349, e3.bhagujarati = 2733, e3.bhagurmukhi = 2605, e3.bhook = 595, e3.bihiragana = 12403, e3.bikatakana = 12499, e3.bilabialclick = 664, e3.bindigurmukhi = 2562, e3.birusquare = 13105, e3.blackcircle = 9679, e3.blackdiamond = 9670, e3.blackdownpointingtriangle = 9660, e3.blackleftpointingpointer = 9668, e3.blackleftpointingtriangle = 9664, e3.blacklenticularbracketleft = 12304, e3.blacklenticularbracketleftvertical = 65083, e3.blacklenticularbracketright = 12305, e3.blacklenticularbracketrightvertical = 65084, e3.blacklowerlefttriangle = 9699, e3.blacklowerrighttriangle = 9698, e3.blackrectangle = 9644, e3.blackrightpointingpointer = 9658, e3.blackrightpointingtriangle = 9654, e3.blacksmallsquare = 9642, e3.blacksmilingface = 9787, e3.blacksquare = 9632, e3.blackstar = 9733, e3.blackupperlefttriangle = 9700, e3.blackupperrighttriangle = 9701, e3.blackuppointingsmalltriangle = 9652, e3.blackuppointingtriangle = 9650, e3.blank = 9251, e3.blinebelow = 7687, e3.block = 9608, e3.bmonospace = 65346, e3.bobaimaithai = 3610, e3.bohiragana = 12412, e3.bokatakana = 12508, e3.bparen = 9373, e3.bqsquare = 13251, e3.braceex = 63732, e3.braceleft = 123, e3.braceleftbt = 63731, e3.braceleftmid = 63730, e3.braceleftmonospace = 65371, e3.braceleftsmall = 65115, e3.bracelefttp = 63729, e3.braceleftvertical = 65079, e3.braceright = 125, e3.bracerightbt = 63742, e3.bracerightmid = 63741, e3.bracerightmonospace = 65373, e3.bracerightsmall = 65116, e3.bracerighttp = 63740, e3.bracerightvertical = 65080, e3.bracketleft = 91, e3.bracketleftbt = 63728, e3.bracketleftex = 63727, e3.bracketleftmonospace = 65339, e3.bracketlefttp = 63726, e3.bracketright = 93, e3.bracketrightbt = 63739, e3.bracketrightex = 63738, e3.bracketrightmonospace = 65341, e3.bracketrighttp = 63737, e3.breve = 728, e3.brevebelowcmb = 814, e3.brevecmb = 774, e3.breveinvertedbelowcmb = 815, e3.breveinvertedcmb = 785, e3.breveinverteddoublecmb = 865, e3.bridgebelowcmb = 810, e3.bridgeinvertedbelowcmb = 826, e3.brokenbar = 166, e3.bstroke = 384, e3.bsuperior = 63210, e3.btopbar = 387, e3.buhiragana = 12406, e3.bukatakana = 12502, e3.bullet = 8226, e3.bulletinverse = 9688, e3.bulletoperator = 8729, e3.bullseye = 9678, e3.c = 99, e3.caarmenian = 1390, e3.cabengali = 2458, e3.cacute = 263, e3.cadeva = 2330, e3.cagujarati = 2714, e3.cagurmukhi = 2586, e3.calsquare = 13192, e3.candrabindubengali = 2433, e3.candrabinducmb = 784, e3.candrabindudeva = 2305, e3.candrabindugujarati = 2689, e3.capslock = 8682, e3.careof = 8453, e3.caron = 711, e3.caronbelowcmb = 812, e3.caroncmb = 780, e3.carriagereturn = 8629, e3.cbopomofo = 12568, e3.ccaron = 269, e3.ccedilla = 231, e3.ccedillaacute = 7689, e3.ccircle = 9426, e3.ccircumflex = 265, e3.ccurl = 597, e3.cdot = 267, e3.cdotaccent = 267, e3.cdsquare = 13253, e3.cedilla = 184, e3.cedillacmb = 807, e3.cent = 162, e3.centigrade = 8451, e3.centinferior = 63199, e3.centmonospace = 65504, e3.centoldstyle = 63394, e3.centsuperior = 63200, e3.chaarmenian = 1401, e3.chabengali = 2459, e3.chadeva = 2331, e3.chagujarati = 2715, e3.chagurmukhi = 2587, e3.chbopomofo = 12564, e3.cheabkhasiancyrillic = 1213, e3.checkmark = 10003, e3.checyrillic = 1095, e3.chedescenderabkhasiancyrillic = 1215, e3.chedescendercyrillic = 1207, e3.chedieresiscyrillic = 1269, e3.cheharmenian = 1395, e3.chekhakassiancyrillic = 1228, e3.cheverticalstrokecyrillic = 1209, e3.chi = 967, e3.chieuchacirclekorean = 12919, e3.chieuchaparenkorean = 12823, e3.chieuchcirclekorean = 12905, e3.chieuchkorean = 12618, e3.chieuchparenkorean = 12809, e3.chochangthai = 3594, e3.chochanthai = 3592, e3.chochingthai = 3593, e3.chochoethai = 3596, e3.chook = 392, e3.cieucacirclekorean = 12918, e3.cieucaparenkorean = 12822, e3.cieuccirclekorean = 12904, e3.cieuckorean = 12616, e3.cieucparenkorean = 12808, e3.cieucuparenkorean = 12828, e3.circle = 9675, e3.circlecopyrt = 169, e3.circlemultiply = 8855, e3.circleot = 8857, e3.circleplus = 8853, e3.circlepostalmark = 12342, e3.circlewithlefthalfblack = 9680, e3.circlewithrighthalfblack = 9681, e3.circumflex = 710, e3.circumflexbelowcmb = 813, e3.circumflexcmb = 770, e3.clear = 8999, e3.clickalveolar = 450, e3.clickdental = 448, e3.clicklateral = 449, e3.clickretroflex = 451, e3.club = 9827, e3.clubsuitblack = 9827, e3.clubsuitwhite = 9831, e3.cmcubedsquare = 13220, e3.cmonospace = 65347, e3.cmsquaredsquare = 13216, e3.coarmenian = 1409, e3.colon = 58, e3.colonmonetary = 8353, e3.colonmonospace = 65306, e3.colonsign = 8353, e3.colonsmall = 65109, e3.colontriangularhalfmod = 721, e3.colontriangularmod = 720, e3.comma = 44, e3.commaabovecmb = 787, e3.commaaboverightcmb = 789, e3.commaaccent = 63171, e3.commaarabic = 1548, e3.commaarmenian = 1373, e3.commainferior = 63201, e3.commamonospace = 65292, e3.commareversedabovecmb = 788, e3.commareversedmod = 701, e3.commasmall = 65104, e3.commasuperior = 63202, e3.commaturnedabovecmb = 786, e3.commaturnedmod = 699, e3.compass = 9788, e3.congruent = 8773, e3.contourintegral = 8750, e3.control = 8963, e3.controlACK = 6, e3.controlBEL = 7, e3.controlBS = 8, e3.controlCAN = 24, e3.controlCR = 13, e3.controlDC1 = 17, e3.controlDC2 = 18, e3.controlDC3 = 19, e3.controlDC4 = 20, e3.controlDEL = 127, e3.controlDLE = 16, e3.controlEM = 25, e3.controlENQ = 5, e3.controlEOT = 4, e3.controlESC = 27, e3.controlETB = 23, e3.controlETX = 3, e3.controlFF = 12, e3.controlFS = 28, e3.controlGS = 29, e3.controlHT = 9, e3.controlLF = 10, e3.controlNAK = 21, e3.controlNULL = 0, e3.controlRS = 30, e3.controlSI = 15, e3.controlSO = 14, e3.controlSOT = 2, e3.controlSTX = 1, e3.controlSUB = 26, e3.controlSYN = 22, e3.controlUS = 31, e3.controlVT = 11, e3.copyright = 169, e3.copyrightsans = 63721, e3.copyrightserif = 63193, e3.cornerbracketleft = 12300, e3.cornerbracketlefthalfwidth = 65378, e3.cornerbracketleftvertical = 65089, e3.cornerbracketright = 12301, e3.cornerbracketrighthalfwidth = 65379, e3.cornerbracketrightvertical = 65090, e3.corporationsquare = 13183, e3.cosquare = 13255, e3.coverkgsquare = 13254, e3.cparen = 9374, e3.cruzeiro = 8354, e3.cstretched = 663, e3.curlyand = 8911, e3.curlyor = 8910, e3.currency = 164, e3.cyrBreve = 63185, e3.cyrFlex = 63186, e3.cyrbreve = 63188, e3.cyrflex = 63189, e3.d = 100, e3.daarmenian = 1380, e3.dabengali = 2470, e3.dadarabic = 1590, e3.dadeva = 2342, e3.dadfinalarabic = 65214, e3.dadinitialarabic = 65215, e3.dadmedialarabic = 65216, e3.dagesh = 1468, e3.dageshhebrew = 1468, e3.dagger = 8224, e3.daggerdbl = 8225, e3.dagujarati = 2726, e3.dagurmukhi = 2598, e3.dahiragana = 12384, e3.dakatakana = 12480, e3.dalarabic = 1583, e3.dalet = 1491, e3.daletdagesh = 64307, e3.daletdageshhebrew = 64307, e3.dalethebrew = 1491, e3.dalfinalarabic = 65194, e3.dammaarabic = 1615, e3.dammalowarabic = 1615, e3.dammatanaltonearabic = 1612, e3.dammatanarabic = 1612, e3.danda = 2404, e3.dargahebrew = 1447, e3.dargalefthebrew = 1447, e3.dasiapneumatacyrilliccmb = 1157, e3.dblGrave = 63187, e3.dblanglebracketleft = 12298, e3.dblanglebracketleftvertical = 65085, e3.dblanglebracketright = 12299, e3.dblanglebracketrightvertical = 65086, e3.dblarchinvertedbelowcmb = 811, e3.dblarrowleft = 8660, e3.dblarrowright = 8658, e3.dbldanda = 2405, e3.dblgrave = 63190, e3.dblgravecmb = 783, e3.dblintegral = 8748, e3.dbllowline = 8215, e3.dbllowlinecmb = 819, e3.dbloverlinecmb = 831, e3.dblprimemod = 698, e3.dblverticalbar = 8214, e3.dblverticallineabovecmb = 782, e3.dbopomofo = 12553, e3.dbsquare = 13256, e3.dcaron = 271, e3.dcedilla = 7697, e3.dcircle = 9427, e3.dcircumflexbelow = 7699, e3.dcroat = 273, e3.ddabengali = 2465, e3.ddadeva = 2337, e3.ddagujarati = 2721, e3.ddagurmukhi = 2593, e3.ddalarabic = 1672, e3.ddalfinalarabic = 64393, e3.dddhadeva = 2396, e3.ddhabengali = 2466, e3.ddhadeva = 2338, e3.ddhagujarati = 2722, e3.ddhagurmukhi = 2594, e3.ddotaccent = 7691, e3.ddotbelow = 7693, e3.decimalseparatorarabic = 1643, e3.decimalseparatorpersian = 1643, e3.decyrillic = 1076, e3.degree = 176, e3.dehihebrew = 1453, e3.dehiragana = 12391, e3.deicoptic = 1007, e3.dekatakana = 12487, e3.deleteleft = 9003, e3.deleteright = 8998, e3.delta = 948, e3.deltaturned = 397, e3.denominatorminusonenumeratorbengali = 2552, e3.dezh = 676, e3.dhabengali = 2471, e3.dhadeva = 2343, e3.dhagujarati = 2727, e3.dhagurmukhi = 2599, e3.dhook = 599, e3.dialytikatonos = 901, e3.dialytikatonoscmb = 836, e3.diamond = 9830, e3.diamondsuitwhite = 9826, e3.dieresis = 168, e3.dieresisacute = 63191, e3.dieresisbelowcmb = 804, e3.dieresiscmb = 776, e3.dieresisgrave = 63192, e3.dieresistonos = 901, e3.dihiragana = 12386, e3.dikatakana = 12482, e3.dittomark = 12291, e3.divide = 247, e3.divides = 8739, e3.divisionslash = 8725, e3.djecyrillic = 1106, e3.dkshade = 9619, e3.dlinebelow = 7695, e3.dlsquare = 13207, e3.dmacron = 273, e3.dmonospace = 65348, e3.dnblock = 9604, e3.dochadathai = 3598, e3.dodekthai = 3604, e3.dohiragana = 12393, e3.dokatakana = 12489, e3.dollar = 36;
      e3.dollarinferior = 63203, e3.dollarmonospace = 65284, e3.dollaroldstyle = 63268, e3.dollarsmall = 65129, e3.dollarsuperior = 63204, e3.dong = 8363, e3.dorusquare = 13094, e3.dotaccent = 729, e3.dotaccentcmb = 775, e3.dotbelowcmb = 803, e3.dotbelowcomb = 803, e3.dotkatakana = 12539, e3.dotlessi = 305, e3.dotlessj = 63166, e3.dotlessjstrokehook = 644, e3.dotmath = 8901, e3.dottedcircle = 9676, e3.doubleyodpatah = 64287, e3.doubleyodpatahhebrew = 64287, e3.downtackbelowcmb = 798, e3.downtackmod = 725, e3.dparen = 9375, e3.dsuperior = 63211, e3.dtail = 598, e3.dtopbar = 396, e3.duhiragana = 12389, e3.dukatakana = 12485, e3.dz = 499, e3.dzaltone = 675, e3.dzcaron = 454, e3.dzcurl = 677, e3.dzeabkhasiancyrillic = 1249, e3.dzecyrillic = 1109, e3.dzhecyrillic = 1119, e3.e = 101, e3.eacute = 233, e3.earth = 9793, e3.ebengali = 2447, e3.ebopomofo = 12572, e3.ebreve = 277, e3.ecandradeva = 2317, e3.ecandragujarati = 2701, e3.ecandravowelsigndeva = 2373, e3.ecandravowelsigngujarati = 2757, e3.ecaron = 283, e3.ecedillabreve = 7709, e3.echarmenian = 1381, e3.echyiwnarmenian = 1415, e3.ecircle = 9428, e3.ecircumflex = 234, e3.ecircumflexacute = 7871, e3.ecircumflexbelow = 7705, e3.ecircumflexdotbelow = 7879, e3.ecircumflexgrave = 7873, e3.ecircumflexhookabove = 7875, e3.ecircumflextilde = 7877, e3.ecyrillic = 1108, e3.edblgrave = 517, e3.edeva = 2319, e3.edieresis = 235, e3.edot = 279, e3.edotaccent = 279, e3.edotbelow = 7865, e3.eegurmukhi = 2575, e3.eematragurmukhi = 2631, e3.efcyrillic = 1092, e3.egrave = 232, e3.egujarati = 2703, e3.eharmenian = 1383, e3.ehbopomofo = 12573, e3.ehiragana = 12360, e3.ehookabove = 7867, e3.eibopomofo = 12575, e3.eight = 56, e3.eightarabic = 1640, e3.eightbengali = 2542, e3.eightcircle = 9319, e3.eightcircleinversesansserif = 10129, e3.eightdeva = 2414, e3.eighteencircle = 9329, e3.eighteenparen = 9349, e3.eighteenperiod = 9369, e3.eightgujarati = 2798, e3.eightgurmukhi = 2670, e3.eighthackarabic = 1640, e3.eighthangzhou = 12328, e3.eighthnotebeamed = 9835, e3.eightideographicparen = 12839, e3.eightinferior = 8328, e3.eightmonospace = 65304, e3.eightoldstyle = 63288, e3.eightparen = 9339, e3.eightperiod = 9359, e3.eightpersian = 1784, e3.eightroman = 8567, e3.eightsuperior = 8312, e3.eightthai = 3672, e3.einvertedbreve = 519, e3.eiotifiedcyrillic = 1125, e3.ekatakana = 12456, e3.ekatakanahalfwidth = 65396, e3.ekonkargurmukhi = 2676, e3.ekorean = 12628, e3.elcyrillic = 1083, e3.element = 8712, e3.elevencircle = 9322, e3.elevenparen = 9342, e3.elevenperiod = 9362, e3.elevenroman = 8570, e3.ellipsis = 8230, e3.ellipsisvertical = 8942, e3.emacron = 275, e3.emacronacute = 7703, e3.emacrongrave = 7701, e3.emcyrillic = 1084, e3.emdash = 8212, e3.emdashvertical = 65073, e3.emonospace = 65349, e3.emphasismarkarmenian = 1371, e3.emptyset = 8709, e3.enbopomofo = 12579, e3.encyrillic = 1085, e3.endash = 8211, e3.endashvertical = 65074, e3.endescendercyrillic = 1187, e3.eng = 331, e3.engbopomofo = 12581, e3.enghecyrillic = 1189, e3.enhookcyrillic = 1224, e3.enspace = 8194, e3.eogonek = 281, e3.eokorean = 12627, e3.eopen = 603, e3.eopenclosed = 666, e3.eopenreversed = 604, e3.eopenreversedclosed = 606, e3.eopenreversedhook = 605, e3.eparen = 9376, e3.epsilon = 949, e3.epsilontonos = 941, e3.equal = 61, e3.equalmonospace = 65309, e3.equalsmall = 65126, e3.equalsuperior = 8316, e3.equivalence = 8801, e3.erbopomofo = 12582, e3.ercyrillic = 1088, e3.ereversed = 600, e3.ereversedcyrillic = 1101, e3.escyrillic = 1089, e3.esdescendercyrillic = 1195, e3.esh = 643, e3.eshcurl = 646, e3.eshortdeva = 2318, e3.eshortvowelsigndeva = 2374, e3.eshreversedloop = 426, e3.eshsquatreversed = 645, e3.esmallhiragana = 12359, e3.esmallkatakana = 12455, e3.esmallkatakanahalfwidth = 65386, e3.estimated = 8494, e3.esuperior = 63212, e3.eta = 951, e3.etarmenian = 1384, e3.etatonos = 942, e3.eth = 240, e3.etilde = 7869, e3.etildebelow = 7707, e3.etnahtafoukhhebrew = 1425, e3.etnahtafoukhlefthebrew = 1425, e3.etnahtahebrew = 1425, e3.etnahtalefthebrew = 1425, e3.eturned = 477, e3.eukorean = 12641, e3.euro = 8364, e3.evowelsignbengali = 2503, e3.evowelsigndeva = 2375, e3.evowelsigngujarati = 2759, e3.exclam = 33, e3.exclamarmenian = 1372, e3.exclamdbl = 8252, e3.exclamdown = 161, e3.exclamdownsmall = 63393, e3.exclammonospace = 65281, e3.exclamsmall = 63265, e3.existential = 8707, e3.ezh = 658, e3.ezhcaron = 495, e3.ezhcurl = 659, e3.ezhreversed = 441, e3.ezhtail = 442, e3.f = 102, e3.fadeva = 2398, e3.fagurmukhi = 2654, e3.fahrenheit = 8457, e3.fathaarabic = 1614, e3.fathalowarabic = 1614, e3.fathatanarabic = 1611, e3.fbopomofo = 12552, e3.fcircle = 9429, e3.fdotaccent = 7711, e3.feharabic = 1601, e3.feharmenian = 1414, e3.fehfinalarabic = 65234, e3.fehinitialarabic = 65235, e3.fehmedialarabic = 65236, e3.feicoptic = 997, e3.female = 9792, e3.ff = 64256, e3.f_f = 64256, e3.ffi = 64259, e3.f_f_i = 64259, e3.ffl = 64260, e3.f_f_l = 64260, e3.fi = 64257, e3.f_i = 64257, e3.fifteencircle = 9326, e3.fifteenparen = 9346, e3.fifteenperiod = 9366, e3.figuredash = 8210, e3.filledbox = 9632, e3.filledrect = 9644, e3.finalkaf = 1498, e3.finalkafdagesh = 64314, e3.finalkafdageshhebrew = 64314, e3.finalkafhebrew = 1498, e3.finalmem = 1501, e3.finalmemhebrew = 1501, e3.finalnun = 1503, e3.finalnunhebrew = 1503, e3.finalpe = 1507, e3.finalpehebrew = 1507, e3.finaltsadi = 1509, e3.finaltsadihebrew = 1509, e3.firsttonechinese = 713, e3.fisheye = 9673, e3.fitacyrillic = 1139, e3.five = 53, e3.fivearabic = 1637, e3.fivebengali = 2539, e3.fivecircle = 9316, e3.fivecircleinversesansserif = 10126, e3.fivedeva = 2411, e3.fiveeighths = 8541, e3.fivegujarati = 2795, e3.fivegurmukhi = 2667, e3.fivehackarabic = 1637, e3.fivehangzhou = 12325, e3.fiveideographicparen = 12836, e3.fiveinferior = 8325, e3.fivemonospace = 65301, e3.fiveoldstyle = 63285, e3.fiveparen = 9336, e3.fiveperiod = 9356, e3.fivepersian = 1781, e3.fiveroman = 8564, e3.fivesuperior = 8309, e3.fivethai = 3669, e3.fl = 64258, e3.f_l = 64258, e3.florin = 402, e3.fmonospace = 65350, e3.fmsquare = 13209, e3.fofanthai = 3615, e3.fofathai = 3613, e3.fongmanthai = 3663, e3.forall = 8704, e3.four = 52, e3.fourarabic = 1636, e3.fourbengali = 2538, e3.fourcircle = 9315, e3.fourcircleinversesansserif = 10125, e3.fourdeva = 2410, e3.fourgujarati = 2794, e3.fourgurmukhi = 2666, e3.fourhackarabic = 1636, e3.fourhangzhou = 12324, e3.fourideographicparen = 12835, e3.fourinferior = 8324, e3.fourmonospace = 65300, e3.fournumeratorbengali = 2551, e3.fouroldstyle = 63284, e3.fourparen = 9335, e3.fourperiod = 9355, e3.fourpersian = 1780, e3.fourroman = 8563, e3.foursuperior = 8308, e3.fourteencircle = 9325, e3.fourteenparen = 9345, e3.fourteenperiod = 9365, e3.fourthai = 3668, e3.fourthtonechinese = 715, e3.fparen = 9377, e3.fraction = 8260, e3.franc = 8355, e3.g = 103, e3.gabengali = 2455, e3.gacute = 501, e3.gadeva = 2327, e3.gafarabic = 1711, e3.gaffinalarabic = 64403, e3.gafinitialarabic = 64404, e3.gafmedialarabic = 64405, e3.gagujarati = 2711, e3.gagurmukhi = 2583, e3.gahiragana = 12364, e3.gakatakana = 12460, e3.gamma = 947, e3.gammalatinsmall = 611, e3.gammasuperior = 736, e3.gangiacoptic = 1003, e3.gbopomofo = 12557, e3.gbreve = 287, e3.gcaron = 487, e3.gcedilla = 291, e3.gcircle = 9430, e3.gcircumflex = 285, e3.gcommaaccent = 291, e3.gdot = 289, e3.gdotaccent = 289, e3.gecyrillic = 1075, e3.gehiragana = 12370, e3.gekatakana = 12466, e3.geometricallyequal = 8785, e3.gereshaccenthebrew = 1436, e3.gereshhebrew = 1523, e3.gereshmuqdamhebrew = 1437, e3.germandbls = 223, e3.gershayimaccenthebrew = 1438, e3.gershayimhebrew = 1524, e3.getamark = 12307, e3.ghabengali = 2456, e3.ghadarmenian = 1394, e3.ghadeva = 2328, e3.ghagujarati = 2712, e3.ghagurmukhi = 2584, e3.ghainarabic = 1594, e3.ghainfinalarabic = 65230, e3.ghaininitialarabic = 65231, e3.ghainmedialarabic = 65232, e3.ghemiddlehookcyrillic = 1173, e3.ghestrokecyrillic = 1171, e3.gheupturncyrillic = 1169, e3.ghhadeva = 2394, e3.ghhagurmukhi = 2650, e3.ghook = 608, e3.ghzsquare = 13203, e3.gihiragana = 12366, e3.gikatakana = 12462, e3.gimarmenian = 1379, e3.gimel = 1490, e3.gimeldagesh = 64306, e3.gimeldageshhebrew = 64306, e3.gimelhebrew = 1490, e3.gjecyrillic = 1107, e3.glottalinvertedstroke = 446, e3.glottalstop = 660, e3.glottalstopinverted = 662, e3.glottalstopmod = 704, e3.glottalstopreversed = 661, e3.glottalstopreversedmod = 705, e3.glottalstopreversedsuperior = 740, e3.glottalstopstroke = 673, e3.glottalstopstrokereversed = 674, e3.gmacron = 7713, e3.gmonospace = 65351, e3.gohiragana = 12372, e3.gokatakana = 12468, e3.gparen = 9378, e3.gpasquare = 13228, e3.gradient = 8711, e3.grave = 96, e3.gravebelowcmb = 790, e3.gravecmb = 768, e3.gravecomb = 768, e3.gravedeva = 2387, e3.gravelowmod = 718, e3.gravemonospace = 65344, e3.gravetonecmb = 832, e3.greater = 62, e3.greaterequal = 8805, e3.greaterequalorless = 8923, e3.greatermonospace = 65310, e3.greaterorequivalent = 8819, e3.greaterorless = 8823, e3.greateroverequal = 8807, e3.greatersmall = 65125, e3.gscript = 609, e3.gstroke = 485, e3.guhiragana = 12368, e3.guillemotleft = 171, e3.guillemotright = 187, e3.guilsinglleft = 8249, e3.guilsinglright = 8250, e3.gukatakana = 12464, e3.guramusquare = 13080, e3.gysquare = 13257, e3.h = 104, e3.haabkhasiancyrillic = 1193, e3.haaltonearabic = 1729, e3.habengali = 2489, e3.hadescendercyrillic = 1203, e3.hadeva = 2361, e3.hagujarati = 2745, e3.hagurmukhi = 2617, e3.haharabic = 1581, e3.hahfinalarabic = 65186, e3.hahinitialarabic = 65187, e3.hahiragana = 12399, e3.hahmedialarabic = 65188, e3.haitusquare = 13098, e3.hakatakana = 12495, e3.hakatakanahalfwidth = 65418, e3.halantgurmukhi = 2637, e3.hamzaarabic = 1569, e3.hamzalowarabic = 1569, e3.hangulfiller = 12644, e3.hardsigncyrillic = 1098, e3.harpoonleftbarbup = 8636, e3.harpoonrightbarbup = 8640, e3.hasquare = 13258, e3.hatafpatah = 1458, e3.hatafpatah16 = 1458, e3.hatafpatah23 = 1458, e3.hatafpatah2f = 1458, e3.hatafpatahhebrew = 1458, e3.hatafpatahnarrowhebrew = 1458, e3.hatafpatahquarterhebrew = 1458, e3.hatafpatahwidehebrew = 1458, e3.hatafqamats = 1459, e3.hatafqamats1b = 1459, e3.hatafqamats28 = 1459, e3.hatafqamats34 = 1459, e3.hatafqamatshebrew = 1459, e3.hatafqamatsnarrowhebrew = 1459, e3.hatafqamatsquarterhebrew = 1459, e3.hatafqamatswidehebrew = 1459, e3.hatafsegol = 1457, e3.hatafsegol17 = 1457, e3.hatafsegol24 = 1457, e3.hatafsegol30 = 1457, e3.hatafsegolhebrew = 1457, e3.hatafsegolnarrowhebrew = 1457, e3.hatafsegolquarterhebrew = 1457, e3.hatafsegolwidehebrew = 1457, e3.hbar = 295, e3.hbopomofo = 12559, e3.hbrevebelow = 7723, e3.hcedilla = 7721, e3.hcircle = 9431, e3.hcircumflex = 293, e3.hdieresis = 7719, e3.hdotaccent = 7715, e3.hdotbelow = 7717, e3.he = 1492, e3.heart = 9829, e3.heartsuitblack = 9829, e3.heartsuitwhite = 9825, e3.hedagesh = 64308, e3.hedageshhebrew = 64308, e3.hehaltonearabic = 1729, e3.heharabic = 1607, e3.hehebrew = 1492, e3.hehfinalaltonearabic = 64423, e3.hehfinalalttwoarabic = 65258, e3.hehfinalarabic = 65258, e3.hehhamzaabovefinalarabic = 64421, e3.hehhamzaaboveisolatedarabic = 64420, e3.hehinitialaltonearabic = 64424, e3.hehinitialarabic = 65259, e3.hehiragana = 12408, e3.hehmedialaltonearabic = 64425, e3.hehmedialarabic = 65260, e3.heiseierasquare = 13179, e3.hekatakana = 12504, e3.hekatakanahalfwidth = 65421, e3.hekutaarusquare = 13110, e3.henghook = 615, e3.herutusquare = 13113, e3.het = 1495, e3.hethebrew = 1495, e3.hhook = 614, e3.hhooksuperior = 689, e3.hieuhacirclekorean = 12923, e3.hieuhaparenkorean = 12827, e3.hieuhcirclekorean = 12909, e3.hieuhkorean = 12622, e3.hieuhparenkorean = 12813, e3.hihiragana = 12402, e3.hikatakana = 12498, e3.hikatakanahalfwidth = 65419, e3.hiriq = 1460, e3.hiriq14 = 1460, e3.hiriq21 = 1460, e3.hiriq2d = 1460, e3.hiriqhebrew = 1460, e3.hiriqnarrowhebrew = 1460, e3.hiriqquarterhebrew = 1460, e3.hiriqwidehebrew = 1460, e3.hlinebelow = 7830, e3.hmonospace = 65352, e3.hoarmenian = 1392, e3.hohipthai = 3627, e3.hohiragana = 12411, e3.hokatakana = 12507, e3.hokatakanahalfwidth = 65422, e3.holam = 1465, e3.holam19 = 1465, e3.holam26 = 1465, e3.holam32 = 1465, e3.holamhebrew = 1465, e3.holamnarrowhebrew = 1465, e3.holamquarterhebrew = 1465, e3.holamwidehebrew = 1465, e3.honokhukthai = 3630, e3.hookabovecomb = 777, e3.hookcmb = 777, e3.hookpalatalizedbelowcmb = 801, e3.hookretroflexbelowcmb = 802, e3.hoonsquare = 13122, e3.horicoptic = 1001, e3.horizontalbar = 8213, e3.horncmb = 795, e3.hotsprings = 9832, e3.house = 8962, e3.hparen = 9379, e3.hsuperior = 688, e3.hturned = 613, e3.huhiragana = 12405, e3.huiitosquare = 13107, e3.hukatakana = 12501, e3.hukatakanahalfwidth = 65420, e3.hungarumlaut = 733, e3.hungarumlautcmb = 779, e3.hv = 405, e3.hyphen = 45, e3.hypheninferior = 63205, e3.hyphenmonospace = 65293, e3.hyphensmall = 65123, e3.hyphensuperior = 63206, e3.hyphentwo = 8208, e3.i = 105, e3.iacute = 237, e3.iacyrillic = 1103, e3.ibengali = 2439, e3.ibopomofo = 12583, e3.ibreve = 301, e3.icaron = 464, e3.icircle = 9432, e3.icircumflex = 238, e3.icyrillic = 1110, e3.idblgrave = 521, e3.ideographearthcircle = 12943, e3.ideographfirecircle = 12939, e3.ideographicallianceparen = 12863, e3.ideographiccallparen = 12858, e3.ideographiccentrecircle = 12965, e3.ideographicclose = 12294, e3.ideographiccomma = 12289, e3.ideographiccommaleft = 65380, e3.ideographiccongratulationparen = 12855, e3.ideographiccorrectcircle = 12963, e3.ideographicearthparen = 12847, e3.ideographicenterpriseparen = 12861, e3.ideographicexcellentcircle = 12957, e3.ideographicfestivalparen = 12864, e3.ideographicfinancialcircle = 12950, e3.ideographicfinancialparen = 12854, e3.ideographicfireparen = 12843, e3.ideographichaveparen = 12850, e3.ideographichighcircle = 12964, e3.ideographiciterationmark = 12293, e3.ideographiclaborcircle = 12952, e3.ideographiclaborparen = 12856, e3.ideographicleftcircle = 12967, e3.ideographiclowcircle = 12966, e3.ideographicmedicinecircle = 12969, e3.ideographicmetalparen = 12846, e3.ideographicmoonparen = 12842, e3.ideographicnameparen = 12852, e3.ideographicperiod = 12290, e3.ideographicprintcircle = 12958, e3.ideographicreachparen = 12867, e3.ideographicrepresentparen = 12857, e3.ideographicresourceparen = 12862, e3.ideographicrightcircle = 12968, e3.ideographicsecretcircle = 12953, e3.ideographicselfparen = 12866, e3.ideographicsocietyparen = 12851, e3.ideographicspace = 12288, e3.ideographicspecialparen = 12853, e3.ideographicstockparen = 12849, e3.ideographicstudyparen = 12859, e3.ideographicsunparen = 12848, e3.ideographicsuperviseparen = 12860, e3.ideographicwaterparen = 12844, e3.ideographicwoodparen = 12845, e3.ideographiczero = 12295, e3.ideographmetalcircle = 12942, e3.ideographmooncircle = 12938, e3.ideographnamecircle = 12948, e3.ideographsuncircle = 12944, e3.ideographwatercircle = 12940, e3.ideographwoodcircle = 12941, e3.ideva = 2311, e3.idieresis = 239, e3.idieresisacute = 7727, e3.idieresiscyrillic = 1253, e3.idotbelow = 7883, e3.iebrevecyrillic = 1239, e3.iecyrillic = 1077, e3.ieungacirclekorean = 12917, e3.ieungaparenkorean = 12821, e3.ieungcirclekorean = 12903, e3.ieungkorean = 12615, e3.ieungparenkorean = 12807, e3.igrave = 236, e3.igujarati = 2695, e3.igurmukhi = 2567, e3.ihiragana = 12356, e3.ihookabove = 7881, e3.iibengali = 2440, e3.iicyrillic = 1080, e3.iideva = 2312, e3.iigujarati = 2696, e3.iigurmukhi = 2568, e3.iimatragurmukhi = 2624, e3.iinvertedbreve = 523, e3.iishortcyrillic = 1081, e3.iivowelsignbengali = 2496, e3.iivowelsigndeva = 2368, e3.iivowelsigngujarati = 2752, e3.ij = 307, e3.ikatakana = 12452, e3.ikatakanahalfwidth = 65394, e3.ikorean = 12643, e3.ilde = 732, e3.iluyhebrew = 1452, e3.imacron = 299, e3.imacroncyrillic = 1251, e3.imageorapproximatelyequal = 8787, e3.imatragurmukhi = 2623, e3.imonospace = 65353, e3.increment = 8710, e3.infinity = 8734, e3.iniarmenian = 1387, e3.integral = 8747, e3.integralbottom = 8993, e3.integralbt = 8993, e3.integralex = 63733, e3.integraltop = 8992, e3.integraltp = 8992, e3.intersection = 8745, e3.intisquare = 13061, e3.invbullet = 9688, e3.invcircle = 9689, e3.invsmileface = 9787, e3.iocyrillic = 1105, e3.iogonek = 303, e3.iota = 953, e3.iotadieresis = 970, e3.iotadieresistonos = 912, e3.iotalatin = 617, e3.iotatonos = 943, e3.iparen = 9380, e3.irigurmukhi = 2674, e3.ismallhiragana = 12355, e3.ismallkatakana = 12451, e3.ismallkatakanahalfwidth = 65384, e3.issharbengali = 2554, e3.istroke = 616, e3.isuperior = 63213, e3.iterationhiragana = 12445, e3.iterationkatakana = 12541, e3.itilde = 297, e3.itildebelow = 7725, e3.iubopomofo = 12585, e3.iucyrillic = 1102, e3.ivowelsignbengali = 2495, e3.ivowelsigndeva = 2367, e3.ivowelsigngujarati = 2751, e3.izhitsacyrillic = 1141, e3.izhitsadblgravecyrillic = 1143, e3.j = 106, e3.jaarmenian = 1393, e3.jabengali = 2460, e3.jadeva = 2332, e3.jagujarati = 2716, e3.jagurmukhi = 2588, e3.jbopomofo = 12560, e3.jcaron = 496, e3.jcircle = 9433, e3.jcircumflex = 309, e3.jcrossedtail = 669, e3.jdotlessstroke = 607, e3.jecyrillic = 1112, e3.jeemarabic = 1580, e3.jeemfinalarabic = 65182, e3.jeeminitialarabic = 65183, e3.jeemmedialarabic = 65184, e3.jeharabic = 1688, e3.jehfinalarabic = 64395, e3.jhabengali = 2461, e3.jhadeva = 2333, e3.jhagujarati = 2717, e3.jhagurmukhi = 2589, e3.jheharmenian = 1403, e3.jis = 12292, e3.jmonospace = 65354, e3.jparen = 9381, e3.jsuperior = 690, e3.k = 107, e3.kabashkircyrillic = 1185, e3.kabengali = 2453, e3.kacute = 7729, e3.kacyrillic = 1082, e3.kadescendercyrillic = 1179, e3.kadeva = 2325, e3.kaf = 1499, e3.kafarabic = 1603, e3.kafdagesh = 64315, e3.kafdageshhebrew = 64315, e3.kaffinalarabic = 65242, e3.kafhebrew = 1499, e3.kafinitialarabic = 65243, e3.kafmedialarabic = 65244, e3.kafrafehebrew = 64333, e3.kagujarati = 2709, e3.kagurmukhi = 2581, e3.kahiragana = 12363, e3.kahookcyrillic = 1220, e3.kakatakana = 12459, e3.kakatakanahalfwidth = 65398, e3.kappa = 954, e3.kappasymbolgreek = 1008, e3.kapyeounmieumkorean = 12657, e3.kapyeounphieuphkorean = 12676, e3.kapyeounpieupkorean = 12664, e3.kapyeounssangpieupkorean = 12665, e3.karoriisquare = 13069, e3.kashidaautoarabic = 1600, e3.kashidaautonosidebearingarabic = 1600, e3.kasmallkatakana = 12533, e3.kasquare = 13188, e3.kasraarabic = 1616, e3.kasratanarabic = 1613, e3.kastrokecyrillic = 1183, e3.katahiraprolongmarkhalfwidth = 65392, e3.kaverticalstrokecyrillic = 1181, e3.kbopomofo = 12558, e3.kcalsquare = 13193, e3.kcaron = 489, e3.kcedilla = 311, e3.kcircle = 9434, e3.kcommaaccent = 311, e3.kdotbelow = 7731, e3.keharmenian = 1412, e3.kehiragana = 12369, e3.kekatakana = 12465, e3.kekatakanahalfwidth = 65401, e3.kenarmenian = 1391, e3.kesmallkatakana = 12534, e3.kgreenlandic = 312, e3.khabengali = 2454, e3.khacyrillic = 1093, e3.khadeva = 2326, e3.khagujarati = 2710, e3.khagurmukhi = 2582, e3.khaharabic = 1582, e3.khahfinalarabic = 65190, e3.khahinitialarabic = 65191, e3.khahmedialarabic = 65192, e3.kheicoptic = 999, e3.khhadeva = 2393, e3.khhagurmukhi = 2649, e3.khieukhacirclekorean = 12920, e3.khieukhaparenkorean = 12824, e3.khieukhcirclekorean = 12906, e3.khieukhkorean = 12619, e3.khieukhparenkorean = 12810, e3.khokhaithai = 3586, e3.khokhonthai = 3589, e3.khokhuatthai = 3587, e3.khokhwaithai = 3588, e3.khomutthai = 3675, e3.khook = 409, e3.khorakhangthai = 3590, e3.khzsquare = 13201, e3.kihiragana = 12365, e3.kikatakana = 12461, e3.kikatakanahalfwidth = 65399, e3.kiroguramusquare = 13077, e3.kiromeetorusquare = 13078, e3.kirosquare = 13076, e3.kiyeokacirclekorean = 12910, e3.kiyeokaparenkorean = 12814, e3.kiyeokcirclekorean = 12896, e3.kiyeokkorean = 12593, e3.kiyeokparenkorean = 12800, e3.kiyeoksioskorean = 12595;
      e3.kjecyrillic = 1116, e3.klinebelow = 7733, e3.klsquare = 13208, e3.kmcubedsquare = 13222, e3.kmonospace = 65355, e3.kmsquaredsquare = 13218, e3.kohiragana = 12371, e3.kohmsquare = 13248, e3.kokaithai = 3585, e3.kokatakana = 12467, e3.kokatakanahalfwidth = 65402, e3.kooposquare = 13086, e3.koppacyrillic = 1153, e3.koreanstandardsymbol = 12927, e3.koroniscmb = 835, e3.kparen = 9382, e3.kpasquare = 13226, e3.ksicyrillic = 1135, e3.ktsquare = 13263, e3.kturned = 670, e3.kuhiragana = 12367, e3.kukatakana = 12463, e3.kukatakanahalfwidth = 65400, e3.kvsquare = 13240, e3.kwsquare = 13246, e3.l = 108, e3.labengali = 2482, e3.lacute = 314, e3.ladeva = 2354, e3.lagujarati = 2738, e3.lagurmukhi = 2610, e3.lakkhangyaothai = 3653, e3.lamaleffinalarabic = 65276, e3.lamalefhamzaabovefinalarabic = 65272, e3.lamalefhamzaaboveisolatedarabic = 65271, e3.lamalefhamzabelowfinalarabic = 65274, e3.lamalefhamzabelowisolatedarabic = 65273, e3.lamalefisolatedarabic = 65275, e3.lamalefmaddaabovefinalarabic = 65270, e3.lamalefmaddaaboveisolatedarabic = 65269, e3.lamarabic = 1604, e3.lambda = 955, e3.lambdastroke = 411, e3.lamed = 1500, e3.lameddagesh = 64316, e3.lameddageshhebrew = 64316, e3.lamedhebrew = 1500, e3.lamfinalarabic = 65246, e3.lamhahinitialarabic = 64714, e3.laminitialarabic = 65247, e3.lamjeeminitialarabic = 64713, e3.lamkhahinitialarabic = 64715, e3.lamlamhehisolatedarabic = 65010, e3.lammedialarabic = 65248, e3.lammeemhahinitialarabic = 64904, e3.lammeeminitialarabic = 64716, e3.largecircle = 9711, e3.lbar = 410, e3.lbelt = 620, e3.lbopomofo = 12556, e3.lcaron = 318, e3.lcedilla = 316, e3.lcircle = 9435, e3.lcircumflexbelow = 7741, e3.lcommaaccent = 316, e3.ldot = 320, e3.ldotaccent = 320, e3.ldotbelow = 7735, e3.ldotbelowmacron = 7737, e3.leftangleabovecmb = 794, e3.lefttackbelowcmb = 792, e3.less = 60, e3.lessequal = 8804, e3.lessequalorgreater = 8922, e3.lessmonospace = 65308, e3.lessorequivalent = 8818, e3.lessorgreater = 8822, e3.lessoverequal = 8806, e3.lesssmall = 65124, e3.lezh = 622, e3.lfblock = 9612, e3.lhookretroflex = 621, e3.lira = 8356, e3.liwnarmenian = 1388, e3.lj = 457, e3.ljecyrillic = 1113, e3.ll = 63168, e3.lladeva = 2355, e3.llagujarati = 2739, e3.llinebelow = 7739, e3.llladeva = 2356, e3.llvocalicbengali = 2529, e3.llvocalicdeva = 2401, e3.llvocalicvowelsignbengali = 2531, e3.llvocalicvowelsigndeva = 2403, e3.lmiddletilde = 619, e3.lmonospace = 65356, e3.lmsquare = 13264, e3.lochulathai = 3628, e3.logicaland = 8743, e3.logicalnot = 172, e3.logicalnotreversed = 8976, e3.logicalor = 8744, e3.lolingthai = 3621, e3.longs = 383, e3.lowlinecenterline = 65102, e3.lowlinecmb = 818, e3.lowlinedashed = 65101, e3.lozenge = 9674, e3.lparen = 9383, e3.lslash = 322, e3.lsquare = 8467, e3.lsuperior = 63214, e3.ltshade = 9617, e3.luthai = 3622, e3.lvocalicbengali = 2444, e3.lvocalicdeva = 2316, e3.lvocalicvowelsignbengali = 2530, e3.lvocalicvowelsigndeva = 2402, e3.lxsquare = 13267, e3.m = 109, e3.mabengali = 2478, e3.macron = 175, e3.macronbelowcmb = 817, e3.macroncmb = 772, e3.macronlowmod = 717, e3.macronmonospace = 65507, e3.macute = 7743, e3.madeva = 2350, e3.magujarati = 2734, e3.magurmukhi = 2606, e3.mahapakhhebrew = 1444, e3.mahapakhlefthebrew = 1444, e3.mahiragana = 12414, e3.maichattawalowleftthai = 63637, e3.maichattawalowrightthai = 63636, e3.maichattawathai = 3659, e3.maichattawaupperleftthai = 63635, e3.maieklowleftthai = 63628, e3.maieklowrightthai = 63627, e3.maiekthai = 3656, e3.maiekupperleftthai = 63626, e3.maihanakatleftthai = 63620, e3.maihanakatthai = 3633, e3.maitaikhuleftthai = 63625, e3.maitaikhuthai = 3655, e3.maitholowleftthai = 63631, e3.maitholowrightthai = 63630, e3.maithothai = 3657, e3.maithoupperleftthai = 63629, e3.maitrilowleftthai = 63634, e3.maitrilowrightthai = 63633, e3.maitrithai = 3658, e3.maitriupperleftthai = 63632, e3.maiyamokthai = 3654, e3.makatakana = 12510, e3.makatakanahalfwidth = 65423, e3.male = 9794, e3.mansyonsquare = 13127, e3.maqafhebrew = 1470, e3.mars = 9794, e3.masoracirclehebrew = 1455, e3.masquare = 13187, e3.mbopomofo = 12551, e3.mbsquare = 13268, e3.mcircle = 9436, e3.mcubedsquare = 13221, e3.mdotaccent = 7745, e3.mdotbelow = 7747, e3.meemarabic = 1605, e3.meemfinalarabic = 65250, e3.meeminitialarabic = 65251, e3.meemmedialarabic = 65252, e3.meemmeeminitialarabic = 64721, e3.meemmeemisolatedarabic = 64584, e3.meetorusquare = 13133, e3.mehiragana = 12417, e3.meizierasquare = 13182, e3.mekatakana = 12513, e3.mekatakanahalfwidth = 65426, e3.mem = 1502, e3.memdagesh = 64318, e3.memdageshhebrew = 64318, e3.memhebrew = 1502, e3.menarmenian = 1396, e3.merkhahebrew = 1445, e3.merkhakefulahebrew = 1446, e3.merkhakefulalefthebrew = 1446, e3.merkhalefthebrew = 1445, e3.mhook = 625, e3.mhzsquare = 13202, e3.middledotkatakanahalfwidth = 65381, e3.middot = 183, e3.mieumacirclekorean = 12914, e3.mieumaparenkorean = 12818, e3.mieumcirclekorean = 12900, e3.mieumkorean = 12609, e3.mieumpansioskorean = 12656, e3.mieumparenkorean = 12804, e3.mieumpieupkorean = 12654, e3.mieumsioskorean = 12655, e3.mihiragana = 12415, e3.mikatakana = 12511, e3.mikatakanahalfwidth = 65424, e3.minus = 8722, e3.minusbelowcmb = 800, e3.minuscircle = 8854, e3.minusmod = 727, e3.minusplus = 8723, e3.minute = 8242, e3.miribaarusquare = 13130, e3.mirisquare = 13129, e3.mlonglegturned = 624, e3.mlsquare = 13206, e3.mmcubedsquare = 13219, e3.mmonospace = 65357, e3.mmsquaredsquare = 13215, e3.mohiragana = 12418, e3.mohmsquare = 13249, e3.mokatakana = 12514, e3.mokatakanahalfwidth = 65427, e3.molsquare = 13270, e3.momathai = 3617, e3.moverssquare = 13223, e3.moverssquaredsquare = 13224, e3.mparen = 9384, e3.mpasquare = 13227, e3.mssquare = 13235, e3.msuperior = 63215, e3.mturned = 623, e3.mu = 181, e3.mu1 = 181, e3.muasquare = 13186, e3.muchgreater = 8811, e3.muchless = 8810, e3.mufsquare = 13196, e3.mugreek = 956, e3.mugsquare = 13197, e3.muhiragana = 12416, e3.mukatakana = 12512, e3.mukatakanahalfwidth = 65425, e3.mulsquare = 13205, e3.multiply = 215, e3.mumsquare = 13211, e3.munahhebrew = 1443, e3.munahlefthebrew = 1443, e3.musicalnote = 9834, e3.musicalnotedbl = 9835, e3.musicflatsign = 9837, e3.musicsharpsign = 9839, e3.mussquare = 13234, e3.muvsquare = 13238, e3.muwsquare = 13244, e3.mvmegasquare = 13241, e3.mvsquare = 13239, e3.mwmegasquare = 13247, e3.mwsquare = 13245, e3.n = 110, e3.nabengali = 2472, e3.nabla = 8711, e3.nacute = 324, e3.nadeva = 2344, e3.nagujarati = 2728, e3.nagurmukhi = 2600, e3.nahiragana = 12394, e3.nakatakana = 12490, e3.nakatakanahalfwidth = 65413, e3.napostrophe = 329, e3.nasquare = 13185, e3.nbopomofo = 12555, e3.nbspace = 160, e3.ncaron = 328, e3.ncedilla = 326, e3.ncircle = 9437, e3.ncircumflexbelow = 7755, e3.ncommaaccent = 326, e3.ndotaccent = 7749, e3.ndotbelow = 7751, e3.nehiragana = 12397, e3.nekatakana = 12493, e3.nekatakanahalfwidth = 65416, e3.newsheqelsign = 8362, e3.nfsquare = 13195, e3.ngabengali = 2457, e3.ngadeva = 2329, e3.ngagujarati = 2713, e3.ngagurmukhi = 2585, e3.ngonguthai = 3591, e3.nhiragana = 12435, e3.nhookleft = 626, e3.nhookretroflex = 627, e3.nieunacirclekorean = 12911, e3.nieunaparenkorean = 12815, e3.nieuncieuckorean = 12597, e3.nieuncirclekorean = 12897, e3.nieunhieuhkorean = 12598, e3.nieunkorean = 12596, e3.nieunpansioskorean = 12648, e3.nieunparenkorean = 12801, e3.nieunsioskorean = 12647, e3.nieuntikeutkorean = 12646, e3.nihiragana = 12395, e3.nikatakana = 12491, e3.nikatakanahalfwidth = 65414, e3.nikhahitleftthai = 63641, e3.nikhahitthai = 3661, e3.nine = 57, e3.ninearabic = 1641, e3.ninebengali = 2543, e3.ninecircle = 9320, e3.ninecircleinversesansserif = 10130, e3.ninedeva = 2415, e3.ninegujarati = 2799, e3.ninegurmukhi = 2671, e3.ninehackarabic = 1641, e3.ninehangzhou = 12329, e3.nineideographicparen = 12840, e3.nineinferior = 8329, e3.ninemonospace = 65305, e3.nineoldstyle = 63289, e3.nineparen = 9340, e3.nineperiod = 9360, e3.ninepersian = 1785, e3.nineroman = 8568, e3.ninesuperior = 8313, e3.nineteencircle = 9330, e3.nineteenparen = 9350, e3.nineteenperiod = 9370, e3.ninethai = 3673, e3.nj = 460, e3.njecyrillic = 1114, e3.nkatakana = 12531, e3.nkatakanahalfwidth = 65437, e3.nlegrightlong = 414, e3.nlinebelow = 7753, e3.nmonospace = 65358, e3.nmsquare = 13210, e3.nnabengali = 2467, e3.nnadeva = 2339, e3.nnagujarati = 2723, e3.nnagurmukhi = 2595, e3.nnnadeva = 2345, e3.nohiragana = 12398, e3.nokatakana = 12494, e3.nokatakanahalfwidth = 65417, e3.nonbreakingspace = 160, e3.nonenthai = 3603, e3.nonuthai = 3609, e3.noonarabic = 1606, e3.noonfinalarabic = 65254, e3.noonghunnaarabic = 1722, e3.noonghunnafinalarabic = 64415, e3.nooninitialarabic = 65255, e3.noonjeeminitialarabic = 64722, e3.noonjeemisolatedarabic = 64587, e3.noonmedialarabic = 65256, e3.noonmeeminitialarabic = 64725, e3.noonmeemisolatedarabic = 64590, e3.noonnoonfinalarabic = 64653, e3.notcontains = 8716, e3.notelement = 8713, e3.notelementof = 8713, e3.notequal = 8800, e3.notgreater = 8815, e3.notgreaternorequal = 8817, e3.notgreaternorless = 8825, e3.notidentical = 8802, e3.notless = 8814, e3.notlessnorequal = 8816, e3.notparallel = 8742, e3.notprecedes = 8832, e3.notsubset = 8836, e3.notsucceeds = 8833, e3.notsuperset = 8837, e3.nowarmenian = 1398, e3.nparen = 9385, e3.nssquare = 13233, e3.nsuperior = 8319, e3.ntilde = 241, e3.nu = 957, e3.nuhiragana = 12396, e3.nukatakana = 12492, e3.nukatakanahalfwidth = 65415, e3.nuktabengali = 2492, e3.nuktadeva = 2364, e3.nuktagujarati = 2748, e3.nuktagurmukhi = 2620, e3.numbersign = 35, e3.numbersignmonospace = 65283, e3.numbersignsmall = 65119, e3.numeralsigngreek = 884, e3.numeralsignlowergreek = 885, e3.numero = 8470, e3.nun = 1504, e3.nundagesh = 64320, e3.nundageshhebrew = 64320, e3.nunhebrew = 1504, e3.nvsquare = 13237, e3.nwsquare = 13243, e3.nyabengali = 2462, e3.nyadeva = 2334, e3.nyagujarati = 2718, e3.nyagurmukhi = 2590, e3.o = 111, e3.oacute = 243, e3.oangthai = 3629, e3.obarred = 629, e3.obarredcyrillic = 1257, e3.obarreddieresiscyrillic = 1259, e3.obengali = 2451, e3.obopomofo = 12571, e3.obreve = 335, e3.ocandradeva = 2321, e3.ocandragujarati = 2705, e3.ocandravowelsigndeva = 2377, e3.ocandravowelsigngujarati = 2761, e3.ocaron = 466, e3.ocircle = 9438, e3.ocircumflex = 244, e3.ocircumflexacute = 7889, e3.ocircumflexdotbelow = 7897, e3.ocircumflexgrave = 7891, e3.ocircumflexhookabove = 7893, e3.ocircumflextilde = 7895, e3.ocyrillic = 1086, e3.odblacute = 337, e3.odblgrave = 525, e3.odeva = 2323, e3.odieresis = 246, e3.odieresiscyrillic = 1255, e3.odotbelow = 7885, e3.oe = 339, e3.oekorean = 12634, e3.ogonek = 731, e3.ogonekcmb = 808, e3.ograve = 242, e3.ogujarati = 2707, e3.oharmenian = 1413, e3.ohiragana = 12362, e3.ohookabove = 7887, e3.ohorn = 417, e3.ohornacute = 7899, e3.ohorndotbelow = 7907, e3.ohorngrave = 7901, e3.ohornhookabove = 7903, e3.ohorntilde = 7905, e3.ohungarumlaut = 337, e3.oi = 419, e3.oinvertedbreve = 527, e3.okatakana = 12458, e3.okatakanahalfwidth = 65397, e3.okorean = 12631, e3.olehebrew = 1451, e3.omacron = 333, e3.omacronacute = 7763, e3.omacrongrave = 7761, e3.omdeva = 2384, e3.omega = 969, e3.omega1 = 982, e3.omegacyrillic = 1121, e3.omegalatinclosed = 631, e3.omegaroundcyrillic = 1147, e3.omegatitlocyrillic = 1149, e3.omegatonos = 974, e3.omgujarati = 2768, e3.omicron = 959, e3.omicrontonos = 972, e3.omonospace = 65359, e3.one = 49, e3.onearabic = 1633, e3.onebengali = 2535, e3.onecircle = 9312, e3.onecircleinversesansserif = 10122, e3.onedeva = 2407, e3.onedotenleader = 8228, e3.oneeighth = 8539, e3.onefitted = 63196, e3.onegujarati = 2791, e3.onegurmukhi = 2663, e3.onehackarabic = 1633, e3.onehalf = 189, e3.onehangzhou = 12321, e3.oneideographicparen = 12832, e3.oneinferior = 8321, e3.onemonospace = 65297, e3.onenumeratorbengali = 2548, e3.oneoldstyle = 63281, e3.oneparen = 9332, e3.oneperiod = 9352, e3.onepersian = 1777, e3.onequarter = 188, e3.oneroman = 8560, e3.onesuperior = 185, e3.onethai = 3665, e3.onethird = 8531, e3.oogonek = 491, e3.oogonekmacron = 493, e3.oogurmukhi = 2579, e3.oomatragurmukhi = 2635, e3.oopen = 596, e3.oparen = 9386, e3.openbullet = 9702, e3.option = 8997, e3.ordfeminine = 170, e3.ordmasculine = 186, e3.orthogonal = 8735, e3.oshortdeva = 2322, e3.oshortvowelsigndeva = 2378, e3.oslash = 248, e3.oslashacute = 511, e3.osmallhiragana = 12361, e3.osmallkatakana = 12457, e3.osmallkatakanahalfwidth = 65387, e3.ostrokeacute = 511, e3.osuperior = 63216, e3.otcyrillic = 1151, e3.otilde = 245, e3.otildeacute = 7757, e3.otildedieresis = 7759, e3.oubopomofo = 12577, e3.overline = 8254, e3.overlinecenterline = 65098, e3.overlinecmb = 773, e3.overlinedashed = 65097, e3.overlinedblwavy = 65100, e3.overlinewavy = 65099, e3.overscore = 175, e3.ovowelsignbengali = 2507, e3.ovowelsigndeva = 2379, e3.ovowelsigngujarati = 2763, e3.p = 112, e3.paampssquare = 13184, e3.paasentosquare = 13099, e3.pabengali = 2474, e3.pacute = 7765, e3.padeva = 2346, e3.pagedown = 8671, e3.pageup = 8670, e3.pagujarati = 2730, e3.pagurmukhi = 2602, e3.pahiragana = 12401, e3.paiyannoithai = 3631, e3.pakatakana = 12497, e3.palatalizationcyrilliccmb = 1156, e3.palochkacyrillic = 1216, e3.pansioskorean = 12671, e3.paragraph = 182, e3.parallel = 8741, e3.parenleft = 40, e3.parenleftaltonearabic = 64830, e3.parenleftbt = 63725, e3.parenleftex = 63724, e3.parenleftinferior = 8333, e3.parenleftmonospace = 65288, e3.parenleftsmall = 65113, e3.parenleftsuperior = 8317, e3.parenlefttp = 63723, e3.parenleftvertical = 65077, e3.parenright = 41, e3.parenrightaltonearabic = 64831, e3.parenrightbt = 63736, e3.parenrightex = 63735, e3.parenrightinferior = 8334, e3.parenrightmonospace = 65289, e3.parenrightsmall = 65114, e3.parenrightsuperior = 8318, e3.parenrighttp = 63734, e3.parenrightvertical = 65078, e3.partialdiff = 8706, e3.paseqhebrew = 1472, e3.pashtahebrew = 1433, e3.pasquare = 13225, e3.patah = 1463, e3.patah11 = 1463, e3.patah1d = 1463, e3.patah2a = 1463, e3.patahhebrew = 1463, e3.patahnarrowhebrew = 1463, e3.patahquarterhebrew = 1463, e3.patahwidehebrew = 1463, e3.pazerhebrew = 1441, e3.pbopomofo = 12550, e3.pcircle = 9439, e3.pdotaccent = 7767, e3.pe = 1508, e3.pecyrillic = 1087, e3.pedagesh = 64324, e3.pedageshhebrew = 64324, e3.peezisquare = 13115, e3.pefinaldageshhebrew = 64323, e3.peharabic = 1662, e3.peharmenian = 1402, e3.pehebrew = 1508, e3.pehfinalarabic = 64343, e3.pehinitialarabic = 64344, e3.pehiragana = 12410, e3.pehmedialarabic = 64345, e3.pekatakana = 12506, e3.pemiddlehookcyrillic = 1191, e3.perafehebrew = 64334, e3.percent = 37, e3.percentarabic = 1642, e3.percentmonospace = 65285, e3.percentsmall = 65130, e3.period = 46, e3.periodarmenian = 1417, e3.periodcentered = 183, e3.periodhalfwidth = 65377, e3.periodinferior = 63207, e3.periodmonospace = 65294, e3.periodsmall = 65106, e3.periodsuperior = 63208, e3.perispomenigreekcmb = 834, e3.perpendicular = 8869, e3.perthousand = 8240, e3.peseta = 8359, e3.pfsquare = 13194, e3.phabengali = 2475, e3.phadeva = 2347, e3.phagujarati = 2731, e3.phagurmukhi = 2603, e3.phi = 966, e3.phi1 = 981, e3.phieuphacirclekorean = 12922, e3.phieuphaparenkorean = 12826, e3.phieuphcirclekorean = 12908, e3.phieuphkorean = 12621, e3.phieuphparenkorean = 12812, e3.philatin = 632, e3.phinthuthai = 3642, e3.phisymbolgreek = 981, e3.phook = 421, e3.phophanthai = 3614, e3.phophungthai = 3612, e3.phosamphaothai = 3616, e3.pi = 960, e3.pieupacirclekorean = 12915, e3.pieupaparenkorean = 12819, e3.pieupcieuckorean = 12662, e3.pieupcirclekorean = 12901, e3.pieupkiyeokkorean = 12658, e3.pieupkorean = 12610, e3.pieupparenkorean = 12805, e3.pieupsioskiyeokkorean = 12660, e3.pieupsioskorean = 12612, e3.pieupsiostikeutkorean = 12661, e3.pieupthieuthkorean = 12663, e3.pieuptikeutkorean = 12659, e3.pihiragana = 12404, e3.pikatakana = 12500, e3.pisymbolgreek = 982, e3.piwrarmenian = 1411, e3.planckover2pi = 8463, e3.planckover2pi1 = 8463, e3.plus = 43, e3.plusbelowcmb = 799, e3.pluscircle = 8853, e3.plusminus = 177, e3.plusmod = 726, e3.plusmonospace = 65291, e3.plussmall = 65122, e3.plussuperior = 8314, e3.pmonospace = 65360, e3.pmsquare = 13272, e3.pohiragana = 12413, e3.pointingindexdownwhite = 9759, e3.pointingindexleftwhite = 9756, e3.pointingindexrightwhite = 9758, e3.pointingindexupwhite = 9757, e3.pokatakana = 12509, e3.poplathai = 3611, e3.postalmark = 12306, e3.postalmarkface = 12320, e3.pparen = 9387, e3.precedes = 8826, e3.prescription = 8478, e3.primemod = 697, e3.primereversed = 8245, e3.product = 8719, e3.projective = 8965, e3.prolongedkana = 12540, e3.propellor = 8984, e3.propersubset = 8834, e3.propersuperset = 8835, e3.proportion = 8759, e3.proportional = 8733, e3.psi = 968, e3.psicyrillic = 1137, e3.psilipneumatacyrilliccmb = 1158, e3.pssquare = 13232, e3.puhiragana = 12407, e3.pukatakana = 12503, e3.pvsquare = 13236, e3.pwsquare = 13242, e3.q = 113, e3.qadeva = 2392, e3.qadmahebrew = 1448, e3.qafarabic = 1602, e3.qaffinalarabic = 65238, e3.qafinitialarabic = 65239, e3.qafmedialarabic = 65240, e3.qamats = 1464, e3.qamats10 = 1464, e3.qamats1a = 1464, e3.qamats1c = 1464, e3.qamats27 = 1464, e3.qamats29 = 1464, e3.qamats33 = 1464, e3.qamatsde = 1464, e3.qamatshebrew = 1464, e3.qamatsnarrowhebrew = 1464, e3.qamatsqatanhebrew = 1464, e3.qamatsqatannarrowhebrew = 1464, e3.qamatsqatanquarterhebrew = 1464, e3.qamatsqatanwidehebrew = 1464, e3.qamatsquarterhebrew = 1464, e3.qamatswidehebrew = 1464, e3.qarneyparahebrew = 1439, e3.qbopomofo = 12561, e3.qcircle = 9440, e3.qhook = 672, e3.qmonospace = 65361, e3.qof = 1511, e3.qofdagesh = 64327, e3.qofdageshhebrew = 64327, e3.qofhebrew = 1511, e3.qparen = 9388, e3.quarternote = 9833, e3.qubuts = 1467, e3.qubuts18 = 1467, e3.qubuts25 = 1467, e3.qubuts31 = 1467, e3.qubutshebrew = 1467, e3.qubutsnarrowhebrew = 1467, e3.qubutsquarterhebrew = 1467, e3.qubutswidehebrew = 1467, e3.question = 63, e3.questionarabic = 1567, e3.questionarmenian = 1374, e3.questiondown = 191, e3.questiondownsmall = 63423, e3.questiongreek = 894, e3.questionmonospace = 65311, e3.questionsmall = 63295, e3.quotedbl = 34, e3.quotedblbase = 8222, e3.quotedblleft = 8220, e3.quotedblmonospace = 65282, e3.quotedblprime = 12318, e3.quotedblprimereversed = 12317, e3.quotedblright = 8221, e3.quoteleft = 8216, e3.quoteleftreversed = 8219, e3.quotereversed = 8219, e3.quoteright = 8217, e3.quoterightn = 329, e3.quotesinglbase = 8218, e3.quotesingle = 39, e3.quotesinglemonospace = 65287, e3.r = 114, e3.raarmenian = 1404, e3.rabengali = 2480, e3.racute = 341, e3.radeva = 2352, e3.radical = 8730, e3.radicalex = 63717, e3.radoverssquare = 13230, e3.radoverssquaredsquare = 13231, e3.radsquare = 13229, e3.rafe = 1471, e3.rafehebrew = 1471, e3.ragujarati = 2736, e3.ragurmukhi = 2608, e3.rahiragana = 12425, e3.rakatakana = 12521, e3.rakatakanahalfwidth = 65431, e3.ralowerdiagonalbengali = 2545, e3.ramiddlediagonalbengali = 2544, e3.ramshorn = 612, e3.ratio = 8758, e3.rbopomofo = 12566, e3.rcaron = 345, e3.rcedilla = 343, e3.rcircle = 9441, e3.rcommaaccent = 343, e3.rdblgrave = 529, e3.rdotaccent = 7769, e3.rdotbelow = 7771, e3.rdotbelowmacron = 7773, e3.referencemark = 8251, e3.reflexsubset = 8838, e3.reflexsuperset = 8839, e3.registered = 174, e3.registersans = 63720, e3.registerserif = 63194, e3.reharabic = 1585, e3.reharmenian = 1408, e3.rehfinalarabic = 65198, e3.rehiragana = 12428, e3.rekatakana = 12524;
      e3.rekatakanahalfwidth = 65434, e3.resh = 1512, e3.reshdageshhebrew = 64328, e3.reshhebrew = 1512, e3.reversedtilde = 8765, e3.reviahebrew = 1431, e3.reviamugrashhebrew = 1431, e3.revlogicalnot = 8976, e3.rfishhook = 638, e3.rfishhookreversed = 639, e3.rhabengali = 2525, e3.rhadeva = 2397, e3.rho = 961, e3.rhook = 637, e3.rhookturned = 635, e3.rhookturnedsuperior = 693, e3.rhosymbolgreek = 1009, e3.rhotichookmod = 734, e3.rieulacirclekorean = 12913, e3.rieulaparenkorean = 12817, e3.rieulcirclekorean = 12899, e3.rieulhieuhkorean = 12608, e3.rieulkiyeokkorean = 12602, e3.rieulkiyeoksioskorean = 12649, e3.rieulkorean = 12601, e3.rieulmieumkorean = 12603, e3.rieulpansioskorean = 12652, e3.rieulparenkorean = 12803, e3.rieulphieuphkorean = 12607, e3.rieulpieupkorean = 12604, e3.rieulpieupsioskorean = 12651, e3.rieulsioskorean = 12605, e3.rieulthieuthkorean = 12606, e3.rieultikeutkorean = 12650, e3.rieulyeorinhieuhkorean = 12653, e3.rightangle = 8735, e3.righttackbelowcmb = 793, e3.righttriangle = 8895, e3.rihiragana = 12426, e3.rikatakana = 12522, e3.rikatakanahalfwidth = 65432, e3.ring = 730, e3.ringbelowcmb = 805, e3.ringcmb = 778, e3.ringhalfleft = 703, e3.ringhalfleftarmenian = 1369, e3.ringhalfleftbelowcmb = 796, e3.ringhalfleftcentered = 723, e3.ringhalfright = 702, e3.ringhalfrightbelowcmb = 825, e3.ringhalfrightcentered = 722, e3.rinvertedbreve = 531, e3.rittorusquare = 13137, e3.rlinebelow = 7775, e3.rlongleg = 636, e3.rlonglegturned = 634, e3.rmonospace = 65362, e3.rohiragana = 12429, e3.rokatakana = 12525, e3.rokatakanahalfwidth = 65435, e3.roruathai = 3619, e3.rparen = 9389, e3.rrabengali = 2524, e3.rradeva = 2353, e3.rragurmukhi = 2652, e3.rreharabic = 1681, e3.rrehfinalarabic = 64397, e3.rrvocalicbengali = 2528, e3.rrvocalicdeva = 2400, e3.rrvocalicgujarati = 2784, e3.rrvocalicvowelsignbengali = 2500, e3.rrvocalicvowelsigndeva = 2372, e3.rrvocalicvowelsigngujarati = 2756, e3.rsuperior = 63217, e3.rtblock = 9616, e3.rturned = 633, e3.rturnedsuperior = 692, e3.ruhiragana = 12427, e3.rukatakana = 12523, e3.rukatakanahalfwidth = 65433, e3.rupeemarkbengali = 2546, e3.rupeesignbengali = 2547, e3.rupiah = 63197, e3.ruthai = 3620, e3.rvocalicbengali = 2443, e3.rvocalicdeva = 2315, e3.rvocalicgujarati = 2699, e3.rvocalicvowelsignbengali = 2499, e3.rvocalicvowelsigndeva = 2371, e3.rvocalicvowelsigngujarati = 2755, e3.s = 115, e3.sabengali = 2488, e3.sacute = 347, e3.sacutedotaccent = 7781, e3.sadarabic = 1589, e3.sadeva = 2360, e3.sadfinalarabic = 65210, e3.sadinitialarabic = 65211, e3.sadmedialarabic = 65212, e3.sagujarati = 2744, e3.sagurmukhi = 2616, e3.sahiragana = 12373, e3.sakatakana = 12469, e3.sakatakanahalfwidth = 65403, e3.sallallahoualayhewasallamarabic = 65018, e3.samekh = 1505, e3.samekhdagesh = 64321, e3.samekhdageshhebrew = 64321, e3.samekhhebrew = 1505, e3.saraaathai = 3634, e3.saraaethai = 3649, e3.saraaimaimalaithai = 3652, e3.saraaimaimuanthai = 3651, e3.saraamthai = 3635, e3.saraathai = 3632, e3.saraethai = 3648, e3.saraiileftthai = 63622, e3.saraiithai = 3637, e3.saraileftthai = 63621, e3.saraithai = 3636, e3.saraothai = 3650, e3.saraueeleftthai = 63624, e3.saraueethai = 3639, e3.saraueleftthai = 63623, e3.sarauethai = 3638, e3.sarauthai = 3640, e3.sarauuthai = 3641, e3.sbopomofo = 12569, e3.scaron = 353, e3.scarondotaccent = 7783, e3.scedilla = 351, e3.schwa = 601, e3.schwacyrillic = 1241, e3.schwadieresiscyrillic = 1243, e3.schwahook = 602, e3.scircle = 9442, e3.scircumflex = 349, e3.scommaaccent = 537, e3.sdotaccent = 7777, e3.sdotbelow = 7779, e3.sdotbelowdotaccent = 7785, e3.seagullbelowcmb = 828, e3.second = 8243, e3.secondtonechinese = 714, e3.section = 167, e3.seenarabic = 1587, e3.seenfinalarabic = 65202, e3.seeninitialarabic = 65203, e3.seenmedialarabic = 65204, e3.segol = 1462, e3.segol13 = 1462, e3.segol1f = 1462, e3.segol2c = 1462, e3.segolhebrew = 1462, e3.segolnarrowhebrew = 1462, e3.segolquarterhebrew = 1462, e3.segoltahebrew = 1426, e3.segolwidehebrew = 1462, e3.seharmenian = 1405, e3.sehiragana = 12379, e3.sekatakana = 12475, e3.sekatakanahalfwidth = 65406, e3.semicolon = 59, e3.semicolonarabic = 1563, e3.semicolonmonospace = 65307, e3.semicolonsmall = 65108, e3.semivoicedmarkkana = 12444, e3.semivoicedmarkkanahalfwidth = 65439, e3.sentisquare = 13090, e3.sentosquare = 13091, e3.seven = 55, e3.sevenarabic = 1639, e3.sevenbengali = 2541, e3.sevencircle = 9318, e3.sevencircleinversesansserif = 10128, e3.sevendeva = 2413, e3.seveneighths = 8542, e3.sevengujarati = 2797, e3.sevengurmukhi = 2669, e3.sevenhackarabic = 1639, e3.sevenhangzhou = 12327, e3.sevenideographicparen = 12838, e3.seveninferior = 8327, e3.sevenmonospace = 65303, e3.sevenoldstyle = 63287, e3.sevenparen = 9338, e3.sevenperiod = 9358, e3.sevenpersian = 1783, e3.sevenroman = 8566, e3.sevensuperior = 8311, e3.seventeencircle = 9328, e3.seventeenparen = 9348, e3.seventeenperiod = 9368, e3.seventhai = 3671, e3.sfthyphen = 173, e3.shaarmenian = 1399, e3.shabengali = 2486, e3.shacyrillic = 1096, e3.shaddaarabic = 1617, e3.shaddadammaarabic = 64609, e3.shaddadammatanarabic = 64606, e3.shaddafathaarabic = 64608, e3.shaddakasraarabic = 64610, e3.shaddakasratanarabic = 64607, e3.shade = 9618, e3.shadedark = 9619, e3.shadelight = 9617, e3.shademedium = 9618, e3.shadeva = 2358, e3.shagujarati = 2742, e3.shagurmukhi = 2614, e3.shalshelethebrew = 1427, e3.shbopomofo = 12565, e3.shchacyrillic = 1097, e3.sheenarabic = 1588, e3.sheenfinalarabic = 65206, e3.sheeninitialarabic = 65207, e3.sheenmedialarabic = 65208, e3.sheicoptic = 995, e3.sheqel = 8362, e3.sheqelhebrew = 8362, e3.sheva = 1456, e3.sheva115 = 1456, e3.sheva15 = 1456, e3.sheva22 = 1456, e3.sheva2e = 1456, e3.shevahebrew = 1456, e3.shevanarrowhebrew = 1456, e3.shevaquarterhebrew = 1456, e3.shevawidehebrew = 1456, e3.shhacyrillic = 1211, e3.shimacoptic = 1005, e3.shin = 1513, e3.shindagesh = 64329, e3.shindageshhebrew = 64329, e3.shindageshshindot = 64300, e3.shindageshshindothebrew = 64300, e3.shindageshsindot = 64301, e3.shindageshsindothebrew = 64301, e3.shindothebrew = 1473, e3.shinhebrew = 1513, e3.shinshindot = 64298, e3.shinshindothebrew = 64298, e3.shinsindot = 64299, e3.shinsindothebrew = 64299, e3.shook = 642, e3.sigma = 963, e3.sigma1 = 962, e3.sigmafinal = 962, e3.sigmalunatesymbolgreek = 1010, e3.sihiragana = 12375, e3.sikatakana = 12471, e3.sikatakanahalfwidth = 65404, e3.siluqhebrew = 1469, e3.siluqlefthebrew = 1469, e3.similar = 8764, e3.sindothebrew = 1474, e3.siosacirclekorean = 12916, e3.siosaparenkorean = 12820, e3.sioscieuckorean = 12670, e3.sioscirclekorean = 12902, e3.sioskiyeokkorean = 12666, e3.sioskorean = 12613, e3.siosnieunkorean = 12667, e3.siosparenkorean = 12806, e3.siospieupkorean = 12669, e3.siostikeutkorean = 12668, e3.six = 54, e3.sixarabic = 1638, e3.sixbengali = 2540, e3.sixcircle = 9317, e3.sixcircleinversesansserif = 10127, e3.sixdeva = 2412, e3.sixgujarati = 2796, e3.sixgurmukhi = 2668, e3.sixhackarabic = 1638, e3.sixhangzhou = 12326, e3.sixideographicparen = 12837, e3.sixinferior = 8326, e3.sixmonospace = 65302, e3.sixoldstyle = 63286, e3.sixparen = 9337, e3.sixperiod = 9357, e3.sixpersian = 1782, e3.sixroman = 8565, e3.sixsuperior = 8310, e3.sixteencircle = 9327, e3.sixteencurrencydenominatorbengali = 2553, e3.sixteenparen = 9347, e3.sixteenperiod = 9367, e3.sixthai = 3670, e3.slash = 47, e3.slashmonospace = 65295, e3.slong = 383, e3.slongdotaccent = 7835, e3.smileface = 9786, e3.smonospace = 65363, e3.sofpasuqhebrew = 1475, e3.softhyphen = 173, e3.softsigncyrillic = 1100, e3.sohiragana = 12381, e3.sokatakana = 12477, e3.sokatakanahalfwidth = 65407, e3.soliduslongoverlaycmb = 824, e3.solidusshortoverlaycmb = 823, e3.sorusithai = 3625, e3.sosalathai = 3624, e3.sosothai = 3595, e3.sosuathai = 3626, e3.space = 32, e3.spacehackarabic = 32, e3.spade = 9824, e3.spadesuitblack = 9824, e3.spadesuitwhite = 9828, e3.sparen = 9390, e3.squarebelowcmb = 827, e3.squarecc = 13252, e3.squarecm = 13213, e3.squarediagonalcrosshatchfill = 9641, e3.squarehorizontalfill = 9636, e3.squarekg = 13199, e3.squarekm = 13214, e3.squarekmcapital = 13262, e3.squareln = 13265, e3.squarelog = 13266, e3.squaremg = 13198, e3.squaremil = 13269, e3.squaremm = 13212, e3.squaremsquared = 13217, e3.squareorthogonalcrosshatchfill = 9638, e3.squareupperlefttolowerrightfill = 9639, e3.squareupperrighttolowerleftfill = 9640, e3.squareverticalfill = 9637, e3.squarewhitewithsmallblack = 9635, e3.srsquare = 13275, e3.ssabengali = 2487, e3.ssadeva = 2359, e3.ssagujarati = 2743, e3.ssangcieuckorean = 12617, e3.ssanghieuhkorean = 12677, e3.ssangieungkorean = 12672, e3.ssangkiyeokkorean = 12594, e3.ssangnieunkorean = 12645, e3.ssangpieupkorean = 12611, e3.ssangsioskorean = 12614, e3.ssangtikeutkorean = 12600, e3.ssuperior = 63218, e3.sterling = 163, e3.sterlingmonospace = 65505, e3.strokelongoverlaycmb = 822, e3.strokeshortoverlaycmb = 821, e3.subset = 8834, e3.subsetnotequal = 8842, e3.subsetorequal = 8838, e3.succeeds = 8827, e3.suchthat = 8715, e3.suhiragana = 12377, e3.sukatakana = 12473, e3.sukatakanahalfwidth = 65405, e3.sukunarabic = 1618, e3.summation = 8721, e3.sun = 9788, e3.superset = 8835, e3.supersetnotequal = 8843, e3.supersetorequal = 8839, e3.svsquare = 13276, e3.syouwaerasquare = 13180, e3.t = 116, e3.tabengali = 2468, e3.tackdown = 8868, e3.tackleft = 8867, e3.tadeva = 2340, e3.tagujarati = 2724, e3.tagurmukhi = 2596, e3.taharabic = 1591, e3.tahfinalarabic = 65218, e3.tahinitialarabic = 65219, e3.tahiragana = 12383, e3.tahmedialarabic = 65220, e3.taisyouerasquare = 13181, e3.takatakana = 12479, e3.takatakanahalfwidth = 65408, e3.tatweelarabic = 1600, e3.tau = 964, e3.tav = 1514, e3.tavdages = 64330, e3.tavdagesh = 64330, e3.tavdageshhebrew = 64330, e3.tavhebrew = 1514, e3.tbar = 359, e3.tbopomofo = 12554, e3.tcaron = 357, e3.tccurl = 680, e3.tcedilla = 355, e3.tcheharabic = 1670, e3.tchehfinalarabic = 64379, e3.tchehinitialarabic = 64380, e3.tchehmedialarabic = 64381, e3.tcircle = 9443, e3.tcircumflexbelow = 7793, e3.tcommaaccent = 355, e3.tdieresis = 7831, e3.tdotaccent = 7787, e3.tdotbelow = 7789, e3.tecyrillic = 1090, e3.tedescendercyrillic = 1197, e3.teharabic = 1578, e3.tehfinalarabic = 65174, e3.tehhahinitialarabic = 64674, e3.tehhahisolatedarabic = 64524, e3.tehinitialarabic = 65175, e3.tehiragana = 12390, e3.tehjeeminitialarabic = 64673, e3.tehjeemisolatedarabic = 64523, e3.tehmarbutaarabic = 1577, e3.tehmarbutafinalarabic = 65172, e3.tehmedialarabic = 65176, e3.tehmeeminitialarabic = 64676, e3.tehmeemisolatedarabic = 64526, e3.tehnoonfinalarabic = 64627, e3.tekatakana = 12486, e3.tekatakanahalfwidth = 65411, e3.telephone = 8481, e3.telephoneblack = 9742, e3.telishagedolahebrew = 1440, e3.telishaqetanahebrew = 1449, e3.tencircle = 9321, e3.tenideographicparen = 12841, e3.tenparen = 9341, e3.tenperiod = 9361, e3.tenroman = 8569, e3.tesh = 679, e3.tet = 1496, e3.tetdagesh = 64312, e3.tetdageshhebrew = 64312, e3.tethebrew = 1496, e3.tetsecyrillic = 1205, e3.tevirhebrew = 1435, e3.tevirlefthebrew = 1435, e3.thabengali = 2469, e3.thadeva = 2341, e3.thagujarati = 2725, e3.thagurmukhi = 2597, e3.thalarabic = 1584, e3.thalfinalarabic = 65196, e3.thanthakhatlowleftthai = 63640, e3.thanthakhatlowrightthai = 63639, e3.thanthakhatthai = 3660, e3.thanthakhatupperleftthai = 63638, e3.theharabic = 1579, e3.thehfinalarabic = 65178, e3.thehinitialarabic = 65179, e3.thehmedialarabic = 65180, e3.thereexists = 8707, e3.therefore = 8756, e3.theta = 952, e3.theta1 = 977, e3.thetasymbolgreek = 977, e3.thieuthacirclekorean = 12921, e3.thieuthaparenkorean = 12825, e3.thieuthcirclekorean = 12907, e3.thieuthkorean = 12620, e3.thieuthparenkorean = 12811, e3.thirteencircle = 9324, e3.thirteenparen = 9344, e3.thirteenperiod = 9364, e3.thonangmonthothai = 3601, e3.thook = 429, e3.thophuthaothai = 3602, e3.thorn = 254, e3.thothahanthai = 3607, e3.thothanthai = 3600, e3.thothongthai = 3608, e3.thothungthai = 3606, e3.thousandcyrillic = 1154, e3.thousandsseparatorarabic = 1644, e3.thousandsseparatorpersian = 1644, e3.three = 51, e3.threearabic = 1635, e3.threebengali = 2537, e3.threecircle = 9314, e3.threecircleinversesansserif = 10124, e3.threedeva = 2409, e3.threeeighths = 8540, e3.threegujarati = 2793, e3.threegurmukhi = 2665, e3.threehackarabic = 1635, e3.threehangzhou = 12323, e3.threeideographicparen = 12834, e3.threeinferior = 8323, e3.threemonospace = 65299, e3.threenumeratorbengali = 2550, e3.threeoldstyle = 63283, e3.threeparen = 9334, e3.threeperiod = 9354, e3.threepersian = 1779, e3.threequarters = 190, e3.threequartersemdash = 63198, e3.threeroman = 8562, e3.threesuperior = 179, e3.threethai = 3667, e3.thzsquare = 13204, e3.tihiragana = 12385, e3.tikatakana = 12481, e3.tikatakanahalfwidth = 65409, e3.tikeutacirclekorean = 12912, e3.tikeutaparenkorean = 12816, e3.tikeutcirclekorean = 12898, e3.tikeutkorean = 12599, e3.tikeutparenkorean = 12802, e3.tilde = 732, e3.tildebelowcmb = 816, e3.tildecmb = 771, e3.tildecomb = 771, e3.tildedoublecmb = 864, e3.tildeoperator = 8764, e3.tildeoverlaycmb = 820, e3.tildeverticalcmb = 830, e3.timescircle = 8855, e3.tipehahebrew = 1430, e3.tipehalefthebrew = 1430, e3.tippigurmukhi = 2672, e3.titlocyrilliccmb = 1155, e3.tiwnarmenian = 1407, e3.tlinebelow = 7791, e3.tmonospace = 65364, e3.toarmenian = 1385, e3.tohiragana = 12392, e3.tokatakana = 12488, e3.tokatakanahalfwidth = 65412, e3.tonebarextrahighmod = 741, e3.tonebarextralowmod = 745, e3.tonebarhighmod = 742, e3.tonebarlowmod = 744, e3.tonebarmidmod = 743, e3.tonefive = 445, e3.tonesix = 389, e3.tonetwo = 424, e3.tonos = 900, e3.tonsquare = 13095, e3.topatakthai = 3599, e3.tortoiseshellbracketleft = 12308, e3.tortoiseshellbracketleftsmall = 65117, e3.tortoiseshellbracketleftvertical = 65081, e3.tortoiseshellbracketright = 12309, e3.tortoiseshellbracketrightsmall = 65118, e3.tortoiseshellbracketrightvertical = 65082, e3.totaothai = 3605, e3.tpalatalhook = 427, e3.tparen = 9391, e3.trademark = 8482, e3.trademarksans = 63722, e3.trademarkserif = 63195, e3.tretroflexhook = 648, e3.triagdn = 9660, e3.triaglf = 9668, e3.triagrt = 9658, e3.triagup = 9650, e3.ts = 678, e3.tsadi = 1510, e3.tsadidagesh = 64326, e3.tsadidageshhebrew = 64326, e3.tsadihebrew = 1510, e3.tsecyrillic = 1094, e3.tsere = 1461, e3.tsere12 = 1461, e3.tsere1e = 1461, e3.tsere2b = 1461, e3.tserehebrew = 1461, e3.tserenarrowhebrew = 1461, e3.tserequarterhebrew = 1461, e3.tserewidehebrew = 1461, e3.tshecyrillic = 1115, e3.tsuperior = 63219, e3.ttabengali = 2463, e3.ttadeva = 2335, e3.ttagujarati = 2719, e3.ttagurmukhi = 2591, e3.tteharabic = 1657, e3.ttehfinalarabic = 64359, e3.ttehinitialarabic = 64360, e3.ttehmedialarabic = 64361, e3.tthabengali = 2464, e3.tthadeva = 2336, e3.tthagujarati = 2720, e3.tthagurmukhi = 2592, e3.tturned = 647, e3.tuhiragana = 12388, e3.tukatakana = 12484, e3.tukatakanahalfwidth = 65410, e3.tusmallhiragana = 12387, e3.tusmallkatakana = 12483, e3.tusmallkatakanahalfwidth = 65391, e3.twelvecircle = 9323, e3.twelveparen = 9343, e3.twelveperiod = 9363, e3.twelveroman = 8571, e3.twentycircle = 9331, e3.twentyhangzhou = 21316, e3.twentyparen = 9351, e3.twentyperiod = 9371, e3.two = 50, e3.twoarabic = 1634, e3.twobengali = 2536, e3.twocircle = 9313, e3.twocircleinversesansserif = 10123, e3.twodeva = 2408, e3.twodotenleader = 8229, e3.twodotleader = 8229, e3.twodotleadervertical = 65072, e3.twogujarati = 2792, e3.twogurmukhi = 2664, e3.twohackarabic = 1634, e3.twohangzhou = 12322, e3.twoideographicparen = 12833, e3.twoinferior = 8322, e3.twomonospace = 65298, e3.twonumeratorbengali = 2549, e3.twooldstyle = 63282, e3.twoparen = 9333, e3.twoperiod = 9353, e3.twopersian = 1778, e3.tworoman = 8561, e3.twostroke = 443, e3.twosuperior = 178, e3.twothai = 3666, e3.twothirds = 8532, e3.u = 117, e3.uacute = 250, e3.ubar = 649, e3.ubengali = 2441, e3.ubopomofo = 12584, e3.ubreve = 365, e3.ucaron = 468, e3.ucircle = 9444, e3.ucircumflex = 251, e3.ucircumflexbelow = 7799, e3.ucyrillic = 1091, e3.udattadeva = 2385, e3.udblacute = 369, e3.udblgrave = 533, e3.udeva = 2313, e3.udieresis = 252, e3.udieresisacute = 472, e3.udieresisbelow = 7795, e3.udieresiscaron = 474, e3.udieresiscyrillic = 1265, e3.udieresisgrave = 476, e3.udieresismacron = 470, e3.udotbelow = 7909, e3.ugrave = 249, e3.ugujarati = 2697, e3.ugurmukhi = 2569, e3.uhiragana = 12358, e3.uhookabove = 7911, e3.uhorn = 432, e3.uhornacute = 7913, e3.uhorndotbelow = 7921, e3.uhorngrave = 7915, e3.uhornhookabove = 7917, e3.uhorntilde = 7919, e3.uhungarumlaut = 369, e3.uhungarumlautcyrillic = 1267, e3.uinvertedbreve = 535, e3.ukatakana = 12454, e3.ukatakanahalfwidth = 65395, e3.ukcyrillic = 1145, e3.ukorean = 12636, e3.umacron = 363, e3.umacroncyrillic = 1263, e3.umacrondieresis = 7803, e3.umatragurmukhi = 2625, e3.umonospace = 65365, e3.underscore = 95, e3.underscoredbl = 8215, e3.underscoremonospace = 65343, e3.underscorevertical = 65075, e3.underscorewavy = 65103, e3.union = 8746, e3.universal = 8704, e3.uogonek = 371, e3.uparen = 9392, e3.upblock = 9600, e3.upperdothebrew = 1476, e3.upsilon = 965, e3.upsilondieresis = 971, e3.upsilondieresistonos = 944, e3.upsilonlatin = 650, e3.upsilontonos = 973, e3.uptackbelowcmb = 797, e3.uptackmod = 724, e3.uragurmukhi = 2675, e3.uring = 367, e3.ushortcyrillic = 1118, e3.usmallhiragana = 12357, e3.usmallkatakana = 12453, e3.usmallkatakanahalfwidth = 65385, e3.ustraightcyrillic = 1199, e3.ustraightstrokecyrillic = 1201, e3.utilde = 361, e3.utildeacute = 7801, e3.utildebelow = 7797, e3.uubengali = 2442, e3.uudeva = 2314, e3.uugujarati = 2698, e3.uugurmukhi = 2570, e3.uumatragurmukhi = 2626, e3.uuvowelsignbengali = 2498, e3.uuvowelsigndeva = 2370, e3.uuvowelsigngujarati = 2754, e3.uvowelsignbengali = 2497, e3.uvowelsigndeva = 2369, e3.uvowelsigngujarati = 2753, e3.v = 118, e3.vadeva = 2357, e3.vagujarati = 2741, e3.vagurmukhi = 2613, e3.vakatakana = 12535, e3.vav = 1493, e3.vavdagesh = 64309, e3.vavdagesh65 = 64309, e3.vavdageshhebrew = 64309, e3.vavhebrew = 1493, e3.vavholam = 64331, e3.vavholamhebrew = 64331, e3.vavvavhebrew = 1520, e3.vavyodhebrew = 1521, e3.vcircle = 9445, e3.vdotbelow = 7807, e3.vecyrillic = 1074, e3.veharabic = 1700, e3.vehfinalarabic = 64363, e3.vehinitialarabic = 64364, e3.vehmedialarabic = 64365, e3.vekatakana = 12537, e3.venus = 9792, e3.verticalbar = 124, e3.verticallineabovecmb = 781, e3.verticallinebelowcmb = 809, e3.verticallinelowmod = 716, e3.verticallinemod = 712, e3.vewarmenian = 1406, e3.vhook = 651, e3.vikatakana = 12536, e3.viramabengali = 2509, e3.viramadeva = 2381, e3.viramagujarati = 2765, e3.visargabengali = 2435, e3.visargadeva = 2307, e3.visargagujarati = 2691, e3.vmonospace = 65366, e3.voarmenian = 1400, e3.voicediterationhiragana = 12446, e3.voicediterationkatakana = 12542, e3.voicedmarkkana = 12443, e3.voicedmarkkanahalfwidth = 65438, e3.vokatakana = 12538, e3.vparen = 9393, e3.vtilde = 7805, e3.vturned = 652, e3.vuhiragana = 12436, e3.vukatakana = 12532, e3.w = 119, e3.wacute = 7811, e3.waekorean = 12633, e3.wahiragana = 12431, e3.wakatakana = 12527, e3.wakatakanahalfwidth = 65436, e3.wakorean = 12632, e3.wasmallhiragana = 12430, e3.wasmallkatakana = 12526, e3.wattosquare = 13143, e3.wavedash = 12316, e3.wavyunderscorevertical = 65076, e3.wawarabic = 1608, e3.wawfinalarabic = 65262, e3.wawhamzaabovearabic = 1572, e3.wawhamzaabovefinalarabic = 65158, e3.wbsquare = 13277, e3.wcircle = 9446, e3.wcircumflex = 373, e3.wdieresis = 7813, e3.wdotaccent = 7815, e3.wdotbelow = 7817, e3.wehiragana = 12433, e3.weierstrass = 8472, e3.wekatakana = 12529, e3.wekorean = 12638, e3.weokorean = 12637, e3.wgrave = 7809, e3.whitebullet = 9702, e3.whitecircle = 9675, e3.whitecircleinverse = 9689, e3.whitecornerbracketleft = 12302, e3.whitecornerbracketleftvertical = 65091, e3.whitecornerbracketright = 12303, e3.whitecornerbracketrightvertical = 65092, e3.whitediamond = 9671, e3.whitediamondcontainingblacksmalldiamond = 9672, e3.whitedownpointingsmalltriangle = 9663;
      e3.whitedownpointingtriangle = 9661, e3.whiteleftpointingsmalltriangle = 9667, e3.whiteleftpointingtriangle = 9665, e3.whitelenticularbracketleft = 12310, e3.whitelenticularbracketright = 12311, e3.whiterightpointingsmalltriangle = 9657, e3.whiterightpointingtriangle = 9655, e3.whitesmallsquare = 9643, e3.whitesmilingface = 9786, e3.whitesquare = 9633, e3.whitestar = 9734, e3.whitetelephone = 9743, e3.whitetortoiseshellbracketleft = 12312, e3.whitetortoiseshellbracketright = 12313, e3.whiteuppointingsmalltriangle = 9653, e3.whiteuppointingtriangle = 9651, e3.wihiragana = 12432, e3.wikatakana = 12528, e3.wikorean = 12639, e3.wmonospace = 65367, e3.wohiragana = 12434, e3.wokatakana = 12530, e3.wokatakanahalfwidth = 65382, e3.won = 8361, e3.wonmonospace = 65510, e3.wowaenthai = 3623, e3.wparen = 9394, e3.wring = 7832, e3.wsuperior = 695, e3.wturned = 653, e3.wynn = 447, e3.x = 120, e3.xabovecmb = 829, e3.xbopomofo = 12562, e3.xcircle = 9447, e3.xdieresis = 7821, e3.xdotaccent = 7819, e3.xeharmenian = 1389, e3.xi = 958, e3.xmonospace = 65368, e3.xparen = 9395, e3.xsuperior = 739, e3.y = 121, e3.yaadosquare = 13134, e3.yabengali = 2479, e3.yacute = 253, e3.yadeva = 2351, e3.yaekorean = 12626, e3.yagujarati = 2735, e3.yagurmukhi = 2607, e3.yahiragana = 12420, e3.yakatakana = 12516, e3.yakatakanahalfwidth = 65428, e3.yakorean = 12625, e3.yamakkanthai = 3662, e3.yasmallhiragana = 12419, e3.yasmallkatakana = 12515, e3.yasmallkatakanahalfwidth = 65388, e3.yatcyrillic = 1123, e3.ycircle = 9448, e3.ycircumflex = 375, e3.ydieresis = 255, e3.ydotaccent = 7823, e3.ydotbelow = 7925, e3.yeharabic = 1610, e3.yehbarreearabic = 1746, e3.yehbarreefinalarabic = 64431, e3.yehfinalarabic = 65266, e3.yehhamzaabovearabic = 1574, e3.yehhamzaabovefinalarabic = 65162, e3.yehhamzaaboveinitialarabic = 65163, e3.yehhamzaabovemedialarabic = 65164, e3.yehinitialarabic = 65267, e3.yehmedialarabic = 65268, e3.yehmeeminitialarabic = 64733, e3.yehmeemisolatedarabic = 64600, e3.yehnoonfinalarabic = 64660, e3.yehthreedotsbelowarabic = 1745, e3.yekorean = 12630, e3.yen = 165, e3.yenmonospace = 65509, e3.yeokorean = 12629, e3.yeorinhieuhkorean = 12678, e3.yerahbenyomohebrew = 1450, e3.yerahbenyomolefthebrew = 1450, e3.yericyrillic = 1099, e3.yerudieresiscyrillic = 1273, e3.yesieungkorean = 12673, e3.yesieungpansioskorean = 12675, e3.yesieungsioskorean = 12674, e3.yetivhebrew = 1434, e3.ygrave = 7923, e3.yhook = 436, e3.yhookabove = 7927, e3.yiarmenian = 1397, e3.yicyrillic = 1111, e3.yikorean = 12642, e3.yinyang = 9775, e3.yiwnarmenian = 1410, e3.ymonospace = 65369, e3.yod = 1497, e3.yoddagesh = 64313, e3.yoddageshhebrew = 64313, e3.yodhebrew = 1497, e3.yodyodhebrew = 1522, e3.yodyodpatahhebrew = 64287, e3.yohiragana = 12424, e3.yoikorean = 12681, e3.yokatakana = 12520, e3.yokatakanahalfwidth = 65430, e3.yokorean = 12635, e3.yosmallhiragana = 12423, e3.yosmallkatakana = 12519, e3.yosmallkatakanahalfwidth = 65390, e3.yotgreek = 1011, e3.yoyaekorean = 12680, e3.yoyakorean = 12679, e3.yoyakthai = 3618, e3.yoyingthai = 3597, e3.yparen = 9396, e3.ypogegrammeni = 890, e3.ypogegrammenigreekcmb = 837, e3.yr = 422, e3.yring = 7833, e3.ysuperior = 696, e3.ytilde = 7929, e3.yturned = 654, e3.yuhiragana = 12422, e3.yuikorean = 12684, e3.yukatakana = 12518, e3.yukatakanahalfwidth = 65429, e3.yukorean = 12640, e3.yusbigcyrillic = 1131, e3.yusbigiotifiedcyrillic = 1133, e3.yuslittlecyrillic = 1127, e3.yuslittleiotifiedcyrillic = 1129, e3.yusmallhiragana = 12421, e3.yusmallkatakana = 12517, e3.yusmallkatakanahalfwidth = 65389, e3.yuyekorean = 12683, e3.yuyeokorean = 12682, e3.yyabengali = 2527, e3.yyadeva = 2399, e3.z = 122, e3.zaarmenian = 1382, e3.zacute = 378, e3.zadeva = 2395, e3.zagurmukhi = 2651, e3.zaharabic = 1592, e3.zahfinalarabic = 65222, e3.zahinitialarabic = 65223, e3.zahiragana = 12374, e3.zahmedialarabic = 65224, e3.zainarabic = 1586, e3.zainfinalarabic = 65200, e3.zakatakana = 12470, e3.zaqefgadolhebrew = 1429, e3.zaqefqatanhebrew = 1428, e3.zarqahebrew = 1432, e3.zayin = 1494, e3.zayindagesh = 64310, e3.zayindageshhebrew = 64310, e3.zayinhebrew = 1494, e3.zbopomofo = 12567, e3.zcaron = 382, e3.zcircle = 9449, e3.zcircumflex = 7825, e3.zcurl = 657, e3.zdot = 380, e3.zdotaccent = 380, e3.zdotbelow = 7827, e3.zecyrillic = 1079, e3.zedescendercyrillic = 1177, e3.zedieresiscyrillic = 1247, e3.zehiragana = 12380, e3.zekatakana = 12476, e3.zero = 48, e3.zeroarabic = 1632, e3.zerobengali = 2534, e3.zerodeva = 2406, e3.zerogujarati = 2790, e3.zerogurmukhi = 2662, e3.zerohackarabic = 1632, e3.zeroinferior = 8320, e3.zeromonospace = 65296, e3.zerooldstyle = 63280, e3.zeropersian = 1776, e3.zerosuperior = 8304, e3.zerothai = 3664, e3.zerowidthjoiner = 65279, e3.zerowidthnonjoiner = 8204, e3.zerowidthspace = 8203, e3.zeta = 950, e3.zhbopomofo = 12563, e3.zhearmenian = 1386, e3.zhebrevecyrillic = 1218, e3.zhecyrillic = 1078, e3.zhedescendercyrillic = 1175, e3.zhedieresiscyrillic = 1245, e3.zihiragana = 12376, e3.zikatakana = 12472, e3.zinorhebrew = 1454, e3.zlinebelow = 7829, e3.zmonospace = 65370, e3.zohiragana = 12382, e3.zokatakana = 12478, e3.zparen = 9397, e3.zretroflexhook = 656, e3.zstroke = 438, e3.zuhiragana = 12378, e3.zukatakana = 12474, e3[".notdef"] = 0, e3.angbracketleftbig = 9001, e3.angbracketleftBig = 9001, e3.angbracketleftbigg = 9001, e3.angbracketleftBigg = 9001, e3.angbracketrightBig = 9002, e3.angbracketrightbig = 9002, e3.angbracketrightBigg = 9002, e3.angbracketrightbigg = 9002, e3.arrowhookleft = 8618, e3.arrowhookright = 8617, e3.arrowlefttophalf = 8636, e3.arrowleftbothalf = 8637, e3.arrownortheast = 8599, e3.arrownorthwest = 8598, e3.arrowrighttophalf = 8640, e3.arrowrightbothalf = 8641, e3.arrowsoutheast = 8600, e3.arrowsouthwest = 8601, e3.backslashbig = 8726, e3.backslashBig = 8726, e3.backslashBigg = 8726, e3.backslashbigg = 8726, e3.bardbl = 8214, e3.bracehtipdownleft = 65079, e3.bracehtipdownright = 65079, e3.bracehtipupleft = 65080, e3.bracehtipupright = 65080, e3.braceleftBig = 123, e3.braceleftbig = 123, e3.braceleftbigg = 123, e3.braceleftBigg = 123, e3.bracerightBig = 125, e3.bracerightbig = 125, e3.bracerightbigg = 125, e3.bracerightBigg = 125, e3.bracketleftbig = 91, e3.bracketleftBig = 91, e3.bracketleftbigg = 91, e3.bracketleftBigg = 91, e3.bracketrightBig = 93, e3.bracketrightbig = 93, e3.bracketrightbigg = 93, e3.bracketrightBigg = 93, e3.ceilingleftbig = 8968, e3.ceilingleftBig = 8968, e3.ceilingleftBigg = 8968, e3.ceilingleftbigg = 8968, e3.ceilingrightbig = 8969, e3.ceilingrightBig = 8969, e3.ceilingrightbigg = 8969, e3.ceilingrightBigg = 8969, e3.circledotdisplay = 8857, e3.circledottext = 8857, e3.circlemultiplydisplay = 8855, e3.circlemultiplytext = 8855, e3.circleplusdisplay = 8853, e3.circleplustext = 8853, e3.contintegraldisplay = 8750, e3.contintegraltext = 8750, e3.coproductdisplay = 8720, e3.coproducttext = 8720, e3.floorleftBig = 8970, e3.floorleftbig = 8970, e3.floorleftbigg = 8970, e3.floorleftBigg = 8970, e3.floorrightbig = 8971, e3.floorrightBig = 8971, e3.floorrightBigg = 8971, e3.floorrightbigg = 8971, e3.hatwide = 770, e3.hatwider = 770, e3.hatwidest = 770, e3.intercal = 7488, e3.integraldisplay = 8747, e3.integraltext = 8747, e3.intersectiondisplay = 8898, e3.intersectiontext = 8898, e3.logicalanddisplay = 8743, e3.logicalandtext = 8743, e3.logicalordisplay = 8744, e3.logicalortext = 8744, e3.parenleftBig = 40, e3.parenleftbig = 40, e3.parenleftBigg = 40, e3.parenleftbigg = 40, e3.parenrightBig = 41, e3.parenrightbig = 41, e3.parenrightBigg = 41, e3.parenrightbigg = 41, e3.prime = 8242, e3.productdisplay = 8719, e3.producttext = 8719, e3.radicalbig = 8730, e3.radicalBig = 8730, e3.radicalBigg = 8730, e3.radicalbigg = 8730, e3.radicalbt = 8730, e3.radicaltp = 8730, e3.radicalvertex = 8730, e3.slashbig = 47, e3.slashBig = 47, e3.slashBigg = 47, e3.slashbigg = 47, e3.summationdisplay = 8721, e3.summationtext = 8721, e3.tildewide = 732, e3.tildewider = 732, e3.tildewidest = 732, e3.uniondisplay = 8899, e3.unionmultidisplay = 8846, e3.unionmultitext = 8846, e3.unionsqdisplay = 8852, e3.unionsqtext = 8852, e3.uniontext = 8899, e3.vextenddouble = 8741, e3.vextendsingle = 8739;
    });
    ar = getLookupTableFactory(function(e3) {
      e3.space = 32, e3.a1 = 9985, e3.a2 = 9986, e3.a202 = 9987, e3.a3 = 9988, e3.a4 = 9742, e3.a5 = 9990, e3.a119 = 9991, e3.a118 = 9992, e3.a117 = 9993, e3.a11 = 9755, e3.a12 = 9758, e3.a13 = 9996, e3.a14 = 9997, e3.a15 = 9998, e3.a16 = 9999, e3.a105 = 1e4, e3.a17 = 10001, e3.a18 = 10002, e3.a19 = 10003, e3.a20 = 10004, e3.a21 = 10005, e3.a22 = 10006, e3.a23 = 10007, e3.a24 = 10008, e3.a25 = 10009, e3.a26 = 10010, e3.a27 = 10011, e3.a28 = 10012, e3.a6 = 10013, e3.a7 = 10014, e3.a8 = 10015, e3.a9 = 10016, e3.a10 = 10017, e3.a29 = 10018, e3.a30 = 10019, e3.a31 = 10020, e3.a32 = 10021, e3.a33 = 10022, e3.a34 = 10023, e3.a35 = 9733, e3.a36 = 10025, e3.a37 = 10026, e3.a38 = 10027, e3.a39 = 10028, e3.a40 = 10029, e3.a41 = 10030, e3.a42 = 10031, e3.a43 = 10032, e3.a44 = 10033, e3.a45 = 10034, e3.a46 = 10035, e3.a47 = 10036, e3.a48 = 10037, e3.a49 = 10038, e3.a50 = 10039, e3.a51 = 10040, e3.a52 = 10041, e3.a53 = 10042, e3.a54 = 10043, e3.a55 = 10044, e3.a56 = 10045, e3.a57 = 10046, e3.a58 = 10047, e3.a59 = 10048, e3.a60 = 10049, e3.a61 = 10050, e3.a62 = 10051, e3.a63 = 10052, e3.a64 = 10053, e3.a65 = 10054, e3.a66 = 10055, e3.a67 = 10056, e3.a68 = 10057, e3.a69 = 10058, e3.a70 = 10059, e3.a71 = 9679, e3.a72 = 10061, e3.a73 = 9632, e3.a74 = 10063, e3.a203 = 10064, e3.a75 = 10065, e3.a204 = 10066, e3.a76 = 9650, e3.a77 = 9660, e3.a78 = 9670, e3.a79 = 10070, e3.a81 = 9687, e3.a82 = 10072, e3.a83 = 10073, e3.a84 = 10074, e3.a97 = 10075, e3.a98 = 10076, e3.a99 = 10077, e3.a100 = 10078, e3.a101 = 10081, e3.a102 = 10082, e3.a103 = 10083, e3.a104 = 10084, e3.a106 = 10085, e3.a107 = 10086, e3.a108 = 10087, e3.a112 = 9827, e3.a111 = 9830, e3.a110 = 9829, e3.a109 = 9824, e3.a120 = 9312, e3.a121 = 9313, e3.a122 = 9314, e3.a123 = 9315, e3.a124 = 9316, e3.a125 = 9317, e3.a126 = 9318, e3.a127 = 9319, e3.a128 = 9320, e3.a129 = 9321, e3.a130 = 10102, e3.a131 = 10103, e3.a132 = 10104, e3.a133 = 10105, e3.a134 = 10106, e3.a135 = 10107, e3.a136 = 10108, e3.a137 = 10109, e3.a138 = 10110, e3.a139 = 10111, e3.a140 = 10112, e3.a141 = 10113, e3.a142 = 10114, e3.a143 = 10115, e3.a144 = 10116, e3.a145 = 10117, e3.a146 = 10118, e3.a147 = 10119, e3.a148 = 10120, e3.a149 = 10121, e3.a150 = 10122, e3.a151 = 10123, e3.a152 = 10124, e3.a153 = 10125, e3.a154 = 10126, e3.a155 = 10127, e3.a156 = 10128, e3.a157 = 10129, e3.a158 = 10130, e3.a159 = 10131, e3.a160 = 10132, e3.a161 = 8594, e3.a163 = 8596, e3.a164 = 8597, e3.a196 = 10136, e3.a165 = 10137, e3.a192 = 10138, e3.a166 = 10139, e3.a167 = 10140, e3.a168 = 10141, e3.a169 = 10142, e3.a170 = 10143, e3.a171 = 10144, e3.a172 = 10145, e3.a173 = 10146, e3.a162 = 10147, e3.a174 = 10148, e3.a175 = 10149, e3.a176 = 10150, e3.a177 = 10151, e3.a178 = 10152, e3.a179 = 10153, e3.a193 = 10154, e3.a180 = 10155, e3.a199 = 10156, e3.a181 = 10157, e3.a200 = 10158, e3.a182 = 10159, e3.a201 = 10161, e3.a183 = 10162, e3.a184 = 10163, e3.a197 = 10164, e3.a185 = 10165, e3.a194 = 10166, e3.a198 = 10167, e3.a186 = 10168, e3.a195 = 10169, e3.a187 = 10170, e3.a188 = 10171, e3.a189 = 10172, e3.a190 = 10173, e3.a191 = 10174, e3.a89 = 10088, e3.a90 = 10089, e3.a93 = 10090, e3.a94 = 10091, e3.a91 = 10092, e3.a92 = 10093, e3.a205 = 10094, e3.a85 = 10095, e3.a206 = 10096, e3.a86 = 10097, e3.a87 = 10098, e3.a88 = 10099, e3.a95 = 10100, e3.a96 = 10101, e3[".notdef"] = 0;
    });
    sr = getLookupTableFactory(function(e3) {
      e3[63721] = 169, e3[63193] = 169, e3[63720] = 174, e3[63194] = 174, e3[63722] = 8482, e3[63195] = 8482, e3[63729] = 9127, e3[63730] = 9128, e3[63731] = 9129, e3[63740] = 9131, e3[63741] = 9132, e3[63742] = 9133, e3[63726] = 9121, e3[63727] = 9122, e3[63728] = 9123, e3[63737] = 9124, e3[63738] = 9125, e3[63739] = 9126, e3[63723] = 9115, e3[63724] = 9116, e3[63725] = 9117, e3[63734] = 9118, e3[63735] = 9119, e3[63736] = 9120;
    });
    nr = [[0, 127], [128, 255], [256, 383], [384, 591], [592, 687, 7424, 7551, 7552, 7615], [688, 767, 42752, 42783], [768, 879, 7616, 7679], [880, 1023], [11392, 11519], [1024, 1279, 1280, 1327, 11744, 11775, 42560, 42655], [1328, 1423], [1424, 1535], [42240, 42559], [1536, 1791, 1872, 1919], [1984, 2047], [2304, 2431], [2432, 2559], [2560, 2687], [2688, 2815], [2816, 2943], [2944, 3071], [3072, 3199], [3200, 3327], [3328, 3455], [3584, 3711], [3712, 3839], [4256, 4351, 11520, 11567], [6912, 7039], [4352, 4607], [7680, 7935, 11360, 11391, 42784, 43007], [7936, 8191], [8192, 8303, 11776, 11903], [8304, 8351], [8352, 8399], [8400, 8447], [8448, 8527], [8528, 8591], [8592, 8703, 10224, 10239, 10496, 10623, 11008, 11263], [8704, 8959, 10752, 11007, 10176, 10223, 10624, 10751], [8960, 9215], [9216, 9279], [9280, 9311], [9312, 9471], [9472, 9599], [9600, 9631], [9632, 9727], [9728, 9983], [9984, 10175], [12288, 12351], [12352, 12447], [12448, 12543, 12784, 12799], [12544, 12591, 12704, 12735], [12592, 12687], [43072, 43135], [12800, 13055], [13056, 13311], [44032, 55215], [55296, 57343], [67840, 67871], [19968, 40959, 11904, 12031, 12032, 12255, 12272, 12287, 13312, 19903, 131072, 173791, 12688, 12703], [57344, 63743], [12736, 12783, 63744, 64255, 194560, 195103], [64256, 64335], [64336, 65023], [65056, 65071], [65040, 65055], [65104, 65135], [65136, 65279], [65280, 65519], [65520, 65535], [3840, 4095], [1792, 1871], [1920, 1983], [3456, 3583], [4096, 4255], [4608, 4991, 4992, 5023, 11648, 11743], [5024, 5119], [5120, 5759], [5760, 5791], [5792, 5887], [6016, 6143], [6144, 6319], [10240, 10495], [40960, 42127], [5888, 5919, 5920, 5951, 5952, 5983, 5984, 6015], [66304, 66351], [66352, 66383], [66560, 66639], [118784, 119039, 119040, 119295, 119296, 119375], [119808, 120831], [1044480, 1048573], [65024, 65039, 917760, 917999], [917504, 917631], [6400, 6479], [6480, 6527], [6528, 6623], [6656, 6687], [11264, 11359], [11568, 11647], [19904, 19967], [43008, 43055], [65536, 65663, 65664, 65791, 65792, 65855], [65856, 65935], [66432, 66463], [66464, 66527], [66640, 66687], [66688, 66735], [67584, 67647], [68096, 68191], [119552, 119647], [73728, 74751, 74752, 74879], [119648, 119679], [7040, 7103], [7168, 7247], [7248, 7295], [43136, 43231], [43264, 43311], [43312, 43359], [43520, 43615], [65936, 65999], [66e3, 66047], [66208, 66271, 66176, 66207, 67872, 67903], [127024, 127135, 126976, 127023]];
    rr = new RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u");
    or = /* @__PURE__ */ new Map();
    gr = true;
    cr = 1;
    hr = 2;
    lr = 4;
    Ir = 32;
    Cr = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
    dr = getLookupTableFactory((e3) => {
      e3[8211] = 65074, e3[8212] = 65073, e3[8229] = 65072, e3[8230] = 65049, e3[12289] = 65041, e3[12290] = 65042, e3[12296] = 65087, e3[12297] = 65088, e3[12298] = 65085, e3[12299] = 65086, e3[12300] = 65089, e3[12301] = 65090, e3[12302] = 65091, e3[12303] = 65092, e3[12304] = 65083, e3[12305] = 65084, e3[12308] = 65081, e3[12309] = 65082, e3[12310] = 65047, e3[12311] = 65048, e3[65103] = 65076, e3[65281] = 65045, e3[65288] = 65077, e3[65289] = 65078, e3[65292] = 65040, e3[65306] = 65043, e3[65307] = 65044, e3[65311] = 65046, e3[65339] = 65095, e3[65341] = 65096, e3[65343] = 65075, e3[65371] = 65079, e3[65373] = 65080;
    });
    ur = getLookupTableFactory(function(e3) {
      e3["Times-Roman"] = "Times-Roman", e3.Helvetica = "Helvetica", e3.Courier = "Courier", e3.Symbol = "Symbol", e3["Times-Bold"] = "Times-Bold", e3["Helvetica-Bold"] = "Helvetica-Bold", e3["Courier-Bold"] = "Courier-Bold", e3.ZapfDingbats = "ZapfDingbats", e3["Times-Italic"] = "Times-Italic", e3["Helvetica-Oblique"] = "Helvetica-Oblique", e3["Courier-Oblique"] = "Courier-Oblique", e3["Times-BoldItalic"] = "Times-BoldItalic", e3["Helvetica-BoldOblique"] = "Helvetica-BoldOblique", e3["Courier-BoldOblique"] = "Courier-BoldOblique", e3.ArialNarrow = "Helvetica", e3["ArialNarrow-Bold"] = "Helvetica-Bold", e3["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique", e3["ArialNarrow-Italic"] = "Helvetica-Oblique", e3.ArialBlack = "Helvetica", e3["ArialBlack-Bold"] = "Helvetica-Bold", e3["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique", e3["ArialBlack-Italic"] = "Helvetica-Oblique", e3["Arial-Black"] = "Helvetica", e3["Arial-Black-Bold"] = "Helvetica-Bold", e3["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique", e3["Arial-Black-Italic"] = "Helvetica-Oblique", e3.Arial = "Helvetica", e3["Arial-Bold"] = "Helvetica-Bold", e3["Arial-BoldItalic"] = "Helvetica-BoldOblique", e3["Arial-Italic"] = "Helvetica-Oblique", e3.ArialMT = "Helvetica", e3["Arial-BoldItalicMT"] = "Helvetica-BoldOblique", e3["Arial-BoldMT"] = "Helvetica-Bold", e3["Arial-ItalicMT"] = "Helvetica-Oblique", e3["Arial-BoldItalicMT-BoldItalic"] = "Helvetica-BoldOblique", e3["Arial-BoldMT-Bold"] = "Helvetica-Bold", e3["Arial-ItalicMT-Italic"] = "Helvetica-Oblique", e3.ArialUnicodeMS = "Helvetica", e3["ArialUnicodeMS-Bold"] = "Helvetica-Bold", e3["ArialUnicodeMS-BoldItalic"] = "Helvetica-BoldOblique", e3["ArialUnicodeMS-Italic"] = "Helvetica-Oblique", e3["Courier-BoldItalic"] = "Courier-BoldOblique", e3["Courier-Italic"] = "Courier-Oblique", e3.CourierNew = "Courier", e3["CourierNew-Bold"] = "Courier-Bold", e3["CourierNew-BoldItalic"] = "Courier-BoldOblique", e3["CourierNew-Italic"] = "Courier-Oblique", e3["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique", e3["CourierNewPS-BoldMT"] = "Courier-Bold", e3["CourierNewPS-ItalicMT"] = "Courier-Oblique", e3.CourierNewPSMT = "Courier", e3["Helvetica-BoldItalic"] = "Helvetica-BoldOblique", e3["Helvetica-Italic"] = "Helvetica-Oblique", e3["Symbol-Bold"] = "Symbol", e3["Symbol-BoldItalic"] = "Symbol", e3["Symbol-Italic"] = "Symbol", e3.TimesNewRoman = "Times-Roman", e3["TimesNewRoman-Bold"] = "Times-Bold", e3["TimesNewRoman-BoldItalic"] = "Times-BoldItalic", e3["TimesNewRoman-Italic"] = "Times-Italic", e3.TimesNewRomanPS = "Times-Roman", e3["TimesNewRomanPS-Bold"] = "Times-Bold", e3["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic", e3["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic", e3["TimesNewRomanPS-BoldMT"] = "Times-Bold", e3["TimesNewRomanPS-Italic"] = "Times-Italic", e3["TimesNewRomanPS-ItalicMT"] = "Times-Italic", e3.TimesNewRomanPSMT = "Times-Roman", e3["TimesNewRomanPSMT-Bold"] = "Times-Bold", e3["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic", e3["TimesNewRomanPSMT-Italic"] = "Times-Italic";
    });
    Qr = getLookupTableFactory(function(e3) {
      e3.Courier = "FoxitFixed.pfb", e3["Courier-Bold"] = "FoxitFixedBold.pfb", e3["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb", e3["Courier-Oblique"] = "FoxitFixedItalic.pfb", e3.Helvetica = "LiberationSans-Regular.ttf", e3["Helvetica-Bold"] = "LiberationSans-Bold.ttf", e3["Helvetica-BoldOblique"] = "LiberationSans-BoldItalic.ttf", e3["Helvetica-Oblique"] = "LiberationSans-Italic.ttf", e3["Times-Roman"] = "FoxitSerif.pfb", e3["Times-Bold"] = "FoxitSerifBold.pfb", e3["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb", e3["Times-Italic"] = "FoxitSerifItalic.pfb", e3.Symbol = "FoxitSymbol.pfb", e3.ZapfDingbats = "FoxitDingbats.pfb", e3["LiberationSans-Regular"] = "LiberationSans-Regular.ttf", e3["LiberationSans-Bold"] = "LiberationSans-Bold.ttf", e3["LiberationSans-Italic"] = "LiberationSans-Italic.ttf", e3["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
    });
    Er = getLookupTableFactory(function(e3) {
      e3.Calibri = "Helvetica", e3["Calibri-Bold"] = "Helvetica-Bold", e3["Calibri-BoldItalic"] = "Helvetica-BoldOblique", e3["Calibri-Italic"] = "Helvetica-Oblique", e3.CenturyGothic = "Helvetica", e3["CenturyGothic-Bold"] = "Helvetica-Bold", e3["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique", e3["CenturyGothic-Italic"] = "Helvetica-Oblique", e3.ComicSansMS = "Comic Sans MS", e3["ComicSansMS-Bold"] = "Comic Sans MS-Bold", e3["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic", e3["ComicSansMS-Italic"] = "Comic Sans MS-Italic", e3.Impact = "Helvetica", e3["ItcSymbol-Bold"] = "Helvetica-Bold", e3["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique", e3["ItcSymbol-Book"] = "Helvetica", e3["ItcSymbol-BookItalic"] = "Helvetica-Oblique", e3["ItcSymbol-Medium"] = "Helvetica", e3["ItcSymbol-MediumItalic"] = "Helvetica-Oblique", e3.LucidaConsole = "Courier", e3["LucidaConsole-Bold"] = "Courier-Bold", e3["LucidaConsole-BoldItalic"] = "Courier-BoldOblique", e3["LucidaConsole-Italic"] = "Courier-Oblique", e3["LucidaSans-Demi"] = "Helvetica-Bold", e3["MS-Gothic"] = "MS Gothic", e3["MS-Gothic-Bold"] = "MS Gothic-Bold", e3["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic", e3["MS-Gothic-Italic"] = "MS Gothic-Italic", e3["MS-Mincho"] = "MS Mincho", e3["MS-Mincho-Bold"] = "MS Mincho-Bold", e3["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic", e3["MS-Mincho-Italic"] = "MS Mincho-Italic", e3["MS-PGothic"] = "MS PGothic", e3["MS-PGothic-Bold"] = "MS PGothic-Bold", e3["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic", e3["MS-PGothic-Italic"] = "MS PGothic-Italic", e3["MS-PMincho"] = "MS PMincho", e3["MS-PMincho-Bold"] = "MS PMincho-Bold", e3["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic", e3["MS-PMincho-Italic"] = "MS PMincho-Italic", e3.NuptialScript = "Times-Italic", e3.SegoeUISymbol = "Helvetica";
    });
    fr = getLookupTableFactory(function(e3) {
      e3["Adobe Jenson"] = true, e3["Adobe Text"] = true, e3.Albertus = true, e3.Aldus = true, e3.Alexandria = true, e3.Algerian = true, e3["American Typewriter"] = true, e3.Antiqua = true, e3.Apex = true, e3.Arno = true, e3.Aster = true, e3.Aurora = true, e3.Baskerville = true, e3.Bell = true, e3.Bembo = true, e3["Bembo Schoolbook"] = true, e3.Benguiat = true, e3["Berkeley Old Style"] = true, e3["Bernhard Modern"] = true, e3["Berthold City"] = true, e3.Bodoni = true, e3["Bauer Bodoni"] = true, e3["Book Antiqua"] = true, e3.Bookman = true, e3["Bordeaux Roman"] = true, e3["Californian FB"] = true, e3.Calisto = true, e3.Calvert = true, e3.Capitals = true, e3.Cambria = true, e3.Cartier = true, e3.Caslon = true, e3.Catull = true, e3.Centaur = true, e3["Century Old Style"] = true, e3["Century Schoolbook"] = true, e3.Chaparral = true, e3["Charis SIL"] = true, e3.Cheltenham = true, e3["Cholla Slab"] = true, e3.Clarendon = true, e3.Clearface = true, e3.Cochin = true, e3.Colonna = true, e3["Computer Modern"] = true, e3["Concrete Roman"] = true, e3.Constantia = true, e3["Cooper Black"] = true, e3.Corona = true, e3.Ecotype = true, e3.Egyptienne = true, e3.Elephant = true, e3.Excelsior = true, e3.Fairfield = true, e3["FF Scala"] = true, e3.Folkard = true, e3.Footlight = true, e3.FreeSerif = true, e3["Friz Quadrata"] = true, e3.Garamond = true, e3.Gentium = true, e3.Georgia = true, e3.Gloucester = true, e3["Goudy Old Style"] = true, e3["Goudy Schoolbook"] = true, e3["Goudy Pro Font"] = true, e3.Granjon = true, e3["Guardian Egyptian"] = true, e3.Heather = true, e3.Hercules = true, e3["High Tower Text"] = true, e3.Hiroshige = true, e3["Hoefler Text"] = true, e3["Humana Serif"] = true, e3.Imprint = true, e3["Ionic No. 5"] = true, e3.Janson = true, e3.Joanna = true, e3.Korinna = true, e3.Lexicon = true, e3.LiberationSerif = true, e3["Liberation Serif"] = true, e3["Linux Libertine"] = true, e3.Literaturnaya = true, e3.Lucida = true, e3["Lucida Bright"] = true, e3.Melior = true, e3.Memphis = true, e3.Miller = true, e3.Minion = true, e3.Modern = true, e3["Mona Lisa"] = true, e3["Mrs Eaves"] = true, e3["MS Serif"] = true, e3["Museo Slab"] = true, e3["New York"] = true, e3["Nimbus Roman"] = true, e3["NPS Rawlinson Roadway"] = true, e3.NuptialScript = true, e3.Palatino = true, e3.Perpetua = true, e3.Plantin = true, e3["Plantin Schoolbook"] = true, e3.Playbill = true, e3["Poor Richard"] = true, e3["Rawlinson Roadway"] = true, e3.Renault = true, e3.Requiem = true, e3.Rockwell = true, e3.Roman = true, e3["Rotis Serif"] = true, e3.Sabon = true, e3.Scala = true, e3.Seagull = true, e3.Sistina = true, e3.Souvenir = true, e3.STIX = true, e3["Stone Informal"] = true, e3["Stone Serif"] = true, e3.Sylfaen = true, e3.Times = true, e3.Trajan = true, e3["Trinit\xE9"] = true, e3["Trump Mediaeval"] = true, e3.Utopia = true, e3["Vale Type"] = true, e3["Bitstream Vera"] = true, e3["Vera Serif"] = true, e3.Versailles = true, e3.Wanted = true, e3.Weiss = true, e3["Wide Latin"] = true, e3.Windsor = true, e3.XITS = true;
    });
    pr = getLookupTableFactory(function(e3) {
      e3.Dingbats = true, e3.Symbol = true, e3.ZapfDingbats = true, e3.Wingdings = true, e3["Wingdings-Bold"] = true, e3["Wingdings-Regular"] = true;
    });
    mr = getLookupTableFactory(function(e3) {
      e3[2] = 10, e3[3] = 32, e3[4] = 33, e3[5] = 34, e3[6] = 35, e3[7] = 36, e3[8] = 37, e3[9] = 38, e3[10] = 39, e3[11] = 40, e3[12] = 41, e3[13] = 42, e3[14] = 43, e3[15] = 44, e3[16] = 45, e3[17] = 46, e3[18] = 47, e3[19] = 48, e3[20] = 49, e3[21] = 50, e3[22] = 51, e3[23] = 52, e3[24] = 53, e3[25] = 54, e3[26] = 55, e3[27] = 56, e3[28] = 57, e3[29] = 58, e3[30] = 894, e3[31] = 60, e3[32] = 61, e3[33] = 62, e3[34] = 63, e3[35] = 64, e3[36] = 65, e3[37] = 66, e3[38] = 67, e3[39] = 68, e3[40] = 69, e3[41] = 70, e3[42] = 71, e3[43] = 72, e3[44] = 73, e3[45] = 74, e3[46] = 75, e3[47] = 76, e3[48] = 77, e3[49] = 78, e3[50] = 79, e3[51] = 80, e3[52] = 81, e3[53] = 82, e3[54] = 83, e3[55] = 84, e3[56] = 85, e3[57] = 86, e3[58] = 87, e3[59] = 88, e3[60] = 89, e3[61] = 90, e3[62] = 91, e3[63] = 92, e3[64] = 93, e3[65] = 94, e3[66] = 95, e3[67] = 96, e3[68] = 97, e3[69] = 98, e3[70] = 99, e3[71] = 100, e3[72] = 101, e3[73] = 102, e3[74] = 103, e3[75] = 104, e3[76] = 105, e3[77] = 106, e3[78] = 107, e3[79] = 108, e3[80] = 109, e3[81] = 110, e3[82] = 111, e3[83] = 112, e3[84] = 113, e3[85] = 114, e3[86] = 115, e3[87] = 116, e3[88] = 117, e3[89] = 118, e3[90] = 119, e3[91] = 120, e3[92] = 121, e3[93] = 122, e3[94] = 123, e3[95] = 124, e3[96] = 125, e3[97] = 126, e3[98] = 196, e3[99] = 197, e3[100] = 199, e3[101] = 201, e3[102] = 209, e3[103] = 214, e3[104] = 220, e3[105] = 225, e3[106] = 224, e3[107] = 226, e3[108] = 228, e3[109] = 227, e3[110] = 229, e3[111] = 231, e3[112] = 233, e3[113] = 232, e3[114] = 234, e3[115] = 235, e3[116] = 237, e3[117] = 236, e3[118] = 238, e3[119] = 239, e3[120] = 241, e3[121] = 243, e3[122] = 242, e3[123] = 244, e3[124] = 246, e3[125] = 245, e3[126] = 250, e3[127] = 249, e3[128] = 251, e3[129] = 252, e3[130] = 8224, e3[131] = 176, e3[132] = 162, e3[133] = 163, e3[134] = 167, e3[135] = 8226, e3[136] = 182, e3[137] = 223, e3[138] = 174, e3[139] = 169, e3[140] = 8482, e3[141] = 180, e3[142] = 168, e3[143] = 8800, e3[144] = 198, e3[145] = 216, e3[146] = 8734, e3[147] = 177, e3[148] = 8804, e3[149] = 8805, e3[150] = 165, e3[151] = 181, e3[152] = 8706, e3[153] = 8721, e3[154] = 8719, e3[156] = 8747, e3[157] = 170, e3[158] = 186, e3[159] = 8486, e3[160] = 230, e3[161] = 248, e3[162] = 191, e3[163] = 161, e3[164] = 172, e3[165] = 8730, e3[166] = 402, e3[167] = 8776, e3[168] = 8710, e3[169] = 171, e3[170] = 187, e3[171] = 8230, e3[179] = 8220, e3[180] = 8221, e3[181] = 8216, e3[182] = 8217, e3[200] = 193, e3[203] = 205, e3[207] = 211, e3[210] = 218, e3[223] = 711, e3[224] = 321, e3[225] = 322, e3[226] = 352, e3[227] = 353, e3[228] = 381, e3[229] = 382, e3[233] = 221, e3[234] = 253, e3[252] = 263, e3[253] = 268, e3[254] = 269, e3[258] = 258, e3[260] = 260, e3[261] = 261, e3[265] = 280, e3[266] = 281, e3[267] = 282, e3[268] = 283, e3[269] = 313, e3[275] = 323, e3[276] = 324, e3[278] = 328, e3[283] = 344, e3[284] = 345, e3[285] = 346, e3[286] = 347, e3[292] = 367, e3[295] = 377, e3[296] = 378, e3[298] = 380, e3[305] = 963, e3[306] = 964, e3[307] = 966, e3[308] = 8215, e3[309] = 8252, e3[310] = 8319, e3[311] = 8359, e3[312] = 8592, e3[313] = 8593, e3[337] = 9552, e3[493] = 1039, e3[494] = 1040, e3[672] = 1488, e3[673] = 1489, e3[674] = 1490, e3[675] = 1491, e3[676] = 1492, e3[677] = 1493, e3[678] = 1494, e3[679] = 1495, e3[680] = 1496, e3[681] = 1497, e3[682] = 1498, e3[683] = 1499, e3[684] = 1500, e3[685] = 1501, e3[686] = 1502, e3[687] = 1503, e3[688] = 1504, e3[689] = 1505, e3[690] = 1506, e3[691] = 1507, e3[692] = 1508, e3[693] = 1509, e3[694] = 1510, e3[695] = 1511, e3[696] = 1512, e3[697] = 1513, e3[698] = 1514, e3[705] = 1524, e3[706] = 8362, e3[710] = 64288, e3[711] = 64298, e3[759] = 1617, e3[761] = 1776, e3[763] = 1778, e3[775] = 1652, e3[777] = 1764, e3[778] = 1780, e3[779] = 1781, e3[780] = 1782, e3[782] = 771, e3[783] = 64726, e3[786] = 8363, e3[788] = 8532, e3[790] = 768, e3[791] = 769, e3[792] = 768, e3[795] = 803, e3[797] = 64336, e3[798] = 64337, e3[799] = 64342, e3[800] = 64343, e3[801] = 64344, e3[802] = 64345, e3[803] = 64362, e3[804] = 64363, e3[805] = 64364, e3[2424] = 7821, e3[2425] = 7822, e3[2426] = 7823, e3[2427] = 7824, e3[2428] = 7825, e3[2429] = 7826, e3[2430] = 7827, e3[2433] = 7682, e3[2678] = 8045, e3[2679] = 8046, e3[2830] = 1552, e3[2838] = 686, e3[2840] = 751, e3[2842] = 753, e3[2843] = 754, e3[2844] = 755, e3[2846] = 757, e3[2856] = 767, e3[2857] = 848, e3[2858] = 849, e3[2862] = 853, e3[2863] = 854, e3[2864] = 855, e3[2865] = 861, e3[2866] = 862, e3[2906] = 7460, e3[2908] = 7462, e3[2909] = 7463, e3[2910] = 7464, e3[2912] = 7466, e3[2913] = 7467, e3[2914] = 7468, e3[2916] = 7470, e3[2917] = 7471, e3[2918] = 7472, e3[2920] = 7474, e3[2921] = 7475, e3[2922] = 7476, e3[2924] = 7478, e3[2925] = 7479, e3[2926] = 7480, e3[2928] = 7482, e3[2929] = 7483, e3[2930] = 7484, e3[2932] = 7486, e3[2933] = 7487, e3[2934] = 7488, e3[2936] = 7490, e3[2937] = 7491, e3[2938] = 7492, e3[2940] = 7494, e3[2941] = 7495, e3[2942] = 7496, e3[2944] = 7498, e3[2946] = 7500, e3[2948] = 7502, e3[2950] = 7504, e3[2951] = 7505, e3[2952] = 7506, e3[2954] = 7508, e3[2955] = 7509, e3[2956] = 7510, e3[2958] = 7512, e3[2959] = 7513, e3[2960] = 7514, e3[2962] = 7516, e3[2963] = 7517, e3[2964] = 7518, e3[2966] = 7520, e3[2967] = 7521, e3[2968] = 7522, e3[2970] = 7524, e3[2971] = 7525, e3[2972] = 7526, e3[2974] = 7528, e3[2975] = 7529, e3[2976] = 7530, e3[2978] = 1537, e3[2979] = 1538, e3[2980] = 1539, e3[2982] = 1549, e3[2983] = 1551, e3[2984] = 1552, e3[2986] = 1554, e3[2987] = 1555, e3[2988] = 1556, e3[2990] = 1623, e3[2991] = 1624, e3[2995] = 1775, e3[2999] = 1791, e3[3002] = 64290, e3[3003] = 64291, e3[3004] = 64292, e3[3006] = 64294, e3[3007] = 64295, e3[3008] = 64296, e3[3011] = 1900, e3[3014] = 8223, e3[3015] = 8244, e3[3017] = 7532, e3[3018] = 7533, e3[3019] = 7534, e3[3075] = 7590, e3[3076] = 7591, e3[3079] = 7594, e3[3080] = 7595, e3[3083] = 7598, e3[3084] = 7599, e3[3087] = 7602, e3[3088] = 7603, e3[3091] = 7606, e3[3092] = 7607, e3[3095] = 7610, e3[3096] = 7611, e3[3099] = 7614, e3[3100] = 7615, e3[3103] = 7618, e3[3104] = 7619, e3[3107] = 8337, e3[3108] = 8338, e3[3116] = 1884, e3[3119] = 1885, e3[3120] = 1885, e3[3123] = 1886, e3[3124] = 1886, e3[3127] = 1887, e3[3128] = 1887, e3[3131] = 1888, e3[3132] = 1888, e3[3135] = 1889, e3[3136] = 1889, e3[3139] = 1890, e3[3140] = 1890, e3[3143] = 1891, e3[3144] = 1891, e3[3147] = 1892, e3[3148] = 1892, e3[3153] = 580, e3[3154] = 581, e3[3157] = 584, e3[3158] = 585, e3[3161] = 588, e3[3162] = 589, e3[3165] = 891, e3[3166] = 892, e3[3169] = 1274, e3[3170] = 1275, e3[3173] = 1278, e3[3174] = 1279, e3[3181] = 7622, e3[3182] = 7623, e3[3282] = 11799, e3[3316] = 578, e3[3379] = 42785, e3[3393] = 1159, e3[3416] = 8377;
    });
    yr = getLookupTableFactory(function(e3) {
      e3[227] = 322, e3[264] = 261, e3[291] = 346;
    });
    wr = getLookupTableFactory(function(e3) {
      e3[1] = 32, e3[4] = 65, e3[5] = 192, e3[6] = 193, e3[9] = 196, e3[17] = 66, e3[18] = 67, e3[21] = 268, e3[24] = 68, e3[28] = 69, e3[29] = 200, e3[30] = 201, e3[32] = 282, e3[38] = 70, e3[39] = 71, e3[44] = 72, e3[47] = 73, e3[48] = 204, e3[49] = 205, e3[58] = 74, e3[60] = 75, e3[62] = 76, e3[68] = 77, e3[69] = 78, e3[75] = 79, e3[76] = 210, e3[80] = 214, e3[87] = 80, e3[89] = 81, e3[90] = 82, e3[92] = 344, e3[94] = 83, e3[97] = 352, e3[100] = 84, e3[104] = 85, e3[109] = 220, e3[115] = 86, e3[116] = 87, e3[121] = 88, e3[122] = 89, e3[124] = 221, e3[127] = 90, e3[129] = 381, e3[258] = 97, e3[259] = 224, e3[260] = 225, e3[263] = 228, e3[268] = 261, e3[271] = 98, e3[272] = 99, e3[273] = 263, e3[275] = 269, e3[282] = 100, e3[286] = 101, e3[287] = 232, e3[288] = 233, e3[290] = 283, e3[295] = 281, e3[296] = 102, e3[336] = 103, e3[346] = 104, e3[349] = 105, e3[350] = 236, e3[351] = 237, e3[361] = 106, e3[364] = 107, e3[367] = 108, e3[371] = 322, e3[373] = 109, e3[374] = 110, e3[381] = 111, e3[382] = 242, e3[383] = 243, e3[386] = 246, e3[393] = 112, e3[395] = 113, e3[396] = 114, e3[398] = 345, e3[400] = 115, e3[401] = 347, e3[403] = 353, e3[410] = 116, e3[437] = 117, e3[442] = 252, e3[448] = 118, e3[449] = 119, e3[454] = 120, e3[455] = 121, e3[457] = 253, e3[460] = 122, e3[462] = 382, e3[463] = 380, e3[853] = 44, e3[855] = 58, e3[856] = 46, e3[876] = 47, e3[878] = 45, e3[882] = 45, e3[894] = 40, e3[895] = 41, e3[896] = 91, e3[897] = 93, e3[923] = 64, e3[1004] = 48, e3[1005] = 49, e3[1006] = 50, e3[1007] = 51, e3[1008] = 52, e3[1009] = 53, e3[1010] = 54, e3[1011] = 55, e3[1012] = 56, e3[1013] = 57, e3[1081] = 37, e3[1085] = 43, e3[1086] = 45;
    });
    ToUnicodeMap = class {
      constructor(e3 = []) {
        this._map = e3;
      }
      get length() {
        return this._map.length;
      }
      forEach(e3) {
        for (const t3 in this._map) e3(t3, this._map[t3].charCodeAt(0));
      }
      has(e3) {
        return void 0 !== this._map[e3];
      }
      get(e3) {
        return this._map[e3];
      }
      charCodeOf(e3) {
        const t3 = this._map;
        if (t3.length <= 65536) return t3.indexOf(e3);
        for (const i3 in t3) if (t3[i3] === e3) return 0 | i3;
        return -1;
      }
      amend(e3) {
        for (const t3 in e3) this._map[t3] = e3[t3];
      }
    };
    IdentityToUnicodeMap = class {
      constructor(e3, t3) {
        this.firstChar = e3, this.lastChar = t3;
      }
      get length() {
        return this.lastChar + 1 - this.firstChar;
      }
      forEach(e3) {
        for (let t3 = this.firstChar, i3 = this.lastChar; t3 <= i3; t3++) e3(t3, t3);
      }
      has(e3) {
        return this.firstChar <= e3 && e3 <= this.lastChar;
      }
      get(e3) {
        if (this.firstChar <= e3 && e3 <= this.lastChar) return String.fromCharCode(e3);
      }
      charCodeOf(e3) {
        return Number.isInteger(e3) && e3 >= this.firstChar && e3 <= this.lastChar ? e3 : -1;
      }
      amend(e3) {
        unreachable("Should not call amend()");
      }
    };
    CFFFont = class {
      constructor(e3, t3) {
        this.properties = t3;
        const i3 = new CFFParser(e3, t3, gr);
        this.cff = i3.parse(), this.cff.duplicateFirstGlyph();
        const a3 = new CFFCompiler(this.cff);
        this.seacs = this.cff.seacs;
        try {
          this.data = a3.compile();
        } catch {
          warn("Failed to compile font " + t3.loadedName), this.data = e3;
        }
        this._createBuiltInEncoding();
      }
      get numGlyphs() {
        return this.cff.charStrings.count;
      }
      getCharset() {
        return this.cff.charset.charset;
      }
      getGlyphMapping() {
        const e3 = this.cff, t3 = this.properties, { cidToGidMap: i3, cMap: a3 } = t3, s3 = e3.charset.charset;
        let n3, r3;
        if (t3.composite) {
          let t4, o4;
          if (i3?.length > 0) {
            t4 = /* @__PURE__ */ Object.create(null);
            for (let e4 = 0, a4 = i3.length; e4 < a4; e4++) {
              const a5 = i3[e4];
              void 0 !== a5 && (t4[a5] = e4);
            }
          }
          if (n3 = /* @__PURE__ */ Object.create(null), e3.isCIDFont) for (r3 = 0; r3 < s3.length; r3++) {
            const e4 = s3[r3];
            o4 = a3.charCodeOf(e4), void 0 !== t4?.[o4] && (o4 = t4[o4]), n3[o4] = r3;
          }
          else for (r3 = 0; r3 < e3.charStrings.count; r3++) o4 = a3.charCodeOf(r3), n3[o4] = r3;
          return n3;
        }
        let o3 = e3.encoding ? e3.encoding.encoding : null;
        return t3.isInternalFont && (o3 = t3.defaultEncoding), n3 = type1FontGlyphMapping(t3, o3, s3), n3;
      }
      hasGlyphId(e3) {
        return this.cff.hasGlyphId(e3);
      }
      _createBuiltInEncoding() {
        const { charset: e3, encoding: t3 } = this.cff;
        if (!e3 || !t3) return;
        const i3 = e3.charset, a3 = t3.encoding, s3 = [];
        for (const e4 in a3) {
          const t4 = a3[e4];
          if (t4 >= 0) {
            const a4 = i3[t4];
            a4 && (s3[e4] = a4);
          }
        }
        s3.length > 0 && (this.properties.builtInEncoding = s3);
      }
    };
    br = [];
    Commands = class {
      constructor() {
        __publicField(this, "cmds", []);
      }
      add(e3, t3) {
        if (t3) if (isNumberArray(t3, null)) this.cmds.push(e3, ...t3);
        else {
          warn(`Commands.add - "${e3}" has at least one non-number arg: "${t3}".`);
          const i3 = t3.map((e4) => "number" == typeof e4 ? e4 : 0);
          this.cmds.push(e3, ...i3);
        }
        else this.cmds.push(e3);
      }
    };
    CompiledFont = class {
      constructor(e3) {
        this.fontMatrix = e3, this.compiledGlyphs = /* @__PURE__ */ Object.create(null), this.compiledCharCodeToGlyphId = /* @__PURE__ */ Object.create(null);
      }
      getPathJs(e3) {
        var _a4;
        const { charCode: t3, glyphId: i3 } = lookupCmap(this.cmap, e3);
        let a3, s3 = this.compiledGlyphs[i3];
        if (!s3) {
          try {
            s3 = this.compileGlyph(this.glyphs[i3], i3);
          } catch (e4) {
            s3 = br, a3 = e4;
          }
          this.compiledGlyphs[i3] = s3;
        }
        if ((_a4 = this.compiledCharCodeToGlyphId)[t3] ?? (_a4[t3] = i3), a3) throw a3;
        return s3;
      }
      compileGlyph(e3, t3) {
        if (!e3 || 0 === e3.length || 14 === e3[0]) return br;
        let i3 = this.fontMatrix;
        if (this.isCFFCIDFont) {
          const e4 = this.fdSelect.getFDIndex(t3);
          if (e4 >= 0 && e4 < this.fdArray.length) {
            i3 = this.fdArray[e4].getByName("FontMatrix") || SA;
          } else warn("Invalid fd index for glyph index.");
        }
        const a3 = new Commands();
        return a3.add(Ks), a3.add(_s, i3.slice()), a3.add(qs), this.compileGlyphImpl(e3, a3, t3), a3.add(Os), a3.cmds;
      }
      compileGlyphImpl() {
        unreachable("Children classes should implement this.");
      }
      hasBuiltPath(e3) {
        const { charCode: t3, glyphId: i3 } = lookupCmap(this.cmap, e3);
        return void 0 !== this.compiledGlyphs[i3] && void 0 !== this.compiledCharCodeToGlyphId[t3];
      }
    };
    TrueTypeCompiled = class extends CompiledFont {
      constructor(e3, t3, i3) {
        super(i3 || [488e-6, 0, 0, 488e-6, 0, 0]), this.glyphs = e3, this.cmap = t3;
      }
      compileGlyphImpl(e3, t3) {
        compileGlyf(e3, t3, this);
      }
    };
    Type2Compiled = class extends CompiledFont {
      constructor(e3, t3, i3, a3) {
        super(i3 || [1e-3, 0, 0, 1e-3, 0, 0]), this.glyphs = e3.glyphs, this.gsubrs = e3.gsubrs || [], this.subrs = e3.subrs || [], this.cmap = t3, this.glyphNameMap = a3 || ir(), this.gsubrsBias = getSubroutineBias(this.gsubrs), this.subrsBias = getSubroutineBias(this.subrs), this.isCFFCIDFont = e3.isCFFCIDFont, this.fdSelect = e3.fdSelect, this.fdArray = e3.fdArray;
      }
      compileGlyphImpl(e3, t3, i3) {
        compileCharString(e3, t3, this, i3);
      }
    };
    FontRendererFactory = class {
      static create(e3, t3) {
        const i3 = new Uint8Array(e3.data);
        let a3, s3, n3, r3, o3, g3;
        const c3 = getUint16(i3, 4);
        for (let e4 = 0, h3 = 12; e4 < c3; e4++, h3 += 16) {
          const e5 = bytesToString(i3.subarray(h3, h3 + 4)), c4 = getUint32(i3, h3 + 8), l3 = getUint32(i3, h3 + 12);
          switch (e5) {
            case "cmap":
              a3 = parseCmap(i3, c4);
              break;
            case "glyf":
              s3 = i3.subarray(c4, c4 + l3);
              break;
            case "loca":
              n3 = i3.subarray(c4, c4 + l3);
              break;
            case "head":
              g3 = getUint16(i3, c4 + 18), o3 = getUint16(i3, c4 + 50);
              break;
            case "CFF ":
              r3 = parseCff(i3, c4, c4 + l3, t3);
          }
        }
        if (s3) {
          const t4 = g3 ? [1 / g3, 0, 0, 1 / g3, 0, 0] : e3.fontMatrix;
          return new TrueTypeCompiled(function(e4, t5, i4) {
            let a4, s4;
            i4 ? (a4 = 4, s4 = getUint32) : (a4 = 2, s4 = (e5, t6) => 2 * getUint16(e5, t6));
            const n4 = [];
            let r4 = s4(t5, 0);
            for (let i5 = a4; i5 < t5.length; i5 += a4) {
              const a5 = s4(t5, i5);
              n4.push(e4.subarray(r4, a5)), r4 = a5;
            }
            return n4;
          }(s3, n3, o3), a3, t4);
        }
        return new Type2Compiled(r3, a3, e3.fontMatrix, e3.glyphNameMap);
      }
    };
    Dr = getLookupTableFactory(function(e3) {
      e3.Courier = 600, e3["Courier-Bold"] = 600, e3["Courier-BoldOblique"] = 600, e3["Courier-Oblique"] = 600, e3.Helvetica = getLookupTableFactory(function(e4) {
        e4.space = 278, e4.exclam = 278, e4.quotedbl = 355, e4.numbersign = 556, e4.dollar = 556, e4.percent = 889, e4.ampersand = 667, e4.quoteright = 222, e4.parenleft = 333, e4.parenright = 333, e4.asterisk = 389, e4.plus = 584, e4.comma = 278, e4.hyphen = 333, e4.period = 278, e4.slash = 278, e4.zero = 556, e4.one = 556, e4.two = 556, e4.three = 556, e4.four = 556, e4.five = 556, e4.six = 556, e4.seven = 556, e4.eight = 556, e4.nine = 556, e4.colon = 278, e4.semicolon = 278, e4.less = 584, e4.equal = 584, e4.greater = 584, e4.question = 556, e4.at = 1015, e4.A = 667, e4.B = 667, e4.C = 722, e4.D = 722, e4.E = 667, e4.F = 611, e4.G = 778, e4.H = 722, e4.I = 278, e4.J = 500, e4.K = 667, e4.L = 556, e4.M = 833, e4.N = 722, e4.O = 778, e4.P = 667, e4.Q = 778, e4.R = 722, e4.S = 667, e4.T = 611, e4.U = 722, e4.V = 667, e4.W = 944, e4.X = 667, e4.Y = 667, e4.Z = 611, e4.bracketleft = 278, e4.backslash = 278, e4.bracketright = 278, e4.asciicircum = 469, e4.underscore = 556, e4.quoteleft = 222, e4.a = 556, e4.b = 556, e4.c = 500, e4.d = 556, e4.e = 556, e4.f = 278, e4.g = 556, e4.h = 556, e4.i = 222, e4.j = 222, e4.k = 500, e4.l = 222, e4.m = 833, e4.n = 556, e4.o = 556, e4.p = 556, e4.q = 556, e4.r = 333, e4.s = 500, e4.t = 278, e4.u = 556, e4.v = 500, e4.w = 722, e4.x = 500, e4.y = 500, e4.z = 500, e4.braceleft = 334, e4.bar = 260, e4.braceright = 334, e4.asciitilde = 584, e4.exclamdown = 333, e4.cent = 556, e4.sterling = 556, e4.fraction = 167, e4.yen = 556, e4.florin = 556, e4.section = 556, e4.currency = 556, e4.quotesingle = 191, e4.quotedblleft = 333, e4.guillemotleft = 556, e4.guilsinglleft = 333, e4.guilsinglright = 333, e4.fi = 500, e4.fl = 500, e4.endash = 556, e4.dagger = 556, e4.daggerdbl = 556, e4.periodcentered = 278, e4.paragraph = 537, e4.bullet = 350, e4.quotesinglbase = 222, e4.quotedblbase = 333, e4.quotedblright = 333, e4.guillemotright = 556, e4.ellipsis = 1e3, e4.perthousand = 1e3, e4.questiondown = 611, e4.grave = 333, e4.acute = 333, e4.circumflex = 333, e4.tilde = 333, e4.macron = 333, e4.breve = 333, e4.dotaccent = 333, e4.dieresis = 333, e4.ring = 333, e4.cedilla = 333, e4.hungarumlaut = 333, e4.ogonek = 333, e4.caron = 333, e4.emdash = 1e3, e4.AE = 1e3, e4.ordfeminine = 370, e4.Lslash = 556, e4.Oslash = 778, e4.OE = 1e3, e4.ordmasculine = 365, e4.ae = 889, e4.dotlessi = 278, e4.lslash = 222, e4.oslash = 611, e4.oe = 944, e4.germandbls = 611, e4.Idieresis = 278, e4.eacute = 556, e4.abreve = 556, e4.uhungarumlaut = 556, e4.ecaron = 556, e4.Ydieresis = 667, e4.divide = 584, e4.Yacute = 667, e4.Acircumflex = 667, e4.aacute = 556, e4.Ucircumflex = 722, e4.yacute = 500, e4.scommaaccent = 500, e4.ecircumflex = 556, e4.Uring = 722, e4.Udieresis = 722, e4.aogonek = 556, e4.Uacute = 722, e4.uogonek = 556, e4.Edieresis = 667, e4.Dcroat = 722, e4.commaaccent = 250, e4.copyright = 737, e4.Emacron = 667, e4.ccaron = 500, e4.aring = 556, e4.Ncommaaccent = 722, e4.lacute = 222, e4.agrave = 556, e4.Tcommaaccent = 611, e4.Cacute = 722, e4.atilde = 556, e4.Edotaccent = 667, e4.scaron = 500, e4.scedilla = 500, e4.iacute = 278, e4.lozenge = 471, e4.Rcaron = 722, e4.Gcommaaccent = 778, e4.ucircumflex = 556, e4.acircumflex = 556, e4.Amacron = 667, e4.rcaron = 333, e4.ccedilla = 500, e4.Zdotaccent = 611, e4.Thorn = 667, e4.Omacron = 778, e4.Racute = 722, e4.Sacute = 667, e4.dcaron = 643, e4.Umacron = 722, e4.uring = 556, e4.threesuperior = 333, e4.Ograve = 778, e4.Agrave = 667, e4.Abreve = 667, e4.multiply = 584, e4.uacute = 556, e4.Tcaron = 611, e4.partialdiff = 476, e4.ydieresis = 500, e4.Nacute = 722, e4.icircumflex = 278, e4.Ecircumflex = 667, e4.adieresis = 556, e4.edieresis = 556, e4.cacute = 500, e4.nacute = 556, e4.umacron = 556, e4.Ncaron = 722, e4.Iacute = 278, e4.plusminus = 584, e4.brokenbar = 260, e4.registered = 737, e4.Gbreve = 778, e4.Idotaccent = 278, e4.summation = 600, e4.Egrave = 667, e4.racute = 333, e4.omacron = 556, e4.Zacute = 611, e4.Zcaron = 611, e4.greaterequal = 549, e4.Eth = 722, e4.Ccedilla = 722, e4.lcommaaccent = 222, e4.tcaron = 317, e4.eogonek = 556, e4.Uogonek = 722, e4.Aacute = 667, e4.Adieresis = 667, e4.egrave = 556, e4.zacute = 500, e4.iogonek = 222, e4.Oacute = 778, e4.oacute = 556, e4.amacron = 556, e4.sacute = 500, e4.idieresis = 278, e4.Ocircumflex = 778, e4.Ugrave = 722, e4.Delta = 612, e4.thorn = 556, e4.twosuperior = 333, e4.Odieresis = 778, e4.mu = 556, e4.igrave = 278, e4.ohungarumlaut = 556, e4.Eogonek = 667, e4.dcroat = 556, e4.threequarters = 834, e4.Scedilla = 667, e4.lcaron = 299, e4.Kcommaaccent = 667, e4.Lacute = 556, e4.trademark = 1e3, e4.edotaccent = 556, e4.Igrave = 278, e4.Imacron = 278, e4.Lcaron = 556, e4.onehalf = 834, e4.lessequal = 549, e4.ocircumflex = 556, e4.ntilde = 556, e4.Uhungarumlaut = 722, e4.Eacute = 667, e4.emacron = 556, e4.gbreve = 556, e4.onequarter = 834, e4.Scaron = 667, e4.Scommaaccent = 667, e4.Ohungarumlaut = 778, e4.degree = 400, e4.ograve = 556, e4.Ccaron = 722, e4.ugrave = 556, e4.radical = 453, e4.Dcaron = 722, e4.rcommaaccent = 333, e4.Ntilde = 722, e4.otilde = 556, e4.Rcommaaccent = 722, e4.Lcommaaccent = 556, e4.Atilde = 667, e4.Aogonek = 667, e4.Aring = 667, e4.Otilde = 778, e4.zdotaccent = 500, e4.Ecaron = 667, e4.Iogonek = 278, e4.kcommaaccent = 500, e4.minus = 584, e4.Icircumflex = 278, e4.ncaron = 556, e4.tcommaaccent = 278, e4.logicalnot = 584, e4.odieresis = 556, e4.udieresis = 556, e4.notequal = 549, e4.gcommaaccent = 556, e4.eth = 556, e4.zcaron = 500, e4.ncommaaccent = 556, e4.onesuperior = 333, e4.imacron = 278, e4.Euro = 556;
      }), e3["Helvetica-Bold"] = getLookupTableFactory(function(e4) {
        e4.space = 278, e4.exclam = 333, e4.quotedbl = 474, e4.numbersign = 556, e4.dollar = 556, e4.percent = 889, e4.ampersand = 722, e4.quoteright = 278, e4.parenleft = 333, e4.parenright = 333, e4.asterisk = 389, e4.plus = 584, e4.comma = 278, e4.hyphen = 333, e4.period = 278, e4.slash = 278, e4.zero = 556, e4.one = 556, e4.two = 556, e4.three = 556, e4.four = 556, e4.five = 556, e4.six = 556, e4.seven = 556, e4.eight = 556, e4.nine = 556, e4.colon = 333, e4.semicolon = 333, e4.less = 584, e4.equal = 584, e4.greater = 584, e4.question = 611, e4.at = 975, e4.A = 722, e4.B = 722, e4.C = 722, e4.D = 722, e4.E = 667, e4.F = 611, e4.G = 778, e4.H = 722, e4.I = 278, e4.J = 556, e4.K = 722, e4.L = 611, e4.M = 833, e4.N = 722, e4.O = 778, e4.P = 667, e4.Q = 778, e4.R = 722, e4.S = 667, e4.T = 611, e4.U = 722, e4.V = 667, e4.W = 944, e4.X = 667, e4.Y = 667, e4.Z = 611, e4.bracketleft = 333, e4.backslash = 278, e4.bracketright = 333, e4.asciicircum = 584, e4.underscore = 556, e4.quoteleft = 278, e4.a = 556, e4.b = 611, e4.c = 556, e4.d = 611, e4.e = 556, e4.f = 333, e4.g = 611, e4.h = 611, e4.i = 278, e4.j = 278, e4.k = 556, e4.l = 278, e4.m = 889, e4.n = 611, e4.o = 611, e4.p = 611, e4.q = 611, e4.r = 389, e4.s = 556, e4.t = 333, e4.u = 611, e4.v = 556, e4.w = 778, e4.x = 556, e4.y = 556, e4.z = 500, e4.braceleft = 389, e4.bar = 280, e4.braceright = 389, e4.asciitilde = 584, e4.exclamdown = 333, e4.cent = 556, e4.sterling = 556, e4.fraction = 167, e4.yen = 556, e4.florin = 556, e4.section = 556, e4.currency = 556, e4.quotesingle = 238, e4.quotedblleft = 500, e4.guillemotleft = 556, e4.guilsinglleft = 333, e4.guilsinglright = 333, e4.fi = 611, e4.fl = 611, e4.endash = 556, e4.dagger = 556, e4.daggerdbl = 556, e4.periodcentered = 278, e4.paragraph = 556, e4.bullet = 350, e4.quotesinglbase = 278, e4.quotedblbase = 500, e4.quotedblright = 500, e4.guillemotright = 556, e4.ellipsis = 1e3, e4.perthousand = 1e3, e4.questiondown = 611, e4.grave = 333, e4.acute = 333, e4.circumflex = 333, e4.tilde = 333, e4.macron = 333, e4.breve = 333, e4.dotaccent = 333, e4.dieresis = 333, e4.ring = 333, e4.cedilla = 333, e4.hungarumlaut = 333, e4.ogonek = 333, e4.caron = 333, e4.emdash = 1e3, e4.AE = 1e3, e4.ordfeminine = 370, e4.Lslash = 611, e4.Oslash = 778, e4.OE = 1e3, e4.ordmasculine = 365, e4.ae = 889, e4.dotlessi = 278, e4.lslash = 278, e4.oslash = 611, e4.oe = 944, e4.germandbls = 611, e4.Idieresis = 278, e4.eacute = 556, e4.abreve = 556, e4.uhungarumlaut = 611, e4.ecaron = 556, e4.Ydieresis = 667, e4.divide = 584, e4.Yacute = 667, e4.Acircumflex = 722, e4.aacute = 556, e4.Ucircumflex = 722, e4.yacute = 556, e4.scommaaccent = 556, e4.ecircumflex = 556, e4.Uring = 722, e4.Udieresis = 722, e4.aogonek = 556, e4.Uacute = 722, e4.uogonek = 611, e4.Edieresis = 667, e4.Dcroat = 722, e4.commaaccent = 250, e4.copyright = 737, e4.Emacron = 667, e4.ccaron = 556, e4.aring = 556, e4.Ncommaaccent = 722, e4.lacute = 278, e4.agrave = 556, e4.Tcommaaccent = 611, e4.Cacute = 722, e4.atilde = 556, e4.Edotaccent = 667, e4.scaron = 556, e4.scedilla = 556, e4.iacute = 278, e4.lozenge = 494, e4.Rcaron = 722, e4.Gcommaaccent = 778, e4.ucircumflex = 611, e4.acircumflex = 556, e4.Amacron = 722, e4.rcaron = 389, e4.ccedilla = 556, e4.Zdotaccent = 611, e4.Thorn = 667, e4.Omacron = 778, e4.Racute = 722, e4.Sacute = 667, e4.dcaron = 743, e4.Umacron = 722, e4.uring = 611, e4.threesuperior = 333, e4.Ograve = 778, e4.Agrave = 722, e4.Abreve = 722, e4.multiply = 584, e4.uacute = 611, e4.Tcaron = 611, e4.partialdiff = 494, e4.ydieresis = 556, e4.Nacute = 722, e4.icircumflex = 278, e4.Ecircumflex = 667, e4.adieresis = 556, e4.edieresis = 556, e4.cacute = 556, e4.nacute = 611, e4.umacron = 611, e4.Ncaron = 722, e4.Iacute = 278, e4.plusminus = 584, e4.brokenbar = 280, e4.registered = 737, e4.Gbreve = 778, e4.Idotaccent = 278, e4.summation = 600, e4.Egrave = 667, e4.racute = 389, e4.omacron = 611, e4.Zacute = 611, e4.Zcaron = 611, e4.greaterequal = 549, e4.Eth = 722, e4.Ccedilla = 722, e4.lcommaaccent = 278, e4.tcaron = 389, e4.eogonek = 556, e4.Uogonek = 722, e4.Aacute = 722, e4.Adieresis = 722, e4.egrave = 556, e4.zacute = 500, e4.iogonek = 278, e4.Oacute = 778, e4.oacute = 611, e4.amacron = 556, e4.sacute = 556, e4.idieresis = 278, e4.Ocircumflex = 778, e4.Ugrave = 722, e4.Delta = 612, e4.thorn = 611, e4.twosuperior = 333, e4.Odieresis = 778, e4.mu = 611, e4.igrave = 278, e4.ohungarumlaut = 611, e4.Eogonek = 667, e4.dcroat = 611, e4.threequarters = 834, e4.Scedilla = 667, e4.lcaron = 400, e4.Kcommaaccent = 722, e4.Lacute = 611, e4.trademark = 1e3, e4.edotaccent = 556, e4.Igrave = 278, e4.Imacron = 278, e4.Lcaron = 611, e4.onehalf = 834, e4.lessequal = 549, e4.ocircumflex = 611, e4.ntilde = 611, e4.Uhungarumlaut = 722, e4.Eacute = 667, e4.emacron = 556, e4.gbreve = 611, e4.onequarter = 834, e4.Scaron = 667, e4.Scommaaccent = 667, e4.Ohungarumlaut = 778, e4.degree = 400, e4.ograve = 611, e4.Ccaron = 722, e4.ugrave = 611, e4.radical = 549, e4.Dcaron = 722, e4.rcommaaccent = 389, e4.Ntilde = 722, e4.otilde = 611, e4.Rcommaaccent = 722, e4.Lcommaaccent = 611, e4.Atilde = 722, e4.Aogonek = 722, e4.Aring = 722, e4.Otilde = 778, e4.zdotaccent = 500, e4.Ecaron = 667, e4.Iogonek = 278, e4.kcommaaccent = 556, e4.minus = 584, e4.Icircumflex = 278, e4.ncaron = 611, e4.tcommaaccent = 333, e4.logicalnot = 584, e4.odieresis = 611, e4.udieresis = 611, e4.notequal = 549, e4.gcommaaccent = 611, e4.eth = 611, e4.zcaron = 500, e4.ncommaaccent = 611, e4.onesuperior = 333, e4.imacron = 278, e4.Euro = 556;
      }), e3["Helvetica-BoldOblique"] = getLookupTableFactory(function(e4) {
        e4.space = 278, e4.exclam = 333, e4.quotedbl = 474, e4.numbersign = 556, e4.dollar = 556, e4.percent = 889, e4.ampersand = 722, e4.quoteright = 278, e4.parenleft = 333, e4.parenright = 333, e4.asterisk = 389, e4.plus = 584, e4.comma = 278, e4.hyphen = 333, e4.period = 278, e4.slash = 278, e4.zero = 556, e4.one = 556, e4.two = 556, e4.three = 556, e4.four = 556, e4.five = 556, e4.six = 556, e4.seven = 556, e4.eight = 556, e4.nine = 556, e4.colon = 333, e4.semicolon = 333, e4.less = 584, e4.equal = 584, e4.greater = 584, e4.question = 611, e4.at = 975, e4.A = 722, e4.B = 722, e4.C = 722, e4.D = 722, e4.E = 667, e4.F = 611, e4.G = 778, e4.H = 722, e4.I = 278, e4.J = 556, e4.K = 722, e4.L = 611, e4.M = 833, e4.N = 722, e4.O = 778, e4.P = 667, e4.Q = 778, e4.R = 722, e4.S = 667, e4.T = 611, e4.U = 722, e4.V = 667, e4.W = 944, e4.X = 667, e4.Y = 667, e4.Z = 611, e4.bracketleft = 333, e4.backslash = 278, e4.bracketright = 333, e4.asciicircum = 584, e4.underscore = 556, e4.quoteleft = 278, e4.a = 556, e4.b = 611, e4.c = 556, e4.d = 611, e4.e = 556, e4.f = 333, e4.g = 611, e4.h = 611, e4.i = 278, e4.j = 278, e4.k = 556, e4.l = 278, e4.m = 889, e4.n = 611, e4.o = 611, e4.p = 611, e4.q = 611, e4.r = 389, e4.s = 556, e4.t = 333, e4.u = 611, e4.v = 556, e4.w = 778, e4.x = 556, e4.y = 556, e4.z = 500, e4.braceleft = 389, e4.bar = 280, e4.braceright = 389, e4.asciitilde = 584, e4.exclamdown = 333, e4.cent = 556, e4.sterling = 556, e4.fraction = 167, e4.yen = 556, e4.florin = 556, e4.section = 556, e4.currency = 556, e4.quotesingle = 238, e4.quotedblleft = 500, e4.guillemotleft = 556, e4.guilsinglleft = 333, e4.guilsinglright = 333, e4.fi = 611, e4.fl = 611, e4.endash = 556, e4.dagger = 556, e4.daggerdbl = 556, e4.periodcentered = 278, e4.paragraph = 556, e4.bullet = 350, e4.quotesinglbase = 278, e4.quotedblbase = 500, e4.quotedblright = 500, e4.guillemotright = 556, e4.ellipsis = 1e3, e4.perthousand = 1e3, e4.questiondown = 611, e4.grave = 333, e4.acute = 333, e4.circumflex = 333, e4.tilde = 333, e4.macron = 333, e4.breve = 333, e4.dotaccent = 333, e4.dieresis = 333, e4.ring = 333, e4.cedilla = 333, e4.hungarumlaut = 333, e4.ogonek = 333, e4.caron = 333, e4.emdash = 1e3, e4.AE = 1e3, e4.ordfeminine = 370, e4.Lslash = 611, e4.Oslash = 778, e4.OE = 1e3, e4.ordmasculine = 365, e4.ae = 889, e4.dotlessi = 278, e4.lslash = 278, e4.oslash = 611, e4.oe = 944, e4.germandbls = 611, e4.Idieresis = 278, e4.eacute = 556, e4.abreve = 556, e4.uhungarumlaut = 611, e4.ecaron = 556, e4.Ydieresis = 667, e4.divide = 584, e4.Yacute = 667, e4.Acircumflex = 722, e4.aacute = 556, e4.Ucircumflex = 722, e4.yacute = 556, e4.scommaaccent = 556, e4.ecircumflex = 556, e4.Uring = 722, e4.Udieresis = 722, e4.aogonek = 556, e4.Uacute = 722, e4.uogonek = 611, e4.Edieresis = 667, e4.Dcroat = 722, e4.commaaccent = 250, e4.copyright = 737, e4.Emacron = 667, e4.ccaron = 556, e4.aring = 556, e4.Ncommaaccent = 722, e4.lacute = 278, e4.agrave = 556, e4.Tcommaaccent = 611, e4.Cacute = 722, e4.atilde = 556, e4.Edotaccent = 667, e4.scaron = 556, e4.scedilla = 556, e4.iacute = 278, e4.lozenge = 494, e4.Rcaron = 722, e4.Gcommaaccent = 778, e4.ucircumflex = 611, e4.acircumflex = 556, e4.Amacron = 722, e4.rcaron = 389, e4.ccedilla = 556, e4.Zdotaccent = 611, e4.Thorn = 667, e4.Omacron = 778, e4.Racute = 722, e4.Sacute = 667, e4.dcaron = 743, e4.Umacron = 722, e4.uring = 611, e4.threesuperior = 333, e4.Ograve = 778, e4.Agrave = 722, e4.Abreve = 722, e4.multiply = 584, e4.uacute = 611, e4.Tcaron = 611, e4.partialdiff = 494, e4.ydieresis = 556, e4.Nacute = 722, e4.icircumflex = 278, e4.Ecircumflex = 667, e4.adieresis = 556, e4.edieresis = 556, e4.cacute = 556, e4.nacute = 611, e4.umacron = 611, e4.Ncaron = 722, e4.Iacute = 278, e4.plusminus = 584, e4.brokenbar = 280, e4.registered = 737, e4.Gbreve = 778, e4.Idotaccent = 278, e4.summation = 600, e4.Egrave = 667, e4.racute = 389, e4.omacron = 611, e4.Zacute = 611, e4.Zcaron = 611, e4.greaterequal = 549, e4.Eth = 722, e4.Ccedilla = 722, e4.lcommaaccent = 278, e4.tcaron = 389, e4.eogonek = 556, e4.Uogonek = 722, e4.Aacute = 722, e4.Adieresis = 722, e4.egrave = 556, e4.zacute = 500, e4.iogonek = 278, e4.Oacute = 778, e4.oacute = 611, e4.amacron = 556, e4.sacute = 556, e4.idieresis = 278, e4.Ocircumflex = 778, e4.Ugrave = 722, e4.Delta = 612, e4.thorn = 611, e4.twosuperior = 333, e4.Odieresis = 778, e4.mu = 611, e4.igrave = 278, e4.ohungarumlaut = 611, e4.Eogonek = 667, e4.dcroat = 611, e4.threequarters = 834, e4.Scedilla = 667, e4.lcaron = 400, e4.Kcommaaccent = 722, e4.Lacute = 611, e4.trademark = 1e3, e4.edotaccent = 556, e4.Igrave = 278, e4.Imacron = 278, e4.Lcaron = 611, e4.onehalf = 834, e4.lessequal = 549, e4.ocircumflex = 611, e4.ntilde = 611, e4.Uhungarumlaut = 722, e4.Eacute = 667, e4.emacron = 556, e4.gbreve = 611, e4.onequarter = 834, e4.Scaron = 667, e4.Scommaaccent = 667, e4.Ohungarumlaut = 778, e4.degree = 400, e4.ograve = 611, e4.Ccaron = 722, e4.ugrave = 611, e4.radical = 549, e4.Dcaron = 722, e4.rcommaaccent = 389, e4.Ntilde = 722, e4.otilde = 611, e4.Rcommaaccent = 722, e4.Lcommaaccent = 611, e4.Atilde = 722, e4.Aogonek = 722, e4.Aring = 722, e4.Otilde = 778, e4.zdotaccent = 500, e4.Ecaron = 667, e4.Iogonek = 278, e4.kcommaaccent = 556, e4.minus = 584, e4.Icircumflex = 278, e4.ncaron = 611, e4.tcommaaccent = 333, e4.logicalnot = 584, e4.odieresis = 611, e4.udieresis = 611, e4.notequal = 549, e4.gcommaaccent = 611, e4.eth = 611, e4.zcaron = 500, e4.ncommaaccent = 611, e4.onesuperior = 333, e4.imacron = 278, e4.Euro = 556;
      }), e3["Helvetica-Oblique"] = getLookupTableFactory(function(e4) {
        e4.space = 278, e4.exclam = 278, e4.quotedbl = 355, e4.numbersign = 556, e4.dollar = 556, e4.percent = 889, e4.ampersand = 667, e4.quoteright = 222, e4.parenleft = 333, e4.parenright = 333, e4.asterisk = 389, e4.plus = 584, e4.comma = 278, e4.hyphen = 333, e4.period = 278, e4.slash = 278, e4.zero = 556, e4.one = 556, e4.two = 556, e4.three = 556, e4.four = 556, e4.five = 556, e4.six = 556, e4.seven = 556, e4.eight = 556, e4.nine = 556, e4.colon = 278, e4.semicolon = 278, e4.less = 584, e4.equal = 584, e4.greater = 584, e4.question = 556, e4.at = 1015, e4.A = 667, e4.B = 667, e4.C = 722, e4.D = 722, e4.E = 667, e4.F = 611, e4.G = 778, e4.H = 722, e4.I = 278, e4.J = 500, e4.K = 667, e4.L = 556, e4.M = 833, e4.N = 722, e4.O = 778, e4.P = 667, e4.Q = 778, e4.R = 722, e4.S = 667, e4.T = 611, e4.U = 722, e4.V = 667, e4.W = 944, e4.X = 667, e4.Y = 667, e4.Z = 611, e4.bracketleft = 278, e4.backslash = 278, e4.bracketright = 278, e4.asciicircum = 469, e4.underscore = 556, e4.quoteleft = 222, e4.a = 556, e4.b = 556, e4.c = 500, e4.d = 556, e4.e = 556, e4.f = 278, e4.g = 556, e4.h = 556, e4.i = 222, e4.j = 222, e4.k = 500, e4.l = 222, e4.m = 833, e4.n = 556, e4.o = 556, e4.p = 556, e4.q = 556, e4.r = 333, e4.s = 500, e4.t = 278, e4.u = 556, e4.v = 500, e4.w = 722, e4.x = 500, e4.y = 500, e4.z = 500, e4.braceleft = 334, e4.bar = 260, e4.braceright = 334, e4.asciitilde = 584, e4.exclamdown = 333, e4.cent = 556, e4.sterling = 556, e4.fraction = 167, e4.yen = 556, e4.florin = 556, e4.section = 556, e4.currency = 556, e4.quotesingle = 191, e4.quotedblleft = 333, e4.guillemotleft = 556, e4.guilsinglleft = 333, e4.guilsinglright = 333, e4.fi = 500, e4.fl = 500, e4.endash = 556, e4.dagger = 556, e4.daggerdbl = 556, e4.periodcentered = 278, e4.paragraph = 537, e4.bullet = 350, e4.quotesinglbase = 222, e4.quotedblbase = 333, e4.quotedblright = 333, e4.guillemotright = 556, e4.ellipsis = 1e3, e4.perthousand = 1e3, e4.questiondown = 611, e4.grave = 333, e4.acute = 333, e4.circumflex = 333, e4.tilde = 333, e4.macron = 333, e4.breve = 333, e4.dotaccent = 333, e4.dieresis = 333, e4.ring = 333, e4.cedilla = 333, e4.hungarumlaut = 333, e4.ogonek = 333, e4.caron = 333, e4.emdash = 1e3, e4.AE = 1e3, e4.ordfeminine = 370, e4.Lslash = 556, e4.Oslash = 778, e4.OE = 1e3, e4.ordmasculine = 365, e4.ae = 889, e4.dotlessi = 278, e4.lslash = 222, e4.oslash = 611, e4.oe = 944, e4.germandbls = 611, e4.Idieresis = 278, e4.eacute = 556, e4.abreve = 556, e4.uhungarumlaut = 556, e4.ecaron = 556, e4.Ydieresis = 667, e4.divide = 584, e4.Yacute = 667, e4.Acircumflex = 667, e4.aacute = 556, e4.Ucircumflex = 722, e4.yacute = 500, e4.scommaaccent = 500, e4.ecircumflex = 556, e4.Uring = 722, e4.Udieresis = 722, e4.aogonek = 556, e4.Uacute = 722, e4.uogonek = 556, e4.Edieresis = 667, e4.Dcroat = 722, e4.commaaccent = 250, e4.copyright = 737, e4.Emacron = 667, e4.ccaron = 500, e4.aring = 556, e4.Ncommaaccent = 722, e4.lacute = 222, e4.agrave = 556, e4.Tcommaaccent = 611, e4.Cacute = 722, e4.atilde = 556, e4.Edotaccent = 667, e4.scaron = 500, e4.scedilla = 500, e4.iacute = 278, e4.lozenge = 471, e4.Rcaron = 722, e4.Gcommaaccent = 778, e4.ucircumflex = 556, e4.acircumflex = 556, e4.Amacron = 667, e4.rcaron = 333, e4.ccedilla = 500, e4.Zdotaccent = 611, e4.Thorn = 667, e4.Omacron = 778, e4.Racute = 722, e4.Sacute = 667, e4.dcaron = 643, e4.Umacron = 722, e4.uring = 556, e4.threesuperior = 333, e4.Ograve = 778, e4.Agrave = 667, e4.Abreve = 667, e4.multiply = 584, e4.uacute = 556, e4.Tcaron = 611, e4.partialdiff = 476, e4.ydieresis = 500, e4.Nacute = 722, e4.icircumflex = 278, e4.Ecircumflex = 667, e4.adieresis = 556, e4.edieresis = 556, e4.cacute = 500, e4.nacute = 556, e4.umacron = 556, e4.Ncaron = 722, e4.Iacute = 278, e4.plusminus = 584, e4.brokenbar = 260, e4.registered = 737, e4.Gbreve = 778, e4.Idotaccent = 278, e4.summation = 600, e4.Egrave = 667, e4.racute = 333, e4.omacron = 556, e4.Zacute = 611, e4.Zcaron = 611, e4.greaterequal = 549, e4.Eth = 722, e4.Ccedilla = 722, e4.lcommaaccent = 222, e4.tcaron = 317, e4.eogonek = 556, e4.Uogonek = 722, e4.Aacute = 667, e4.Adieresis = 667, e4.egrave = 556, e4.zacute = 500, e4.iogonek = 222, e4.Oacute = 778, e4.oacute = 556, e4.amacron = 556, e4.sacute = 500, e4.idieresis = 278, e4.Ocircumflex = 778, e4.Ugrave = 722, e4.Delta = 612, e4.thorn = 556, e4.twosuperior = 333, e4.Odieresis = 778, e4.mu = 556, e4.igrave = 278, e4.ohungarumlaut = 556, e4.Eogonek = 667, e4.dcroat = 556, e4.threequarters = 834, e4.Scedilla = 667, e4.lcaron = 299, e4.Kcommaaccent = 667, e4.Lacute = 556, e4.trademark = 1e3, e4.edotaccent = 556, e4.Igrave = 278, e4.Imacron = 278, e4.Lcaron = 556, e4.onehalf = 834, e4.lessequal = 549, e4.ocircumflex = 556, e4.ntilde = 556, e4.Uhungarumlaut = 722, e4.Eacute = 667, e4.emacron = 556, e4.gbreve = 556, e4.onequarter = 834, e4.Scaron = 667, e4.Scommaaccent = 667, e4.Ohungarumlaut = 778, e4.degree = 400, e4.ograve = 556, e4.Ccaron = 722, e4.ugrave = 556, e4.radical = 453, e4.Dcaron = 722, e4.rcommaaccent = 333, e4.Ntilde = 722, e4.otilde = 556, e4.Rcommaaccent = 722, e4.Lcommaaccent = 556, e4.Atilde = 667, e4.Aogonek = 667, e4.Aring = 667, e4.Otilde = 778, e4.zdotaccent = 500, e4.Ecaron = 667, e4.Iogonek = 278, e4.kcommaaccent = 500, e4.minus = 584, e4.Icircumflex = 278, e4.ncaron = 556, e4.tcommaaccent = 278, e4.logicalnot = 584, e4.odieresis = 556, e4.udieresis = 556, e4.notequal = 549, e4.gcommaaccent = 556, e4.eth = 556, e4.zcaron = 500, e4.ncommaaccent = 556, e4.onesuperior = 333, e4.imacron = 278, e4.Euro = 556;
      }), e3.Symbol = getLookupTableFactory(function(e4) {
        e4.space = 250, e4.exclam = 333, e4.universal = 713, e4.numbersign = 500, e4.existential = 549, e4.percent = 833, e4.ampersand = 778, e4.suchthat = 439, e4.parenleft = 333, e4.parenright = 333, e4.asteriskmath = 500, e4.plus = 549, e4.comma = 250, e4.minus = 549, e4.period = 250, e4.slash = 278, e4.zero = 500, e4.one = 500, e4.two = 500, e4.three = 500, e4.four = 500, e4.five = 500, e4.six = 500, e4.seven = 500, e4.eight = 500, e4.nine = 500, e4.colon = 278, e4.semicolon = 278, e4.less = 549, e4.equal = 549, e4.greater = 549, e4.question = 444, e4.congruent = 549, e4.Alpha = 722, e4.Beta = 667, e4.Chi = 722, e4.Delta = 612, e4.Epsilon = 611, e4.Phi = 763, e4.Gamma = 603, e4.Eta = 722, e4.Iota = 333, e4.theta1 = 631, e4.Kappa = 722, e4.Lambda = 686, e4.Mu = 889, e4.Nu = 722, e4.Omicron = 722, e4.Pi = 768, e4.Theta = 741, e4.Rho = 556, e4.Sigma = 592, e4.Tau = 611, e4.Upsilon = 690, e4.sigma1 = 439, e4.Omega = 768, e4.Xi = 645, e4.Psi = 795, e4.Zeta = 611, e4.bracketleft = 333, e4.therefore = 863, e4.bracketright = 333, e4.perpendicular = 658, e4.underscore = 500, e4.radicalex = 500, e4.alpha = 631, e4.beta = 549, e4.chi = 549, e4.delta = 494, e4.epsilon = 439, e4.phi = 521, e4.gamma = 411, e4.eta = 603, e4.iota = 329, e4.phi1 = 603, e4.kappa = 549, e4.lambda = 549, e4.mu = 576, e4.nu = 521, e4.omicron = 549, e4.pi = 549, e4.theta = 521, e4.rho = 549, e4.sigma = 603, e4.tau = 439, e4.upsilon = 576, e4.omega1 = 713, e4.omega = 686, e4.xi = 493, e4.psi = 686, e4.zeta = 494, e4.braceleft = 480, e4.bar = 200, e4.braceright = 480, e4.similar = 549, e4.Euro = 750, e4.Upsilon1 = 620, e4.minute = 247, e4.lessequal = 549, e4.fraction = 167, e4.infinity = 713, e4.florin = 500, e4.club = 753, e4.diamond = 753, e4.heart = 753, e4.spade = 753, e4.arrowboth = 1042, e4.arrowleft = 987, e4.arrowup = 603, e4.arrowright = 987, e4.arrowdown = 603, e4.degree = 400, e4.plusminus = 549, e4.second = 411, e4.greaterequal = 549, e4.multiply = 549, e4.proportional = 713, e4.partialdiff = 494, e4.bullet = 460, e4.divide = 549, e4.notequal = 549, e4.equivalence = 549, e4.approxequal = 549, e4.ellipsis = 1e3, e4.arrowvertex = 603, e4.arrowhorizex = 1e3, e4.carriagereturn = 658, e4.aleph = 823, e4.Ifraktur = 686, e4.Rfraktur = 795, e4.weierstrass = 987, e4.circlemultiply = 768, e4.circleplus = 768, e4.emptyset = 823, e4.intersection = 768, e4.union = 768, e4.propersuperset = 713, e4.reflexsuperset = 713, e4.notsubset = 713, e4.propersubset = 713, e4.reflexsubset = 713, e4.element = 713, e4.notelement = 713, e4.angle = 768, e4.gradient = 713, e4.registerserif = 790, e4.copyrightserif = 790, e4.trademarkserif = 890, e4.product = 823, e4.radical = 549, e4.dotmath = 250, e4.logicalnot = 713, e4.logicaland = 603, e4.logicalor = 603, e4.arrowdblboth = 1042, e4.arrowdblleft = 987, e4.arrowdblup = 603, e4.arrowdblright = 987, e4.arrowdbldown = 603, e4.lozenge = 494, e4.angleleft = 329, e4.registersans = 790, e4.copyrightsans = 790, e4.trademarksans = 786, e4.summation = 713, e4.parenlefttp = 384, e4.parenleftex = 384, e4.parenleftbt = 384, e4.bracketlefttp = 384, e4.bracketleftex = 384, e4.bracketleftbt = 384, e4.bracelefttp = 494, e4.braceleftmid = 494, e4.braceleftbt = 494, e4.braceex = 494, e4.angleright = 329, e4.integral = 274, e4.integraltp = 686, e4.integralex = 686, e4.integralbt = 686, e4.parenrighttp = 384, e4.parenrightex = 384, e4.parenrightbt = 384, e4.bracketrighttp = 384, e4.bracketrightex = 384, e4.bracketrightbt = 384, e4.bracerighttp = 494, e4.bracerightmid = 494, e4.bracerightbt = 494, e4.apple = 790;
      }), e3["Times-Roman"] = getLookupTableFactory(function(e4) {
        e4.space = 250, e4.exclam = 333, e4.quotedbl = 408, e4.numbersign = 500, e4.dollar = 500, e4.percent = 833, e4.ampersand = 778, e4.quoteright = 333, e4.parenleft = 333, e4.parenright = 333, e4.asterisk = 500, e4.plus = 564, e4.comma = 250, e4.hyphen = 333, e4.period = 250, e4.slash = 278, e4.zero = 500, e4.one = 500, e4.two = 500, e4.three = 500, e4.four = 500, e4.five = 500, e4.six = 500, e4.seven = 500, e4.eight = 500, e4.nine = 500, e4.colon = 278, e4.semicolon = 278, e4.less = 564, e4.equal = 564, e4.greater = 564, e4.question = 444, e4.at = 921, e4.A = 722, e4.B = 667, e4.C = 667, e4.D = 722, e4.E = 611, e4.F = 556, e4.G = 722, e4.H = 722, e4.I = 333, e4.J = 389, e4.K = 722, e4.L = 611, e4.M = 889, e4.N = 722, e4.O = 722, e4.P = 556, e4.Q = 722, e4.R = 667, e4.S = 556, e4.T = 611, e4.U = 722, e4.V = 722, e4.W = 944, e4.X = 722, e4.Y = 722, e4.Z = 611, e4.bracketleft = 333, e4.backslash = 278, e4.bracketright = 333, e4.asciicircum = 469, e4.underscore = 500, e4.quoteleft = 333, e4.a = 444, e4.b = 500, e4.c = 444, e4.d = 500, e4.e = 444, e4.f = 333, e4.g = 500, e4.h = 500, e4.i = 278, e4.j = 278, e4.k = 500, e4.l = 278, e4.m = 778, e4.n = 500, e4.o = 500, e4.p = 500, e4.q = 500, e4.r = 333, e4.s = 389, e4.t = 278, e4.u = 500, e4.v = 500, e4.w = 722, e4.x = 500, e4.y = 500, e4.z = 444, e4.braceleft = 480, e4.bar = 200, e4.braceright = 480, e4.asciitilde = 541, e4.exclamdown = 333, e4.cent = 500, e4.sterling = 500, e4.fraction = 167, e4.yen = 500, e4.florin = 500, e4.section = 500, e4.currency = 500, e4.quotesingle = 180, e4.quotedblleft = 444, e4.guillemotleft = 500, e4.guilsinglleft = 333, e4.guilsinglright = 333, e4.fi = 556, e4.fl = 556, e4.endash = 500, e4.dagger = 500, e4.daggerdbl = 500, e4.periodcentered = 250, e4.paragraph = 453, e4.bullet = 350, e4.quotesinglbase = 333, e4.quotedblbase = 444, e4.quotedblright = 444, e4.guillemotright = 500, e4.ellipsis = 1e3, e4.perthousand = 1e3, e4.questiondown = 444, e4.grave = 333, e4.acute = 333, e4.circumflex = 333, e4.tilde = 333, e4.macron = 333, e4.breve = 333, e4.dotaccent = 333, e4.dieresis = 333, e4.ring = 333, e4.cedilla = 333, e4.hungarumlaut = 333, e4.ogonek = 333, e4.caron = 333, e4.emdash = 1e3, e4.AE = 889, e4.ordfeminine = 276, e4.Lslash = 611, e4.Oslash = 722, e4.OE = 889, e4.ordmasculine = 310, e4.ae = 667, e4.dotlessi = 278, e4.lslash = 278, e4.oslash = 500, e4.oe = 722, e4.germandbls = 500, e4.Idieresis = 333, e4.eacute = 444, e4.abreve = 444, e4.uhungarumlaut = 500, e4.ecaron = 444, e4.Ydieresis = 722, e4.divide = 564, e4.Yacute = 722, e4.Acircumflex = 722, e4.aacute = 444, e4.Ucircumflex = 722, e4.yacute = 500, e4.scommaaccent = 389, e4.ecircumflex = 444, e4.Uring = 722, e4.Udieresis = 722, e4.aogonek = 444, e4.Uacute = 722, e4.uogonek = 500, e4.Edieresis = 611, e4.Dcroat = 722, e4.commaaccent = 250, e4.copyright = 760, e4.Emacron = 611, e4.ccaron = 444, e4.aring = 444, e4.Ncommaaccent = 722, e4.lacute = 278, e4.agrave = 444, e4.Tcommaaccent = 611, e4.Cacute = 667, e4.atilde = 444, e4.Edotaccent = 611, e4.scaron = 389, e4.scedilla = 389, e4.iacute = 278, e4.lozenge = 471, e4.Rcaron = 667, e4.Gcommaaccent = 722, e4.ucircumflex = 500, e4.acircumflex = 444, e4.Amacron = 722, e4.rcaron = 333, e4.ccedilla = 444, e4.Zdotaccent = 611, e4.Thorn = 556, e4.Omacron = 722, e4.Racute = 667, e4.Sacute = 556, e4.dcaron = 588, e4.Umacron = 722, e4.uring = 500, e4.threesuperior = 300, e4.Ograve = 722, e4.Agrave = 722, e4.Abreve = 722, e4.multiply = 564, e4.uacute = 500, e4.Tcaron = 611, e4.partialdiff = 476, e4.ydieresis = 500, e4.Nacute = 722, e4.icircumflex = 278, e4.Ecircumflex = 611, e4.adieresis = 444, e4.edieresis = 444, e4.cacute = 444, e4.nacute = 500, e4.umacron = 500, e4.Ncaron = 722, e4.Iacute = 333, e4.plusminus = 564, e4.brokenbar = 200, e4.registered = 760, e4.Gbreve = 722, e4.Idotaccent = 333, e4.summation = 600, e4.Egrave = 611, e4.racute = 333, e4.omacron = 500, e4.Zacute = 611, e4.Zcaron = 611, e4.greaterequal = 549, e4.Eth = 722, e4.Ccedilla = 667, e4.lcommaaccent = 278, e4.tcaron = 326, e4.eogonek = 444, e4.Uogonek = 722, e4.Aacute = 722, e4.Adieresis = 722, e4.egrave = 444, e4.zacute = 444, e4.iogonek = 278, e4.Oacute = 722, e4.oacute = 500, e4.amacron = 444, e4.sacute = 389, e4.idieresis = 278, e4.Ocircumflex = 722, e4.Ugrave = 722, e4.Delta = 612, e4.thorn = 500, e4.twosuperior = 300, e4.Odieresis = 722, e4.mu = 500, e4.igrave = 278, e4.ohungarumlaut = 500, e4.Eogonek = 611, e4.dcroat = 500, e4.threequarters = 750, e4.Scedilla = 556, e4.lcaron = 344, e4.Kcommaaccent = 722, e4.Lacute = 611, e4.trademark = 980, e4.edotaccent = 444, e4.Igrave = 333, e4.Imacron = 333, e4.Lcaron = 611, e4.onehalf = 750, e4.lessequal = 549, e4.ocircumflex = 500, e4.ntilde = 500, e4.Uhungarumlaut = 722, e4.Eacute = 611, e4.emacron = 444, e4.gbreve = 500, e4.onequarter = 750, e4.Scaron = 556, e4.Scommaaccent = 556, e4.Ohungarumlaut = 722, e4.degree = 400, e4.ograve = 500, e4.Ccaron = 667, e4.ugrave = 500, e4.radical = 453, e4.Dcaron = 722, e4.rcommaaccent = 333, e4.Ntilde = 722, e4.otilde = 500, e4.Rcommaaccent = 667, e4.Lcommaaccent = 611, e4.Atilde = 722, e4.Aogonek = 722, e4.Aring = 722, e4.Otilde = 722, e4.zdotaccent = 444, e4.Ecaron = 611, e4.Iogonek = 333, e4.kcommaaccent = 500, e4.minus = 564, e4.Icircumflex = 333, e4.ncaron = 500, e4.tcommaaccent = 278, e4.logicalnot = 564, e4.odieresis = 500, e4.udieresis = 500, e4.notequal = 549, e4.gcommaaccent = 500, e4.eth = 500, e4.zcaron = 444, e4.ncommaaccent = 500, e4.onesuperior = 300, e4.imacron = 278, e4.Euro = 500;
      }), e3["Times-Bold"] = getLookupTableFactory(function(e4) {
        e4.space = 250, e4.exclam = 333, e4.quotedbl = 555, e4.numbersign = 500, e4.dollar = 500, e4.percent = 1e3, e4.ampersand = 833, e4.quoteright = 333, e4.parenleft = 333, e4.parenright = 333, e4.asterisk = 500, e4.plus = 570, e4.comma = 250, e4.hyphen = 333, e4.period = 250, e4.slash = 278, e4.zero = 500, e4.one = 500, e4.two = 500, e4.three = 500, e4.four = 500, e4.five = 500, e4.six = 500, e4.seven = 500, e4.eight = 500, e4.nine = 500, e4.colon = 333, e4.semicolon = 333, e4.less = 570, e4.equal = 570, e4.greater = 570, e4.question = 500, e4.at = 930, e4.A = 722, e4.B = 667, e4.C = 722, e4.D = 722, e4.E = 667, e4.F = 611, e4.G = 778, e4.H = 778, e4.I = 389, e4.J = 500, e4.K = 778, e4.L = 667, e4.M = 944, e4.N = 722, e4.O = 778, e4.P = 611, e4.Q = 778, e4.R = 722, e4.S = 556, e4.T = 667, e4.U = 722, e4.V = 722, e4.W = 1e3, e4.X = 722, e4.Y = 722, e4.Z = 667, e4.bracketleft = 333, e4.backslash = 278, e4.bracketright = 333, e4.asciicircum = 581, e4.underscore = 500, e4.quoteleft = 333, e4.a = 500, e4.b = 556, e4.c = 444, e4.d = 556, e4.e = 444, e4.f = 333, e4.g = 500, e4.h = 556, e4.i = 278, e4.j = 333, e4.k = 556, e4.l = 278, e4.m = 833, e4.n = 556, e4.o = 500, e4.p = 556, e4.q = 556, e4.r = 444, e4.s = 389, e4.t = 333, e4.u = 556, e4.v = 500, e4.w = 722, e4.x = 500, e4.y = 500, e4.z = 444, e4.braceleft = 394, e4.bar = 220, e4.braceright = 394, e4.asciitilde = 520, e4.exclamdown = 333, e4.cent = 500, e4.sterling = 500, e4.fraction = 167, e4.yen = 500, e4.florin = 500, e4.section = 500, e4.currency = 500, e4.quotesingle = 278, e4.quotedblleft = 500, e4.guillemotleft = 500, e4.guilsinglleft = 333, e4.guilsinglright = 333, e4.fi = 556, e4.fl = 556, e4.endash = 500, e4.dagger = 500, e4.daggerdbl = 500, e4.periodcentered = 250, e4.paragraph = 540, e4.bullet = 350, e4.quotesinglbase = 333, e4.quotedblbase = 500, e4.quotedblright = 500, e4.guillemotright = 500, e4.ellipsis = 1e3, e4.perthousand = 1e3, e4.questiondown = 500, e4.grave = 333, e4.acute = 333, e4.circumflex = 333, e4.tilde = 333, e4.macron = 333, e4.breve = 333, e4.dotaccent = 333, e4.dieresis = 333, e4.ring = 333, e4.cedilla = 333, e4.hungarumlaut = 333, e4.ogonek = 333, e4.caron = 333, e4.emdash = 1e3, e4.AE = 1e3, e4.ordfeminine = 300, e4.Lslash = 667, e4.Oslash = 778, e4.OE = 1e3, e4.ordmasculine = 330, e4.ae = 722, e4.dotlessi = 278, e4.lslash = 278, e4.oslash = 500, e4.oe = 722, e4.germandbls = 556, e4.Idieresis = 389, e4.eacute = 444, e4.abreve = 500, e4.uhungarumlaut = 556, e4.ecaron = 444, e4.Ydieresis = 722, e4.divide = 570, e4.Yacute = 722, e4.Acircumflex = 722, e4.aacute = 500, e4.Ucircumflex = 722, e4.yacute = 500, e4.scommaaccent = 389, e4.ecircumflex = 444, e4.Uring = 722, e4.Udieresis = 722, e4.aogonek = 500, e4.Uacute = 722, e4.uogonek = 556, e4.Edieresis = 667, e4.Dcroat = 722, e4.commaaccent = 250, e4.copyright = 747, e4.Emacron = 667, e4.ccaron = 444, e4.aring = 500, e4.Ncommaaccent = 722, e4.lacute = 278, e4.agrave = 500, e4.Tcommaaccent = 667, e4.Cacute = 722, e4.atilde = 500, e4.Edotaccent = 667, e4.scaron = 389, e4.scedilla = 389, e4.iacute = 278, e4.lozenge = 494, e4.Rcaron = 722, e4.Gcommaaccent = 778, e4.ucircumflex = 556, e4.acircumflex = 500, e4.Amacron = 722, e4.rcaron = 444, e4.ccedilla = 444, e4.Zdotaccent = 667, e4.Thorn = 611, e4.Omacron = 778, e4.Racute = 722, e4.Sacute = 556, e4.dcaron = 672, e4.Umacron = 722, e4.uring = 556, e4.threesuperior = 300, e4.Ograve = 778, e4.Agrave = 722, e4.Abreve = 722, e4.multiply = 570, e4.uacute = 556, e4.Tcaron = 667, e4.partialdiff = 494, e4.ydieresis = 500, e4.Nacute = 722, e4.icircumflex = 278, e4.Ecircumflex = 667, e4.adieresis = 500, e4.edieresis = 444, e4.cacute = 444, e4.nacute = 556, e4.umacron = 556, e4.Ncaron = 722, e4.Iacute = 389, e4.plusminus = 570, e4.brokenbar = 220, e4.registered = 747, e4.Gbreve = 778, e4.Idotaccent = 389, e4.summation = 600, e4.Egrave = 667, e4.racute = 444, e4.omacron = 500, e4.Zacute = 667, e4.Zcaron = 667, e4.greaterequal = 549, e4.Eth = 722, e4.Ccedilla = 722, e4.lcommaaccent = 278, e4.tcaron = 416, e4.eogonek = 444, e4.Uogonek = 722, e4.Aacute = 722, e4.Adieresis = 722, e4.egrave = 444, e4.zacute = 444, e4.iogonek = 278, e4.Oacute = 778, e4.oacute = 500, e4.amacron = 500, e4.sacute = 389, e4.idieresis = 278, e4.Ocircumflex = 778, e4.Ugrave = 722, e4.Delta = 612, e4.thorn = 556, e4.twosuperior = 300, e4.Odieresis = 778, e4.mu = 556, e4.igrave = 278, e4.ohungarumlaut = 500, e4.Eogonek = 667, e4.dcroat = 556, e4.threequarters = 750, e4.Scedilla = 556, e4.lcaron = 394, e4.Kcommaaccent = 778, e4.Lacute = 667, e4.trademark = 1e3, e4.edotaccent = 444, e4.Igrave = 389, e4.Imacron = 389, e4.Lcaron = 667, e4.onehalf = 750, e4.lessequal = 549, e4.ocircumflex = 500, e4.ntilde = 556, e4.Uhungarumlaut = 722, e4.Eacute = 667, e4.emacron = 444, e4.gbreve = 500, e4.onequarter = 750, e4.Scaron = 556, e4.Scommaaccent = 556, e4.Ohungarumlaut = 778, e4.degree = 400, e4.ograve = 500, e4.Ccaron = 722, e4.ugrave = 556, e4.radical = 549, e4.Dcaron = 722, e4.rcommaaccent = 444, e4.Ntilde = 722, e4.otilde = 500, e4.Rcommaaccent = 722, e4.Lcommaaccent = 667, e4.Atilde = 722, e4.Aogonek = 722, e4.Aring = 722, e4.Otilde = 778, e4.zdotaccent = 444, e4.Ecaron = 667, e4.Iogonek = 389, e4.kcommaaccent = 556, e4.minus = 570, e4.Icircumflex = 389, e4.ncaron = 556, e4.tcommaaccent = 333, e4.logicalnot = 570, e4.odieresis = 500, e4.udieresis = 556, e4.notequal = 549, e4.gcommaaccent = 500, e4.eth = 500, e4.zcaron = 444, e4.ncommaaccent = 556, e4.onesuperior = 300, e4.imacron = 278, e4.Euro = 500;
      }), e3["Times-BoldItalic"] = getLookupTableFactory(function(e4) {
        e4.space = 250, e4.exclam = 389, e4.quotedbl = 555, e4.numbersign = 500, e4.dollar = 500, e4.percent = 833, e4.ampersand = 778, e4.quoteright = 333, e4.parenleft = 333, e4.parenright = 333, e4.asterisk = 500, e4.plus = 570, e4.comma = 250, e4.hyphen = 333, e4.period = 250, e4.slash = 278, e4.zero = 500, e4.one = 500, e4.two = 500, e4.three = 500, e4.four = 500, e4.five = 500, e4.six = 500, e4.seven = 500, e4.eight = 500, e4.nine = 500, e4.colon = 333, e4.semicolon = 333, e4.less = 570, e4.equal = 570, e4.greater = 570, e4.question = 500, e4.at = 832, e4.A = 667, e4.B = 667, e4.C = 667, e4.D = 722, e4.E = 667, e4.F = 667, e4.G = 722, e4.H = 778, e4.I = 389, e4.J = 500, e4.K = 667, e4.L = 611, e4.M = 889, e4.N = 722, e4.O = 722, e4.P = 611, e4.Q = 722, e4.R = 667, e4.S = 556, e4.T = 611, e4.U = 722, e4.V = 667, e4.W = 889, e4.X = 667, e4.Y = 611, e4.Z = 611, e4.bracketleft = 333, e4.backslash = 278, e4.bracketright = 333, e4.asciicircum = 570, e4.underscore = 500, e4.quoteleft = 333, e4.a = 500, e4.b = 500, e4.c = 444, e4.d = 500, e4.e = 444, e4.f = 333, e4.g = 500, e4.h = 556, e4.i = 278, e4.j = 278, e4.k = 500, e4.l = 278, e4.m = 778, e4.n = 556, e4.o = 500, e4.p = 500, e4.q = 500, e4.r = 389, e4.s = 389, e4.t = 278, e4.u = 556, e4.v = 444, e4.w = 667, e4.x = 500, e4.y = 444, e4.z = 389, e4.braceleft = 348, e4.bar = 220, e4.braceright = 348, e4.asciitilde = 570, e4.exclamdown = 389, e4.cent = 500, e4.sterling = 500, e4.fraction = 167, e4.yen = 500, e4.florin = 500, e4.section = 500, e4.currency = 500, e4.quotesingle = 278, e4.quotedblleft = 500, e4.guillemotleft = 500, e4.guilsinglleft = 333, e4.guilsinglright = 333, e4.fi = 556, e4.fl = 556, e4.endash = 500, e4.dagger = 500, e4.daggerdbl = 500, e4.periodcentered = 250, e4.paragraph = 500, e4.bullet = 350, e4.quotesinglbase = 333, e4.quotedblbase = 500, e4.quotedblright = 500, e4.guillemotright = 500, e4.ellipsis = 1e3, e4.perthousand = 1e3, e4.questiondown = 500, e4.grave = 333, e4.acute = 333, e4.circumflex = 333, e4.tilde = 333, e4.macron = 333, e4.breve = 333, e4.dotaccent = 333, e4.dieresis = 333, e4.ring = 333, e4.cedilla = 333, e4.hungarumlaut = 333, e4.ogonek = 333, e4.caron = 333, e4.emdash = 1e3, e4.AE = 944, e4.ordfeminine = 266, e4.Lslash = 611, e4.Oslash = 722, e4.OE = 944, e4.ordmasculine = 300, e4.ae = 722, e4.dotlessi = 278, e4.lslash = 278, e4.oslash = 500, e4.oe = 722, e4.germandbls = 500, e4.Idieresis = 389, e4.eacute = 444, e4.abreve = 500, e4.uhungarumlaut = 556, e4.ecaron = 444, e4.Ydieresis = 611, e4.divide = 570, e4.Yacute = 611, e4.Acircumflex = 667, e4.aacute = 500, e4.Ucircumflex = 722, e4.yacute = 444, e4.scommaaccent = 389, e4.ecircumflex = 444, e4.Uring = 722, e4.Udieresis = 722, e4.aogonek = 500, e4.Uacute = 722, e4.uogonek = 556, e4.Edieresis = 667, e4.Dcroat = 722, e4.commaaccent = 250, e4.copyright = 747, e4.Emacron = 667, e4.ccaron = 444, e4.aring = 500, e4.Ncommaaccent = 722, e4.lacute = 278, e4.agrave = 500, e4.Tcommaaccent = 611, e4.Cacute = 667, e4.atilde = 500, e4.Edotaccent = 667, e4.scaron = 389, e4.scedilla = 389, e4.iacute = 278, e4.lozenge = 494, e4.Rcaron = 667, e4.Gcommaaccent = 722, e4.ucircumflex = 556, e4.acircumflex = 500, e4.Amacron = 667, e4.rcaron = 389, e4.ccedilla = 444, e4.Zdotaccent = 611, e4.Thorn = 611, e4.Omacron = 722, e4.Racute = 667, e4.Sacute = 556, e4.dcaron = 608, e4.Umacron = 722, e4.uring = 556, e4.threesuperior = 300, e4.Ograve = 722, e4.Agrave = 667, e4.Abreve = 667, e4.multiply = 570, e4.uacute = 556, e4.Tcaron = 611, e4.partialdiff = 494, e4.ydieresis = 444, e4.Nacute = 722, e4.icircumflex = 278, e4.Ecircumflex = 667, e4.adieresis = 500, e4.edieresis = 444, e4.cacute = 444, e4.nacute = 556, e4.umacron = 556, e4.Ncaron = 722, e4.Iacute = 389, e4.plusminus = 570, e4.brokenbar = 220, e4.registered = 747, e4.Gbreve = 722, e4.Idotaccent = 389, e4.summation = 600, e4.Egrave = 667, e4.racute = 389, e4.omacron = 500, e4.Zacute = 611, e4.Zcaron = 611, e4.greaterequal = 549, e4.Eth = 722, e4.Ccedilla = 667, e4.lcommaaccent = 278, e4.tcaron = 366, e4.eogonek = 444, e4.Uogonek = 722, e4.Aacute = 667, e4.Adieresis = 667, e4.egrave = 444, e4.zacute = 389, e4.iogonek = 278, e4.Oacute = 722, e4.oacute = 500, e4.amacron = 500, e4.sacute = 389, e4.idieresis = 278, e4.Ocircumflex = 722, e4.Ugrave = 722, e4.Delta = 612, e4.thorn = 500, e4.twosuperior = 300, e4.Odieresis = 722, e4.mu = 576, e4.igrave = 278, e4.ohungarumlaut = 500, e4.Eogonek = 667, e4.dcroat = 500, e4.threequarters = 750, e4.Scedilla = 556, e4.lcaron = 382, e4.Kcommaaccent = 667, e4.Lacute = 611, e4.trademark = 1e3, e4.edotaccent = 444, e4.Igrave = 389, e4.Imacron = 389, e4.Lcaron = 611, e4.onehalf = 750, e4.lessequal = 549, e4.ocircumflex = 500, e4.ntilde = 556, e4.Uhungarumlaut = 722, e4.Eacute = 667, e4.emacron = 444, e4.gbreve = 500, e4.onequarter = 750, e4.Scaron = 556, e4.Scommaaccent = 556, e4.Ohungarumlaut = 722, e4.degree = 400, e4.ograve = 500, e4.Ccaron = 667, e4.ugrave = 556, e4.radical = 549, e4.Dcaron = 722, e4.rcommaaccent = 389, e4.Ntilde = 722, e4.otilde = 500, e4.Rcommaaccent = 667, e4.Lcommaaccent = 611, e4.Atilde = 667, e4.Aogonek = 667, e4.Aring = 667, e4.Otilde = 722, e4.zdotaccent = 389, e4.Ecaron = 667, e4.Iogonek = 389, e4.kcommaaccent = 500, e4.minus = 606, e4.Icircumflex = 389, e4.ncaron = 556, e4.tcommaaccent = 278, e4.logicalnot = 606, e4.odieresis = 500, e4.udieresis = 556, e4.notequal = 549, e4.gcommaaccent = 500, e4.eth = 500, e4.zcaron = 389, e4.ncommaaccent = 556, e4.onesuperior = 300, e4.imacron = 278, e4.Euro = 500;
      }), e3["Times-Italic"] = getLookupTableFactory(function(e4) {
        e4.space = 250, e4.exclam = 333, e4.quotedbl = 420, e4.numbersign = 500, e4.dollar = 500, e4.percent = 833, e4.ampersand = 778, e4.quoteright = 333, e4.parenleft = 333, e4.parenright = 333, e4.asterisk = 500, e4.plus = 675, e4.comma = 250, e4.hyphen = 333, e4.period = 250, e4.slash = 278, e4.zero = 500, e4.one = 500, e4.two = 500, e4.three = 500, e4.four = 500, e4.five = 500, e4.six = 500, e4.seven = 500, e4.eight = 500, e4.nine = 500, e4.colon = 333, e4.semicolon = 333, e4.less = 675, e4.equal = 675, e4.greater = 675, e4.question = 500, e4.at = 920, e4.A = 611, e4.B = 611, e4.C = 667, e4.D = 722, e4.E = 611, e4.F = 611, e4.G = 722, e4.H = 722, e4.I = 333, e4.J = 444, e4.K = 667, e4.L = 556, e4.M = 833, e4.N = 667, e4.O = 722, e4.P = 611, e4.Q = 722, e4.R = 611, e4.S = 500, e4.T = 556, e4.U = 722, e4.V = 611, e4.W = 833, e4.X = 611, e4.Y = 556, e4.Z = 556, e4.bracketleft = 389, e4.backslash = 278, e4.bracketright = 389, e4.asciicircum = 422, e4.underscore = 500, e4.quoteleft = 333, e4.a = 500, e4.b = 500, e4.c = 444, e4.d = 500, e4.e = 444, e4.f = 278, e4.g = 500, e4.h = 500, e4.i = 278, e4.j = 278, e4.k = 444, e4.l = 278, e4.m = 722, e4.n = 500, e4.o = 500, e4.p = 500, e4.q = 500, e4.r = 389, e4.s = 389, e4.t = 278, e4.u = 500, e4.v = 444, e4.w = 667, e4.x = 444, e4.y = 444, e4.z = 389, e4.braceleft = 400, e4.bar = 275, e4.braceright = 400, e4.asciitilde = 541, e4.exclamdown = 389, e4.cent = 500, e4.sterling = 500, e4.fraction = 167, e4.yen = 500, e4.florin = 500, e4.section = 500, e4.currency = 500, e4.quotesingle = 214, e4.quotedblleft = 556, e4.guillemotleft = 500, e4.guilsinglleft = 333, e4.guilsinglright = 333, e4.fi = 500, e4.fl = 500, e4.endash = 500, e4.dagger = 500, e4.daggerdbl = 500, e4.periodcentered = 250, e4.paragraph = 523, e4.bullet = 350, e4.quotesinglbase = 333, e4.quotedblbase = 556, e4.quotedblright = 556, e4.guillemotright = 500, e4.ellipsis = 889, e4.perthousand = 1e3, e4.questiondown = 500, e4.grave = 333, e4.acute = 333, e4.circumflex = 333, e4.tilde = 333, e4.macron = 333, e4.breve = 333, e4.dotaccent = 333, e4.dieresis = 333, e4.ring = 333, e4.cedilla = 333, e4.hungarumlaut = 333, e4.ogonek = 333, e4.caron = 333, e4.emdash = 889, e4.AE = 889, e4.ordfeminine = 276, e4.Lslash = 556, e4.Oslash = 722, e4.OE = 944, e4.ordmasculine = 310, e4.ae = 667, e4.dotlessi = 278, e4.lslash = 278, e4.oslash = 500, e4.oe = 667, e4.germandbls = 500, e4.Idieresis = 333, e4.eacute = 444, e4.abreve = 500, e4.uhungarumlaut = 500, e4.ecaron = 444, e4.Ydieresis = 556, e4.divide = 675, e4.Yacute = 556, e4.Acircumflex = 611, e4.aacute = 500, e4.Ucircumflex = 722, e4.yacute = 444, e4.scommaaccent = 389, e4.ecircumflex = 444, e4.Uring = 722, e4.Udieresis = 722, e4.aogonek = 500, e4.Uacute = 722, e4.uogonek = 500, e4.Edieresis = 611, e4.Dcroat = 722, e4.commaaccent = 250, e4.copyright = 760, e4.Emacron = 611, e4.ccaron = 444, e4.aring = 500, e4.Ncommaaccent = 667, e4.lacute = 278, e4.agrave = 500, e4.Tcommaaccent = 556, e4.Cacute = 667, e4.atilde = 500, e4.Edotaccent = 611, e4.scaron = 389, e4.scedilla = 389, e4.iacute = 278, e4.lozenge = 471, e4.Rcaron = 611, e4.Gcommaaccent = 722, e4.ucircumflex = 500, e4.acircumflex = 500, e4.Amacron = 611, e4.rcaron = 389, e4.ccedilla = 444, e4.Zdotaccent = 556, e4.Thorn = 611, e4.Omacron = 722, e4.Racute = 611, e4.Sacute = 500, e4.dcaron = 544, e4.Umacron = 722, e4.uring = 500, e4.threesuperior = 300, e4.Ograve = 722, e4.Agrave = 611, e4.Abreve = 611, e4.multiply = 675, e4.uacute = 500, e4.Tcaron = 556, e4.partialdiff = 476, e4.ydieresis = 444, e4.Nacute = 667, e4.icircumflex = 278, e4.Ecircumflex = 611, e4.adieresis = 500, e4.edieresis = 444, e4.cacute = 444, e4.nacute = 500, e4.umacron = 500, e4.Ncaron = 667, e4.Iacute = 333, e4.plusminus = 675, e4.brokenbar = 275, e4.registered = 760, e4.Gbreve = 722, e4.Idotaccent = 333, e4.summation = 600, e4.Egrave = 611, e4.racute = 389, e4.omacron = 500, e4.Zacute = 556, e4.Zcaron = 556, e4.greaterequal = 549, e4.Eth = 722, e4.Ccedilla = 667, e4.lcommaaccent = 278, e4.tcaron = 300, e4.eogonek = 444, e4.Uogonek = 722, e4.Aacute = 611, e4.Adieresis = 611, e4.egrave = 444, e4.zacute = 389, e4.iogonek = 278, e4.Oacute = 722, e4.oacute = 500, e4.amacron = 500, e4.sacute = 389, e4.idieresis = 278, e4.Ocircumflex = 722, e4.Ugrave = 722, e4.Delta = 612, e4.thorn = 500, e4.twosuperior = 300, e4.Odieresis = 722, e4.mu = 500, e4.igrave = 278, e4.ohungarumlaut = 500, e4.Eogonek = 611, e4.dcroat = 500, e4.threequarters = 750, e4.Scedilla = 500, e4.lcaron = 300, e4.Kcommaaccent = 667, e4.Lacute = 556, e4.trademark = 980, e4.edotaccent = 444, e4.Igrave = 333, e4.Imacron = 333, e4.Lcaron = 611, e4.onehalf = 750, e4.lessequal = 549, e4.ocircumflex = 500, e4.ntilde = 500, e4.Uhungarumlaut = 722, e4.Eacute = 611, e4.emacron = 444, e4.gbreve = 500, e4.onequarter = 750, e4.Scaron = 500, e4.Scommaaccent = 500, e4.Ohungarumlaut = 722, e4.degree = 400, e4.ograve = 500, e4.Ccaron = 667, e4.ugrave = 500, e4.radical = 453, e4.Dcaron = 722, e4.rcommaaccent = 389, e4.Ntilde = 667, e4.otilde = 500, e4.Rcommaaccent = 611, e4.Lcommaaccent = 556, e4.Atilde = 611, e4.Aogonek = 611, e4.Aring = 611, e4.Otilde = 722, e4.zdotaccent = 389, e4.Ecaron = 611, e4.Iogonek = 333, e4.kcommaaccent = 444, e4.minus = 675, e4.Icircumflex = 333, e4.ncaron = 500, e4.tcommaaccent = 278, e4.logicalnot = 675, e4.odieresis = 500, e4.udieresis = 500, e4.notequal = 549, e4.gcommaaccent = 500, e4.eth = 500, e4.zcaron = 389, e4.ncommaaccent = 500, e4.onesuperior = 300, e4.imacron = 278, e4.Euro = 500;
      }), e3.ZapfDingbats = getLookupTableFactory(function(e4) {
        e4.space = 278, e4.a1 = 974, e4.a2 = 961, e4.a202 = 974, e4.a3 = 980, e4.a4 = 719, e4.a5 = 789, e4.a119 = 790, e4.a118 = 791, e4.a117 = 690, e4.a11 = 960, e4.a12 = 939, e4.a13 = 549, e4.a14 = 855, e4.a15 = 911, e4.a16 = 933, e4.a105 = 911, e4.a17 = 945, e4.a18 = 974, e4.a19 = 755, e4.a20 = 846, e4.a21 = 762, e4.a22 = 761, e4.a23 = 571, e4.a24 = 677, e4.a25 = 763, e4.a26 = 760, e4.a27 = 759, e4.a28 = 754, e4.a6 = 494, e4.a7 = 552, e4.a8 = 537, e4.a9 = 577, e4.a10 = 692, e4.a29 = 786, e4.a30 = 788, e4.a31 = 788, e4.a32 = 790, e4.a33 = 793, e4.a34 = 794, e4.a35 = 816, e4.a36 = 823, e4.a37 = 789, e4.a38 = 841, e4.a39 = 823, e4.a40 = 833, e4.a41 = 816, e4.a42 = 831, e4.a43 = 923, e4.a44 = 744, e4.a45 = 723, e4.a46 = 749, e4.a47 = 790, e4.a48 = 792, e4.a49 = 695, e4.a50 = 776, e4.a51 = 768, e4.a52 = 792, e4.a53 = 759, e4.a54 = 707, e4.a55 = 708, e4.a56 = 682, e4.a57 = 701, e4.a58 = 826, e4.a59 = 815, e4.a60 = 789, e4.a61 = 789, e4.a62 = 707, e4.a63 = 687, e4.a64 = 696, e4.a65 = 689, e4.a66 = 786, e4.a67 = 787, e4.a68 = 713, e4.a69 = 791, e4.a70 = 785, e4.a71 = 791, e4.a72 = 873, e4.a73 = 761, e4.a74 = 762, e4.a203 = 762, e4.a75 = 759, e4.a204 = 759, e4.a76 = 892, e4.a77 = 892, e4.a78 = 788, e4.a79 = 784, e4.a81 = 438, e4.a82 = 138, e4.a83 = 277, e4.a84 = 415, e4.a97 = 392, e4.a98 = 392, e4.a99 = 668, e4.a100 = 668, e4.a89 = 390, e4.a90 = 390, e4.a93 = 317, e4.a94 = 317, e4.a91 = 276, e4.a92 = 276, e4.a205 = 509, e4.a85 = 509, e4.a206 = 410, e4.a86 = 410, e4.a87 = 234, e4.a88 = 234, e4.a95 = 334, e4.a96 = 334, e4.a101 = 732, e4.a102 = 544, e4.a103 = 544, e4.a104 = 910, e4.a106 = 667, e4.a107 = 760, e4.a108 = 760, e4.a112 = 776, e4.a111 = 595, e4.a110 = 694, e4.a109 = 626, e4.a120 = 788, e4.a121 = 788, e4.a122 = 788, e4.a123 = 788, e4.a124 = 788, e4.a125 = 788, e4.a126 = 788, e4.a127 = 788, e4.a128 = 788, e4.a129 = 788, e4.a130 = 788, e4.a131 = 788, e4.a132 = 788, e4.a133 = 788, e4.a134 = 788, e4.a135 = 788, e4.a136 = 788, e4.a137 = 788, e4.a138 = 788, e4.a139 = 788, e4.a140 = 788, e4.a141 = 788, e4.a142 = 788, e4.a143 = 788, e4.a144 = 788, e4.a145 = 788, e4.a146 = 788, e4.a147 = 788, e4.a148 = 788, e4.a149 = 788, e4.a150 = 788, e4.a151 = 788, e4.a152 = 788, e4.a153 = 788, e4.a154 = 788, e4.a155 = 788, e4.a156 = 788, e4.a157 = 788, e4.a158 = 788, e4.a159 = 788, e4.a160 = 894, e4.a161 = 838, e4.a163 = 1016, e4.a164 = 458, e4.a196 = 748, e4.a165 = 924, e4.a192 = 748, e4.a166 = 918, e4.a167 = 927, e4.a168 = 928, e4.a169 = 928, e4.a170 = 834, e4.a171 = 873, e4.a172 = 828, e4.a173 = 924, e4.a162 = 924, e4.a174 = 917, e4.a175 = 930, e4.a176 = 931, e4.a177 = 463, e4.a178 = 883, e4.a179 = 836, e4.a193 = 836, e4.a180 = 867, e4.a199 = 867, e4.a181 = 696, e4.a200 = 696, e4.a182 = 874, e4.a201 = 874, e4.a183 = 760, e4.a184 = 946, e4.a197 = 771, e4.a185 = 865, e4.a194 = 771, e4.a198 = 888, e4.a186 = 967, e4.a195 = 888, e4.a187 = 831, e4.a188 = 873, e4.a189 = 927, e4.a190 = 970, e4.a191 = 918;
      });
    });
    Sr = getLookupTableFactory(function(e3) {
      e3.Courier = { ascent: 629, descent: -157, capHeight: 562, xHeight: -426 }, e3["Courier-Bold"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 439 }, e3["Courier-Oblique"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 426 }, e3["Courier-BoldOblique"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 426 }, e3.Helvetica = { ascent: 718, descent: -207, capHeight: 718, xHeight: 523 }, e3["Helvetica-Bold"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 532 }, e3["Helvetica-Oblique"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 523 }, e3["Helvetica-BoldOblique"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 532 }, e3["Times-Roman"] = { ascent: 683, descent: -217, capHeight: 662, xHeight: 450 }, e3["Times-Bold"] = { ascent: 683, descent: -217, capHeight: 676, xHeight: 461 }, e3["Times-Italic"] = { ascent: 683, descent: -217, capHeight: 653, xHeight: 441 }, e3["Times-BoldItalic"] = { ascent: 683, descent: -217, capHeight: 669, xHeight: 462 }, e3.Symbol = { ascent: Math.NaN, descent: Math.NaN, capHeight: Math.NaN, xHeight: Math.NaN }, e3.ZapfDingbats = { ascent: Math.NaN, descent: Math.NaN, capHeight: Math.NaN, xHeight: Math.NaN };
    });
    GlyfTable = class {
      constructor({ glyfTable: e3, isGlyphLocationsLong: t3, locaTable: i3, numGlyphs: a3 }) {
        this.glyphs = [];
        const s3 = new DataView(i3.buffer, i3.byteOffset, i3.byteLength), n3 = new DataView(e3.buffer, e3.byteOffset, e3.byteLength), r3 = t3 ? 4 : 2;
        let o3 = t3 ? s3.getUint32(0) : 2 * s3.getUint16(0), g3 = 0;
        for (let e4 = 0; e4 < a3; e4++) {
          g3 += r3;
          const e5 = t3 ? s3.getUint32(g3) : 2 * s3.getUint16(g3);
          if (e5 === o3) {
            this.glyphs.push(new Glyph({}));
            continue;
          }
          const i4 = Glyph.parse(o3, n3);
          this.glyphs.push(i4), o3 = e5;
        }
      }
      getSize() {
        return this.glyphs.reduce((e3, t3) => e3 + (t3.getSize() + 3 & -4), 0);
      }
      write() {
        const e3 = this.getSize(), t3 = new DataView(new ArrayBuffer(e3)), i3 = e3 > 131070, a3 = i3 ? 4 : 2, s3 = new DataView(new ArrayBuffer((this.glyphs.length + 1) * a3));
        i3 ? s3.setUint32(0, 0) : s3.setUint16(0, 0);
        let n3 = 0, r3 = 0;
        for (const e4 of this.glyphs) n3 += e4.write(n3, t3), n3 = n3 + 3 & -4, r3 += a3, i3 ? s3.setUint32(r3, n3) : s3.setUint16(r3, n3 >> 1);
        return { isLocationLong: i3, loca: new Uint8Array(s3.buffer), glyf: new Uint8Array(t3.buffer) };
      }
      scale(e3) {
        for (let t3 = 0, i3 = this.glyphs.length; t3 < i3; t3++) this.glyphs[t3].scale(e3[t3]);
      }
    };
    Glyph = class _Glyph {
      constructor({ header: e3 = null, simple: t3 = null, composites: i3 = null }) {
        this.header = e3, this.simple = t3, this.composites = i3;
      }
      static parse(e3, t3) {
        const [i3, a3] = GlyphHeader.parse(e3, t3);
        if (e3 += i3, a3.numberOfContours < 0) {
          const i4 = [];
          for (; ; ) {
            const [a4, s4] = CompositeGlyph.parse(e3, t3);
            if (e3 += a4, i4.push(s4), !(32 & s4.flags)) break;
          }
          return new _Glyph({ header: a3, composites: i4 });
        }
        const s3 = SimpleGlyph.parse(e3, t3, a3.numberOfContours);
        return new _Glyph({ header: a3, simple: s3 });
      }
      getSize() {
        if (!this.header) return 0;
        const e3 = this.simple ? this.simple.getSize() : this.composites.reduce((e4, t3) => e4 + t3.getSize(), 0);
        return this.header.getSize() + e3;
      }
      write(e3, t3) {
        if (!this.header) return 0;
        const i3 = e3;
        if (e3 += this.header.write(e3, t3), this.simple) e3 += this.simple.write(e3, t3);
        else for (const i4 of this.composites) e3 += i4.write(e3, t3);
        return e3 - i3;
      }
      scale(e3) {
        if (!this.header) return;
        const t3 = (this.header.xMin + this.header.xMax) / 2;
        if (this.header.scale(t3, e3), this.simple) this.simple.scale(t3, e3);
        else for (const i3 of this.composites) i3.scale(t3, e3);
      }
    };
    GlyphHeader = class _GlyphHeader {
      constructor({ numberOfContours: e3, xMin: t3, yMin: i3, xMax: a3, yMax: s3 }) {
        this.numberOfContours = e3, this.xMin = t3, this.yMin = i3, this.xMax = a3, this.yMax = s3;
      }
      static parse(e3, t3) {
        return [10, new _GlyphHeader({ numberOfContours: t3.getInt16(e3), xMin: t3.getInt16(e3 + 2), yMin: t3.getInt16(e3 + 4), xMax: t3.getInt16(e3 + 6), yMax: t3.getInt16(e3 + 8) })];
      }
      getSize() {
        return 10;
      }
      write(e3, t3) {
        return t3.setInt16(e3, this.numberOfContours), t3.setInt16(e3 + 2, this.xMin), t3.setInt16(e3 + 4, this.yMin), t3.setInt16(e3 + 6, this.xMax), t3.setInt16(e3 + 8, this.yMax), 10;
      }
      scale(e3, t3) {
        this.xMin = Math.round(e3 + (this.xMin - e3) * t3), this.xMax = Math.round(e3 + (this.xMax - e3) * t3);
      }
    };
    Contour = class {
      constructor({ flags: e3, xCoordinates: t3, yCoordinates: i3 }) {
        this.xCoordinates = t3, this.yCoordinates = i3, this.flags = e3;
      }
    };
    SimpleGlyph = class _SimpleGlyph {
      constructor({ contours: e3, instructions: t3 }) {
        this.contours = e3, this.instructions = t3;
      }
      static parse(e3, t3, i3) {
        const a3 = [];
        for (let s4 = 0; s4 < i3; s4++) {
          const i4 = t3.getUint16(e3);
          e3 += 2, a3.push(i4);
        }
        const s3 = a3[i3 - 1] + 1, n3 = t3.getUint16(e3);
        e3 += 2;
        const r3 = new Uint8Array(t3).slice(e3, e3 + n3);
        e3 += n3;
        const o3 = [];
        for (let i4 = 0; i4 < s3; e3++, i4++) {
          let a4 = t3.getUint8(e3);
          if (o3.push(a4), 8 & a4) {
            const s4 = t3.getUint8(++e3);
            a4 ^= 8;
            for (let e4 = 0; e4 < s4; e4++) o3.push(a4);
            i4 += s4;
          }
        }
        const g3 = [];
        let c3 = [], h3 = [], l3 = [];
        const C3 = [];
        let d3 = 0, u3 = 0;
        for (let i4 = 0; i4 < s3; i4++) {
          const s4 = o3[i4];
          if (2 & s4) {
            const i5 = t3.getUint8(e3++);
            u3 += 16 & s4 ? i5 : -i5, c3.push(u3);
          } else 16 & s4 || (u3 += t3.getInt16(e3), e3 += 2), c3.push(u3);
          a3[d3] === i4 && (d3++, g3.push(c3), c3 = []);
        }
        u3 = 0, d3 = 0;
        for (let i4 = 0; i4 < s3; i4++) {
          const s4 = o3[i4];
          if (4 & s4) {
            const i5 = t3.getUint8(e3++);
            u3 += 32 & s4 ? i5 : -i5, h3.push(u3);
          } else 32 & s4 || (u3 += t3.getInt16(e3), e3 += 2), h3.push(u3);
          l3.push(1 & s4 | 64 & s4), a3[d3] === i4 && (c3 = g3[d3], d3++, C3.push(new Contour({ flags: l3, xCoordinates: c3, yCoordinates: h3 })), h3 = [], l3 = []);
        }
        return new _SimpleGlyph({ contours: C3, instructions: r3 });
      }
      getSize() {
        let e3 = 2 * this.contours.length + 2 + this.instructions.length, t3 = 0, i3 = 0;
        for (const a3 of this.contours) {
          e3 += a3.flags.length;
          for (let s3 = 0, n3 = a3.xCoordinates.length; s3 < n3; s3++) {
            const n4 = a3.xCoordinates[s3], r3 = a3.yCoordinates[s3];
            let o3 = Math.abs(n4 - t3);
            o3 > 255 ? e3 += 2 : o3 > 0 && (e3 += 1), t3 = n4, o3 = Math.abs(r3 - i3), o3 > 255 ? e3 += 2 : o3 > 0 && (e3 += 1), i3 = r3;
          }
        }
        return e3;
      }
      write(e3, t3) {
        const i3 = e3, a3 = [], s3 = [], n3 = [];
        let r3 = 0, o3 = 0;
        for (const i4 of this.contours) {
          for (let e4 = 0, t4 = i4.xCoordinates.length; e4 < t4; e4++) {
            let t5 = i4.flags[e4];
            const g3 = i4.xCoordinates[e4];
            let c3 = g3 - r3;
            if (0 === c3) t5 |= 16, a3.push(0);
            else {
              const e5 = Math.abs(c3);
              e5 <= 255 ? (t5 |= c3 >= 0 ? 18 : 2, a3.push(e5)) : a3.push(c3);
            }
            r3 = g3;
            const h3 = i4.yCoordinates[e4];
            if (c3 = h3 - o3, 0 === c3) t5 |= 32, s3.push(0);
            else {
              const e5 = Math.abs(c3);
              e5 <= 255 ? (t5 |= c3 >= 0 ? 36 : 4, s3.push(e5)) : s3.push(c3);
            }
            o3 = h3, n3.push(t5);
          }
          t3.setUint16(e3, a3.length - 1), e3 += 2;
        }
        t3.setUint16(e3, this.instructions.length), e3 += 2, this.instructions.length && (new Uint8Array(t3.buffer, 0, t3.buffer.byteLength).set(this.instructions, e3), e3 += this.instructions.length);
        for (const i4 of n3) t3.setUint8(e3++, i4);
        for (let i4 = 0, s4 = a3.length; i4 < s4; i4++) {
          const s5 = a3[i4], r4 = n3[i4];
          2 & r4 ? t3.setUint8(e3++, s5) : 16 & r4 || (t3.setInt16(e3, s5), e3 += 2);
        }
        for (let i4 = 0, a4 = s3.length; i4 < a4; i4++) {
          const a5 = s3[i4], r4 = n3[i4];
          4 & r4 ? t3.setUint8(e3++, a5) : 32 & r4 || (t3.setInt16(e3, a5), e3 += 2);
        }
        return e3 - i3;
      }
      scale(e3, t3) {
        for (const i3 of this.contours) if (0 !== i3.xCoordinates.length) for (let a3 = 0, s3 = i3.xCoordinates.length; a3 < s3; a3++) i3.xCoordinates[a3] = Math.round(e3 + (i3.xCoordinates[a3] - e3) * t3);
      }
    };
    CompositeGlyph = class _CompositeGlyph {
      constructor({ flags: e3, glyphIndex: t3, argument1: i3, argument2: a3, transf: s3, instructions: n3 }) {
        this.flags = e3, this.glyphIndex = t3, this.argument1 = i3, this.argument2 = a3, this.transf = s3, this.instructions = n3;
      }
      static parse(e3, t3) {
        const i3 = e3, a3 = [];
        let s3 = t3.getUint16(e3);
        const n3 = t3.getUint16(e3 + 2);
        let r3, o3;
        e3 += 4, 1 & s3 ? (2 & s3 ? (r3 = t3.getInt16(e3), o3 = t3.getInt16(e3 + 2)) : (r3 = t3.getUint16(e3), o3 = t3.getUint16(e3 + 2)), e3 += 4, s3 ^= 1) : (2 & s3 ? (r3 = t3.getInt8(e3), o3 = t3.getInt8(e3 + 1)) : (r3 = t3.getUint8(e3), o3 = t3.getUint8(e3 + 1)), e3 += 2), 8 & s3 ? (a3.push(t3.getUint16(e3)), e3 += 2) : 64 & s3 ? (a3.push(t3.getUint16(e3), t3.getUint16(e3 + 2)), e3 += 4) : 128 & s3 && (a3.push(t3.getUint16(e3), t3.getUint16(e3 + 2), t3.getUint16(e3 + 4), t3.getUint16(e3 + 6)), e3 += 8);
        let g3 = null;
        if (256 & s3) {
          const i4 = t3.getUint16(e3);
          e3 += 2, g3 = new Uint8Array(t3).slice(e3, e3 + i4), e3 += i4;
        }
        return [e3 - i3, new _CompositeGlyph({ flags: s3, glyphIndex: n3, argument1: r3, argument2: o3, transf: a3, instructions: g3 })];
      }
      getSize() {
        let e3 = 4 + 2 * this.transf.length;
        return 256 & this.flags && (e3 += 2 + this.instructions.length), e3 += 2, 2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (e3 += 2) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (e3 += 2), e3;
      }
      write(e3, t3) {
        const i3 = e3;
        return 2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (this.flags |= 1) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (this.flags |= 1), t3.setUint16(e3, this.flags), t3.setUint16(e3 + 2, this.glyphIndex), e3 += 4, 1 & this.flags ? (2 & this.flags ? (t3.setInt16(e3, this.argument1), t3.setInt16(e3 + 2, this.argument2)) : (t3.setUint16(e3, this.argument1), t3.setUint16(e3 + 2, this.argument2)), e3 += 4) : (t3.setUint8(e3, this.argument1), t3.setUint8(e3 + 1, this.argument2), e3 += 2), 256 & this.flags && (t3.setUint16(e3, this.instructions.length), e3 += 2, this.instructions.length && (new Uint8Array(t3.buffer, 0, t3.buffer.byteLength).set(this.instructions, e3), e3 += this.instructions.length)), e3 - i3;
      }
      scale(e3, t3) {
      }
    };
    OpenTypeFileBuilder = class _OpenTypeFileBuilder {
      constructor(e3) {
        this.sfnt = e3, this.tables = /* @__PURE__ */ Object.create(null);
      }
      static getSearchParams(e3, t3) {
        let i3 = 1, a3 = 0;
        for (; (i3 ^ e3) > i3; ) i3 <<= 1, a3++;
        const s3 = i3 * t3;
        return { range: s3, entry: a3, rangeShift: t3 * e3 - s3 };
      }
      toArray() {
        let e3 = this.sfnt;
        const t3 = this.tables, i3 = Object.keys(t3);
        i3.sort();
        const a3 = i3.length;
        let s3, n3, r3, o3, g3, c3 = 12 + 16 * a3;
        const h3 = [c3];
        for (s3 = 0; s3 < a3; s3++) {
          o3 = t3[i3[s3]];
          c3 += (o3.length + 3 & -4) >>> 0, h3.push(c3);
        }
        const l3 = new Uint8Array(c3);
        for (s3 = 0; s3 < a3; s3++) o3 = t3[i3[s3]], writeData(l3, h3[s3], o3);
        "true" === e3 && (e3 = string32(65536)), l3[0] = 255 & e3.charCodeAt(0), l3[1] = 255 & e3.charCodeAt(1), l3[2] = 255 & e3.charCodeAt(2), l3[3] = 255 & e3.charCodeAt(3), writeInt16(l3, 4, a3);
        const C3 = _OpenTypeFileBuilder.getSearchParams(a3, 16);
        for (writeInt16(l3, 6, C3.range), writeInt16(l3, 8, C3.entry), writeInt16(l3, 10, C3.rangeShift), c3 = 12, s3 = 0; s3 < a3; s3++) {
          g3 = i3[s3], l3[c3] = 255 & g3.charCodeAt(0), l3[c3 + 1] = 255 & g3.charCodeAt(1), l3[c3 + 2] = 255 & g3.charCodeAt(2), l3[c3 + 3] = 255 & g3.charCodeAt(3);
          let e4 = 0;
          for (n3 = h3[s3], r3 = h3[s3 + 1]; n3 < r3; n3 += 4) {
            e4 = e4 + readUint32(l3, n3) >>> 0;
          }
          writeInt32(l3, c3 + 4, e4), writeInt32(l3, c3 + 8, h3[s3]), writeInt32(l3, c3 + 12, t3[g3].length), c3 += 16;
        }
        return l3;
      }
      addTable(e3, t3) {
        if (e3 in this.tables) throw new Error("Table " + e3 + " already exists");
        this.tables[e3] = t3;
      }
    };
    Fr = [4];
    kr = [5];
    Rr = [6];
    xr = [7];
    Nr = [8];
    Mr = [12, 35];
    Gr = [14];
    vr = [21];
    Lr = [22];
    Ur = [30];
    Hr = [31];
    Type1CharString = class {
      constructor() {
        this.width = 0, this.lsb = 0, this.flexing = false, this.output = [], this.stack = [];
      }
      convert(e3, t3, i3) {
        const a3 = e3.length;
        let s3, n3, r3, o3 = false;
        for (let g3 = 0; g3 < a3; g3++) {
          let a4 = e3[g3];
          if (a4 < 32) {
            switch (12 === a4 && (a4 = (a4 << 8) + e3[++g3]), a4) {
              case 1:
              case 3:
              case 9:
              case 3072:
              case 3073:
              case 3074:
              case 3105:
                this.stack = [];
                break;
              case 4:
                if (this.flexing) {
                  if (this.stack.length < 1) {
                    o3 = true;
                    break;
                  }
                  const e5 = this.stack.pop();
                  this.stack.push(0, e5);
                  break;
                }
                o3 = this.executeCommand(1, Fr);
                break;
              case 5:
                o3 = this.executeCommand(2, kr);
                break;
              case 6:
                o3 = this.executeCommand(1, Rr);
                break;
              case 7:
                o3 = this.executeCommand(1, xr);
                break;
              case 8:
                o3 = this.executeCommand(6, Nr);
                break;
              case 10:
                if (this.stack.length < 1) {
                  o3 = true;
                  break;
                }
                if (r3 = this.stack.pop(), !t3[r3]) {
                  o3 = true;
                  break;
                }
                o3 = this.convert(t3[r3], t3, i3);
                break;
              case 11:
                return o3;
              case 13:
                if (this.stack.length < 2) {
                  o3 = true;
                  break;
                }
                s3 = this.stack.pop(), n3 = this.stack.pop(), this.lsb = n3, this.width = s3, this.stack.push(s3, n3), o3 = this.executeCommand(2, Lr);
                break;
              case 14:
                this.output.push(Gr[0]);
                break;
              case 21:
                if (this.flexing) break;
                o3 = this.executeCommand(2, vr);
                break;
              case 22:
                if (this.flexing) {
                  this.stack.push(0);
                  break;
                }
                o3 = this.executeCommand(1, Lr);
                break;
              case 30:
                o3 = this.executeCommand(4, Ur);
                break;
              case 31:
                o3 = this.executeCommand(4, Hr);
                break;
              case 3078:
                if (i3) {
                  const e5 = this.stack.at(-5);
                  this.seac = this.stack.splice(-4, 4), this.seac[0] += this.lsb - e5, o3 = this.executeCommand(0, Gr);
                } else o3 = this.executeCommand(4, Gr);
                break;
              case 3079:
                if (this.stack.length < 4) {
                  o3 = true;
                  break;
                }
                this.stack.pop(), s3 = this.stack.pop();
                const e4 = this.stack.pop();
                n3 = this.stack.pop(), this.lsb = n3, this.width = s3, this.stack.push(s3, n3, e4), o3 = this.executeCommand(3, vr);
                break;
              case 3084:
                if (this.stack.length < 2) {
                  o3 = true;
                  break;
                }
                const g4 = this.stack.pop(), c3 = this.stack.pop();
                this.stack.push(c3 / g4);
                break;
              case 3088:
                if (this.stack.length < 2) {
                  o3 = true;
                  break;
                }
                r3 = this.stack.pop();
                const h3 = this.stack.pop();
                if (0 === r3 && 3 === h3) {
                  const e5 = this.stack.splice(-17, 17);
                  this.stack.push(e5[2] + e5[0], e5[3] + e5[1], e5[4], e5[5], e5[6], e5[7], e5[8], e5[9], e5[10], e5[11], e5[12], e5[13], e5[14]), o3 = this.executeCommand(13, Mr, true), this.flexing = false, this.stack.push(e5[15], e5[16]);
                } else 1 === r3 && 0 === h3 && (this.flexing = true);
                break;
              case 3089:
                break;
              default:
                warn('Unknown type 1 charstring command of "' + a4 + '"');
            }
            if (o3) break;
          } else a4 <= 246 ? a4 -= 139 : a4 = a4 <= 250 ? 256 * (a4 - 247) + e3[++g3] + 108 : a4 <= 254 ? -256 * (a4 - 251) - e3[++g3] - 108 : (255 & e3[++g3]) << 24 | (255 & e3[++g3]) << 16 | (255 & e3[++g3]) << 8 | 255 & e3[++g3], this.stack.push(a4);
        }
        return o3;
      }
      executeCommand(e3, t3, i3) {
        const a3 = this.stack.length;
        if (e3 > a3) return true;
        const s3 = a3 - e3;
        for (let e4 = s3; e4 < a3; e4++) {
          let t4 = this.stack[e4];
          Number.isInteger(t4) ? this.output.push(28, t4 >> 8 & 255, 255 & t4) : (t4 = 65536 * t4 | 0, this.output.push(255, t4 >> 24 & 255, t4 >> 16 & 255, t4 >> 8 & 255, 255 & t4));
        }
        return this.output.push(...t3), i3 ? this.stack.splice(s3, e3) : this.stack.length = 0, false;
      }
    };
    Type1Parser = class {
      constructor(e3, t3, i3) {
        if (t3) {
          const t4 = e3.getBytes(), i4 = !((isHexDigit(t4[0]) || isWhiteSpace(t4[0])) && isHexDigit(t4[1]) && isHexDigit(t4[2]) && isHexDigit(t4[3]) && isHexDigit(t4[4]) && isHexDigit(t4[5]) && isHexDigit(t4[6]) && isHexDigit(t4[7]));
          e3 = new Stream(i4 ? decrypt(t4, 55665, 4) : function(e4, t5, i5) {
            let a3 = 0 | t5;
            const s3 = e4.length, n3 = new Uint8Array(s3 >>> 1);
            let r3, o3;
            for (r3 = 0, o3 = 0; r3 < s3; r3++) {
              const t6 = e4[r3];
              if (!isHexDigit(t6)) continue;
              let i6;
              for (r3++; r3 < s3 && !isHexDigit(i6 = e4[r3]); ) r3++;
              if (r3 < s3) {
                const e5 = parseInt(String.fromCharCode(t6, i6), 16);
                n3[o3++] = e5 ^ a3 >> 8, a3 = 52845 * (e5 + a3) + 22719 & 65535;
              }
            }
            return n3.slice(i5, o3);
          }(t4, 55665, 4));
        }
        this.seacAnalysisEnabled = !!i3, this.stream = e3, this.nextChar();
      }
      readNumberArray() {
        this.getToken();
        const e3 = [];
        for (; ; ) {
          const t3 = this.getToken();
          if (null === t3 || "]" === t3 || "}" === t3) break;
          e3.push(parseFloat(t3 || 0));
        }
        return e3;
      }
      readNumber() {
        const e3 = this.getToken();
        return parseFloat(e3 || 0);
      }
      readInt() {
        const e3 = this.getToken();
        return 0 | parseInt(e3 || 0, 10);
      }
      readBoolean() {
        return "true" === this.getToken() ? 1 : 0;
      }
      nextChar() {
        return this.currentChar = this.stream.getByte();
      }
      prevChar() {
        return this.stream.skip(-2), this.currentChar = this.stream.getByte();
      }
      getToken() {
        let e3 = false, t3 = this.currentChar;
        for (; ; ) {
          if (-1 === t3) return null;
          if (e3) 10 !== t3 && 13 !== t3 || (e3 = false);
          else if (37 === t3) e3 = true;
          else if (!isWhiteSpace(t3)) break;
          t3 = this.nextChar();
        }
        if (isSpecial(t3)) return this.nextChar(), String.fromCharCode(t3);
        let i3 = "";
        do {
          i3 += String.fromCharCode(t3), t3 = this.nextChar();
        } while (t3 >= 0 && !isWhiteSpace(t3) && !isSpecial(t3));
        return i3;
      }
      readCharStrings(e3, t3) {
        return -1 === t3 ? e3 : decrypt(e3, 4330, t3);
      }
      extractFontProgram(e3) {
        const t3 = this.stream, i3 = [], a3 = [], s3 = /* @__PURE__ */ Object.create(null);
        s3.lenIV = 4;
        const n3 = { subrs: [], charstrings: [], properties: { privateData: s3 } };
        let r3, o3, g3, c3;
        for (; null !== (r3 = this.getToken()); ) if ("/" === r3) switch (r3 = this.getToken(), r3) {
          case "CharStrings":
            for (this.getToken(), this.getToken(), this.getToken(), this.getToken(); r3 = this.getToken(), null !== r3 && "end" !== r3; ) {
              if ("/" !== r3) continue;
              const e5 = this.getToken();
              o3 = this.readInt(), this.getToken(), g3 = o3 > 0 ? t3.getBytes(o3) : new Uint8Array(0), c3 = n3.properties.privateData.lenIV;
              const i4 = this.readCharStrings(g3, c3);
              this.nextChar(), r3 = this.getToken(), "noaccess" === r3 ? this.getToken() : "/" === r3 && this.prevChar(), a3.push({ glyph: e5, encoded: i4 });
            }
            break;
          case "Subrs":
            for (this.readInt(), this.getToken(); "dup" === this.getToken(); ) {
              const e5 = this.readInt();
              o3 = this.readInt(), this.getToken(), g3 = o3 > 0 ? t3.getBytes(o3) : new Uint8Array(0), c3 = n3.properties.privateData.lenIV;
              const a4 = this.readCharStrings(g3, c3);
              this.nextChar(), r3 = this.getToken(), "noaccess" === r3 && this.getToken(), i3[e5] = a4;
            }
            break;
          case "BlueValues":
          case "OtherBlues":
          case "FamilyBlues":
          case "FamilyOtherBlues":
            const e4 = this.readNumberArray();
            e4.length > 0 && e4.length, 0;
            break;
          case "StemSnapH":
          case "StemSnapV":
            n3.properties.privateData[r3] = this.readNumberArray();
            break;
          case "StdHW":
          case "StdVW":
            n3.properties.privateData[r3] = this.readNumberArray()[0];
            break;
          case "BlueShift":
          case "lenIV":
          case "BlueFuzz":
          case "BlueScale":
          case "LanguageGroup":
            n3.properties.privateData[r3] = this.readNumber();
            break;
          case "ExpansionFactor":
            n3.properties.privateData[r3] = this.readNumber() || 0.06;
            break;
          case "ForceBold":
            n3.properties.privateData[r3] = this.readBoolean();
        }
        for (const { encoded: t4, glyph: s4 } of a3) {
          const a4 = new Type1CharString(), r4 = a4.convert(t4, i3, this.seacAnalysisEnabled);
          let o4 = a4.output;
          r4 && (o4 = [14]);
          const g4 = { glyphName: s4, charstring: o4, width: a4.width, lsb: a4.lsb, seac: a4.seac };
          if (".notdef" === s4 ? n3.charstrings.unshift(g4) : n3.charstrings.push(g4), e3.builtInEncoding) {
            const t5 = e3.builtInEncoding.indexOf(s4);
            t5 > -1 && void 0 === e3.widths[t5] && t5 >= e3.firstChar && t5 <= e3.lastChar && (e3.widths[t5] = a4.width);
          }
        }
        return n3;
      }
      extractFontHeader(e3) {
        let t3;
        for (; null !== (t3 = this.getToken()); ) if ("/" === t3) switch (t3 = this.getToken(), t3) {
          case "FontMatrix":
            const i3 = this.readNumberArray();
            e3.fontMatrix = i3;
            break;
          case "Encoding":
            const a3 = this.getToken();
            let s3;
            if (/^\d+$/.test(a3)) {
              s3 = [];
              const e4 = 0 | parseInt(a3, 10);
              this.getToken();
              for (let i4 = 0; i4 < e4; i4++) {
                for (t3 = this.getToken(); "dup" !== t3 && "def" !== t3; ) if (t3 = this.getToken(), null === t3) return;
                if ("def" === t3) break;
                const e5 = this.readInt();
                this.getToken();
                const i5 = this.getToken();
                s3[e5] = i5, this.getToken();
              }
            } else s3 = getEncoding(a3);
            e3.builtInEncoding = s3;
            break;
          case "FontBBox":
            const n3 = this.readNumberArray();
            e3.ascent = Math.max(n3[3], n3[1]), e3.descent = Math.min(n3[1], n3[3]), e3.ascentScaled = true;
        }
      }
    };
    Type1Font = class {
      constructor(e3, t3, i3) {
        let a3 = i3.length1;
        i3.length2;
        let s3 = t3.peekBytes(6);
        const n3 = 128 === s3[0] && 1 === s3[1];
        n3 && (t3.skip(6), a3 = s3[5] << 24 | s3[4] << 16 | s3[3] << 8 | s3[2]);
        const r3 = function(e4, t4) {
          const i4 = [101, 101, 120, 101, 99], a4 = e4.pos;
          let s4, n4, r4, o4;
          try {
            s4 = e4.getBytes(t4), n4 = s4.length;
          } catch {
          }
          if (n4 === t4 && (r4 = findBlock(s4, i4, t4 - 2 * i4.length), r4.found && r4.length === t4)) return { stream: new Stream(s4), length: t4 };
          for (warn('Invalid "Length1" property in Type1 font -- trying to recover.'), e4.pos = a4; r4 = findBlock(e4.peekBytes(2048), i4, 0), 0 !== r4.length; ) if (e4.pos += r4.length, r4.found) {
            o4 = e4.pos - a4;
            break;
          }
          return e4.pos = a4, o4 ? { stream: new Stream(e4.getBytes(o4)), length: o4 } : (warn('Unable to recover "Length1" property in Type1 font -- using as is.'), { stream: new Stream(e4.getBytes(t4)), length: t4 });
        }(t3, a3);
        new Type1Parser(r3.stream, false, gr).extractFontHeader(i3), n3 && (s3 = t3.getBytes(6), s3[5], s3[4], s3[3], s3[2]);
        const o3 = function(e4) {
          const t4 = e4.getBytes();
          if (0 === t4.length) throw new FormatError("getEexecBlock - no font program found.");
          return { stream: new Stream(t4), length: t4.length };
        }(t3), g3 = new Type1Parser(o3.stream, true, gr).extractFontProgram(i3);
        for (const e4 in g3.properties) i3[e4] = g3.properties[e4];
        const c3 = g3.charstrings, h3 = this.getType2Charstrings(c3), l3 = this.getType2Subrs(g3.subrs);
        this.charstrings = c3, this.data = this.wrap(e3, h3, this.charstrings, l3, i3), this.seacs = this.getSeacs(g3.charstrings);
      }
      get numGlyphs() {
        return this.charstrings.length + 1;
      }
      getCharset() {
        const e3 = [".notdef"];
        for (const { glyphName: t3 } of this.charstrings) e3.push(t3);
        return e3;
      }
      getGlyphMapping(e3) {
        const t3 = this.charstrings;
        if (e3.composite) {
          const i4 = /* @__PURE__ */ Object.create(null);
          for (let a4 = 0, s4 = t3.length; a4 < s4; a4++) {
            i4[e3.cMap.charCodeOf(a4)] = a4 + 1;
          }
          return i4;
        }
        const i3 = [".notdef"];
        let a3, s3;
        for (s3 = 0; s3 < t3.length; s3++) i3.push(t3[s3].glyphName);
        const n3 = e3.builtInEncoding;
        if (n3) {
          a3 = /* @__PURE__ */ Object.create(null);
          for (const e4 in n3) s3 = i3.indexOf(n3[e4]), s3 >= 0 && (a3[e4] = s3);
        }
        return type1FontGlyphMapping(e3, a3, i3);
      }
      hasGlyphId(e3) {
        if (e3 < 0 || e3 >= this.numGlyphs) return false;
        if (0 === e3) return true;
        return this.charstrings[e3 - 1].charstring.length > 0;
      }
      getSeacs(e3) {
        const t3 = [];
        for (let i3 = 0, a3 = e3.length; i3 < a3; i3++) {
          const a4 = e3[i3];
          a4.seac && (t3[i3 + 1] = a4.seac);
        }
        return t3;
      }
      getType2Charstrings(e3) {
        const t3 = [];
        for (const i3 of e3) t3.push(i3.charstring);
        return t3;
      }
      getType2Subrs(e3) {
        let t3 = 0;
        const i3 = e3.length;
        t3 = i3 < 1133 ? 107 : i3 < 33769 ? 1131 : 32768;
        const a3 = [];
        let s3;
        for (s3 = 0; s3 < t3; s3++) a3.push([11]);
        for (s3 = 0; s3 < i3; s3++) a3.push(e3[s3]);
        return a3;
      }
      wrap(e3, t3, i3, a3, s3) {
        const n3 = new CFF();
        n3.header = new CFFHeader(1, 0, 4, 4), n3.names = [e3];
        const r3 = new CFFTopDict();
        r3.setByName("version", 391), r3.setByName("Notice", 392), r3.setByName("FullName", 393), r3.setByName("FamilyName", 394), r3.setByName("Weight", 395), r3.setByName("Encoding", null), r3.setByName("FontMatrix", s3.fontMatrix), r3.setByName("FontBBox", s3.bbox), r3.setByName("charset", null), r3.setByName("CharStrings", null), r3.setByName("Private", null), n3.topDict = r3;
        const o3 = new CFFStrings();
        o3.add("Version 0.11"), o3.add("See original notice"), o3.add(e3), o3.add(e3), o3.add("Medium"), n3.strings = o3, n3.globalSubrIndex = new CFFIndex();
        const g3 = t3.length, c3 = [".notdef"];
        let h3, l3;
        for (h3 = 0; h3 < g3; h3++) {
          const e4 = i3[h3].glyphName;
          -1 === Vn.indexOf(e4) && o3.add(e4), c3.push(e4);
        }
        n3.charset = new CFFCharset(false, 0, c3);
        const C3 = new CFFIndex();
        for (C3.add([139, 14]), h3 = 0; h3 < g3; h3++) C3.add(t3[h3]);
        n3.charStrings = C3;
        const d3 = new CFFPrivateDict();
        d3.setByName("Subrs", null);
        const u3 = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
        for (h3 = 0, l3 = u3.length; h3 < l3; h3++) {
          const e4 = u3[h3];
          if (!(e4 in s3.privateData)) continue;
          const t4 = s3.privateData[e4];
          if (Array.isArray(t4)) for (let e5 = t4.length - 1; e5 > 0; e5--) t4[e5] -= t4[e5 - 1];
          d3.setByName(e4, t4);
        }
        n3.topDict.privateDict = d3;
        const Q3 = new CFFIndex();
        for (h3 = 0, l3 = a3.length; h3 < l3; h3++) Q3.add(a3[h3]);
        d3.subrsIndex = Q3;
        return new CFFCompiler(n3).compile();
      }
    };
    Tr = [[57344, 63743], [1048576, 1114109]];
    Jr = 1e3;
    Yr = ["ascent", "bbox", "black", "bold", "charProcOperatorList", "composite", "cssFontInfo", "data", "defaultVMetrics", "defaultWidth", "descent", "fallbackName", "fontMatrix", "isInvalidPDFjsFont", "isType3Font", "italic", "loadedName", "mimetype", "missingFile", "name", "remeasure", "subtype", "systemFontInfo", "type", "vertical"];
    Pr = ["cMap", "defaultEncoding", "differences", "isMonospace", "isSerifFont", "isSymbolicFont", "seacMap", "toFontChar", "toUnicode", "vmetrics", "widths"];
    fonts_Glyph = class {
      constructor(e3, t3, i3, a3, s3, n3, r3, o3, g3) {
        this.originalCharCode = e3, this.fontChar = t3, this.unicode = i3, this.accent = a3, this.width = s3, this.vmetric = n3, this.operatorListId = r3, this.isSpace = o3, this.isInFont = g3;
      }
      get category() {
        return shadow(this, "category", function(e3) {
          const t3 = or.get(e3);
          if (t3) return t3;
          const i3 = e3.match(rr), a3 = { isWhitespace: !!i3?.[1], isZeroWidthDiacritic: !!i3?.[2], isInvisibleFormatMark: !!i3?.[3] };
          return or.set(e3, a3), a3;
        }(this.unicode), true);
      }
    };
    Font = class {
      constructor(e3, t3, i3) {
        this.name = e3, this.psName = null, this.mimetype = null, this.disableFontFace = false, this.loadedName = i3.loadedName, this.isType3Font = i3.isType3Font, this.missingFile = false, this.cssFontInfo = i3.cssFontInfo, this._charsCache = /* @__PURE__ */ Object.create(null), this._glyphCache = /* @__PURE__ */ Object.create(null);
        let a3 = !!(i3.flags & hr);
        if (!a3 && !i3.isSimulatedFlags) {
          const t4 = e3.replaceAll(/[,_]/g, "-").split("-", 1)[0], i4 = fr();
          for (const e4 of t4.split("+")) if (i4[e4]) {
            a3 = true;
            break;
          }
        }
        this.isSerifFont = a3, this.isSymbolicFont = !!(i3.flags & lr), this.isMonospace = !!(i3.flags & cr);
        let { type: s3, subtype: n3 } = i3;
        this.type = s3, this.subtype = n3, this.systemFontInfo = i3.systemFontInfo;
        const r3 = e3.match(/^InvalidPDFjsFont_(.*)_\d+$/);
        if (this.isInvalidPDFjsFont = !!r3, this.isInvalidPDFjsFont ? this.fallbackName = r3[1] : this.isMonospace ? this.fallbackName = "monospace" : this.isSerifFont ? this.fallbackName = "serif" : this.fallbackName = "sans-serif", this.systemFontInfo?.guessFallback && (this.systemFontInfo.guessFallback = false, this.systemFontInfo.css += `,${this.fallbackName}`), this.differences = i3.differences, this.widths = i3.widths, this.defaultWidth = i3.defaultWidth, this.composite = i3.composite, this.cMap = i3.cMap, this.capHeight = i3.capHeight / Jr, this.ascent = i3.ascent / Jr, this.descent = i3.descent / Jr, this.lineHeight = this.ascent - this.descent, this.fontMatrix = i3.fontMatrix, this.bbox = i3.bbox, this.defaultEncoding = i3.defaultEncoding, this.toUnicode = i3.toUnicode, this.toFontChar = [], "Type3" === i3.type) {
          for (let e4 = 0; e4 < 256; e4++) this.toFontChar[e4] = this.differences[e4] || i3.defaultEncoding[e4];
          return;
        }
        if (this.cidEncoding = i3.cidEncoding || "", this.vertical = !!i3.vertical, this.vertical && (this.vmetrics = i3.vmetrics, this.defaultVMetrics = i3.defaultVMetrics), !t3 || t3.isEmpty) return t3 && warn('Font file is empty in "' + e3 + '" (' + this.loadedName + ")"), void this.fallbackToSystemFont(i3);
        let o3;
        [s3, n3] = getFontFileType(t3, i3), s3 === this.type && n3 === this.subtype || info(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${s3}/${n3}.`);
        try {
          switch (s3) {
            case "MMType1":
              info("MMType1 font (" + e3 + "), falling back to Type1.");
            case "Type1":
            case "CIDFontType0":
              this.mimetype = "font/opentype";
              const a4 = "Type1C" === n3 || "CIDFontType0C" === n3 ? new CFFFont(t3, i3) : new Type1Font(e3, t3, i3);
              adjustWidths(i3), o3 = this.convert(e3, a4, i3);
              break;
            case "OpenType":
            case "TrueType":
            case "CIDFontType2":
              this.mimetype = "font/opentype", o3 = this.checkAndRepair(e3, t3, i3), this.isOpenType && (adjustWidths(i3), s3 = "OpenType");
              break;
            default:
              throw new FormatError(`Font ${s3} is not supported`);
          }
        } catch (e4) {
          return warn(e4), void this.fallbackToSystemFont(i3);
        }
        amendFallbackToUnicode(i3), this.data = o3, this.type = s3, this.subtype = n3, this.fontMatrix = i3.fontMatrix, this.widths = i3.widths, this.defaultWidth = i3.defaultWidth, this.toUnicode = i3.toUnicode, this.seacMap = i3.seacMap;
      }
      get renderer() {
        return shadow(this, "renderer", FontRendererFactory.create(this, gr));
      }
      exportData(e3 = false) {
        const t3 = e3 ? [...Yr, ...Pr] : Yr, i3 = /* @__PURE__ */ Object.create(null);
        let a3, s3;
        for (a3 of t3) s3 = this[a3], void 0 !== s3 && (i3[a3] = s3);
        return i3;
      }
      fallbackToSystemFont(e3) {
        this.missingFile = true;
        const { name: t3, type: i3 } = this;
        let a3 = normalizeFontName(t3);
        const s3 = ur(), n3 = Er(), r3 = !!s3[a3], o3 = !(!n3[a3] || !s3[n3[a3]]);
        a3 = s3[a3] || n3[a3] || a3;
        const g3 = Sr()[a3];
        g3 && (isNaN(this.ascent) && (this.ascent = g3.ascent / Jr), isNaN(this.descent) && (this.descent = g3.descent / Jr), isNaN(this.capHeight) && (this.capHeight = g3.capHeight / Jr)), this.bold = /bold/gi.test(a3), this.italic = /oblique|italic/gi.test(a3), this.black = /Black/g.test(t3);
        const c3 = /Narrow/g.test(t3);
        if (this.remeasure = (!r3 || c3) && Object.keys(this.widths).length > 0, (r3 || o3) && "CIDFontType2" === i3 && this.cidEncoding.startsWith("Identity-")) {
          const i4 = e3.cidToGidMap, a4 = [];
          if (applyStandardFontGlyphMap(a4, mr()), /Arial-?Black/i.test(t3) ? applyStandardFontGlyphMap(a4, yr()) : /Calibri/i.test(t3) && applyStandardFontGlyphMap(a4, wr()), i4) {
            for (const e4 in a4) {
              const t4 = a4[e4];
              void 0 !== i4[t4] && (a4[+e4] = i4[t4]);
            }
            i4.length !== this.toUnicode.length && e3.hasIncludedToUnicodeMap && this.toUnicode instanceof IdentityToUnicodeMap && this.toUnicode.forEach(function(e4, t4) {
              const s4 = a4[e4];
              void 0 === i4[s4] && (a4[+e4] = t4);
            });
          }
          this.toUnicode instanceof IdentityToUnicodeMap || this.toUnicode.forEach(function(e4, t4) {
            a4[+e4] = t4;
          }), this.toFontChar = a4, this.toUnicode = new ToUnicodeMap(a4);
        } else if (/Symbol/i.test(a3)) this.toFontChar = buildToFontChar(jn, ir(), this.differences);
        else if (/Dingbats/i.test(a3)) this.toFontChar = buildToFontChar(Xn, ar(), this.differences);
        else if (r3 || o3) {
          const e4 = buildToFontChar(this.defaultEncoding, ir(), this.differences);
          "CIDFontType2" !== i3 || this.cidEncoding.startsWith("Identity-") || this.toUnicode instanceof IdentityToUnicodeMap || this.toUnicode.forEach(function(t4, i4) {
            e4[+t4] = i4;
          }), this.toFontChar = e4;
        } else {
          const e4 = ir(), i4 = [];
          this.toUnicode.forEach((t4, a4) => {
            if (!this.composite) {
              const i5 = getUnicodeForGlyph(this.differences[t4] || this.defaultEncoding[t4], e4);
              -1 !== i5 && (a4 = i5);
            }
            i4[+t4] = a4;
          }), this.composite && this.toUnicode instanceof IdentityToUnicodeMap && /Tahoma|Verdana/i.test(t3) && applyStandardFontGlyphMap(i4, mr()), this.toFontChar = i4;
        }
        amendFallbackToUnicode(e3), this.loadedName = a3.split("-", 1)[0];
      }
      checkAndRepair(e3, t3, i3) {
        const a3 = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
        function readTables(e4, t4) {
          const i4 = /* @__PURE__ */ Object.create(null);
          i4["OS/2"] = null, i4.cmap = null, i4.head = null, i4.hhea = null, i4.hmtx = null, i4.maxp = null, i4.name = null, i4.post = null;
          for (let s4 = 0; s4 < t4; s4++) {
            const t5 = readTableEntry(e4);
            a3.includes(t5.tag) && (0 !== t5.length && (i4[t5.tag] = t5));
          }
          return i4;
        }
        function readTableEntry(e4) {
          const t4 = e4.getString(4), i4 = e4.getInt32() >>> 0, a4 = e4.getInt32() >>> 0, s4 = e4.getInt32() >>> 0, n4 = e4.pos;
          e4.pos = e4.start || 0, e4.skip(a4);
          const r4 = e4.getBytes(s4);
          return e4.pos = n4, "head" === t4 && (r4[8] = r4[9] = r4[10] = r4[11] = 0, r4[17] |= 32), { tag: t4, checksum: i4, length: s4, offset: a4, data: r4 };
        }
        function readOpenTypeHeader(e4) {
          return { version: e4.getString(4), numTables: e4.getUint16(), searchRange: e4.getUint16(), entrySelector: e4.getUint16(), rangeShift: e4.getUint16() };
        }
        function sanitizeGlyph(e4, t4, i4, a4, s4, n4) {
          const r4 = { length: 0, sizeOfInstructions: 0 };
          if (t4 < 0 || t4 >= e4.length || i4 > e4.length || i4 - t4 <= 12) return r4;
          const o4 = e4.subarray(t4, i4), g4 = signedInt16(o4[2], o4[3]), c4 = signedInt16(o4[4], o4[5]), h4 = signedInt16(o4[6], o4[7]), l4 = signedInt16(o4[8], o4[9]);
          g4 > h4 && (writeSignedInt16(o4, 2, h4), writeSignedInt16(o4, 6, g4)), c4 > l4 && (writeSignedInt16(o4, 4, l4), writeSignedInt16(o4, 8, c4));
          const C4 = signedInt16(o4[0], o4[1]);
          if (C4 < 0) return C4 < -1 || (a4.set(o4, s4), r4.length = o4.length), r4;
          let d4, u4 = 10, Q4 = 0;
          for (d4 = 0; d4 < C4; d4++) {
            Q4 = (o4[u4] << 8 | o4[u4 + 1]) + 1, u4 += 2;
          }
          const f4 = u4, p4 = o4[u4] << 8 | o4[u4 + 1];
          r4.sizeOfInstructions = p4, u4 += 2 + p4;
          const m4 = u4;
          let y4 = 0;
          for (d4 = 0; d4 < Q4; d4++) {
            const e5 = o4[u4++];
            192 & e5 && (o4[u4 - 1] = 63 & e5);
            let t5 = 2;
            2 & e5 ? t5 = 1 : 16 & e5 && (t5 = 0);
            let i5 = 2;
            4 & e5 ? i5 = 1 : 32 & e5 && (i5 = 0);
            const a5 = t5 + i5;
            if (y4 += a5, 8 & e5) {
              const e6 = o4[u4++];
              0 === e6 && (o4[u4 - 1] ^= 8), d4 += e6, y4 += e6 * a5;
            }
          }
          if (0 === y4) return r4;
          let w4 = u4 + y4;
          return w4 > o4.length ? r4 : !n4 && p4 > 0 ? (a4.set(o4.subarray(0, f4), s4), a4.set([0, 0], s4 + f4), a4.set(o4.subarray(m4, w4), s4 + f4 + 2), w4 -= p4, o4.length - w4 > 3 && (w4 = w4 + 3 & -4), r4.length = w4, r4) : o4.length - w4 > 3 ? (w4 = w4 + 3 & -4, a4.set(o4.subarray(0, w4), s4), r4.length = w4, r4) : (a4.set(o4, s4), r4.length = o4.length, r4);
        }
        function readNameTable(e4) {
          const i4 = (t3.start || 0) + e4.offset;
          t3.pos = i4;
          const a4 = [[], []], s4 = [], n4 = e4.length, r4 = i4 + n4;
          if (0 !== t3.getUint16() || n4 < 6) return [a4, s4];
          const o4 = t3.getUint16(), g4 = t3.getUint16();
          let c4, h4;
          for (c4 = 0; c4 < o4 && t3.pos + 12 <= r4; c4++) {
            const e5 = { platform: t3.getUint16(), encoding: t3.getUint16(), language: t3.getUint16(), name: t3.getUint16(), length: t3.getUint16(), offset: t3.getUint16() };
            (isMacNameRecord(e5) || isWinNameRecord(e5)) && s4.push(e5);
          }
          for (c4 = 0, h4 = s4.length; c4 < h4; c4++) {
            const e5 = s4[c4];
            if (e5.length <= 0) continue;
            const n5 = i4 + g4 + e5.offset;
            if (n5 + e5.length > r4) continue;
            t3.pos = n5;
            const o5 = e5.name;
            if (e5.encoding) {
              let i5 = "";
              for (let a5 = 0, s5 = e5.length; a5 < s5; a5 += 2) i5 += String.fromCharCode(t3.getUint16());
              a4[1][o5] = i5;
            } else a4[0][o5] = t3.getString(e5.length);
          }
          return [a4, s4];
        }
        const s3 = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
        function sanitizeTTProgram(e4, t4) {
          let i4, a4, n4, r4, o4, g4 = e4.data, c4 = 0, h4 = 0, l4 = 0;
          const C4 = [], d4 = [], u4 = [];
          let Q4 = t4.tooComplexToFollowFunctions, f4 = false, p4 = 0, m4 = 0;
          for (let e5 = g4.length; c4 < e5; ) {
            const e6 = g4[c4++];
            if (64 === e6) if (a4 = g4[c4++], f4 || m4) c4 += a4;
            else for (i4 = 0; i4 < a4; i4++) C4.push(g4[c4++]);
            else if (65 === e6) if (a4 = g4[c4++], f4 || m4) c4 += 2 * a4;
            else for (i4 = 0; i4 < a4; i4++) n4 = g4[c4++], C4.push(n4 << 8 | g4[c4++]);
            else if (176 == (248 & e6)) if (a4 = e6 - 176 + 1, f4 || m4) c4 += a4;
            else for (i4 = 0; i4 < a4; i4++) C4.push(g4[c4++]);
            else if (184 == (248 & e6)) if (a4 = e6 - 184 + 1, f4 || m4) c4 += 2 * a4;
            else for (i4 = 0; i4 < a4; i4++) n4 = g4[c4++], C4.push(n4 << 8 | g4[c4++]);
            else if (43 !== e6 || Q4) if (44 !== e6 || Q4) {
              if (45 === e6) if (f4) f4 = false, h4 = c4;
              else {
                if (o4 = d4.pop(), !o4) return warn("TT: ENDF bad stack"), void (t4.hintsValid = false);
                r4 = u4.pop(), g4 = o4.data, c4 = o4.i, t4.functionsStackDeltas[r4] = C4.length - o4.stackTop;
              }
              else if (137 === e6) (f4 || m4) && (warn("TT: nested IDEFs not allowed"), Q4 = true), f4 = true, l4 = c4;
              else if (88 === e6) ++p4;
              else if (27 === e6) m4 = p4;
              else if (89 === e6) m4 === p4 && (m4 = 0), --p4;
              else if (28 === e6 && !f4 && !m4) {
                const e7 = C4.at(-1);
                e7 > 0 && (c4 += e7 - 1);
              }
            } else (f4 || m4) && (warn("TT: nested FDEFs not allowed"), Q4 = true), f4 = true, l4 = c4, r4 = C4.pop(), t4.functionsDefined[r4] = { data: g4, i: c4 };
            else if (!f4 && !m4) {
              if (r4 = C4.at(-1), isNaN(r4)) info("TT: CALL empty stack (or invalid entry).");
              else if (t4.functionsUsed[r4] = true, r4 in t4.functionsStackDeltas) {
                const e7 = C4.length + t4.functionsStackDeltas[r4];
                if (e7 < 0) return warn("TT: CALL invalid functions stack delta."), void (t4.hintsValid = false);
                C4.length = e7;
              } else if (r4 in t4.functionsDefined && !u4.includes(r4)) {
                if (d4.push({ data: g4, i: c4, stackTop: C4.length - 1 }), u4.push(r4), o4 = t4.functionsDefined[r4], !o4) return warn("TT: CALL non-existent function"), void (t4.hintsValid = false);
                g4 = o4.data, c4 = o4.i;
              }
            }
            if (!f4 && !m4) {
              let t5 = 0;
              for (e6 <= 142 ? t5 = s3[e6] : e6 >= 192 && e6 <= 223 ? t5 = -1 : e6 >= 224 && (t5 = -2), e6 >= 113 && e6 <= 117 && (a4 = C4.pop(), isNaN(a4) || (t5 = 2 * -a4)); t5 < 0 && C4.length > 0; ) C4.pop(), t5++;
              for (; t5 > 0; ) C4.push(NaN), t5--;
            }
          }
          t4.tooComplexToFollowFunctions = Q4;
          const y4 = [g4];
          c4 > g4.length && y4.push(new Uint8Array(c4 - g4.length)), l4 > h4 && (warn("TT: complementing a missing function tail"), y4.push(new Uint8Array([34, 45]))), function(e5, t5) {
            if (t5.length > 1) {
              let i5, a5, s4 = 0;
              for (i5 = 0, a5 = t5.length; i5 < a5; i5++) s4 += t5[i5].length;
              s4 = s4 + 3 & -4;
              const n5 = new Uint8Array(s4);
              let r5 = 0;
              for (i5 = 0, a5 = t5.length; i5 < a5; i5++) n5.set(t5[i5], r5), r5 += t5[i5].length;
              e5.data = n5, e5.length = s4;
            }
          }(e4, y4);
        }
        let n3, r3, o3, g3;
        if (isTrueTypeCollectionFile(t3 = new Stream(new Uint8Array(t3.getBytes())))) {
          const e4 = function(e5, t4) {
            const { numFonts: i4, offsetTable: a4 } = function(e6) {
              const t5 = e6.getString(4);
              assert("ttcf" === t5, "Must be a TrueType Collection font.");
              const i5 = e6.getUint16(), a5 = e6.getUint16(), s5 = e6.getInt32() >>> 0, n5 = [];
              for (let t6 = 0; t6 < s5; t6++) n5.push(e6.getInt32() >>> 0);
              const r4 = { ttcTag: t5, majorVersion: i5, minorVersion: a5, numFonts: s5, offsetTable: n5 };
              switch (i5) {
                case 1:
                  return r4;
                case 2:
                  return r4.dsigTag = e6.getInt32() >>> 0, r4.dsigLength = e6.getInt32() >>> 0, r4.dsigOffset = e6.getInt32() >>> 0, r4;
              }
              throw new FormatError(`Invalid TrueType Collection majorVersion: ${i5}.`);
            }(e5), s4 = t4.split("+");
            let n4;
            for (let r4 = 0; r4 < i4; r4++) {
              e5.pos = (e5.start || 0) + a4[r4];
              const i5 = readOpenTypeHeader(e5), o4 = readTables(e5, i5.numTables);
              if (!o4.name) throw new FormatError('TrueType Collection font must contain a "name" table.');
              const [g4] = readNameTable(o4.name);
              for (let e6 = 0, a5 = g4.length; e6 < a5; e6++) for (let a6 = 0, r5 = g4[e6].length; a6 < r5; a6++) {
                const r6 = g4[e6][a6]?.replaceAll(/\s/g, "");
                if (r6) {
                  if (r6 === t4) return { header: i5, tables: o4 };
                  if (!(s4.length < 2)) for (const e7 of s4) r6 === e7 && (n4 = { name: e7, header: i5, tables: o4 });
                }
              }
            }
            if (n4) return warn(`TrueType Collection does not contain "${t4}" font, falling back to "${n4.name}" font instead.`), { header: n4.header, tables: n4.tables };
            throw new FormatError(`TrueType Collection does not contain "${t4}" font.`);
          }(t3, this.name);
          n3 = e4.header, r3 = e4.tables;
        } else n3 = readOpenTypeHeader(t3), r3 = readTables(t3, n3.numTables);
        const c3 = !r3["CFF "];
        if (c3) {
          if (!r3.loca) throw new FormatError('Required "loca" table is not found');
          r3.glyf || (warn('Required "glyf" table is not found -- trying to recover.'), r3.glyf = { tag: "glyf", data: new Uint8Array(0) }), this.isOpenType = false;
        } else {
          const t4 = i3.composite && (i3.cidToGidMap?.length > 0 || !(i3.cMap instanceof IdentityCMap));
          if ("OTTO" === n3.version && !t4 || !r3.head || !r3.hhea || !r3.maxp || !r3.post) return g3 = new Stream(r3["CFF "].data), o3 = new CFFFont(g3, i3), adjustWidths(i3), this.convert(e3, o3, i3);
          delete r3.glyf, delete r3.loca, delete r3.fpgm, delete r3.prep, delete r3["cvt "], this.isOpenType = true;
        }
        if (!r3.maxp) throw new FormatError('Required "maxp" table is not found');
        t3.pos = (t3.start || 0) + r3.maxp.offset;
        let h3 = t3.getInt32();
        const l3 = t3.getUint16();
        if (65536 !== h3 && 20480 !== h3) {
          if (6 === r3.maxp.length) h3 = 20480;
          else {
            if (!(r3.maxp.length >= 32)) throw new FormatError('"maxp" table has a wrong version number');
            h3 = 65536;
          }
          !function(e4, t4, i4) {
            e4[t4 + 3] = 255 & i4, e4[t4 + 2] = i4 >>> 8, e4[t4 + 1] = i4 >>> 16, e4[t4] = i4 >>> 24;
          }(r3.maxp.data, 0, h3);
        }
        if (i3.scaleFactors?.length === l3 && c3) {
          const { scaleFactors: e4 } = i3, t4 = int16(r3.head.data[50], r3.head.data[51]), a4 = new GlyfTable({ glyfTable: r3.glyf.data, isGlyphLocationsLong: t4, locaTable: r3.loca.data, numGlyphs: l3 });
          a4.scale(e4);
          const { glyf: s4, loca: n4, isLocationLong: o4 } = a4.write();
          r3.glyf.data = s4, r3.loca.data = n4, o4 !== !!t4 && (r3.head.data[50] = 0, r3.head.data[51] = o4 ? 1 : 0);
          const g4 = r3.hmtx.data;
          for (let t5 = 0; t5 < l3; t5++) {
            const i4 = 4 * t5, a5 = Math.round(e4[t5] * int16(g4[i4], g4[i4 + 1]));
            g4[i4] = a5 >> 8 & 255, g4[i4 + 1] = 255 & a5;
            writeSignedInt16(g4, i4 + 2, Math.round(e4[t5] * signedInt16(g4[i4 + 2], g4[i4 + 3])));
          }
        }
        let C3 = l3 + 1, d3 = true;
        C3 > 65535 && (d3 = false, C3 = l3, warn("Not enough space in glyfs to duplicate first glyph."));
        let u3 = 0, Q3 = 0;
        if (h3 >= 65536 && r3.maxp.length >= 32) {
          t3.pos += 8;
          t3.getUint16() > 2 && (r3.maxp.data[14] = 0, r3.maxp.data[15] = 2), t3.pos += 4, u3 = t3.getUint16(), t3.pos += 4, Q3 = t3.getUint16();
        }
        r3.maxp.data[4] = C3 >> 8, r3.maxp.data[5] = 255 & C3;
        const f3 = function(e4, t4, i4, a4) {
          const s4 = { functionsDefined: [], functionsUsed: [], functionsStackDeltas: [], tooComplexToFollowFunctions: false, hintsValid: true };
          if (e4 && sanitizeTTProgram(e4, s4), t4 && sanitizeTTProgram(t4, s4), e4 && function(e5, t5) {
            if (!e5.tooComplexToFollowFunctions) {
              if (e5.functionsDefined.length > t5) return warn("TT: more functions defined than expected"), void (e5.hintsValid = false);
              for (let i5 = 0, a5 = e5.functionsUsed.length; i5 < a5; i5++) {
                if (i5 > t5) return warn("TT: invalid function id: " + i5), void (e5.hintsValid = false);
                if (e5.functionsUsed[i5] && !e5.functionsDefined[i5]) return warn("TT: undefined function: " + i5), void (e5.hintsValid = false);
              }
            }
          }(s4, a4), i4 && 1 & i4.length) {
            const e5 = new Uint8Array(i4.length + 1);
            e5.set(i4.data), i4.data = e5;
          }
          return s4.hintsValid;
        }(r3.fpgm, r3.prep, r3["cvt "], u3);
        if (f3 || (delete r3.fpgm, delete r3.prep, delete r3["cvt "]), function(e4, t4, i4, a4, s4, n4) {
          if (!t4) return void (i4 && (i4.data = null));
          e4.pos = (e4.start || 0) + t4.offset, e4.pos += 4, e4.pos += 2, e4.pos += 2, e4.pos += 2, e4.pos += 2, e4.pos += 2, e4.pos += 2, e4.pos += 2, e4.pos += 2, e4.pos += 2;
          const r4 = e4.getUint16();
          e4.pos += 8, e4.pos += 2;
          let o4 = e4.getUint16();
          if (0 !== r4) {
            2 & int16(a4.data[44], a4.data[45]) || (t4.data[22] = 0, t4.data[23] = 0);
          }
          o4 > s4 && (info(`The numOfMetrics (${o4}) should not be greater than the numGlyphs (${s4}).`), o4 = s4, t4.data[34] = (65280 & o4) >> 8, t4.data[35] = 255 & o4);
          const g4 = s4 - o4 - (i4.length - 4 * o4 >> 1);
          if (g4 > 0) {
            const e5 = new Uint8Array(i4.length + 2 * g4);
            e5.set(i4.data), n4 && (e5[i4.length] = i4.data[2], e5[i4.length + 1] = i4.data[3]), i4.data = e5;
          }
        }(t3, r3.hhea, r3.hmtx, r3.head, C3, d3), !r3.head) throw new FormatError('Required "head" table is not found');
        !function(e4, t4, i4) {
          const a4 = e4.data, s4 = (n4 = a4[0], r4 = a4[1], o4 = a4[2], g4 = a4[3], (n4 << 24) + (r4 << 16) + (o4 << 8) + g4);
          var n4, r4, o4, g4;
          s4 >> 16 != 1 && (info("Attempting to fix invalid version in head table: " + s4), a4[0] = 0, a4[1] = 1, a4[2] = 0, a4[3] = 0);
          const c4 = int16(a4[50], a4[51]);
          if (c4 < 0 || c4 > 1) {
            info("Attempting to fix invalid indexToLocFormat in head table: " + c4);
            const e5 = t4 + 1;
            if (i4 === e5 << 1) a4[50] = 0, a4[51] = 0;
            else {
              if (i4 !== e5 << 2) throw new FormatError("Could not fix indexToLocFormat: " + c4);
              a4[50] = 0, a4[51] = 1;
            }
          }
        }(r3.head, l3, c3 ? r3.loca.length : 0);
        let p3 = /* @__PURE__ */ Object.create(null);
        if (c3) {
          const e4 = int16(r3.head.data[50], r3.head.data[51]), t4 = function(e5, t5, i4, a4, s4, n4, r4) {
            let o4, g4, c4;
            a4 ? (o4 = 4, g4 = function(e6, t6) {
              return e6[t6] << 24 | e6[t6 + 1] << 16 | e6[t6 + 2] << 8 | e6[t6 + 3];
            }, c4 = function(e6, t6, i5) {
              e6[t6] = i5 >>> 24 & 255, e6[t6 + 1] = i5 >> 16 & 255, e6[t6 + 2] = i5 >> 8 & 255, e6[t6 + 3] = 255 & i5;
            }) : (o4 = 2, g4 = function(e6, t6) {
              return e6[t6] << 9 | e6[t6 + 1] << 1;
            }, c4 = function(e6, t6, i5) {
              e6[t6] = i5 >> 9 & 255, e6[t6 + 1] = i5 >> 1 & 255;
            });
            const h4 = n4 ? i4 + 1 : i4, l4 = o4 * (1 + h4), C4 = new Uint8Array(l4);
            C4.set(e5.data.subarray(0, l4)), e5.data = C4;
            const d4 = t5.data, u4 = d4.length, Q4 = new Uint8Array(u4);
            let f4, p4;
            const m4 = [];
            for (f4 = 0, p4 = 0; f4 < i4 + 1; f4++, p4 += o4) {
              let e6 = g4(C4, p4);
              e6 > u4 && (e6 = u4), m4.push({ index: f4, offset: e6, endOffset: 0 });
            }
            for (m4.sort((e6, t6) => e6.offset - t6.offset), f4 = 0; f4 < i4; f4++) m4[f4].endOffset = m4[f4 + 1].offset;
            for (m4.sort((e6, t6) => e6.index - t6.index), f4 = 0; f4 < i4; f4++) {
              const { offset: e6, endOffset: t6 } = m4[f4];
              if (0 !== e6 || 0 !== t6) break;
              const i5 = m4[f4 + 1].offset;
              if (0 !== i5) {
                m4[f4].endOffset = i5;
                break;
              }
            }
            const y4 = m4.at(-2);
            0 !== y4.offset && 0 === y4.endOffset && (y4.endOffset = u4);
            const w4 = /* @__PURE__ */ Object.create(null);
            let b4 = 0;
            for (c4(C4, 0, b4), f4 = 0, p4 = o4; f4 < i4; f4++, p4 += o4) {
              const e6 = sanitizeGlyph(d4, m4[f4].offset, m4[f4].endOffset, Q4, b4, s4), t6 = e6.length;
              0 === t6 && (w4[f4] = true), e6.sizeOfInstructions > r4 && (r4 = e6.sizeOfInstructions), b4 += t6, c4(C4, p4, b4);
            }
            if (0 === b4) {
              const e6 = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
              for (f4 = 0, p4 = o4; f4 < h4; f4++, p4 += o4) c4(C4, p4, e6.length);
              t5.data = e6;
            } else if (n4) {
              const i5 = g4(C4, o4);
              Q4.length > i5 + b4 ? t5.data = Q4.subarray(0, i5 + b4) : (t5.data = new Uint8Array(i5 + b4), t5.data.set(Q4.subarray(0, b4))), t5.data.set(Q4.subarray(0, i5), b4), c4(e5.data, C4.length - o4, b4 + i5);
            } else t5.data = Q4.subarray(0, b4);
            return { missingGlyphs: w4, maxSizeOfInstructions: r4 };
          }(r3.loca, r3.glyf, l3, e4, f3, d3, Q3);
          p3 = t4.missingGlyphs, h3 >= 65536 && r3.maxp.length >= 32 && (r3.maxp.data[26] = t4.maxSizeOfInstructions >> 8, r3.maxp.data[27] = 255 & t4.maxSizeOfInstructions);
        }
        if (!r3.hhea) throw new FormatError('Required "hhea" table is not found');
        0 === r3.hhea.data[10] && 0 === r3.hhea.data[11] && (r3.hhea.data[10] = 255, r3.hhea.data[11] = 255);
        const m3 = { unitsPerEm: int16(r3.head.data[18], r3.head.data[19]), yMax: signedInt16(r3.head.data[42], r3.head.data[43]), yMin: signedInt16(r3.head.data[38], r3.head.data[39]), ascent: signedInt16(r3.hhea.data[4], r3.hhea.data[5]), descent: signedInt16(r3.hhea.data[6], r3.hhea.data[7]), lineGap: signedInt16(r3.hhea.data[8], r3.hhea.data[9]) };
        this.ascent = m3.ascent / m3.unitsPerEm, this.descent = m3.descent / m3.unitsPerEm, this.lineGap = m3.lineGap / m3.unitsPerEm, this.cssFontInfo?.lineHeight ? (this.lineHeight = this.cssFontInfo.metrics.lineHeight, this.lineGap = this.cssFontInfo.metrics.lineGap) : this.lineHeight = this.ascent - this.descent + this.lineGap, r3.post && function(e4, i4, a4) {
          const s4 = (t3.start || 0) + e4.offset;
          t3.pos = s4;
          const n4 = s4 + e4.length, r4 = t3.getInt32();
          let o4;
          t3.skip(28);
          let g4, c4 = true;
          switch (r4) {
            case 65536:
              o4 = Cr;
              break;
            case 131072:
              const e5 = t3.getUint16();
              if (e5 !== a4) {
                c4 = false;
                break;
              }
              const s5 = [];
              for (g4 = 0; g4 < e5; ++g4) {
                const e6 = t3.getUint16();
                if (e6 >= 32768) {
                  c4 = false;
                  break;
                }
                s5.push(e6);
              }
              if (!c4) break;
              const h4 = [], l4 = [];
              for (; t3.pos < n4; ) {
                const e6 = t3.getByte();
                for (l4.length = e6, g4 = 0; g4 < e6; ++g4) l4[g4] = String.fromCharCode(t3.getByte());
                h4.push(l4.join(""));
              }
              for (o4 = [], g4 = 0; g4 < e5; ++g4) {
                const e6 = s5[g4];
                e6 < 258 ? o4.push(Cr[e6]) : o4.push(h4[e6 - 258]);
              }
              break;
            case 196608:
              break;
            default:
              warn("Unknown/unsupported post table version " + r4), c4 = false, i4.defaultEncoding && (o4 = i4.defaultEncoding);
          }
          i4.glyphNames = o4;
        }(r3.post, i3, l3), r3.post = { tag: "post", data: createPostTable(i3) };
        const y3 = /* @__PURE__ */ Object.create(null);
        function hasGlyph(e4) {
          return !p3[e4];
        }
        if (i3.composite) {
          const e4 = i3.cidToGidMap || [], t4 = 0 === e4.length;
          i3.cMap.forEach(function(i4, a4) {
            if ("string" == typeof a4 && (a4 = convertCidString(i4, a4, true)), a4 > 65535) throw new FormatError("Max size of CID is 65,535");
            let s4 = -1;
            t4 ? s4 = a4 : void 0 !== e4[a4] && (s4 = e4[a4]), s4 >= 0 && s4 < l3 && hasGlyph(s4) && (y3[i4] = s4);
          });
        } else {
          const e4 = function(e5, t4, i4, a5) {
            if (!e5) return warn("No cmap table available."), { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false };
            let s5, n5 = (t4.start || 0) + e5.offset;
            t4.pos = n5, t4.skip(2);
            const r4 = t4.getUint16();
            let o5, g5 = false;
            for (let e6 = 0; e6 < r4; e6++) {
              const s6 = t4.getUint16(), n6 = t4.getUint16(), c5 = t4.getInt32() >>> 0;
              let h5 = false;
              if (o5?.platformId !== s6 || o5?.encodingId !== n6) {
                if (0 !== s6 || 0 !== n6 && 1 !== n6 && 3 !== n6) if (1 === s6 && 0 === n6) h5 = true;
                else if (3 !== s6 || 1 !== n6 || !a5 && o5) {
                  if (i4 && 3 === s6 && 0 === n6) {
                    h5 = true;
                    let i5 = true;
                    if (e6 < r4 - 1) {
                      const e7 = t4.peekBytes(2);
                      int16(e7[0], e7[1]) < s6 && (i5 = false);
                    }
                    i5 && (g5 = true);
                  }
                } else h5 = true, i4 || (g5 = true);
                else h5 = true;
                if (h5 && (o5 = { platformId: s6, encodingId: n6, offset: c5 }), g5) break;
              }
            }
            if (o5 && (t4.pos = n5 + o5.offset), !o5 || -1 === t4.peekByte()) return warn("Could not find a preferred cmap table."), { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false };
            const c4 = t4.getUint16();
            let h4 = false;
            const l4 = [];
            let C4, d4;
            if (0 === c4) {
              for (t4.skip(4), C4 = 0; C4 < 256; C4++) {
                const e6 = t4.getByte();
                e6 && l4.push({ charCode: C4, glyphId: e6 });
              }
              h4 = true;
            } else if (2 === c4) {
              t4.skip(4);
              const e6 = [];
              let i5 = 0;
              for (let a7 = 0; a7 < 256; a7++) {
                const a8 = t4.getUint16() >> 3;
                e6.push(a8), i5 = Math.max(a8, i5);
              }
              const a6 = [];
              for (let e7 = 0; e7 <= i5; e7++) a6.push({ firstCode: t4.getUint16(), entryCount: t4.getUint16(), idDelta: signedInt16(t4.getByte(), t4.getByte()), idRangePos: t4.pos + t4.getUint16() });
              for (let i6 = 0; i6 < 256; i6++) if (0 === e6[i6]) t4.pos = a6[0].idRangePos + 2 * i6, d4 = t4.getUint16(), l4.push({ charCode: i6, glyphId: d4 });
              else {
                const s6 = a6[e6[i6]];
                for (C4 = 0; C4 < s6.entryCount; C4++) {
                  const e7 = (i6 << 8) + C4 + s6.firstCode;
                  t4.pos = s6.idRangePos + 2 * C4, d4 = t4.getUint16(), 0 !== d4 && (d4 = (d4 + s6.idDelta) % 65536), l4.push({ charCode: e7, glyphId: d4 });
                }
              }
            } else if (4 === c4) {
              t4.skip(4);
              const e6 = t4.getUint16() >> 1;
              t4.skip(6);
              const i5 = [];
              let a6;
              for (a6 = 0; a6 < e6; a6++) i5.push({ end: t4.getUint16() });
              for (t4.skip(2), a6 = 0; a6 < e6; a6++) i5[a6].start = t4.getUint16();
              for (a6 = 0; a6 < e6; a6++) i5[a6].delta = t4.getUint16();
              let r5, o6 = 0;
              for (a6 = 0; a6 < e6; a6++) {
                s5 = i5[a6];
                const n6 = t4.getUint16();
                n6 ? (r5 = (n6 >> 1) - (e6 - a6), s5.offsetIndex = r5, o6 = Math.max(o6, r5 + s5.end - s5.start + 1)) : s5.offsetIndex = -1;
              }
              const g6 = [];
              for (C4 = 0; C4 < o6; C4++) g6.push(t4.getUint16());
              for (a6 = 0; a6 < e6; a6++) {
                s5 = i5[a6], n5 = s5.start;
                const e7 = s5.end, t5 = s5.delta;
                for (r5 = s5.offsetIndex, C4 = n5; C4 <= e7; C4++) 65535 !== C4 && (d4 = r5 < 0 ? C4 : g6[r5 + C4 - n5], d4 = d4 + t5 & 65535, l4.push({ charCode: C4, glyphId: d4 }));
              }
            } else if (6 === c4) {
              t4.skip(4);
              const e6 = t4.getUint16(), i5 = t4.getUint16();
              for (C4 = 0; C4 < i5; C4++) {
                d4 = t4.getUint16();
                const i6 = e6 + C4;
                l4.push({ charCode: i6, glyphId: d4 });
              }
            } else {
              if (12 !== c4) return warn("cmap table has unsupported format: " + c4), { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false };
              {
                t4.skip(10);
                const e6 = t4.getInt32() >>> 0;
                for (C4 = 0; C4 < e6; C4++) {
                  const e7 = t4.getInt32() >>> 0, i5 = t4.getInt32() >>> 0;
                  let a6 = t4.getInt32() >>> 0;
                  for (let t5 = e7; t5 <= i5; t5++) l4.push({ charCode: t5, glyphId: a6++ });
                }
              }
            }
            l4.sort(function(e6, t5) {
              return e6.charCode - t5.charCode;
            });
            for (let e6 = 1; e6 < l4.length; e6++) l4[e6 - 1].charCode === l4[e6].charCode && (l4.splice(e6, 1), e6--);
            return { platformId: o5.platformId, encodingId: o5.encodingId, mappings: l4, hasShortCmap: h4 };
          }(r3.cmap, t3, this.isSymbolicFont, i3.hasEncoding), a4 = e4.platformId, s4 = e4.encodingId, n4 = e4.mappings;
          let o4 = [], g4 = false;
          if (!i3.hasEncoding || "MacRomanEncoding" !== i3.baseEncodingName && "WinAnsiEncoding" !== i3.baseEncodingName || (o4 = getEncoding(i3.baseEncodingName)), i3.hasEncoding && !this.isSymbolicFont && (3 === a4 && 1 === s4 || 1 === a4 && 0 === s4)) {
            const e5 = ir();
            for (let t4 = 0; t4 < 256; t4++) {
              let r4;
              if (r4 = void 0 !== this.differences[t4] ? this.differences[t4] : o4.length && "" !== o4[t4] ? o4[t4] : _n2[t4], !r4) continue;
              const g5 = recoverGlyphName(r4, e5);
              let c4;
              if (3 === a4 && 1 === s4 ? c4 = e5[g5] : 1 === a4 && 0 === s4 && (c4 = qn.indexOf(g5)), void 0 === c4) {
                if (!i3.glyphNames && i3.hasIncludedToUnicodeMap && !(this.toUnicode instanceof IdentityToUnicodeMap)) {
                  const e6 = this.toUnicode.get(t4);
                  e6 && (c4 = e6.codePointAt(0));
                }
                if (void 0 === c4) continue;
              }
              for (const e6 of n4) if (e6.charCode === c4) {
                y3[t4] = e6.glyphId;
                break;
              }
            }
          } else if (0 === a4) {
            for (const e5 of n4) y3[e5.charCode] = e5.glyphId;
            g4 = true;
          } else if (3 === a4 && 0 === s4) for (const e5 of n4) {
            let t4 = e5.charCode;
            t4 >= 61440 && t4 <= 61695 && (t4 &= 255), y3[t4] = e5.glyphId;
          }
          else for (const e5 of n4) y3[e5.charCode] = e5.glyphId;
          if (i3.glyphNames && (o4.length || this.differences.length)) for (let e5 = 0; e5 < 256; ++e5) {
            if (!g4 && void 0 !== y3[e5]) continue;
            const t4 = this.differences[e5] || o4[e5];
            if (!t4) continue;
            const a5 = i3.glyphNames.indexOf(t4);
            a5 > 0 && hasGlyph(a5) && (y3[e5] = a5);
          }
        }
        0 === y3.length && (y3[0] = 0);
        let w3 = C3 - 1;
        if (d3 || (w3 = 0), !i3.cssFontInfo) {
          const e4 = adjustMapping(y3, hasGlyph, w3, this.toUnicode);
          this.toFontChar = e4.toFontChar, r3.cmap = { tag: "cmap", data: createCmapTable(e4.charCodeToGlyphId, e4.toUnicodeExtraMap, C3) }, r3["OS/2"] && function(e5, t4) {
            t4.pos = (t4.start || 0) + e5.offset;
            const i4 = t4.getUint16();
            t4.skip(60);
            const a4 = t4.getUint16();
            return !(i4 < 4 && 768 & a4) && (!(t4.getUint16() > t4.getUint16()) && (t4.skip(6), 0 !== t4.getUint16() && (e5.data[8] = e5.data[9] = 0, true)));
          }(r3["OS/2"], t3) || (r3["OS/2"] = { tag: "OS/2", data: createOS2Table(i3, e4.charCodeToGlyphId, m3) });
        }
        if (!c3) try {
          g3 = new Stream(r3["CFF "].data);
          o3 = new CFFParser(g3, i3, gr).parse(), o3.duplicateFirstGlyph();
          const e4 = new CFFCompiler(o3);
          r3["CFF "].data = e4.compile();
        } catch {
          warn("Failed to compile font " + i3.loadedName);
        }
        if (r3.name) {
          const [t4, a4] = readNameTable(r3.name);
          r3.name.data = createNameTable(e3, t4), this.psName = t4[0][6] || null, i3.composite || function(e4, t5, i4) {
            if (e4.isInternalFont) return;
            if (e4.hasIncludedToUnicodeMap) return;
            if (e4.hasEncoding) return;
            if (e4.toUnicode instanceof IdentityToUnicodeMap) return;
            if (!t5) return;
            if (0 === i4.length) return;
            if (e4.defaultEncoding === Wn) return;
            for (const e5 of i4) if (!isWinNameRecord(e5)) return;
            const a5 = Wn, s4 = [], n4 = ir();
            for (const e5 in a5) {
              const t6 = a5[e5];
              if ("" === t6) continue;
              const i5 = n4[t6];
              void 0 !== i5 && (s4[e5] = String.fromCharCode(i5));
            }
            s4.length > 0 && e4.toUnicode.amend(s4);
          }(i3, this.isSymbolicFont, a4);
        } else r3.name = { tag: "name", data: createNameTable(this.name) };
        const b3 = new OpenTypeFileBuilder(n3.version);
        for (const e4 in r3) b3.addTable(e4, r3[e4].data);
        return b3.toArray();
      }
      convert(e3, t3, i3) {
        i3.fixedPitch = false, i3.builtInEncoding && function(e4, t4) {
          if (e4.isInternalFont) return;
          if (e4.hasIncludedToUnicodeMap) return;
          if (t4 === e4.defaultEncoding) return;
          if (e4.toUnicode instanceof IdentityToUnicodeMap) return;
          const i4 = [], a4 = ir();
          for (const s4 in t4) {
            if (e4.hasEncoding && (e4.baseEncodingName || void 0 !== e4.differences[s4])) continue;
            const n4 = getUnicodeForGlyph(t4[s4], a4);
            -1 !== n4 && (i4[s4] = String.fromCharCode(n4));
          }
          i4.length > 0 && e4.toUnicode.amend(i4);
        }(i3, i3.builtInEncoding);
        let a3 = 1;
        t3 instanceof CFFFont && (a3 = t3.numGlyphs - 1);
        const s3 = t3.getGlyphMapping(i3);
        let n3 = null, r3 = s3, o3 = null;
        i3.cssFontInfo || (n3 = adjustMapping(s3, t3.hasGlyphId.bind(t3), a3, this.toUnicode), this.toFontChar = n3.toFontChar, r3 = n3.charCodeToGlyphId, o3 = n3.toUnicodeExtraMap);
        const g3 = t3.numGlyphs;
        function getCharCodes(e4, t4) {
          let i4 = null;
          for (const a4 in e4) t4 === e4[a4] && (i4 || (i4 = [])).push(0 | a4);
          return i4;
        }
        function createCharCode(e4, t4) {
          for (const i4 in e4) if (t4 === e4[i4]) return 0 | i4;
          return n3.charCodeToGlyphId[n3.nextAvailableFontCharCode] = t4, n3.nextAvailableFontCharCode++;
        }
        const c3 = t3.seacs;
        if (n3 && c3?.length) {
          const e4 = i3.fontMatrix || SA, a4 = t3.getCharset(), r4 = /* @__PURE__ */ Object.create(null);
          for (let t4 in c3) {
            t4 |= 0;
            const i4 = c3[t4], o4 = _n2[i4[2]], g4 = _n2[i4[3]], h4 = a4.indexOf(o4), l4 = a4.indexOf(g4);
            if (h4 < 0 || l4 < 0) continue;
            const C3 = { x: i4[0] * e4[0] + i4[1] * e4[2] + e4[4], y: i4[0] * e4[1] + i4[1] * e4[3] + e4[5] }, d3 = getCharCodes(s3, t4);
            if (d3) for (const e5 of d3) {
              const t5 = n3.charCodeToGlyphId, i5 = createCharCode(t5, h4), a5 = createCharCode(t5, l4);
              r4[e5] = { baseFontCharCode: i5, accentFontCharCode: a5, accentOffset: C3 };
            }
          }
          i3.seacMap = r4;
        }
        const h3 = i3.fontMatrix ? 1 / Math.max(...i3.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3, l3 = new OpenTypeFileBuilder("OTTO");
        return l3.addTable("CFF ", t3.data), l3.addTable("OS/2", createOS2Table(i3, r3)), l3.addTable("cmap", createCmapTable(r3, o3, g3)), l3.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<\xF5\0\0" + safeString16(h3) + "\0\0\0\0\x9E\v~'\0\0\0\0\x9E\v~'\0\0" + safeString16(i3.descent) + "\xFF" + safeString16(i3.ascent) + string16(i3.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0"), l3.addTable("hhea", "\0\0\0" + safeString16(i3.ascent) + safeString16(i3.descent) + "\0\0\xFF\xFF\0\0\0\0\0\0" + safeString16(i3.capHeight) + safeString16(Math.tan(i3.italicAngle) * i3.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + string16(g3)), l3.addTable("hmtx", function() {
          const e4 = t3.charstrings, i4 = t3.cff ? t3.cff.widths : null;
          let a4 = "\0\0\0\0";
          for (let t4 = 1, s4 = g3; t4 < s4; t4++) {
            let s5 = 0;
            if (e4) {
              const i5 = e4[t4 - 1];
              s5 = "width" in i5 ? i5.width : 0;
            } else i4 && (s5 = Math.ceil(i4[t4] || 0));
            a4 += string16(s5) + string16(0);
          }
          return a4;
        }()), l3.addTable("maxp", "\0\0P\0" + string16(g3)), l3.addTable("name", createNameTable(e3)), l3.addTable("post", createPostTable(i3)), l3.toArray();
      }
      get _spaceWidth() {
        const e3 = ["space", "minus", "one", "i", "I"];
        let t3;
        for (const i3 of e3) {
          if (i3 in this.widths) {
            t3 = this.widths[i3];
            break;
          }
          const e4 = ir()[i3];
          let a3 = 0;
          if (this.composite && this.cMap.contains(e4) && (a3 = this.cMap.lookup(e4), "string" == typeof a3 && (a3 = convertCidString(e4, a3))), !a3 && this.toUnicode && (a3 = this.toUnicode.charCodeOf(e4)), a3 <= 0 && (a3 = e4), t3 = this.widths[a3], t3) break;
        }
        return shadow(this, "_spaceWidth", t3 || this.defaultWidth);
      }
      _charToGlyph(e3, t3 = false) {
        let i3, a3, s3, n3 = this._glyphCache[e3];
        if (n3?.isSpace === t3) return n3;
        let r3 = e3;
        this.cMap?.contains(e3) && (r3 = this.cMap.lookup(e3), "string" == typeof r3 && (r3 = convertCidString(e3, r3))), a3 = this.widths[r3], "number" != typeof a3 && (a3 = this.defaultWidth);
        const o3 = this.vmetrics?.[r3];
        let g3 = this.toUnicode.get(e3) || e3;
        "number" == typeof g3 && (g3 = String.fromCharCode(g3));
        let c3 = void 0 !== this.toFontChar[e3];
        if (i3 = this.toFontChar[e3] || e3, this.missingFile) {
          const t4 = this.differences[e3] || this.defaultEncoding[e3];
          ".notdef" !== t4 && "" !== t4 || "Type1" !== this.type || (i3 = 32, "" === t4 && (a3 || (a3 = this._spaceWidth), g3 = String.fromCharCode(i3))), i3 = function(e4) {
            return e4 >= 65520 && e4 <= 65535 ? 0 : e4 >= 62976 && e4 <= 63743 ? sr()[e4] || e4 : 173 === e4 ? 45 : e4;
          }(i3);
        }
        this.isType3Font && (s3 = i3);
        let h3 = null;
        if (this.seacMap?.[e3]) {
          c3 = true;
          const t4 = this.seacMap[e3];
          i3 = t4.baseFontCharCode, h3 = { fontChar: String.fromCodePoint(t4.accentFontCharCode), offset: t4.accentOffset };
        }
        let l3 = "";
        if ("number" == typeof i3 && (i3 <= 1114111 ? l3 = String.fromCodePoint(i3) : warn(`charToGlyph - invalid fontCharCode: ${i3}`)), this.missingFile && this.vertical && 1 === l3.length) {
          const e4 = dr()[l3.charCodeAt(0)];
          e4 && (l3 = g3 = String.fromCharCode(e4));
        }
        return n3 = new fonts_Glyph(e3, l3, g3, h3, a3, o3, s3, t3, c3), this._glyphCache[e3] = n3;
      }
      charsToGlyphs(e3) {
        let t3 = this._charsCache[e3];
        if (t3) return t3;
        if (t3 = [], this.cMap) {
          const i3 = /* @__PURE__ */ Object.create(null), a3 = e3.length;
          let s3 = 0;
          for (; s3 < a3; ) {
            this.cMap.readCharCode(e3, s3, i3);
            const { charcode: a4, length: n3 } = i3;
            s3 += n3;
            const r3 = this._charToGlyph(a4, 1 === n3 && 32 === e3.charCodeAt(s3 - 1));
            t3.push(r3);
          }
        } else for (let i3 = 0, a3 = e3.length; i3 < a3; ++i3) {
          const a4 = e3.charCodeAt(i3), s3 = this._charToGlyph(a4, 32 === a4);
          t3.push(s3);
        }
        return this._charsCache[e3] = t3;
      }
      getCharPositions(e3) {
        const t3 = [];
        if (this.cMap) {
          const i3 = /* @__PURE__ */ Object.create(null);
          let a3 = 0;
          for (; a3 < e3.length; ) {
            this.cMap.readCharCode(e3, a3, i3);
            const s3 = i3.length;
            t3.push([a3, a3 + s3]), a3 += s3;
          }
        } else for (let i3 = 0, a3 = e3.length; i3 < a3; ++i3) t3.push([i3, i3 + 1]);
        return t3;
      }
      get glyphCacheValues() {
        return Object.values(this._glyphCache);
      }
      encodeString(e3) {
        const t3 = [], i3 = [], hasCurrentBufErrors = () => t3.length % 2 == 1, a3 = this.toUnicode instanceof IdentityToUnicodeMap ? (e4) => this.toUnicode.charCodeOf(e4) : (e4) => this.toUnicode.charCodeOf(String.fromCodePoint(e4));
        for (let s3 = 0, n3 = e3.length; s3 < n3; s3++) {
          const n4 = e3.codePointAt(s3);
          if (n4 > 55295 && (n4 < 57344 || n4 > 65533) && s3++, this.toUnicode) {
            const e4 = a3(n4);
            if (-1 !== e4) {
              hasCurrentBufErrors() && (t3.push(i3.join("")), i3.length = 0);
              for (let t4 = (this.cMap ? this.cMap.getCharCodeLength(e4) : 1) - 1; t4 >= 0; t4--) i3.push(String.fromCharCode(e4 >> 8 * t4 & 255));
              continue;
            }
          }
          hasCurrentBufErrors() || (t3.push(i3.join("")), i3.length = 0), i3.push(String.fromCodePoint(n4));
        }
        return t3.push(i3.join("")), t3;
      }
    };
    ErrorFont = class {
      constructor(e3) {
        this.error = e3, this.loadedName = "g_font_error", this.missingFile = true;
      }
      charsToGlyphs() {
        return [];
      }
      encodeString(e3) {
        return [e3];
      }
      exportData(e3 = false) {
        return { error: this.error };
      }
    };
    Or = 2;
    Kr = 3;
    qr = 4;
    _r2 = 5;
    Wr = 6;
    jr = 7;
    Pattern = class {
      constructor() {
        unreachable("Cannot initialize Pattern.");
      }
      static parseShading(e3, t3, i3, a3, s3) {
        const n3 = e3 instanceof BaseStream ? e3.dict : e3, r3 = n3.get("ShadingType");
        try {
          switch (r3) {
            case Or:
            case Kr:
              return new RadialAxialShading(n3, t3, i3, a3, s3);
            case qr:
            case _r2:
            case Wr:
            case jr:
              return new MeshShading(e3, t3, i3, a3, s3);
            default:
              throw new FormatError("Unsupported ShadingType: " + r3);
          }
        } catch (e4) {
          if (e4 instanceof MissingDataException) throw e4;
          return warn(e4), new DummyShading();
        }
      }
    };
    BaseShading = class {
      getIR() {
        unreachable("Abstract method `getIR` called.");
      }
    };
    __publicField(BaseShading, "SMALL_NUMBER", 1e-6);
    RadialAxialShading = class extends BaseShading {
      constructor(e3, t3, i3, a3, s3) {
        super(), this.shadingType = e3.get("ShadingType");
        let n3 = 0;
        if (this.shadingType === Or ? n3 = 4 : this.shadingType === Kr && (n3 = 6), this.coordsArr = e3.getArray("Coords"), !isNumberArray(this.coordsArr, n3)) throw new FormatError("RadialAxialShading: Invalid /Coords array.");
        const r3 = ColorSpace.parse({ cs: e3.getRaw("CS") || e3.getRaw("ColorSpace"), xref: t3, resources: i3, pdfFunctionFactory: a3, localColorSpaceCache: s3 });
        this.bbox = lookupNormalRect(e3.getArray("BBox"), null);
        let o3 = 0, g3 = 1;
        const c3 = e3.getArray("Domain");
        isNumberArray(c3, 2) && ([o3, g3] = c3);
        let h3 = false, l3 = false;
        const C3 = e3.getArray("Extend");
        var d3, u3;
        if (d3 = C3, u3 = 2, Array.isArray(d3) && d3.length === u3 && d3.every((e4) => "boolean" == typeof e4) && ([h3, l3] = C3), !(this.shadingType !== Kr || h3 && l3)) {
          const [e4, t4, i4, a4, s4, n4] = this.coordsArr, r4 = Math.hypot(e4 - a4, t4 - s4);
          i4 <= n4 + r4 && n4 <= i4 + r4 && warn("Unsupported radial gradient.");
        }
        this.extendStart = h3, this.extendEnd = l3;
        const Q3 = e3.getRaw("Function"), f3 = a3.createFromArray(Q3), p3 = (g3 - o3) / 840, m3 = this.colorStops = [];
        if (o3 >= g3 || p3 <= 0) return void info("Bad shading domain.");
        const y3 = new Float32Array(r3.numComps), w3 = new Float32Array(1);
        let b3, D3 = 0;
        w3[0] = o3, f3(w3, 0, y3, 0);
        let S3 = r3.getRgb(y3, 0);
        const F3 = Util.makeHexColor(S3[0], S3[1], S3[2]);
        m3.push([0, F3]);
        let k3 = 1;
        w3[0] = o3 + p3, f3(w3, 0, y3, 0);
        let R3 = r3.getRgb(y3, 0), x3 = R3[0] - S3[0] + 1, N3 = R3[1] - S3[1] + 1, M3 = R3[2] - S3[2] + 1, G3 = R3[0] - S3[0] - 1, v3 = R3[1] - S3[1] - 1, L3 = R3[2] - S3[2] - 1;
        for (let e4 = 2; e4 < 840; e4++) {
          w3[0] = o3 + e4 * p3, f3(w3, 0, y3, 0), b3 = r3.getRgb(y3, 0);
          const t4 = e4 - D3;
          x3 = Math.min(x3, (b3[0] - S3[0] + 1) / t4), N3 = Math.min(N3, (b3[1] - S3[1] + 1) / t4), M3 = Math.min(M3, (b3[2] - S3[2] + 1) / t4), G3 = Math.max(G3, (b3[0] - S3[0] - 1) / t4), v3 = Math.max(v3, (b3[1] - S3[1] - 1) / t4), L3 = Math.max(L3, (b3[2] - S3[2] - 1) / t4);
          if (!(G3 <= x3 && v3 <= N3 && L3 <= M3)) {
            const e5 = Util.makeHexColor(R3[0], R3[1], R3[2]);
            m3.push([k3 / 840, e5]), x3 = b3[0] - R3[0] + 1, N3 = b3[1] - R3[1] + 1, M3 = b3[2] - R3[2] + 1, G3 = b3[0] - R3[0] - 1, v3 = b3[1] - R3[1] - 1, L3 = b3[2] - R3[2] - 1, D3 = k3, S3 = R3;
          }
          k3 = e4, R3 = b3;
        }
        const U3 = Util.makeHexColor(R3[0], R3[1], R3[2]);
        m3.push([1, U3]);
        let H3 = "transparent";
        e3.has("Background") && (b3 = r3.getRgb(e3.get("Background"), 0), H3 = Util.makeHexColor(b3[0], b3[1], b3[2])), h3 || (m3.unshift([0, H3]), m3[1][0] += BaseShading.SMALL_NUMBER), l3 || (m3.at(-1)[0] -= BaseShading.SMALL_NUMBER, m3.push([1, H3])), this.colorStops = m3;
      }
      getIR() {
        const { coordsArr: e3, shadingType: t3 } = this;
        let i3, a3, s3, n3, r3;
        return t3 === Or ? (a3 = [e3[0], e3[1]], s3 = [e3[2], e3[3]], n3 = null, r3 = null, i3 = "axial") : t3 === Kr ? (a3 = [e3[0], e3[1]], s3 = [e3[3], e3[4]], n3 = e3[2], r3 = e3[5], i3 = "radial") : unreachable(`getPattern type unknown: ${t3}`), ["RadialAxial", i3, this.bbox, this.colorStops, a3, s3, n3, r3];
      }
    };
    MeshStreamReader = class {
      constructor(e3, t3) {
        this.stream = e3, this.context = t3, this.buffer = 0, this.bufferLength = 0;
        const i3 = t3.numComps;
        this.tmpCompsBuf = new Float32Array(i3);
        const a3 = t3.colorSpace.numComps;
        this.tmpCsCompsBuf = t3.colorFn ? new Float32Array(a3) : this.tmpCompsBuf;
      }
      get hasData() {
        if (this.stream.end) return this.stream.pos < this.stream.end;
        if (this.bufferLength > 0) return true;
        const e3 = this.stream.getByte();
        return !(e3 < 0) && (this.buffer = e3, this.bufferLength = 8, true);
      }
      readBits(e3) {
        let t3 = this.buffer, i3 = this.bufferLength;
        if (32 === e3) {
          if (0 === i3) return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
          t3 = t3 << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
          const e4 = this.stream.getByte();
          return this.buffer = e4 & (1 << i3) - 1, (t3 << 8 - i3 | (255 & e4) >> i3) >>> 0;
        }
        if (8 === e3 && 0 === i3) return this.stream.getByte();
        for (; i3 < e3; ) t3 = t3 << 8 | this.stream.getByte(), i3 += 8;
        return i3 -= e3, this.bufferLength = i3, this.buffer = t3 & (1 << i3) - 1, t3 >> i3;
      }
      align() {
        this.buffer = 0, this.bufferLength = 0;
      }
      readFlag() {
        return this.readBits(this.context.bitsPerFlag);
      }
      readCoordinate() {
        const e3 = this.context.bitsPerCoordinate, t3 = this.readBits(e3), i3 = this.readBits(e3), a3 = this.context.decode, s3 = e3 < 32 ? 1 / ((1 << e3) - 1) : 23283064365386963e-26;
        return [t3 * s3 * (a3[1] - a3[0]) + a3[0], i3 * s3 * (a3[3] - a3[2]) + a3[2]];
      }
      readComponents() {
        const e3 = this.context.numComps, t3 = this.context.bitsPerComponent, i3 = t3 < 32 ? 1 / ((1 << t3) - 1) : 23283064365386963e-26, a3 = this.context.decode, s3 = this.tmpCompsBuf;
        for (let n4 = 0, r3 = 4; n4 < e3; n4++, r3 += 2) {
          const e4 = this.readBits(t3);
          s3[n4] = e4 * i3 * (a3[r3 + 1] - a3[r3]) + a3[r3];
        }
        const n3 = this.tmpCsCompsBuf;
        return this.context.colorFn && this.context.colorFn(s3, 0, n3, 0), this.context.colorSpace.getRgb(n3, 0);
      }
    };
    Xr = /* @__PURE__ */ Object.create(null);
    _MeshShading = class _MeshShading extends BaseShading {
      constructor(e3, t3, i3, a3, s3) {
        if (super(), !(e3 instanceof BaseStream)) throw new FormatError("Mesh data is not a stream");
        const n3 = e3.dict;
        this.shadingType = n3.get("ShadingType"), this.bbox = lookupNormalRect(n3.getArray("BBox"), null);
        const r3 = ColorSpace.parse({ cs: n3.getRaw("CS") || n3.getRaw("ColorSpace"), xref: t3, resources: i3, pdfFunctionFactory: a3, localColorSpaceCache: s3 });
        this.background = n3.has("Background") ? r3.getRgb(n3.get("Background"), 0) : null;
        const o3 = n3.getRaw("Function"), g3 = o3 ? a3.createFromArray(o3) : null;
        this.coords = [], this.colors = [], this.figures = [];
        const c3 = { bitsPerCoordinate: n3.get("BitsPerCoordinate"), bitsPerComponent: n3.get("BitsPerComponent"), bitsPerFlag: n3.get("BitsPerFlag"), decode: n3.getArray("Decode"), colorFn: g3, colorSpace: r3, numComps: g3 ? 1 : r3.numComps }, h3 = new MeshStreamReader(e3, c3);
        let l3 = false;
        switch (this.shadingType) {
          case qr:
            this._decodeType4Shading(h3);
            break;
          case _r2:
            const e4 = 0 | n3.get("VerticesPerRow");
            if (e4 < 2) throw new FormatError("Invalid VerticesPerRow");
            this._decodeType5Shading(h3, e4);
            break;
          case Wr:
            this._decodeType6Shading(h3), l3 = true;
            break;
          case jr:
            this._decodeType7Shading(h3), l3 = true;
            break;
          default:
            unreachable("Unsupported mesh type.");
        }
        if (l3) {
          this._updateBounds();
          for (let e4 = 0, t4 = this.figures.length; e4 < t4; e4++) this._buildFigureFromPatch(e4);
        }
        this._updateBounds(), this._packData();
      }
      _decodeType4Shading(e3) {
        const t3 = this.coords, i3 = this.colors, a3 = [];
        let s3 = 0;
        for (; e3.hasData; ) {
          const n3 = e3.readFlag(), r3 = e3.readCoordinate(), o3 = e3.readComponents();
          if (0 === s3) {
            if (!(0 <= n3 && n3 <= 2)) throw new FormatError("Unknown type4 flag");
            switch (n3) {
              case 0:
                s3 = 3;
                break;
              case 1:
                a3.push(a3.at(-2), a3.at(-1)), s3 = 1;
                break;
              case 2:
                a3.push(a3.at(-3), a3.at(-1)), s3 = 1;
            }
          }
          a3.push(t3.length), t3.push(r3), i3.push(o3), s3--, e3.align();
        }
        this.figures.push({ type: "triangles", coords: new Int32Array(a3), colors: new Int32Array(a3) });
      }
      _decodeType5Shading(e3, t3) {
        const i3 = this.coords, a3 = this.colors, s3 = [];
        for (; e3.hasData; ) {
          const t4 = e3.readCoordinate(), n3 = e3.readComponents();
          s3.push(i3.length), i3.push(t4), a3.push(n3);
        }
        this.figures.push({ type: "lattice", coords: new Int32Array(s3), colors: new Int32Array(s3), verticesPerRow: t3 });
      }
      _decodeType6Shading(e3) {
        const t3 = this.coords, i3 = this.colors, a3 = new Int32Array(16), s3 = new Int32Array(4);
        for (; e3.hasData; ) {
          const n3 = e3.readFlag();
          if (!(0 <= n3 && n3 <= 3)) throw new FormatError("Unknown type6 flag");
          const r3 = t3.length;
          for (let i4 = 0, a4 = 0 !== n3 ? 8 : 12; i4 < a4; i4++) t3.push(e3.readCoordinate());
          const o3 = i3.length;
          for (let t4 = 0, a4 = 0 !== n3 ? 2 : 4; t4 < a4; t4++) i3.push(e3.readComponents());
          let g3, c3, h3, l3;
          switch (n3) {
            case 0:
              a3[12] = r3 + 3, a3[13] = r3 + 4, a3[14] = r3 + 5, a3[15] = r3 + 6, a3[8] = r3 + 2, a3[11] = r3 + 7, a3[4] = r3 + 1, a3[7] = r3 + 8, a3[0] = r3, a3[1] = r3 + 11, a3[2] = r3 + 10, a3[3] = r3 + 9, s3[2] = o3 + 1, s3[3] = o3 + 2, s3[0] = o3, s3[1] = o3 + 3;
              break;
            case 1:
              g3 = a3[12], c3 = a3[13], h3 = a3[14], l3 = a3[15], a3[12] = l3, a3[13] = r3 + 0, a3[14] = r3 + 1, a3[15] = r3 + 2, a3[8] = h3, a3[11] = r3 + 3, a3[4] = c3, a3[7] = r3 + 4, a3[0] = g3, a3[1] = r3 + 7, a3[2] = r3 + 6, a3[3] = r3 + 5, g3 = s3[2], c3 = s3[3], s3[2] = c3, s3[3] = o3, s3[0] = g3, s3[1] = o3 + 1;
              break;
            case 2:
              g3 = a3[15], c3 = a3[11], a3[12] = a3[3], a3[13] = r3 + 0, a3[14] = r3 + 1, a3[15] = r3 + 2, a3[8] = a3[7], a3[11] = r3 + 3, a3[4] = c3, a3[7] = r3 + 4, a3[0] = g3, a3[1] = r3 + 7, a3[2] = r3 + 6, a3[3] = r3 + 5, g3 = s3[3], s3[2] = s3[1], s3[3] = o3, s3[0] = g3, s3[1] = o3 + 1;
              break;
            case 3:
              a3[12] = a3[0], a3[13] = r3 + 0, a3[14] = r3 + 1, a3[15] = r3 + 2, a3[8] = a3[1], a3[11] = r3 + 3, a3[4] = a3[2], a3[7] = r3 + 4, a3[0] = a3[3], a3[1] = r3 + 7, a3[2] = r3 + 6, a3[3] = r3 + 5, s3[2] = s3[0], s3[3] = o3, s3[0] = s3[1], s3[1] = o3 + 1;
          }
          a3[5] = t3.length, t3.push([(-4 * t3[a3[0]][0] - t3[a3[15]][0] + 6 * (t3[a3[4]][0] + t3[a3[1]][0]) - 2 * (t3[a3[12]][0] + t3[a3[3]][0]) + 3 * (t3[a3[13]][0] + t3[a3[7]][0])) / 9, (-4 * t3[a3[0]][1] - t3[a3[15]][1] + 6 * (t3[a3[4]][1] + t3[a3[1]][1]) - 2 * (t3[a3[12]][1] + t3[a3[3]][1]) + 3 * (t3[a3[13]][1] + t3[a3[7]][1])) / 9]), a3[6] = t3.length, t3.push([(-4 * t3[a3[3]][0] - t3[a3[12]][0] + 6 * (t3[a3[2]][0] + t3[a3[7]][0]) - 2 * (t3[a3[0]][0] + t3[a3[15]][0]) + 3 * (t3[a3[4]][0] + t3[a3[14]][0])) / 9, (-4 * t3[a3[3]][1] - t3[a3[12]][1] + 6 * (t3[a3[2]][1] + t3[a3[7]][1]) - 2 * (t3[a3[0]][1] + t3[a3[15]][1]) + 3 * (t3[a3[4]][1] + t3[a3[14]][1])) / 9]), a3[9] = t3.length, t3.push([(-4 * t3[a3[12]][0] - t3[a3[3]][0] + 6 * (t3[a3[8]][0] + t3[a3[13]][0]) - 2 * (t3[a3[0]][0] + t3[a3[15]][0]) + 3 * (t3[a3[11]][0] + t3[a3[1]][0])) / 9, (-4 * t3[a3[12]][1] - t3[a3[3]][1] + 6 * (t3[a3[8]][1] + t3[a3[13]][1]) - 2 * (t3[a3[0]][1] + t3[a3[15]][1]) + 3 * (t3[a3[11]][1] + t3[a3[1]][1])) / 9]), a3[10] = t3.length, t3.push([(-4 * t3[a3[15]][0] - t3[a3[0]][0] + 6 * (t3[a3[11]][0] + t3[a3[14]][0]) - 2 * (t3[a3[12]][0] + t3[a3[3]][0]) + 3 * (t3[a3[2]][0] + t3[a3[8]][0])) / 9, (-4 * t3[a3[15]][1] - t3[a3[0]][1] + 6 * (t3[a3[11]][1] + t3[a3[14]][1]) - 2 * (t3[a3[12]][1] + t3[a3[3]][1]) + 3 * (t3[a3[2]][1] + t3[a3[8]][1])) / 9]), this.figures.push({ type: "patch", coords: new Int32Array(a3), colors: new Int32Array(s3) });
        }
      }
      _decodeType7Shading(e3) {
        const t3 = this.coords, i3 = this.colors, a3 = new Int32Array(16), s3 = new Int32Array(4);
        for (; e3.hasData; ) {
          const n3 = e3.readFlag();
          if (!(0 <= n3 && n3 <= 3)) throw new FormatError("Unknown type7 flag");
          const r3 = t3.length;
          for (let i4 = 0, a4 = 0 !== n3 ? 12 : 16; i4 < a4; i4++) t3.push(e3.readCoordinate());
          const o3 = i3.length;
          for (let t4 = 0, a4 = 0 !== n3 ? 2 : 4; t4 < a4; t4++) i3.push(e3.readComponents());
          let g3, c3, h3, l3;
          switch (n3) {
            case 0:
              a3[12] = r3 + 3, a3[13] = r3 + 4, a3[14] = r3 + 5, a3[15] = r3 + 6, a3[8] = r3 + 2, a3[9] = r3 + 13, a3[10] = r3 + 14, a3[11] = r3 + 7, a3[4] = r3 + 1, a3[5] = r3 + 12, a3[6] = r3 + 15, a3[7] = r3 + 8, a3[0] = r3, a3[1] = r3 + 11, a3[2] = r3 + 10, a3[3] = r3 + 9, s3[2] = o3 + 1, s3[3] = o3 + 2, s3[0] = o3, s3[1] = o3 + 3;
              break;
            case 1:
              g3 = a3[12], c3 = a3[13], h3 = a3[14], l3 = a3[15], a3[12] = l3, a3[13] = r3 + 0, a3[14] = r3 + 1, a3[15] = r3 + 2, a3[8] = h3, a3[9] = r3 + 9, a3[10] = r3 + 10, a3[11] = r3 + 3, a3[4] = c3, a3[5] = r3 + 8, a3[6] = r3 + 11, a3[7] = r3 + 4, a3[0] = g3, a3[1] = r3 + 7, a3[2] = r3 + 6, a3[3] = r3 + 5, g3 = s3[2], c3 = s3[3], s3[2] = c3, s3[3] = o3, s3[0] = g3, s3[1] = o3 + 1;
              break;
            case 2:
              g3 = a3[15], c3 = a3[11], a3[12] = a3[3], a3[13] = r3 + 0, a3[14] = r3 + 1, a3[15] = r3 + 2, a3[8] = a3[7], a3[9] = r3 + 9, a3[10] = r3 + 10, a3[11] = r3 + 3, a3[4] = c3, a3[5] = r3 + 8, a3[6] = r3 + 11, a3[7] = r3 + 4, a3[0] = g3, a3[1] = r3 + 7, a3[2] = r3 + 6, a3[3] = r3 + 5, g3 = s3[3], s3[2] = s3[1], s3[3] = o3, s3[0] = g3, s3[1] = o3 + 1;
              break;
            case 3:
              a3[12] = a3[0], a3[13] = r3 + 0, a3[14] = r3 + 1, a3[15] = r3 + 2, a3[8] = a3[1], a3[9] = r3 + 9, a3[10] = r3 + 10, a3[11] = r3 + 3, a3[4] = a3[2], a3[5] = r3 + 8, a3[6] = r3 + 11, a3[7] = r3 + 4, a3[0] = a3[3], a3[1] = r3 + 7, a3[2] = r3 + 6, a3[3] = r3 + 5, s3[2] = s3[0], s3[3] = o3, s3[0] = s3[1], s3[1] = o3 + 1;
          }
          this.figures.push({ type: "patch", coords: new Int32Array(a3), colors: new Int32Array(s3) });
        }
      }
      _buildFigureFromPatch(e3) {
        const t3 = this.figures[e3];
        assert("patch" === t3.type, "Unexpected patch mesh figure");
        const i3 = this.coords, a3 = this.colors, s3 = t3.coords, n3 = t3.colors, r3 = Math.min(i3[s3[0]][0], i3[s3[3]][0], i3[s3[12]][0], i3[s3[15]][0]), o3 = Math.min(i3[s3[0]][1], i3[s3[3]][1], i3[s3[12]][1], i3[s3[15]][1]), g3 = Math.max(i3[s3[0]][0], i3[s3[3]][0], i3[s3[12]][0], i3[s3[15]][0]), c3 = Math.max(i3[s3[0]][1], i3[s3[3]][1], i3[s3[12]][1], i3[s3[15]][1]);
        let h3 = Math.ceil((g3 - r3) * _MeshShading.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
        h3 = Math.max(_MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(_MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, h3));
        let l3 = Math.ceil((c3 - o3) * _MeshShading.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
        l3 = Math.max(_MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(_MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, l3));
        const C3 = h3 + 1, d3 = new Int32Array((l3 + 1) * C3), u3 = new Int32Array((l3 + 1) * C3);
        let Q3 = 0;
        const f3 = new Uint8Array(3), p3 = new Uint8Array(3), m3 = a3[n3[0]], y3 = a3[n3[1]], w3 = a3[n3[2]], b3 = a3[n3[3]], D3 = getB(l3), S3 = getB(h3);
        for (let e4 = 0; e4 <= l3; e4++) {
          f3[0] = (m3[0] * (l3 - e4) + w3[0] * e4) / l3 | 0, f3[1] = (m3[1] * (l3 - e4) + w3[1] * e4) / l3 | 0, f3[2] = (m3[2] * (l3 - e4) + w3[2] * e4) / l3 | 0, p3[0] = (y3[0] * (l3 - e4) + b3[0] * e4) / l3 | 0, p3[1] = (y3[1] * (l3 - e4) + b3[1] * e4) / l3 | 0, p3[2] = (y3[2] * (l3 - e4) + b3[2] * e4) / l3 | 0;
          for (let t4 = 0; t4 <= h3; t4++, Q3++) {
            if (!(0 !== e4 && e4 !== l3 || 0 !== t4 && t4 !== h3)) continue;
            let n4 = 0, r4 = 0, o4 = 0;
            for (let a4 = 0; a4 <= 3; a4++) for (let g5 = 0; g5 <= 3; g5++, o4++) {
              const c4 = D3[e4][a4] * S3[t4][g5];
              n4 += i3[s3[o4]][0] * c4, r4 += i3[s3[o4]][1] * c4;
            }
            d3[Q3] = i3.length, i3.push([n4, r4]), u3[Q3] = a3.length;
            const g4 = new Uint8Array(3);
            g4[0] = (f3[0] * (h3 - t4) + p3[0] * t4) / h3 | 0, g4[1] = (f3[1] * (h3 - t4) + p3[1] * t4) / h3 | 0, g4[2] = (f3[2] * (h3 - t4) + p3[2] * t4) / h3 | 0, a3.push(g4);
          }
        }
        d3[0] = s3[0], u3[0] = n3[0], d3[h3] = s3[3], u3[h3] = n3[1], d3[C3 * l3] = s3[12], u3[C3 * l3] = n3[2], d3[C3 * l3 + h3] = s3[15], u3[C3 * l3 + h3] = n3[3], this.figures[e3] = { type: "lattice", coords: d3, colors: u3, verticesPerRow: C3 };
      }
      _updateBounds() {
        let e3 = this.coords[0][0], t3 = this.coords[0][1], i3 = e3, a3 = t3;
        for (let s3 = 1, n3 = this.coords.length; s3 < n3; s3++) {
          const n4 = this.coords[s3][0], r3 = this.coords[s3][1];
          e3 = e3 > n4 ? n4 : e3, t3 = t3 > r3 ? r3 : t3, i3 = i3 < n4 ? n4 : i3, a3 = a3 < r3 ? r3 : a3;
        }
        this.bounds = [e3, t3, i3, a3];
      }
      _packData() {
        let e3, t3, i3, a3;
        const s3 = this.coords, n3 = new Float32Array(2 * s3.length);
        for (e3 = 0, i3 = 0, t3 = s3.length; e3 < t3; e3++) {
          const t4 = s3[e3];
          n3[i3++] = t4[0], n3[i3++] = t4[1];
        }
        this.coords = n3;
        const r3 = this.colors, o3 = new Uint8Array(3 * r3.length);
        for (e3 = 0, i3 = 0, t3 = r3.length; e3 < t3; e3++) {
          const t4 = r3[e3];
          o3[i3++] = t4[0], o3[i3++] = t4[1], o3[i3++] = t4[2];
        }
        this.colors = o3;
        const g3 = this.figures;
        for (e3 = 0, t3 = g3.length; e3 < t3; e3++) {
          const t4 = g3[e3], s4 = t4.coords, n4 = t4.colors;
          for (i3 = 0, a3 = s4.length; i3 < a3; i3++) s4[i3] *= 2, n4[i3] *= 3;
        }
      }
      getIR() {
        const { bounds: e3 } = this;
        if (e3[2] - e3[0] == 0 || e3[3] - e3[1] == 0) throw new FormatError(`Invalid MeshShading bounds: [${e3}].`);
        return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, e3, this.bbox, this.background];
      }
    };
    __publicField(_MeshShading, "MIN_SPLIT_PATCH_CHUNKS_AMOUNT", 3);
    __publicField(_MeshShading, "MAX_SPLIT_PATCH_CHUNKS_AMOUNT", 20);
    __publicField(_MeshShading, "TRIANGLE_DENSITY", 20);
    MeshShading = _MeshShading;
    DummyShading = class extends BaseShading {
      getIR() {
        return ["Dummy"];
      }
    };
    Vr = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.54657, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.73293, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.9121, 0.86943, 0.79795, 0.88198, 0.77958, 0.70864, 0.81055, 0.90399, 0.88653, 0.96017, 0.82577, 0.77892, 0.78257, 0.97507, 1.54657, 0.97507, 0.85284, 0.89552, 0.90176, 0.88762, 0.8785, 0.75241, 0.8785, 0.90518, 0.95015, 0.77618, 0.8785, 0.88401, 0.91916, 0.86304, 0.88401, 0.91488, 0.8785, 0.8801, 0.8785, 0.8785, 0.91343, 0.7173, 1.04106, 0.8785, 0.85075, 0.95794, 0.82616, 0.85162, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.12401, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.73293, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.9121, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.85284, 0.87508, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.8715, 0.75241, 0.90518, 0.90518, 0.90518, 0.90518, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.8785, 0.8801, 0.8801, 0.8801, 0.8801, 0.8801, 0.90747, 0.89049, 0.8785, 0.8785, 0.8785, 0.8785, 0.85162, 0.8785, 0.85162, 0.83908, 0.88762, 0.83908, 0.88762, 0.83908, 0.88762, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.87289, 0.83016, 0.88506, 0.93125, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.81921, 0.77618, 0.81921, 0.77618, 0.81921, 0.77618, 1, 1, 0.87356, 0.8785, 0.91075, 0.89608, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76229, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.79468, 0.91926, 0.88175, 0.70823, 0.94903, 0.9121, 0.8785, 1, 1, 0.9121, 0.8785, 0.87802, 0.88656, 0.8785, 0.86943, 0.8801, 0.86943, 0.8801, 0.86943, 0.8801, 0.87402, 0.89291, 0.77958, 0.91343, 1, 1, 0.77958, 0.91343, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.96017, 0.95794, 0.77892, 0.85162, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.88762, 0.77539, 0.8715, 0.87508, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70674, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.06303, 0.83908, 0.80352, 0.57184, 0.6965, 0.56289, 0.82001, 0.56029, 0.81235, 1.02988, 0.83908, 0.7762, 0.68156, 0.80367, 0.73133, 0.78257, 0.87356, 0.86943, 0.95958, 0.75727, 0.89019, 1.04924, 0.9121, 0.7648, 0.86943, 0.87356, 0.79795, 0.78275, 0.81055, 0.77892, 0.9762, 0.82577, 0.99819, 0.84896, 0.95958, 0.77892, 0.96108, 1.01407, 0.89049, 1.02988, 0.94211, 0.96108, 0.8936, 0.84021, 0.87842, 0.96399, 0.79109, 0.89049, 1.00813, 1.02988, 0.86077, 0.87445, 0.92099, 0.84723, 0.86513, 0.8801, 0.75638, 0.85714, 0.78216, 0.79586, 0.87965, 0.94211, 0.97747, 0.78287, 0.97926, 0.84971, 1.02988, 0.94211, 0.8801, 0.94211, 0.84971, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90264, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90518, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90548, 1, 1, 1, 1, 1, 1, 0.96017, 0.95794, 0.96017, 0.95794, 0.96017, 0.95794, 0.77892, 0.85162, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.92794, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71143, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.93835, 0.83406, 0.91133, 0.84107, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90527, 1.81055, 0.90527, 1.81055, 1.31006, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    Zr = { lineHeight: 1.2207, lineGap: 0.2207 };
    zr = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.56239, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.71805, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.90872, 0.85938, 0.79795, 0.87068, 0.77958, 0.69766, 0.81055, 0.90399, 0.88653, 0.96068, 0.82577, 0.77892, 0.78257, 0.97507, 1.529, 0.97507, 0.85284, 0.89552, 0.90176, 0.94908, 0.86411, 0.74012, 0.86411, 0.88323, 0.95015, 0.86411, 0.86331, 0.88401, 0.91916, 0.86304, 0.88401, 0.9039, 0.86331, 0.86331, 0.86411, 0.86411, 0.90464, 0.70852, 1.04106, 0.86331, 0.84372, 0.95794, 0.82616, 0.84548, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.19129, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.71805, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.90872, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.85284, 0.87068, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.85887, 0.74012, 0.88323, 0.88323, 0.88323, 0.88323, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.90747, 0.89049, 0.86331, 0.86331, 0.86331, 0.86331, 0.84548, 0.86411, 0.84548, 0.83908, 0.94908, 0.83908, 0.94908, 0.83908, 0.94908, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.87289, 0.79538, 0.88506, 0.92726, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.81921, 0.86411, 0.81921, 0.86411, 0.81921, 0.86411, 1, 1, 0.87356, 0.86331, 0.91075, 0.8777, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76467, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.77312, 0.91926, 0.88175, 0.70823, 0.94903, 0.90872, 0.86331, 1, 1, 0.90872, 0.86331, 0.86906, 0.88116, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.87402, 0.86549, 0.77958, 0.90464, 1, 1, 0.77958, 0.90464, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.96068, 0.95794, 0.77892, 0.84548, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.94908, 0.77539, 0.85887, 0.87068, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70088, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.48387, 0.83908, 0.80352, 0.57118, 0.6965, 0.56347, 0.79179, 0.55853, 0.80346, 1.02988, 0.83908, 0.7762, 0.67174, 0.86036, 0.73133, 0.78257, 0.87356, 0.86441, 0.95958, 0.75727, 0.89019, 1.04924, 0.90872, 0.74889, 0.85938, 0.87891, 0.79795, 0.7957, 0.81055, 0.77892, 0.97447, 0.82577, 0.97466, 0.87179, 0.95958, 0.77892, 0.94252, 0.95612, 0.8753, 1.02988, 0.92733, 0.94252, 0.87411, 0.84021, 0.8728, 0.95612, 0.74081, 0.8753, 1.02189, 1.02988, 0.84814, 0.87445, 0.91822, 0.84723, 0.85668, 0.86331, 0.81344, 0.87581, 0.76422, 0.82046, 0.96057, 0.92733, 0.99375, 0.78022, 0.95452, 0.86015, 1.02988, 0.92733, 0.86331, 0.92733, 0.86015, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90631, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88323, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85174, 1, 1, 1, 1, 1, 1, 0.96068, 0.95794, 0.96068, 0.95794, 0.96068, 0.95794, 0.77892, 0.84548, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.89807, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71094, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.92972, 0.83406, 0.91133, 0.83326, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90616, 1.81055, 0.90527, 1.81055, 1.3107, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    $r = { lineHeight: 1.2207, lineGap: 0.2207 };
    eo = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39543, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.72346, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89249, 0.84118, 0.77452, 0.85374, 0.75186, 0.67789, 0.79776, 0.88844, 0.85066, 0.94309, 0.77818, 0.7306, 0.76659, 1.10369, 1.38313, 1.10369, 1.06139, 0.89552, 0.8739, 0.9245, 0.9245, 0.83203, 0.9245, 0.85865, 1.09842, 0.9245, 0.9245, 1.03297, 1.07692, 0.90918, 1.03297, 0.94959, 0.9245, 0.92274, 0.9245, 0.9245, 1.02933, 0.77832, 1.20562, 0.9245, 0.8916, 0.98986, 0.86621, 0.89453, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.16359, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.72346, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89249, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.85284, 0.84557, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.84843, 0.83203, 0.85865, 0.85865, 0.85865, 0.85865, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.9245, 0.92274, 0.92274, 0.92274, 0.92274, 0.92274, 0.90747, 0.86651, 0.9245, 0.9245, 0.9245, 0.9245, 0.89453, 0.9245, 0.89453, 0.8675, 0.9245, 0.8675, 0.9245, 0.8675, 0.9245, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.85193, 0.8875, 0.86477, 0.99034, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.81105, 0.9245, 0.81105, 0.9245, 0.81105, 0.9245, 1, 1, 0.86275, 0.9245, 0.90872, 0.93591, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77896, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.9375, 0.98156, 0.93407, 0.77261, 1.11429, 0.89249, 0.9245, 1, 1, 0.89249, 0.9245, 0.92534, 0.86698, 0.9245, 0.84118, 0.92274, 0.84118, 0.92274, 0.84118, 0.92274, 0.8667, 0.86291, 0.75186, 1.02933, 1, 1, 0.75186, 1.02933, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 1, 1, 0.79776, 0.97655, 0.79776, 1.23023, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.94309, 0.98986, 0.7306, 0.89453, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.9245, 0.76318, 0.84843, 0.84557, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67009, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.8675, 0.90861, 0.6192, 0.7363, 0.64824, 0.82411, 0.56321, 0.85696, 1.23516, 0.8675, 0.81552, 0.7286, 0.84134, 0.73206, 0.76659, 0.86275, 0.84369, 0.90685, 0.77892, 0.85871, 1.02638, 0.89249, 0.75828, 0.84118, 0.85984, 0.77452, 0.76466, 0.79776, 0.7306, 0.90782, 0.77818, 0.903, 0.87291, 0.90685, 0.7306, 0.99058, 1.03667, 0.94635, 1.23516, 0.9849, 0.99058, 0.92393, 0.8916, 0.942, 1.03667, 0.75026, 0.94635, 1.0297, 1.23516, 0.90918, 0.94048, 0.98217, 0.89746, 0.84153, 0.92274, 0.82507, 0.88832, 0.84438, 0.88178, 1.03525, 0.9849, 1.00225, 0.78086, 0.97248, 0.89404, 1.23516, 0.9849, 0.92274, 0.9849, 0.89404, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85865, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90933, 1, 1, 1, 1, 1, 1, 0.94309, 0.98986, 0.94309, 0.98986, 0.94309, 0.98986, 0.7306, 0.89453, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.68994, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.97858, 0.82616, 0.91133, 0.83437, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90572, 1.81055, 0.90749, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85284, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    to = { lineHeight: 1.2207, lineGap: 0.2207 };
    Ao = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39016, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.73834, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89385, 0.85122, 0.77452, 0.86503, 0.75186, 0.68887, 0.79776, 0.88844, 0.85066, 0.94258, 0.77818, 0.7306, 0.76659, 1.10369, 1.39016, 1.10369, 1.06139, 0.89552, 0.8739, 0.86128, 0.94469, 0.8457, 0.94469, 0.89464, 1.09842, 0.84636, 0.94469, 1.03297, 1.07692, 0.90918, 1.03297, 0.95897, 0.94469, 0.9482, 0.94469, 0.94469, 1.04692, 0.78223, 1.20562, 0.94469, 0.90332, 0.98986, 0.86621, 0.90527, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.08707, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.73834, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89385, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.85284, 0.85311, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.8693, 0.8457, 0.89464, 0.89464, 0.89464, 0.89464, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.94469, 0.9482, 0.9482, 0.9482, 0.9482, 0.9482, 0.90747, 0.86651, 0.94469, 0.94469, 0.94469, 0.94469, 0.90527, 0.94469, 0.90527, 0.8675, 0.86128, 0.8675, 0.86128, 0.8675, 0.86128, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.85193, 0.92454, 0.86477, 0.9921, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.81105, 0.84636, 0.81105, 0.84636, 0.81105, 0.84636, 1, 1, 0.86275, 0.94469, 0.90872, 0.95786, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77741, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.90452, 0.98156, 1.11842, 0.77261, 1.11429, 0.89385, 0.94469, 1, 1, 0.89385, 0.94469, 0.95877, 0.86901, 0.94469, 0.85122, 0.9482, 0.85122, 0.9482, 0.85122, 0.9482, 0.8667, 0.90016, 0.75186, 1.04692, 1, 1, 0.75186, 1.04692, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 1, 1, 0.79776, 0.92188, 0.79776, 1.23023, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.94258, 0.98986, 0.7306, 0.90527, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.86128, 0.76318, 0.8693, 0.85311, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67742, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.86686, 0.90861, 0.62267, 0.74359, 0.65649, 0.85498, 0.56963, 0.88254, 1.23516, 0.8675, 0.81552, 0.75443, 0.84503, 0.73206, 0.76659, 0.86275, 0.85122, 0.90685, 0.77892, 0.85746, 1.02638, 0.89385, 0.75657, 0.85122, 0.86275, 0.77452, 0.74171, 0.79776, 0.7306, 0.95165, 0.77818, 0.89772, 0.88831, 0.90685, 0.7306, 0.98142, 1.02191, 0.96576, 1.23516, 0.99018, 0.98142, 0.9236, 0.89258, 0.94035, 1.02191, 0.78848, 0.96576, 0.9561, 1.23516, 0.90918, 0.92578, 0.95424, 0.89746, 0.83969, 0.9482, 0.80113, 0.89442, 0.85208, 0.86155, 0.98022, 0.99018, 1.00452, 0.81209, 0.99247, 0.89181, 1.23516, 0.99018, 0.9482, 0.99018, 0.89181, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88844, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89464, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96766, 1, 1, 1, 1, 1, 1, 0.94258, 0.98986, 0.94258, 0.98986, 0.94258, 0.98986, 0.7306, 0.90527, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.69043, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.99331, 0.82616, 0.91133, 0.84286, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90527, 1.81055, 0.90527, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1.07185, 0.99413, 0.96334, 1.08065, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    io = { lineHeight: 1.2207, lineGap: 0.2207 };
    ao = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.03374, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00042, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.03828, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00034, 0.99977, 1, 0.99997, 1.00026, 1.00078, 1.00036, 0.99973, 1.00013, 1.0006, 0.99977, 0.99977, 0.99988, 0.85148, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 1.00069, 1.00022, 0.99977, 1.00001, 0.99984, 1.00026, 1.00001, 1.00024, 1.00001, 0.9999, 1, 1.0006, 1.00001, 1.00041, 0.99962, 1.00026, 1.0006, 0.99995, 1.00041, 0.99942, 0.99973, 0.99927, 1.00082, 0.99902, 1.00026, 1.00087, 1.0006, 1.00069, 0.99973, 0.99867, 0.99973, 0.9993, 1.00026, 1.00049, 1.00056, 1, 0.99988, 0.99935, 0.99995, 0.99954, 1.00055, 0.99945, 1.00032, 1.0006, 0.99995, 1.00026, 0.99995, 1.00032, 1.00001, 1.00008, 0.99971, 1.00019, 0.9994, 1.00001, 1.0006, 1.00044, 0.99973, 1.00023, 1.00047, 1, 0.99942, 0.99561, 0.99989, 1.00035, 0.99977, 1.00035, 0.99977, 1.00019, 0.99944, 1.00001, 1.00021, 0.99926, 1.00035, 1.00035, 0.99942, 1.00048, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.99989, 1.00057, 1.00001, 0.99936, 1.00052, 1.00012, 0.99996, 1.00043, 1, 1.00035, 0.9994, 0.99976, 1.00035, 0.99973, 1.00052, 1.00041, 1.00119, 1.00037, 0.99973, 1.00002, 0.99986, 1.00041, 1.00041, 0.99902, 0.9996, 1.00034, 0.99999, 1.00026, 0.99999, 1.00026, 0.99973, 1.00052, 0.99973, 1, 0.99973, 1.00041, 1.00075, 0.9994, 1.0003, 0.99999, 1, 1.00041, 0.99955, 1, 0.99915, 0.99973, 0.99973, 1.00026, 1.00119, 0.99955, 0.99973, 1.0006, 0.99911, 1.0006, 1.00026, 0.99972, 1.00026, 0.99902, 1.00041, 0.99973, 0.99999, 1, 1, 1.00038, 1.0005, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 1.00047, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    so = { lineHeight: 1.2, lineGap: 0.2 };
    no = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.0044, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99971, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.01011, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99977, 1, 1, 1.00026, 0.99969, 0.99972, 0.99981, 0.9998, 1.0006, 0.99977, 0.99977, 1.00022, 0.91155, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 0.99966, 1.00022, 1.00032, 1.00001, 0.99944, 1.00026, 1.00001, 0.99968, 1.00001, 1.00047, 1, 1.0006, 1.00001, 0.99981, 1.00101, 1.00026, 1.0006, 0.99948, 0.99981, 1.00064, 0.99973, 0.99942, 1.00101, 1.00061, 1.00026, 1.00069, 1.0006, 1.00014, 0.99973, 1.01322, 0.99973, 1.00065, 1.00026, 1.00012, 0.99923, 1, 1.00064, 1.00076, 0.99948, 1.00055, 1.00063, 1.00007, 0.99943, 1.0006, 0.99948, 1.00026, 0.99948, 0.99943, 1.00001, 1.00001, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, 0.99973, 0.99978, 1.00001, 1.00057, 0.99989, 0.99967, 0.99964, 0.99967, 0.99977, 0.99999, 0.99977, 1.00038, 0.99977, 1.00001, 0.99973, 1.00066, 0.99967, 0.99967, 1.00041, 0.99998, 0.99999, 0.99977, 1.00022, 0.99967, 1.00001, 0.99977, 1.00026, 0.99964, 1.00031, 1.00001, 0.99999, 0.99999, 1, 1.00023, 1, 1, 0.99999, 1.00035, 1.00001, 0.99999, 0.99973, 0.99977, 0.99999, 1.00058, 0.99973, 0.99973, 0.99955, 0.9995, 1.00026, 1.00026, 1.00032, 0.99989, 1.00034, 0.99999, 1.00026, 1.00026, 1.00026, 0.99973, 0.45998, 0.99973, 1.00026, 0.99973, 1.00001, 0.99999, 0.99982, 0.99994, 0.99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, 0.99973, 0.99973, 1.00026, 0.99949, 1.00002, 0.99973, 1.0006, 1.0006, 1.0006, 0.99975, 1.00026, 1.00026, 1.00032, 0.98685, 0.99973, 1.00026, 1, 1, 0.99966, 1.00044, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1, 0.99973, 0.99971, 0.99978, 1, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00098, 1, 1, 1, 1.00049, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    ro = { lineHeight: 1.35, lineGap: 0.2 };
    oo = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.0288, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 0.99946, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.06311, 0.99973, 1.00024, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00041, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.89547, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00001, 1, 1.00054, 0.99977, 1.00084, 1.00007, 0.99973, 1.00013, 0.99924, 1.00001, 1.00001, 0.99945, 0.91221, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00001, 0.99999, 0.99977, 0.99933, 1.00022, 1.00054, 1.00001, 1.00065, 1.00026, 1.00001, 1.0001, 1.00001, 1.00052, 1, 1.0006, 1.00001, 0.99945, 0.99897, 0.99968, 0.99924, 1.00036, 0.99945, 0.99949, 1, 1.0006, 0.99897, 0.99918, 0.99968, 0.99911, 0.99924, 1, 0.99962, 1.01487, 1, 1.0005, 0.99973, 1.00012, 1.00043, 1, 0.99995, 0.99994, 1.00036, 0.99947, 1.00019, 1.00063, 1.00025, 0.99924, 1.00036, 0.99973, 1.00036, 1.00025, 1.00001, 1.00001, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, 0.99957, 0.99972, 0.9994, 0.99954, 0.99975, 1.00051, 1.00001, 1.00019, 1.00001, 1.0001, 0.99986, 1.00001, 1.00001, 1.00038, 0.99954, 0.99954, 0.9994, 1.00066, 0.99999, 0.99977, 1.00022, 1.00054, 1.00001, 0.99977, 1.00026, 0.99975, 1.0001, 1.00001, 0.99993, 0.9995, 0.99955, 1.00016, 0.99978, 0.99974, 1.00019, 1.00022, 0.99955, 1.00053, 0.99973, 1.00089, 1.00005, 0.99967, 1.00048, 0.99973, 1.00002, 1.00034, 0.99973, 0.99973, 0.99964, 1.00006, 1.00066, 0.99947, 0.99973, 0.98894, 0.99973, 1, 0.44898, 1, 0.99946, 1, 1.00039, 1.00082, 0.99991, 0.99991, 0.99985, 1.00022, 1.00023, 1.00061, 1.00006, 0.99966, 0.99973, 0.99973, 0.99973, 1.00019, 1.0008, 1, 0.99924, 0.99924, 0.99924, 0.99983, 1.00044, 0.99973, 0.99964, 0.98332, 1, 0.99973, 1, 1, 0.99962, 0.99895, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 1.00423, 0.99925, 0.99999, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00049, 1, 1.00245, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 1.00003, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    go = { lineHeight: 1.35, lineGap: 0.2 };
    co = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.04596, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 1.00019, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.02572, 0.99973, 1.00005, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99999, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.84533, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99928, 1, 0.99977, 1.00013, 1.00055, 0.99947, 0.99945, 0.99941, 0.99924, 1.00001, 1.00001, 1.0004, 0.91621, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00005, 0.99999, 0.99977, 1.00015, 1.00022, 0.99977, 1.00001, 0.99973, 1.00026, 1.00001, 1.00019, 1.00001, 0.99946, 1, 1.0006, 1.00001, 0.99978, 1.00045, 0.99973, 0.99924, 1.00023, 0.99978, 0.99966, 1, 1.00065, 1.00045, 1.00019, 0.99973, 0.99973, 0.99924, 1, 1, 0.96499, 1, 1.00055, 0.99973, 1.00008, 1.00027, 1, 0.9997, 0.99995, 1.00023, 0.99933, 1.00019, 1.00015, 1.00031, 0.99924, 1.00023, 0.99973, 1.00023, 1.00031, 1.00001, 0.99928, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, 0.99988, 0.99975, 1, 1.00082, 0.99561, 0.9996, 1.00035, 1.00001, 0.99962, 1.00001, 1.00092, 0.99964, 1.00001, 0.99963, 0.99999, 1.00035, 1.00035, 1.00082, 0.99962, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.9996, 0.99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, 0.99971, 0.99962, 1.00035, 0.99975, 0.99977, 0.99973, 1.00043, 0.99953, 1.0007, 0.99915, 0.99973, 1.00008, 0.99892, 1.00073, 1.00073, 1.00114, 0.99915, 1.00073, 0.99955, 0.99973, 1.00092, 0.99973, 1, 0.99998, 1, 1.0003, 1, 1.00043, 1.00001, 0.99969, 1.0003, 1, 1.00035, 1.00001, 0.9995, 1, 1.00092, 0.99973, 0.99973, 0.99973, 1.0007, 0.9995, 1, 0.99924, 1.0006, 0.99924, 0.99972, 1.00062, 0.99973, 1.00114, 1.00073, 1, 0.99955, 1, 1, 1.00047, 0.99968, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 0.99925, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    ho = { lineHeight: 1.2, lineGap: 0.2 };
    lo = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 719, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 785, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 385, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 465, 722, 333, 853, 906, 474, 825, 927, 838, 278, 722, 722, 601, 719, 667, 611, 722, 778, 278, 722, 667, 833, 722, 644, 778, 722, 667, 600, 611, 667, 821, 667, 809, 802, 278, 667, 615, 451, 611, 278, 582, 615, 610, 556, 606, 475, 460, 611, 541, 278, 558, 556, 612, 556, 445, 611, 766, 619, 520, 684, 446, 582, 715, 576, 753, 845, 278, 582, 611, 582, 845, 667, 669, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 722, 622, 719, 722, 719, 722, 567, 712, 667, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 556, 618, 615, 417, 635, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 556, 556, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 615, 556, 604, 778, 611, 487, 447, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1094, 556, 885, 489, 1115, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
    Io = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    Co = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 740, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 782, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 396, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 722, 333, 854, 906, 473, 844, 930, 847, 278, 722, 722, 610, 671, 667, 611, 722, 778, 278, 722, 667, 833, 722, 657, 778, 718, 667, 590, 611, 667, 822, 667, 829, 781, 278, 667, 620, 479, 611, 278, 591, 620, 621, 556, 610, 479, 492, 611, 558, 278, 566, 556, 603, 556, 450, 611, 712, 605, 532, 664, 409, 591, 704, 578, 773, 834, 278, 591, 611, 591, 834, 667, 667, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 719, 677, 719, 722, 708, 722, 614, 722, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1e3, 708, 719, 1042, 729, 556, 619, 604, 534, 618, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 556, 556, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 619, 556, 611, 778, 611, 575, 467, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1104, 556, 885, 516, 1146, 1e3, 768, 600, 834, 834, 834, 834, 999, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
    Bo = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    uo = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 625, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 733, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 281, 556, 400, 556, 222, 722, 556, 722, 556, 722, 556, 615, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 354, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 789, 846, 389, 794, 865, 775, 222, 667, 667, 570, 671, 667, 611, 722, 778, 278, 667, 667, 833, 722, 648, 778, 725, 667, 600, 611, 667, 837, 667, 831, 761, 278, 667, 570, 439, 555, 222, 550, 570, 571, 500, 556, 439, 463, 555, 542, 222, 500, 492, 548, 500, 447, 556, 670, 573, 486, 603, 374, 550, 652, 546, 728, 779, 222, 550, 556, 550, 779, 667, 667, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 715, 639, 724, 667, 651, 667, 544, 704, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 556, 562, 522, 493, 553, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 556, 556, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 565, 500, 556, 778, 556, 492, 339, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1083, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 998, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 584, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
    Qo = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    Eo = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 615, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 735, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 292, 556, 334, 556, 222, 722, 556, 722, 556, 722, 556, 604, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 375, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 784, 838, 384, 774, 855, 752, 222, 667, 667, 551, 668, 667, 611, 722, 778, 278, 667, 668, 833, 722, 650, 778, 722, 667, 618, 611, 667, 798, 667, 835, 748, 278, 667, 578, 446, 556, 222, 547, 578, 575, 500, 557, 446, 441, 556, 556, 222, 500, 500, 576, 500, 448, 556, 690, 569, 482, 617, 395, 547, 648, 525, 713, 781, 222, 547, 556, 547, 781, 667, 667, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 722, 635, 719, 667, 656, 667, 542, 677, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 556, 573, 531, 365, 583, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 556, 556, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 559, 500, 552, 778, 556, 489, 411, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1073, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
    fo = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    po = [1.36898, 1, 1, 0.72706, 0.80479, 0.83734, 0.98894, 0.99793, 0.9897, 0.93884, 0.86209, 0.94292, 0.94292, 1.16661, 1.02058, 0.93582, 0.96694, 0.93582, 1.19137, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.72851, 0.78966, 0.90838, 0.83637, 0.82391, 0.96376, 0.80061, 0.86275, 0.8768, 0.95407, 1.0258, 0.73901, 0.85022, 0.83655, 1.0156, 0.95546, 0.92179, 0.87107, 0.92179, 0.82114, 0.8096, 0.89713, 0.94438, 0.95353, 0.94083, 0.91905, 0.90406, 0.9446, 0.94292, 1.18777, 0.94292, 1.02058, 0.89903, 0.90088, 0.94938, 0.97898, 0.81093, 0.97571, 0.94938, 1.024, 0.9577, 0.95933, 0.98621, 1.0474, 0.97455, 0.98981, 0.9672, 0.95933, 0.9446, 0.97898, 0.97407, 0.97646, 0.78036, 1.10208, 0.95442, 0.95298, 0.97579, 0.9332, 0.94039, 0.938, 0.80687, 1.01149, 0.80687, 1.02058, 0.80479, 0.99793, 0.99793, 0.99793, 0.99793, 1.01149, 1.00872, 0.90088, 0.91882, 1.0213, 0.8361, 1.02058, 0.62295, 0.54324, 0.89022, 1.08595, 1, 1, 0.90088, 1, 0.97455, 0.93582, 0.90088, 1, 1.05686, 0.8361, 0.99642, 0.99642, 0.99642, 0.72851, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.868, 0.82391, 0.80061, 0.80061, 0.80061, 0.80061, 1.0258, 1.0258, 1.0258, 1.0258, 0.97484, 0.95546, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 1.02058, 0.92179, 0.94438, 0.94438, 0.94438, 0.94438, 0.90406, 0.86958, 0.98225, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.9031, 0.81093, 0.94938, 0.94938, 0.94938, 0.94938, 0.98621, 0.98621, 0.98621, 0.98621, 0.93969, 0.95933, 0.9446, 0.9446, 0.9446, 0.9446, 0.9446, 1.08595, 0.9446, 0.95442, 0.95442, 0.95442, 0.95442, 0.94039, 0.97898, 0.94039, 0.90838, 0.94938, 0.90838, 0.94938, 0.90838, 0.94938, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.96376, 0.84313, 0.97484, 0.97571, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.8768, 0.9577, 0.8768, 0.9577, 0.8768, 0.9577, 1, 1, 0.95407, 0.95933, 0.97069, 0.95933, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 0.887, 1.01591, 0.73901, 1.0474, 1, 1, 0.97455, 0.83655, 0.98981, 1, 1, 0.83655, 0.73977, 0.83655, 0.73903, 0.84638, 1.033, 0.95546, 0.95933, 1, 1, 0.95546, 0.95933, 0.8271, 0.95417, 0.95933, 0.92179, 0.9446, 0.92179, 0.9446, 0.92179, 0.9446, 0.936, 0.91964, 0.82114, 0.97646, 1, 1, 0.82114, 0.97646, 0.8096, 0.78036, 0.8096, 0.78036, 1, 1, 0.8096, 0.78036, 1, 1, 0.89713, 0.77452, 0.89713, 1.10208, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94083, 0.97579, 0.90406, 0.94039, 0.90406, 0.9446, 0.938, 0.9446, 0.938, 0.9446, 0.938, 1, 0.99793, 0.90838, 0.94938, 0.868, 0.9031, 0.92179, 0.9446, 1, 1, 0.89713, 1.10208, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90989, 0.9358, 0.91945, 0.83181, 0.75261, 0.87992, 0.82976, 0.96034, 0.83689, 0.97268, 1.0078, 0.90838, 0.83637, 0.8019, 0.90157, 0.80061, 0.9446, 0.95407, 0.92436, 1.0258, 0.85022, 0.97153, 1.0156, 0.95546, 0.89192, 0.92179, 0.92361, 0.87107, 0.96318, 0.89713, 0.93704, 0.95638, 0.91905, 0.91709, 0.92796, 1.0258, 0.93704, 0.94836, 1.0373, 0.95933, 1.0078, 0.95871, 0.94836, 0.96174, 0.92601, 0.9498, 0.98607, 0.95776, 0.95933, 1.05453, 1.0078, 0.98275, 0.9314, 0.95617, 0.91701, 1.05993, 0.9446, 0.78367, 0.9553, 1, 0.86832, 1.0128, 0.95871, 0.99394, 0.87548, 0.96361, 0.86774, 1.0078, 0.95871, 0.9446, 0.95871, 0.86774, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.94083, 0.97579, 0.94083, 0.97579, 0.94083, 0.97579, 0.90406, 0.94039, 0.96694, 1, 0.89903, 1, 1, 1, 0.93582, 0.93582, 0.93582, 1, 0.908, 0.908, 0.918, 0.94219, 0.94219, 0.96544, 1, 1.285, 1, 1, 0.81079, 0.81079, 1, 1, 0.74854, 1, 1, 1, 1, 0.99793, 1, 1, 1, 0.65, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.17173, 1, 0.80535, 0.76169, 1.02058, 1.0732, 1.05486, 1, 1, 1.30692, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.16161, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    mo = { lineHeight: 1.2, lineGap: 0.2 };
    yo = [1.36898, 1, 1, 0.66227, 0.80779, 0.81625, 0.97276, 0.97276, 0.97733, 0.92222, 0.83266, 0.94292, 0.94292, 1.16148, 1.02058, 0.93582, 0.96694, 0.93582, 1.17337, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.71541, 0.76813, 0.85576, 0.80591, 0.80729, 0.94299, 0.77512, 0.83655, 0.86523, 0.92222, 0.98621, 0.71743, 0.81698, 0.79726, 0.98558, 0.92222, 0.90637, 0.83809, 0.90637, 0.80729, 0.76463, 0.86275, 0.90699, 0.91605, 0.9154, 0.85308, 0.85458, 0.90531, 0.94292, 1.21296, 0.94292, 1.02058, 0.89903, 1.18616, 0.99613, 0.91677, 0.78216, 0.91677, 0.90083, 0.98796, 0.9135, 0.92168, 0.95381, 0.98981, 0.95298, 0.95381, 0.93459, 0.92168, 0.91513, 0.92004, 0.91677, 0.95077, 0.748, 1.04502, 0.91677, 0.92061, 0.94236, 0.89544, 0.89364, 0.9, 0.80687, 0.8578, 0.80687, 1.02058, 0.80779, 0.97276, 0.97276, 0.97276, 0.97276, 0.8578, 0.99973, 1.18616, 0.91339, 1.08074, 0.82891, 1.02058, 0.55509, 0.71526, 0.89022, 1.08595, 1, 1, 1.18616, 1, 0.96736, 0.93582, 1.18616, 1, 1.04864, 0.82711, 0.99043, 0.99043, 0.99043, 0.71541, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.845, 0.80729, 0.77512, 0.77512, 0.77512, 0.77512, 0.98621, 0.98621, 0.98621, 0.98621, 0.95961, 0.92222, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 1.02058, 0.90251, 0.90699, 0.90699, 0.90699, 0.90699, 0.85458, 0.83659, 0.94951, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.85811, 0.78216, 0.90083, 0.90083, 0.90083, 0.90083, 0.95381, 0.95381, 0.95381, 0.95381, 0.9135, 0.92168, 0.91513, 0.91513, 0.91513, 0.91513, 0.91513, 1.08595, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.89364, 0.92332, 0.89364, 0.85576, 0.99613, 0.85576, 0.99613, 0.85576, 0.99613, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.94299, 0.76783, 0.95961, 0.91677, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.86523, 0.9135, 0.86523, 0.9135, 0.86523, 0.9135, 1, 1, 0.92222, 0.92168, 0.92222, 0.92168, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.86036, 0.97096, 0.71743, 0.98981, 1, 1, 0.95298, 0.79726, 0.95381, 1, 1, 0.79726, 0.6894, 0.79726, 0.74321, 0.81691, 1.0006, 0.92222, 0.92168, 1, 1, 0.92222, 0.92168, 0.79464, 0.92098, 0.92168, 0.90637, 0.91513, 0.90637, 0.91513, 0.90637, 0.91513, 0.909, 0.87514, 0.80729, 0.95077, 1, 1, 0.80729, 0.95077, 0.76463, 0.748, 0.76463, 0.748, 1, 1, 0.76463, 0.748, 1, 1, 0.86275, 0.72651, 0.86275, 1.04502, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.9154, 0.94236, 0.85458, 0.89364, 0.85458, 0.90531, 0.9, 0.90531, 0.9, 0.90531, 0.9, 1, 0.97276, 0.85576, 0.99613, 0.845, 0.85811, 0.90251, 0.91677, 1, 1, 0.86275, 1.04502, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.00899, 1.30628, 0.85576, 0.80178, 0.66862, 0.7927, 0.69323, 0.88127, 0.72459, 0.89711, 0.95381, 0.85576, 0.80591, 0.7805, 0.94729, 0.77512, 0.90531, 0.92222, 0.90637, 0.98621, 0.81698, 0.92655, 0.98558, 0.92222, 0.85359, 0.90637, 0.90976, 0.83809, 0.94523, 0.86275, 0.83509, 0.93157, 0.85308, 0.83392, 0.92346, 0.98621, 0.83509, 0.92886, 0.91324, 0.92168, 0.95381, 0.90646, 0.92886, 0.90557, 0.86847, 0.90276, 0.91324, 0.86842, 0.92168, 0.99531, 0.95381, 0.9224, 0.85408, 0.92699, 0.86847, 1.0051, 0.91513, 0.80487, 0.93481, 1, 0.88159, 1.05214, 0.90646, 0.97355, 0.81539, 0.89398, 0.85923, 0.95381, 0.90646, 0.91513, 0.90646, 0.85923, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9154, 0.94236, 0.9154, 0.94236, 0.9154, 0.94236, 0.85458, 0.89364, 0.96694, 1, 0.89903, 1, 1, 1, 0.91782, 0.91782, 0.91782, 1, 0.896, 0.896, 0.896, 0.9332, 0.9332, 0.95973, 1, 1.26, 1, 1, 0.80479, 0.80178, 1, 1, 0.85633, 1, 1, 1, 1, 0.97276, 1, 1, 1, 0.698, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.14542, 1, 0.79199, 0.78694, 1.02058, 1.03493, 1.05486, 1, 1, 1.23026, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.20006, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    wo = { lineHeight: 1.2, lineGap: 0.2 };
    bo = [1.36898, 1, 1, 0.65507, 0.84943, 0.85639, 0.88465, 0.88465, 0.86936, 0.88307, 0.86948, 0.85283, 0.85283, 1.06383, 1.02058, 0.75945, 0.9219, 0.75945, 1.17337, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.75945, 0.75945, 1.02058, 1.02058, 1.02058, 0.69046, 0.70926, 0.85158, 0.77812, 0.76852, 0.89591, 0.70466, 0.76125, 0.80094, 0.86822, 0.83864, 0.728, 0.77212, 0.79475, 0.93637, 0.87514, 0.8588, 0.76013, 0.8588, 0.72421, 0.69866, 0.77598, 0.85991, 0.80811, 0.87832, 0.78112, 0.77512, 0.8562, 1.0222, 1.18417, 1.0222, 1.27014, 0.89903, 1.15012, 0.93859, 0.94399, 0.846, 0.94399, 0.81453, 1.0186, 0.94219, 0.96017, 1.03075, 1.02175, 0.912, 1.03075, 0.96998, 0.96017, 0.93859, 0.94399, 0.94399, 0.95493, 0.746, 1.12658, 0.94578, 0.91, 0.979, 0.882, 0.882, 0.83, 0.85034, 0.83537, 0.85034, 1.02058, 0.70869, 0.88465, 0.88465, 0.88465, 0.88465, 0.83537, 0.90083, 1.15012, 0.9161, 0.94565, 0.73541, 1.02058, 0.53609, 0.69353, 0.79519, 1.08595, 1, 1, 1.15012, 1, 0.91974, 0.75945, 1.15012, 1, 0.9446, 0.73361, 0.9005, 0.9005, 0.9005, 0.62864, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.773, 0.76852, 0.70466, 0.70466, 0.70466, 0.70466, 0.83864, 0.83864, 0.83864, 0.83864, 0.90561, 0.87514, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 1.02058, 0.85751, 0.85991, 0.85991, 0.85991, 0.85991, 0.77512, 0.76013, 0.88075, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.8075, 0.846, 0.81453, 0.81453, 0.81453, 0.81453, 0.82424, 0.82424, 0.82424, 0.82424, 0.9278, 0.96017, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 1.08595, 0.8562, 0.94578, 0.94578, 0.94578, 0.94578, 0.882, 0.94578, 0.882, 0.85158, 0.93859, 0.85158, 0.93859, 0.85158, 0.93859, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.89591, 0.8544, 0.90561, 0.94399, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.80094, 0.94219, 0.80094, 0.94219, 0.80094, 0.94219, 1, 1, 0.86822, 0.96017, 0.86822, 0.96017, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 1.03075, 0.83864, 0.82424, 0.81402, 1.02738, 0.728, 1.02175, 1, 1, 0.912, 0.79475, 1.03075, 1, 1, 0.79475, 0.83911, 0.79475, 0.66266, 0.80553, 1.06676, 0.87514, 0.96017, 1, 1, 0.87514, 0.96017, 0.86865, 0.87396, 0.96017, 0.8588, 0.93859, 0.8588, 0.93859, 0.8588, 0.93859, 0.867, 0.84759, 0.72421, 0.95493, 1, 1, 0.72421, 0.95493, 0.69866, 0.746, 0.69866, 0.746, 1, 1, 0.69866, 0.746, 1, 1, 0.77598, 0.88417, 0.77598, 1.12658, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.87832, 0.979, 0.77512, 0.882, 0.77512, 0.8562, 0.83, 0.8562, 0.83, 0.8562, 0.83, 1, 0.88465, 0.85158, 0.93859, 0.773, 0.8075, 0.85751, 0.8562, 1, 1, 0.77598, 1.12658, 1.15012, 1.15012, 1.15012, 1.15012, 1.15012, 1.15313, 1.15012, 1.15012, 1.15012, 1.08106, 1.03901, 0.85158, 0.77025, 0.62264, 0.7646, 0.65351, 0.86026, 0.69461, 0.89947, 1.03075, 0.85158, 0.77812, 0.76449, 0.88836, 0.70466, 0.8562, 0.86822, 0.8588, 0.83864, 0.77212, 0.85308, 0.93637, 0.87514, 0.82352, 0.8588, 0.85701, 0.76013, 0.89058, 0.77598, 0.8156, 0.82565, 0.78112, 0.77899, 0.89386, 0.83864, 0.8156, 0.9486, 0.92388, 0.96186, 1.03075, 0.91123, 0.9486, 0.93298, 0.878, 0.93942, 0.92388, 0.84596, 0.96186, 0.95119, 1.03075, 0.922, 0.88787, 0.95829, 0.88, 0.93559, 0.93859, 0.78815, 0.93758, 1, 0.89217, 1.03737, 0.91123, 0.93969, 0.77487, 0.85769, 0.86799, 1.03075, 0.91123, 0.93859, 0.91123, 0.86799, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87832, 0.979, 0.87832, 0.979, 0.87832, 0.979, 0.77512, 0.882, 0.9219, 1, 0.89903, 1, 1, 1, 0.87321, 0.87321, 0.87321, 1, 1.027, 1.027, 1.027, 0.86847, 0.86847, 0.79121, 1, 1.124, 1, 1, 0.73572, 0.73572, 1, 1, 0.85034, 1, 1, 1, 1, 0.88465, 1, 1, 1, 0.669, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04828, 1, 0.74948, 0.75187, 1.02058, 0.98391, 1.02119, 1, 1, 1.06233, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05233, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    Do = { lineHeight: 1.2, lineGap: 0.2 };
    So = [1.36898, 1, 1, 0.76305, 0.82784, 0.94935, 0.89364, 0.92241, 0.89073, 0.90706, 0.98472, 0.85283, 0.85283, 1.0664, 1.02058, 0.74505, 0.9219, 0.74505, 1.23456, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.74505, 0.74505, 1.02058, 1.02058, 1.02058, 0.73002, 0.72601, 0.91755, 0.8126, 0.80314, 0.92222, 0.73764, 0.79726, 0.83051, 0.90284, 0.86023, 0.74, 0.8126, 0.84869, 0.96518, 0.91115, 0.8858, 0.79761, 0.8858, 0.74498, 0.73914, 0.81363, 0.89591, 0.83659, 0.89633, 0.85608, 0.8111, 0.90531, 1.0222, 1.22736, 1.0222, 1.27014, 0.89903, 0.90088, 0.86667, 1.0231, 0.896, 1.01411, 0.90083, 1.05099, 1.00512, 0.99793, 1.05326, 1.09377, 0.938, 1.06226, 1.00119, 0.99793, 0.98714, 1.0231, 1.01231, 0.98196, 0.792, 1.19137, 0.99074, 0.962, 1.01915, 0.926, 0.942, 0.856, 0.85034, 0.92006, 0.85034, 1.02058, 0.69067, 0.92241, 0.92241, 0.92241, 0.92241, 0.92006, 0.9332, 0.90088, 0.91882, 0.93484, 0.75339, 1.02058, 0.56866, 0.54324, 0.79519, 1.08595, 1, 1, 0.90088, 1, 0.95325, 0.74505, 0.90088, 1, 0.97198, 0.75339, 0.91009, 0.91009, 0.91009, 0.66466, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.788, 0.80314, 0.73764, 0.73764, 0.73764, 0.73764, 0.86023, 0.86023, 0.86023, 0.86023, 0.92915, 0.91115, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 1.02058, 0.8858, 0.89591, 0.89591, 0.89591, 0.89591, 0.8111, 0.79611, 0.89713, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86936, 0.896, 0.90083, 0.90083, 0.90083, 0.90083, 0.84224, 0.84224, 0.84224, 0.84224, 0.97276, 0.99793, 0.98714, 0.98714, 0.98714, 0.98714, 0.98714, 1.08595, 0.89876, 0.99074, 0.99074, 0.99074, 0.99074, 0.942, 1.0231, 0.942, 0.91755, 0.86667, 0.91755, 0.86667, 0.91755, 0.86667, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.92222, 0.93372, 0.92915, 1.01411, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.83051, 1.00512, 0.83051, 1.00512, 0.83051, 1.00512, 1, 1, 0.90284, 0.99793, 0.90976, 0.99793, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 1.05326, 0.86023, 0.84224, 0.82873, 1.07469, 0.74, 1.09377, 1, 1, 0.938, 0.84869, 1.06226, 1, 1, 0.84869, 0.83704, 0.84869, 0.81441, 0.85588, 1.08927, 0.91115, 0.99793, 1, 1, 0.91115, 0.99793, 0.91887, 0.90991, 0.99793, 0.8858, 0.98714, 0.8858, 0.98714, 0.8858, 0.98714, 0.894, 0.91434, 0.74498, 0.98196, 1, 1, 0.74498, 0.98196, 0.73914, 0.792, 0.73914, 0.792, 1, 1, 0.73914, 0.792, 1, 1, 0.81363, 0.904, 0.81363, 1.19137, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89633, 1.01915, 0.8111, 0.942, 0.8111, 0.90531, 0.856, 0.90531, 0.856, 0.90531, 0.856, 1, 0.92241, 0.91755, 0.86667, 0.788, 0.86936, 0.8858, 0.89876, 1, 1, 0.81363, 1.19137, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90388, 1.03901, 0.92138, 0.78105, 0.7154, 0.86169, 0.80513, 0.94007, 0.82528, 0.98612, 1.06226, 0.91755, 0.8126, 0.81884, 0.92819, 0.73764, 0.90531, 0.90284, 0.8858, 0.86023, 0.8126, 0.91172, 0.96518, 0.91115, 0.83089, 0.8858, 0.87791, 0.79761, 0.89297, 0.81363, 0.88157, 0.89992, 0.85608, 0.81992, 0.94307, 0.86023, 0.88157, 0.95308, 0.98699, 0.99793, 1.06226, 0.95817, 0.95308, 0.97358, 0.928, 0.98088, 0.98699, 0.92761, 0.99793, 0.96017, 1.06226, 0.986, 0.944, 0.95978, 0.938, 0.96705, 0.98714, 0.80442, 0.98972, 1, 0.89762, 1.04552, 0.95817, 0.99007, 0.87064, 0.91879, 0.88888, 1.06226, 0.95817, 0.98714, 0.95817, 0.88888, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89633, 1.01915, 0.89633, 1.01915, 0.89633, 1.01915, 0.8111, 0.942, 0.9219, 1, 0.89903, 1, 1, 1, 0.93173, 0.93173, 0.93173, 1, 1.06304, 1.06304, 1.06904, 0.89903, 0.89903, 0.80549, 1, 1.156, 1, 1, 0.76575, 0.76575, 1, 1, 0.72458, 1, 1, 1, 1, 0.92241, 1, 1, 1, 0.619, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.07257, 1, 0.74705, 0.71119, 1.02058, 1.024, 1.02119, 1, 1, 1.1536, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05638, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    Fo = { lineHeight: 1.2, lineGap: 0.2 };
    ko = [1.76738, 1, 1, 0.99297, 0.9824, 1.04016, 1.06497, 1.03424, 0.97529, 1.17647, 1.23203, 1.1085, 1.1085, 1.16939, 1.2107, 0.9754, 1.21408, 0.9754, 1.59578, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 0.81378, 0.81378, 1.2107, 1.2107, 1.2107, 0.71703, 0.97847, 0.97363, 0.88776, 0.8641, 1.02096, 0.79795, 0.85132, 0.914, 1.06085, 1.1406, 0.8007, 0.89858, 0.83693, 1.14889, 1.09398, 0.97489, 0.92094, 0.97489, 0.90399, 0.84041, 0.95923, 1.00135, 1, 1.06467, 0.98243, 0.90996, 0.99361, 1.1085, 1.56942, 1.1085, 1.2107, 0.74627, 0.94282, 0.96752, 1.01519, 0.86304, 1.01359, 0.97278, 1.15103, 1.01359, 0.98561, 1.02285, 1.02285, 1.00527, 1.02285, 1.0302, 0.99041, 1.0008, 1.01519, 1.01359, 1.02258, 0.79104, 1.16862, 0.99041, 0.97454, 1.02511, 0.99298, 0.96752, 0.95801, 0.94856, 1.16579, 0.94856, 1.2107, 0.9824, 1.03424, 1.03424, 1, 1.03424, 1.16579, 0.8727, 1.3871, 1.18622, 1.10818, 1.04478, 1.2107, 1.18622, 0.75155, 0.94994, 1.28826, 1.21408, 1.21408, 0.91056, 1, 0.91572, 0.9754, 0.64663, 1.18328, 1.24866, 1.04478, 1.14169, 1.15749, 1.17389, 0.71703, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.93506, 0.8641, 0.79795, 0.79795, 0.79795, 0.79795, 1.1406, 1.1406, 1.1406, 1.1406, 1.02096, 1.09398, 0.97426, 0.97426, 0.97426, 0.97426, 0.97426, 1.2107, 0.97489, 1.00135, 1.00135, 1.00135, 1.00135, 0.90996, 0.92094, 1.02798, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.93136, 0.86304, 0.97278, 0.97278, 0.97278, 0.97278, 1.02285, 1.02285, 1.02285, 1.02285, 0.97122, 0.99041, 1, 1, 1, 1, 1, 1.28826, 1.0008, 0.99041, 0.99041, 0.99041, 0.99041, 0.96752, 1.01519, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 1.02096, 1.03057, 1.02096, 1.03517, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.914, 1.01359, 0.914, 1.01359, 0.914, 1.01359, 1, 1, 1.06085, 0.98561, 1.06085, 1.00879, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 0.97138, 1.08692, 0.8007, 1.02285, 1, 1, 1.00527, 0.83693, 1.02285, 1, 1, 0.83693, 0.9455, 0.83693, 0.90418, 0.83693, 1.13005, 1.09398, 0.99041, 1, 1, 1.09398, 0.99041, 0.96692, 1.09251, 0.99041, 0.97489, 1.0008, 0.97489, 1.0008, 0.97489, 1.0008, 0.93994, 0.97931, 0.90399, 1.02258, 1, 1, 0.90399, 1.02258, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 1, 1, 0.95923, 1.07034, 0.95923, 1.16862, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.06467, 1.02511, 0.90996, 0.96752, 0.90996, 0.99361, 0.95801, 0.99361, 0.95801, 0.99361, 0.95801, 1.07733, 1.03424, 0.97363, 0.96752, 0.93506, 0.93136, 0.97489, 1.0008, 1, 1, 0.95923, 1.16862, 1.15103, 1.15103, 1.01173, 1.03959, 0.75953, 0.81378, 0.79912, 1.15103, 1.21994, 0.95161, 0.87815, 1.01149, 0.81525, 0.7676, 0.98167, 1.01134, 1.02546, 0.84097, 1.03089, 1.18102, 0.97363, 0.88776, 0.85134, 0.97826, 0.79795, 0.99361, 1.06085, 0.97489, 1.1406, 0.89858, 1.0388, 1.14889, 1.09398, 0.86039, 0.97489, 1.0595, 0.92094, 0.94793, 0.95923, 0.90996, 0.99346, 0.98243, 1.02112, 0.95493, 1.1406, 0.90996, 1.03574, 1.02597, 1.0008, 1.18102, 1.06628, 1.03574, 1.0192, 1.01932, 1.00886, 0.97531, 1.0106, 1.0008, 1.13189, 1.18102, 1.02277, 0.98683, 1.0016, 0.99561, 1.07237, 1.0008, 0.90434, 0.99921, 0.93803, 0.8965, 1.23085, 1.06628, 1.04983, 0.96268, 1.0499, 0.98439, 1.18102, 1.06628, 1.0008, 1.06628, 0.98439, 0.79795, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09466, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.97278, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.02065, 1, 1, 1, 1, 1, 1, 1.06467, 1.02511, 1.06467, 1.02511, 1.06467, 1.02511, 0.90996, 0.96752, 1, 1.21408, 0.89903, 1, 1, 0.75155, 1.04394, 1.04394, 1.04394, 1.04394, 0.98633, 0.98633, 0.98633, 0.73047, 0.73047, 1.20642, 0.91211, 1.25635, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.12454, 0.93503, 1.03424, 1.19687, 1.03424, 1, 1, 1, 0.771, 1, 1, 1.15749, 1.15749, 1.15749, 1.10948, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.16897, 1, 0.96085, 0.90137, 1.2107, 1.18416, 1.13973, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21172, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18874, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.09193, 1.09193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    Ro = { lineHeight: 1.33008, lineGap: 0 };
    xo = [1.76738, 1, 1, 0.98946, 1.03959, 1.04016, 1.02809, 1.036, 0.97639, 1.10953, 1.23203, 1.11144, 1.11144, 1.16939, 1.21237, 0.9754, 1.21261, 0.9754, 1.59754, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 0.81378, 0.81378, 1.21237, 1.21237, 1.21237, 0.73541, 0.97847, 0.97363, 0.89723, 0.87897, 1.0426, 0.79429, 0.85292, 0.91149, 1.05815, 1.1406, 0.79631, 0.90128, 0.83853, 1.04396, 1.10615, 0.97552, 0.94436, 0.97552, 0.88641, 0.80527, 0.96083, 1.00135, 1, 1.06777, 0.9817, 0.91142, 0.99361, 1.11144, 1.57293, 1.11144, 1.21237, 0.74627, 1.31818, 1.06585, 0.97042, 0.83055, 0.97042, 0.93503, 1.1261, 0.97042, 0.97922, 1.14236, 0.94552, 1.01054, 1.14236, 1.02471, 0.97922, 0.94165, 0.97042, 0.97042, 1.0276, 0.78929, 1.1261, 0.97922, 0.95874, 1.02197, 0.98507, 0.96752, 0.97168, 0.95107, 1.16579, 0.95107, 1.21237, 1.03959, 1.036, 1.036, 1, 1.036, 1.16579, 0.87357, 1.31818, 1.18754, 1.26781, 1.05356, 1.21237, 1.18622, 0.79487, 0.94994, 1.29004, 1.24047, 1.24047, 1.31818, 1, 0.91484, 0.9754, 1.31818, 1.1349, 1.24866, 1.05356, 1.13934, 1.15574, 1.17389, 0.73541, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.94385, 0.87897, 0.79429, 0.79429, 0.79429, 0.79429, 1.1406, 1.1406, 1.1406, 1.1406, 1.0426, 1.10615, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 1.21237, 0.97552, 1.00135, 1.00135, 1.00135, 1.00135, 0.91142, 0.94436, 0.98721, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 0.96705, 0.83055, 0.93503, 0.93503, 0.93503, 0.93503, 1.14236, 1.14236, 1.14236, 1.14236, 0.93125, 0.97922, 0.94165, 0.94165, 0.94165, 0.94165, 0.94165, 1.29004, 0.94165, 0.97922, 0.97922, 0.97922, 0.97922, 0.96752, 0.97042, 0.96752, 0.97363, 1.06585, 0.97363, 1.06585, 0.97363, 1.06585, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 1.0426, 1.0033, 1.0426, 0.97042, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.91149, 0.97042, 0.91149, 0.97042, 0.91149, 0.97042, 1, 1, 1.05815, 0.97922, 1.05815, 0.97922, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 0.97441, 1.04302, 0.79631, 1.01582, 1, 1, 1.01054, 0.83853, 1.14236, 1, 1, 0.83853, 1.09125, 0.83853, 0.90418, 0.83853, 1.19508, 1.10615, 0.97922, 1, 1, 1.10615, 0.97922, 1.01034, 1.10466, 0.97922, 0.97552, 0.94165, 0.97552, 0.94165, 0.97552, 0.94165, 0.91602, 0.91981, 0.88641, 1.0276, 1, 1, 0.88641, 1.0276, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 1, 1, 0.96083, 1.05403, 0.95923, 1.16862, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.06777, 1.02197, 0.91142, 0.96752, 0.91142, 0.99361, 0.97168, 0.99361, 0.97168, 0.99361, 0.97168, 1.23199, 1.036, 0.97363, 1.06585, 0.94385, 0.96705, 0.97552, 0.94165, 1, 1, 0.96083, 1.1261, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 0.95161, 1.27126, 1.00811, 0.83284, 0.77702, 0.99137, 0.95253, 1.0347, 0.86142, 1.07205, 1.14236, 0.97363, 0.89723, 0.86869, 1.09818, 0.79429, 0.99361, 1.05815, 0.97552, 1.1406, 0.90128, 1.06662, 1.04396, 1.10615, 0.84918, 0.97552, 1.04694, 0.94436, 0.98015, 0.96083, 0.91142, 1.00356, 0.9817, 1.01945, 0.98999, 1.1406, 0.91142, 1.04961, 0.9898, 1.00639, 1.14236, 1.07514, 1.04961, 0.99607, 1.02897, 1.008, 0.9898, 0.95134, 1.00639, 1.11121, 1.14236, 1.00518, 0.97981, 1.02186, 1, 1.08578, 0.94165, 0.99314, 0.98387, 0.93028, 0.93377, 1.35125, 1.07514, 1.10687, 0.93491, 1.04232, 1.00351, 1.14236, 1.07514, 0.94165, 1.07514, 1.00351, 0.79429, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09097, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.93503, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96609, 1, 1, 1, 1, 1, 1, 1.06777, 1.02197, 1.06777, 1.02197, 1.06777, 1.02197, 0.91142, 0.96752, 1, 1.21261, 0.89903, 1, 1, 0.75155, 1.04745, 1.04745, 1.04745, 1.04394, 0.98633, 0.98633, 0.98633, 0.72959, 0.72959, 1.20502, 0.91406, 1.26514, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.09125, 0.93327, 1.03336, 1.16541, 1.036, 1, 1, 1, 0.771, 1, 1, 1.15574, 1.15574, 1.15574, 1.15574, 0.86364, 0.94434, 0.86279, 0.94434, 0.86224, 1, 1, 1.16798, 1, 0.96085, 0.90068, 1.21237, 1.18416, 1.13904, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21339, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18775, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.13269, 1.13269, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    No = { lineHeight: 1.33008, lineGap: 0 };
    Mo = [1.76738, 1, 1, 0.98946, 1.14763, 1.05365, 1.06234, 0.96927, 0.92586, 1.15373, 1.18414, 0.91349, 0.91349, 1.07403, 1.17308, 0.78383, 1.20088, 0.78383, 1.42531, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78383, 0.78383, 1.17308, 1.17308, 1.17308, 0.77349, 0.94565, 0.94729, 0.85944, 0.88506, 0.9858, 0.74817, 0.80016, 0.88449, 0.98039, 0.95782, 0.69238, 0.89898, 0.83231, 0.98183, 1.03989, 0.96924, 0.86237, 0.96924, 0.80595, 0.74524, 0.86091, 0.95402, 0.94143, 0.98448, 0.8858, 0.83089, 0.93285, 1.0949, 1.39016, 1.0949, 1.45994, 0.74627, 1.04839, 0.97454, 0.97454, 0.87207, 0.97454, 0.87533, 1.06151, 0.97454, 1.00176, 1.16484, 1.08132, 0.98047, 1.16484, 1.02989, 1.01054, 0.96225, 0.97454, 0.97454, 1.06598, 0.79004, 1.16344, 1.00351, 0.94629, 0.9973, 0.91016, 0.96777, 0.9043, 0.91082, 0.92481, 0.91082, 1.17308, 0.95748, 0.96927, 0.96927, 1, 0.96927, 0.92481, 0.80597, 1.04839, 1.23393, 1.1781, 0.9245, 1.17308, 1.20808, 0.63218, 0.94261, 1.24822, 1.09971, 1.09971, 1.04839, 1, 0.85273, 0.78032, 1.04839, 1.09971, 1.22326, 0.9245, 1.09836, 1.13525, 1.15222, 0.70424, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.85498, 0.88506, 0.74817, 0.74817, 0.74817, 0.74817, 0.95782, 0.95782, 0.95782, 0.95782, 0.9858, 1.03989, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.17308, 0.96924, 0.95402, 0.95402, 0.95402, 0.95402, 0.83089, 0.86237, 0.88409, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.92916, 0.87207, 0.87533, 0.87533, 0.87533, 0.87533, 0.93146, 0.93146, 0.93146, 0.93146, 0.93854, 1.01054, 0.96225, 0.96225, 0.96225, 0.96225, 0.96225, 1.24822, 0.8761, 1.00351, 1.00351, 1.00351, 1.00351, 0.96777, 0.97454, 0.96777, 0.94729, 0.97454, 0.94729, 0.97454, 0.94729, 0.97454, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.9858, 0.95391, 0.9858, 0.97454, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.88449, 0.97454, 0.88449, 0.97454, 0.88449, 0.97454, 1, 1, 0.98039, 1.00176, 0.98039, 1.00176, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 1.16484, 0.95782, 0.93146, 0.84421, 1.12761, 0.69238, 1.08132, 1, 1, 0.98047, 0.83231, 1.16484, 1, 1, 0.84723, 1.04861, 0.84723, 0.78755, 0.83231, 1.23736, 1.03989, 1.01054, 1, 1, 1.03989, 1.01054, 0.9857, 1.03849, 1.01054, 0.96924, 0.96225, 0.96924, 0.96225, 0.96924, 0.96225, 0.92383, 0.90171, 0.80595, 1.06598, 1, 1, 0.80595, 1.06598, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 1, 1, 0.86091, 1.02759, 0.85771, 1.16344, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.98448, 0.9973, 0.83089, 0.96777, 0.83089, 0.93285, 0.9043, 0.93285, 0.9043, 0.93285, 0.9043, 1.31868, 0.96927, 0.94729, 0.97454, 0.85498, 0.92916, 0.96924, 0.8761, 1, 1, 0.86091, 1.16344, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 0.81965, 0.81965, 0.94729, 0.78032, 0.71022, 0.90883, 0.84171, 0.99877, 0.77596, 1.05734, 1.2, 0.94729, 0.85944, 0.82791, 0.9607, 0.74817, 0.93285, 0.98039, 0.96924, 0.95782, 0.89898, 0.98316, 0.98183, 1.03989, 0.78614, 0.96924, 0.97642, 0.86237, 0.86075, 0.86091, 0.83089, 0.90082, 0.8858, 0.97296, 1.01284, 0.95782, 0.83089, 1.0976, 1.04, 1.03342, 1.2, 1.0675, 1.0976, 0.98205, 1.03809, 1.05097, 1.04, 0.95364, 1.03342, 1.05401, 1.2, 1.02148, 1.0119, 1.04724, 1.0127, 1.02732, 0.96225, 0.8965, 0.97783, 0.93574, 0.94818, 1.30679, 1.0675, 1.11826, 0.99821, 1.0557, 1.0326, 1.2, 1.0675, 0.96225, 1.0675, 1.0326, 0.74817, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03754, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87533, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.98705, 1, 1, 1, 1, 1, 1, 0.98448, 0.9973, 0.98448, 0.9973, 0.98448, 0.9973, 0.83089, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 0.94945, 0.94945, 0.94945, 0.94945, 1.12317, 1.12317, 1.12317, 0.67603, 0.67603, 1.15621, 0.73584, 1.21191, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87709, 0.96927, 1.01473, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.09836, 1.09836, 1.09836, 1.01522, 0.86321, 0.94434, 0.8649, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86438, 1.17308, 1.18416, 1.14589, 0.69825, 0.97622, 1.96791, 1.24822, 1.24822, 1.17308, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.17984, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10742, 1.10742, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    Go = { lineHeight: 1.33008, lineGap: 0 };
    vo = [1.76738, 1, 1, 0.98594, 1.02285, 1.10454, 1.06234, 0.96927, 0.92037, 1.19985, 1.2046, 0.90616, 0.90616, 1.07152, 1.1714, 0.78032, 1.20088, 0.78032, 1.40246, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78032, 0.78032, 1.1714, 1.1714, 1.1714, 0.80597, 0.94084, 0.96706, 0.85944, 0.85734, 0.97093, 0.75842, 0.79936, 0.88198, 0.9831, 0.95782, 0.71387, 0.86969, 0.84636, 1.07796, 1.03584, 0.96924, 0.83968, 0.96924, 0.82826, 0.79649, 0.85771, 0.95132, 0.93119, 0.98965, 0.88433, 0.8287, 0.93365, 1.08612, 1.3638, 1.08612, 1.45786, 0.74627, 0.80499, 0.91484, 1.05707, 0.92383, 1.05882, 0.9403, 1.12654, 1.05882, 1.01756, 1.09011, 1.09011, 0.99414, 1.09011, 1.034, 1.01756, 1.05356, 1.05707, 1.05882, 1.04399, 0.84863, 1.21968, 1.01756, 0.95801, 1.00068, 0.91797, 0.96777, 0.9043, 0.90351, 0.92105, 0.90351, 1.1714, 0.85337, 0.96927, 0.96927, 0.99912, 0.96927, 0.92105, 0.80597, 1.2434, 1.20808, 1.05937, 0.90957, 1.1714, 1.20808, 0.75155, 0.94261, 1.24644, 1.09971, 1.09971, 0.84751, 1, 0.85273, 0.78032, 0.61584, 1.05425, 1.17914, 0.90957, 1.08665, 1.11593, 1.14169, 0.73381, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.86035, 0.85734, 0.75842, 0.75842, 0.75842, 0.75842, 0.95782, 0.95782, 0.95782, 0.95782, 0.97093, 1.03584, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.1714, 0.96924, 0.95132, 0.95132, 0.95132, 0.95132, 0.8287, 0.83968, 0.89049, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.93575, 0.92383, 0.9403, 0.9403, 0.9403, 0.9403, 0.8717, 0.8717, 0.8717, 0.8717, 1.00527, 1.01756, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 1.24644, 0.95923, 1.01756, 1.01756, 1.01756, 1.01756, 0.96777, 1.05707, 0.96777, 0.96706, 0.91484, 0.96706, 0.91484, 0.96706, 0.91484, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.97093, 1.0969, 0.97093, 1.05882, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.88198, 1.05882, 0.88198, 1.05882, 0.88198, 1.05882, 1, 1, 0.9831, 1.01756, 0.9831, 1.01756, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 1.09011, 0.95782, 0.8717, 0.84784, 1.11551, 0.71387, 1.09011, 1, 1, 0.99414, 0.84636, 1.09011, 1, 1, 0.84636, 1.0536, 0.84636, 0.94298, 0.84636, 1.23297, 1.03584, 1.01756, 1, 1, 1.03584, 1.01756, 1.00323, 1.03444, 1.01756, 0.96924, 1.05356, 0.96924, 1.05356, 0.96924, 1.05356, 0.93066, 0.98293, 0.82826, 1.04399, 1, 1, 0.82826, 1.04399, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 1, 1, 0.85771, 1.17318, 0.85771, 1.21968, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.98965, 1.00068, 0.8287, 0.96777, 0.8287, 0.93365, 0.9043, 0.93365, 0.9043, 0.93365, 0.9043, 1.08571, 0.96927, 0.96706, 0.91484, 0.86035, 0.93575, 0.96924, 0.95923, 1, 1, 0.85771, 1.21968, 1.11437, 1.11437, 0.93109, 0.91202, 0.60411, 0.84164, 0.55572, 1.01173, 0.97361, 0.81818, 0.81818, 0.96635, 0.78032, 0.72727, 0.92366, 0.98601, 1.03405, 0.77968, 1.09799, 1.2, 0.96706, 0.85944, 0.85638, 0.96491, 0.75842, 0.93365, 0.9831, 0.96924, 0.95782, 0.86969, 0.94152, 1.07796, 1.03584, 0.78437, 0.96924, 0.98715, 0.83968, 0.83491, 0.85771, 0.8287, 0.94492, 0.88433, 0.9287, 1.0098, 0.95782, 0.8287, 1.0625, 0.98248, 1.03424, 1.2, 1.01071, 1.0625, 0.95246, 1.03809, 1.04912, 0.98248, 1.00221, 1.03424, 1.05443, 1.2, 1.04785, 0.99609, 1.00169, 1.05176, 0.99346, 1.05356, 0.9087, 1.03004, 0.95542, 0.93117, 1.23362, 1.01071, 1.07831, 1.02512, 1.05205, 1.03502, 1.2, 1.01071, 1.05356, 1.01071, 1.03502, 0.75842, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03719, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9403, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04021, 1, 1, 1, 1, 1, 1, 0.98965, 1.00068, 0.98965, 1.00068, 0.98965, 1.00068, 0.8287, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 1.03077, 1.03077, 1.03077, 1.03077, 1.13196, 1.13196, 1.13196, 0.67428, 0.67428, 1.16039, 0.73291, 1.20996, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87796, 0.96927, 1.01518, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.10539, 1.10539, 1.11358, 1.06967, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86507, 1.1714, 1.18416, 1.14589, 0.69825, 0.97622, 1.9697, 1.24822, 1.24822, 1.17238, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18083, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10938, 1.10938, 1, 1, 1, 1.05425, 1.09971, 1.09971, 1.09971, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    Lo = { lineHeight: 1.33008, lineGap: 0 };
    Uo = getLookupTableFactory(function(e3) {
      e3["MyriadPro-Regular"] = e3["PdfJS-Fallback-Regular"] = { name: "LiberationSans-Regular", factors: So, baseWidths: Eo, baseMapping: fo, metrics: Fo }, e3["MyriadPro-Bold"] = e3["PdfJS-Fallback-Bold"] = { name: "LiberationSans-Bold", factors: po, baseWidths: lo, baseMapping: Io, metrics: mo }, e3["MyriadPro-It"] = e3["MyriadPro-Italic"] = e3["PdfJS-Fallback-Italic"] = { name: "LiberationSans-Italic", factors: bo, baseWidths: uo, baseMapping: Qo, metrics: Do }, e3["MyriadPro-BoldIt"] = e3["MyriadPro-BoldItalic"] = e3["PdfJS-Fallback-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: yo, baseWidths: Co, baseMapping: Bo, metrics: wo }, e3.ArialMT = e3.Arial = e3["Arial-Regular"] = { name: "LiberationSans-Regular", baseWidths: Eo, baseMapping: fo }, e3["Arial-BoldMT"] = e3["Arial-Bold"] = { name: "LiberationSans-Bold", baseWidths: lo, baseMapping: Io }, e3["Arial-ItalicMT"] = e3["Arial-Italic"] = { name: "LiberationSans-Italic", baseWidths: uo, baseMapping: Qo }, e3["Arial-BoldItalicMT"] = e3["Arial-BoldItalic"] = { name: "LiberationSans-BoldItalic", baseWidths: Co, baseMapping: Bo }, e3["Calibri-Regular"] = { name: "LiberationSans-Regular", factors: Ao, baseWidths: Eo, baseMapping: fo, metrics: io }, e3["Calibri-Bold"] = { name: "LiberationSans-Bold", factors: Vr, baseWidths: lo, baseMapping: Io, metrics: Zr }, e3["Calibri-Italic"] = { name: "LiberationSans-Italic", factors: eo, baseWidths: uo, baseMapping: Qo, metrics: to }, e3["Calibri-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: zr, baseWidths: Co, baseMapping: Bo, metrics: $r }, e3["Segoeui-Regular"] = { name: "LiberationSans-Regular", factors: vo, baseWidths: Eo, baseMapping: fo, metrics: Lo }, e3["Segoeui-Bold"] = { name: "LiberationSans-Bold", factors: ko, baseWidths: lo, baseMapping: Io, metrics: Ro }, e3["Segoeui-Italic"] = { name: "LiberationSans-Italic", factors: Mo, baseWidths: uo, baseMapping: Qo, metrics: Go }, e3["Segoeui-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: xo, baseWidths: Co, baseMapping: Bo, metrics: No }, e3["Helvetica-Regular"] = e3.Helvetica = { name: "LiberationSans-Regular", factors: co, baseWidths: Eo, baseMapping: fo, metrics: ho }, e3["Helvetica-Bold"] = { name: "LiberationSans-Bold", factors: ao, baseWidths: lo, baseMapping: Io, metrics: so }, e3["Helvetica-Italic"] = { name: "LiberationSans-Italic", factors: oo, baseWidths: uo, baseMapping: Qo, metrics: go }, e3["Helvetica-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: no, baseWidths: Co, baseMapping: Bo, metrics: ro };
    });
    PostScriptParser = class {
      constructor(e3) {
        this.lexer = e3, this.operators = [], this.token = null, this.prev = null;
      }
      nextToken() {
        this.prev = this.token, this.token = this.lexer.getToken();
      }
      accept(e3) {
        return this.token.type === e3 && (this.nextToken(), true);
      }
      expect(e3) {
        if (this.accept(e3)) return true;
        throw new FormatError(`Unexpected symbol: found ${this.token.type} expected ${e3}.`);
      }
      parse() {
        return this.nextToken(), this.expect(Ho.LBRACE), this.parseBlock(), this.expect(Ho.RBRACE), this.operators;
      }
      parseBlock() {
        for (; ; ) if (this.accept(Ho.NUMBER)) this.operators.push(this.prev.value);
        else if (this.accept(Ho.OPERATOR)) this.operators.push(this.prev.value);
        else {
          if (!this.accept(Ho.LBRACE)) return;
          this.parseCondition();
        }
      }
      parseCondition() {
        const e3 = this.operators.length;
        if (this.operators.push(null, null), this.parseBlock(), this.expect(Ho.RBRACE), this.accept(Ho.IF)) this.operators[e3] = this.operators.length, this.operators[e3 + 1] = "jz";
        else {
          if (!this.accept(Ho.LBRACE)) throw new FormatError("PS Function: error parsing conditional.");
          {
            const t3 = this.operators.length;
            this.operators.push(null, null);
            const i3 = this.operators.length;
            this.parseBlock(), this.expect(Ho.RBRACE), this.expect(Ho.IFELSE), this.operators[t3] = this.operators.length, this.operators[t3 + 1] = "j", this.operators[e3] = i3, this.operators[e3 + 1] = "jz";
          }
        }
      }
    };
    Ho = { LBRACE: 0, RBRACE: 1, NUMBER: 2, OPERATOR: 3, IF: 4, IFELSE: 5 };
    PostScriptToken = class _PostScriptToken {
      static get opCache() {
        return shadow(this, "opCache", /* @__PURE__ */ Object.create(null));
      }
      constructor(e3, t3) {
        this.type = e3, this.value = t3;
      }
      static getOperator(e3) {
        var _a4;
        return (_a4 = _PostScriptToken.opCache)[e3] || (_a4[e3] = new _PostScriptToken(Ho.OPERATOR, e3));
      }
      static get LBRACE() {
        return shadow(this, "LBRACE", new _PostScriptToken(Ho.LBRACE, "{"));
      }
      static get RBRACE() {
        return shadow(this, "RBRACE", new _PostScriptToken(Ho.RBRACE, "}"));
      }
      static get IF() {
        return shadow(this, "IF", new _PostScriptToken(Ho.IF, "IF"));
      }
      static get IFELSE() {
        return shadow(this, "IFELSE", new _PostScriptToken(Ho.IFELSE, "IFELSE"));
      }
    };
    PostScriptLexer = class {
      constructor(e3) {
        this.stream = e3, this.nextChar(), this.strBuf = [];
      }
      nextChar() {
        return this.currentChar = this.stream.getByte();
      }
      getToken() {
        let e3 = false, t3 = this.currentChar;
        for (; ; ) {
          if (t3 < 0) return Xs;
          if (e3) 10 !== t3 && 13 !== t3 || (e3 = false);
          else if (37 === t3) e3 = true;
          else if (!isWhiteSpace(t3)) break;
          t3 = this.nextChar();
        }
        switch (0 | t3) {
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
          case 43:
          case 45:
          case 46:
            return new PostScriptToken(Ho.NUMBER, this.getNumber());
          case 123:
            return this.nextChar(), PostScriptToken.LBRACE;
          case 125:
            return this.nextChar(), PostScriptToken.RBRACE;
        }
        const i3 = this.strBuf;
        for (i3.length = 0, i3[0] = String.fromCharCode(t3); (t3 = this.nextChar()) >= 0 && (t3 >= 65 && t3 <= 90 || t3 >= 97 && t3 <= 122); ) i3.push(String.fromCharCode(t3));
        const a3 = i3.join("");
        switch (a3.toLowerCase()) {
          case "if":
            return PostScriptToken.IF;
          case "ifelse":
            return PostScriptToken.IFELSE;
          default:
            return PostScriptToken.getOperator(a3);
        }
      }
      getNumber() {
        let e3 = this.currentChar;
        const t3 = this.strBuf;
        for (t3.length = 0, t3[0] = String.fromCharCode(e3); (e3 = this.nextChar()) >= 0 && (e3 >= 48 && e3 <= 57 || 45 === e3 || 46 === e3); ) t3.push(String.fromCharCode(e3));
        const i3 = parseFloat(t3.join(""));
        if (isNaN(i3)) throw new FormatError(`Invalid floating point number: ${i3}`);
        return i3;
      }
    };
    BaseLocalCache = class {
      constructor(e3) {
        this._onlyRefs = true === e3?.onlyRefs, this._onlyRefs || (this._nameRefMap = /* @__PURE__ */ new Map(), this._imageMap = /* @__PURE__ */ new Map()), this._imageCache = new RefSetCache();
      }
      getByName(e3) {
        this._onlyRefs && unreachable("Should not call `getByName` method.");
        const t3 = this._nameRefMap.get(e3);
        return t3 ? this.getByRef(t3) : this._imageMap.get(e3) || null;
      }
      getByRef(e3) {
        return this._imageCache.get(e3) || null;
      }
      set(e3, t3, i3) {
        unreachable("Abstract method `set` called.");
      }
    };
    LocalImageCache = class extends BaseLocalCache {
      set(e3, t3 = null, i3) {
        if ("string" != typeof e3) throw new Error('LocalImageCache.set - expected "name" argument.');
        if (t3) {
          if (this._imageCache.has(t3)) return;
          return this._nameRefMap.set(e3, t3), void this._imageCache.put(t3, i3);
        }
        this._imageMap.has(e3) || this._imageMap.set(e3, i3);
      }
    };
    LocalColorSpaceCache = class extends BaseLocalCache {
      set(e3 = null, t3 = null, i3) {
        if ("string" != typeof e3 && !t3) throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
        if (t3) {
          if (this._imageCache.has(t3)) return;
          return null !== e3 && this._nameRefMap.set(e3, t3), void this._imageCache.put(t3, i3);
        }
        this._imageMap.has(e3) || this._imageMap.set(e3, i3);
      }
    };
    LocalFunctionCache = class extends BaseLocalCache {
      constructor(e3) {
        super({ onlyRefs: true });
      }
      set(e3 = null, t3, i3) {
        if (!t3) throw new Error('LocalFunctionCache.set - expected "ref" argument.');
        this._imageCache.has(t3) || this._imageCache.put(t3, i3);
      }
    };
    LocalGStateCache = class extends BaseLocalCache {
      set(e3, t3 = null, i3) {
        if ("string" != typeof e3) throw new Error('LocalGStateCache.set - expected "name" argument.');
        if (t3) {
          if (this._imageCache.has(t3)) return;
          return this._nameRefMap.set(e3, t3), void this._imageCache.put(t3, i3);
        }
        this._imageMap.has(e3) || this._imageMap.set(e3, i3);
      }
    };
    LocalTilingPatternCache = class extends BaseLocalCache {
      constructor(e3) {
        super({ onlyRefs: true });
      }
      set(e3 = null, t3, i3) {
        if (!t3) throw new Error('LocalTilingPatternCache.set - expected "ref" argument.');
        this._imageCache.has(t3) || this._imageCache.put(t3, i3);
      }
    };
    RegionalImageCache = class extends BaseLocalCache {
      constructor(e3) {
        super({ onlyRefs: true });
      }
      set(e3 = null, t3, i3) {
        if (!t3) throw new Error('RegionalImageCache.set - expected "ref" argument.');
        this._imageCache.has(t3) || this._imageCache.put(t3, i3);
      }
    };
    _GlobalImageCache = class _GlobalImageCache {
      constructor() {
        __privateAdd(this, _GlobalImageCache_instances);
        __privateAdd(this, _b, new RefSet());
        this._refCache = new RefSetCache(), this._imageCache = new RefSetCache();
      }
      shouldCache(e3, t3) {
        let i3 = this._refCache.get(e3);
        return i3 || (i3 = /* @__PURE__ */ new Set(), this._refCache.put(e3, i3)), i3.add(t3), !(i3.size < _GlobalImageCache.NUM_PAGES_THRESHOLD) && !(!this._imageCache.has(e3) && __privateGet(this, _GlobalImageCache_instances, S_get));
      }
      addDecodeFailed(e3) {
        __privateGet(this, _b).put(e3);
      }
      hasDecodeFailed(e3) {
        return __privateGet(this, _b).has(e3);
      }
      addByteSize(e3, t3) {
        const i3 = this._imageCache.get(e3);
        i3 && (i3.byteSize || (i3.byteSize = t3));
      }
      getData(e3, t3) {
        const i3 = this._refCache.get(e3);
        if (!i3) return null;
        if (i3.size < _GlobalImageCache.NUM_PAGES_THRESHOLD) return null;
        const a3 = this._imageCache.get(e3);
        return a3 ? (i3.add(t3), a3) : null;
      }
      setData(e3, t3) {
        if (!this._refCache.has(e3)) throw new Error('GlobalImageCache.setData - expected "shouldCache" to have been called.');
        this._imageCache.has(e3) || (__privateGet(this, _GlobalImageCache_instances, S_get) ? warn("GlobalImageCache.setData - cache limit reached.") : this._imageCache.put(e3, t3));
      }
      clear(e3 = false) {
        e3 || (__privateGet(this, _b).clear(), this._refCache.clear()), this._imageCache.clear();
      }
    };
    _b = new WeakMap();
    _GlobalImageCache_instances = new WeakSet();
    D_get = function() {
      let e3 = 0;
      for (const t3 of this._imageCache) e3 += t3.byteSize;
      return e3;
    };
    S_get = function() {
      return !(this._imageCache.size < _GlobalImageCache.MIN_IMAGES_TO_CACHE) && !(__privateGet(this, _GlobalImageCache_instances, D_get) < _GlobalImageCache.MAX_BYTE_SIZE);
    };
    __publicField(_GlobalImageCache, "NUM_PAGES_THRESHOLD", 2);
    __publicField(_GlobalImageCache, "MIN_IMAGES_TO_CACHE", 10);
    __publicField(_GlobalImageCache, "MAX_BYTE_SIZE", 5e7);
    GlobalImageCache = _GlobalImageCache;
    PDFFunctionFactory = class {
      constructor({ xref: e3, isEvalSupported: t3 = true }) {
        this.xref = e3, this.isEvalSupported = false !== t3;
      }
      create(e3) {
        const t3 = this.getCached(e3);
        if (t3) return t3;
        const i3 = PDFFunction.parse({ xref: this.xref, isEvalSupported: this.isEvalSupported, fn: e3 instanceof Ref ? this.xref.fetch(e3) : e3 });
        return this._cache(e3, i3), i3;
      }
      createFromArray(e3) {
        const t3 = this.getCached(e3);
        if (t3) return t3;
        const i3 = PDFFunction.parseArray({ xref: this.xref, isEvalSupported: this.isEvalSupported, fnObj: e3 instanceof Ref ? this.xref.fetch(e3) : e3 });
        return this._cache(e3, i3), i3;
      }
      getCached(e3) {
        let t3;
        if (e3 instanceof Ref ? t3 = e3 : e3 instanceof Dict ? t3 = e3.objId : e3 instanceof BaseStream && (t3 = e3.dict?.objId), t3) {
          const e4 = this._localFunctionCache.getByRef(t3);
          if (e4) return e4;
        }
        return null;
      }
      _cache(e3, t3) {
        if (!t3) throw new Error('PDFFunctionFactory._cache - expected "parsedFunction" argument.');
        let i3;
        e3 instanceof Ref ? i3 = e3 : e3 instanceof Dict ? i3 = e3.objId : e3 instanceof BaseStream && (i3 = e3.dict?.objId), i3 && this._localFunctionCache.set(null, i3, t3);
      }
      get _localFunctionCache() {
        return shadow(this, "_localFunctionCache", new LocalFunctionCache());
      }
    };
    PDFFunction = class {
      static getSampleArray(e3, t3, i3, a3) {
        let s3, n3, r3 = 1;
        for (s3 = 0, n3 = e3.length; s3 < n3; s3++) r3 *= e3[s3];
        r3 *= t3;
        const o3 = new Array(r3);
        let g3 = 0, c3 = 0;
        const h3 = 1 / (2 ** i3 - 1), l3 = a3.getBytes((r3 * i3 + 7) / 8);
        let C3 = 0;
        for (s3 = 0; s3 < r3; s3++) {
          for (; g3 < i3; ) c3 <<= 8, c3 |= l3[C3++], g3 += 8;
          g3 -= i3, o3[s3] = (c3 >> g3) * h3, c3 &= (1 << g3) - 1;
        }
        return o3;
      }
      static parse({ xref: e3, isEvalSupported: t3, fn: i3 }) {
        const a3 = i3.dict || i3;
        switch (a3.get("FunctionType")) {
          case 0:
            return this.constructSampled({ xref: e3, isEvalSupported: t3, fn: i3, dict: a3 });
          case 1:
            break;
          case 2:
            return this.constructInterpolated({ xref: e3, isEvalSupported: t3, dict: a3 });
          case 3:
            return this.constructStiched({ xref: e3, isEvalSupported: t3, dict: a3 });
          case 4:
            return this.constructPostScript({ xref: e3, isEvalSupported: t3, fn: i3, dict: a3 });
        }
        throw new FormatError("Unknown type of function");
      }
      static parseArray({ xref: e3, isEvalSupported: t3, fnObj: i3 }) {
        if (!Array.isArray(i3)) return this.parse({ xref: e3, isEvalSupported: t3, fn: i3 });
        const a3 = [];
        for (const s3 of i3) a3.push(this.parse({ xref: e3, isEvalSupported: t3, fn: e3.fetchIfRef(s3) }));
        return function(e4, t4, i4, s3) {
          for (let n3 = 0, r3 = a3.length; n3 < r3; n3++) a3[n3](e4, t4, i4, s3 + n3);
        };
      }
      static constructSampled({ xref: e3, isEvalSupported: t3, fn: i3, dict: a3 }) {
        function toMultiArray(e4) {
          const t4 = e4.length, i4 = [];
          let a4 = 0;
          for (let s4 = 0; s4 < t4; s4 += 2) i4[a4++] = [e4[s4], e4[s4 + 1]];
          return i4;
        }
        function interpolate(e4, t4, i4, a4, s4) {
          return a4 + (s4 - a4) / (i4 - t4) * (e4 - t4);
        }
        let s3 = toNumberArray(a3.getArray("Domain")), n3 = toNumberArray(a3.getArray("Range"));
        if (!s3 || !n3) throw new FormatError("No domain or range");
        const r3 = s3.length / 2, o3 = n3.length / 2;
        s3 = toMultiArray(s3), n3 = toMultiArray(n3);
        const g3 = toNumberArray(a3.getArray("Size")), c3 = a3.get("BitsPerSample"), h3 = a3.get("Order") || 1;
        1 !== h3 && info("No support for cubic spline interpolation: " + h3);
        let l3 = toNumberArray(a3.getArray("Encode"));
        if (l3) l3 = toMultiArray(l3);
        else {
          l3 = [];
          for (let e4 = 0; e4 < r3; ++e4) l3.push([0, g3[e4] - 1]);
        }
        let C3 = toNumberArray(a3.getArray("Decode"));
        C3 = C3 ? toMultiArray(C3) : n3;
        const d3 = this.getSampleArray(g3, o3, c3, i3);
        return function(e4, t4, i4, a4) {
          const c4 = 1 << r3, h4 = new Float64Array(c4), u3 = new Uint32Array(c4);
          let Q3, f3;
          for (f3 = 0; f3 < c4; f3++) h4[f3] = 1;
          let p3 = o3, m3 = 1;
          for (Q3 = 0; Q3 < r3; ++Q3) {
            const i5 = s3[Q3][0], a5 = s3[Q3][1];
            let n4 = interpolate(Math.min(Math.max(e4[t4 + Q3], i5), a5), i5, a5, l3[Q3][0], l3[Q3][1]);
            const r4 = g3[Q3];
            n4 = Math.min(Math.max(n4, 0), r4 - 1);
            const o4 = n4 < r4 - 1 ? Math.floor(n4) : n4 - 1, C4 = o4 + 1 - n4, d4 = n4 - o4, y3 = o4 * p3, w3 = y3 + p3;
            for (f3 = 0; f3 < c4; f3++) f3 & m3 ? (h4[f3] *= d4, u3[f3] += w3) : (h4[f3] *= C4, u3[f3] += y3);
            p3 *= r4, m3 <<= 1;
          }
          for (f3 = 0; f3 < o3; ++f3) {
            let e5 = 0;
            for (Q3 = 0; Q3 < c4; Q3++) e5 += d3[u3[Q3] + f3] * h4[Q3];
            e5 = interpolate(e5, 0, 1, C3[f3][0], C3[f3][1]), i4[a4 + f3] = Math.min(Math.max(e5, n3[f3][0]), n3[f3][1]);
          }
        };
      }
      static constructInterpolated({ xref: e3, isEvalSupported: t3, dict: i3 }) {
        const a3 = toNumberArray(i3.getArray("C0")) || [0], s3 = toNumberArray(i3.getArray("C1")) || [1], n3 = i3.get("N"), r3 = [];
        for (let e4 = 0, t4 = a3.length; e4 < t4; ++e4) r3.push(s3[e4] - a3[e4]);
        const o3 = r3.length;
        return function(e4, t4, i4, s4) {
          const g3 = 1 === n3 ? e4[t4] : e4[t4] ** n3;
          for (let e5 = 0; e5 < o3; ++e5) i4[s4 + e5] = a3[e5] + g3 * r3[e5];
        };
      }
      static constructStiched({ xref: e3, isEvalSupported: t3, dict: i3 }) {
        const a3 = toNumberArray(i3.getArray("Domain"));
        if (!a3) throw new FormatError("No domain");
        if (1 !== a3.length / 2) throw new FormatError("Bad domain for stiched function");
        const s3 = [];
        for (const a4 of i3.get("Functions")) s3.push(this.parse({ xref: e3, isEvalSupported: t3, fn: e3.fetchIfRef(a4) }));
        const n3 = toNumberArray(i3.getArray("Bounds")), r3 = toNumberArray(i3.getArray("Encode")), o3 = new Float32Array(1);
        return function(e4, t4, i4, g3) {
          const c3 = function(e5, t5, i5) {
            return e5 > i5 ? e5 = i5 : e5 < t5 && (e5 = t5), e5;
          }(e4[t4], a3[0], a3[1]), h3 = n3.length;
          let l3;
          for (l3 = 0; l3 < h3 && !(c3 < n3[l3]); ++l3) ;
          let C3 = a3[0];
          l3 > 0 && (C3 = n3[l3 - 1]);
          let d3 = a3[1];
          l3 < n3.length && (d3 = n3[l3]);
          const u3 = r3[2 * l3], Q3 = r3[2 * l3 + 1];
          o3[0] = C3 === d3 ? u3 : u3 + (c3 - C3) * (Q3 - u3) / (d3 - C3), s3[l3](o3, 0, i4, g3);
        };
      }
      static constructPostScript({ xref: e3, isEvalSupported: t3, fn: i3, dict: a3 }) {
        const s3 = toNumberArray(a3.getArray("Domain")), n3 = toNumberArray(a3.getArray("Range"));
        if (!s3) throw new FormatError("No domain.");
        if (!n3) throw new FormatError("No range.");
        const r3 = new PostScriptLexer(i3), o3 = new PostScriptParser(r3).parse();
        if (t3 && FeatureTest.isEvalSupported) {
          const e4 = new PostScriptCompiler().compile(o3, s3, n3);
          if (e4) return new Function("src", "srcOffset", "dest", "destOffset", e4);
        }
        info("Unable to compile PS function");
        const g3 = n3.length >> 1, c3 = s3.length >> 1, h3 = new PostScriptEvaluator(o3), l3 = /* @__PURE__ */ Object.create(null);
        let C3 = 8192;
        const d3 = new Float32Array(c3);
        return function(e4, t4, i4, a4) {
          let s4, r4, o4 = "";
          const u3 = d3;
          for (s4 = 0; s4 < c3; s4++) r4 = e4[t4 + s4], u3[s4] = r4, o4 += r4 + "_";
          const Q3 = l3[o4];
          if (void 0 !== Q3) return void i4.set(Q3, a4);
          const f3 = new Float32Array(g3), p3 = h3.execute(u3), m3 = p3.length - g3;
          for (s4 = 0; s4 < g3; s4++) {
            r4 = p3[m3 + s4];
            let e5 = n3[2 * s4];
            r4 < e5 ? r4 = e5 : (e5 = n3[2 * s4 + 1], r4 > e5 && (r4 = e5)), f3[s4] = r4;
          }
          C3 > 0 && (C3--, l3[o4] = f3), i4.set(f3, a4);
        };
      }
    };
    _PostScriptStack = class _PostScriptStack {
      constructor(e3) {
        this.stack = e3 ? Array.from(e3) : [];
      }
      push(e3) {
        if (this.stack.length >= _PostScriptStack.MAX_STACK_SIZE) throw new Error("PostScript function stack overflow.");
        this.stack.push(e3);
      }
      pop() {
        if (this.stack.length <= 0) throw new Error("PostScript function stack underflow.");
        return this.stack.pop();
      }
      copy(e3) {
        if (this.stack.length + e3 >= _PostScriptStack.MAX_STACK_SIZE) throw new Error("PostScript function stack overflow.");
        const t3 = this.stack;
        for (let i3 = t3.length - e3, a3 = e3 - 1; a3 >= 0; a3--, i3++) t3.push(t3[i3]);
      }
      index(e3) {
        this.push(this.stack[this.stack.length - e3 - 1]);
      }
      roll(e3, t3) {
        const i3 = this.stack, a3 = i3.length - e3, s3 = i3.length - 1, n3 = a3 + (t3 - Math.floor(t3 / e3) * e3);
        for (let e4 = a3, t4 = s3; e4 < t4; e4++, t4--) {
          const a4 = i3[e4];
          i3[e4] = i3[t4], i3[t4] = a4;
        }
        for (let e4 = a3, t4 = n3 - 1; e4 < t4; e4++, t4--) {
          const a4 = i3[e4];
          i3[e4] = i3[t4], i3[t4] = a4;
        }
        for (let e4 = n3, t4 = s3; e4 < t4; e4++, t4--) {
          const a4 = i3[e4];
          i3[e4] = i3[t4], i3[t4] = a4;
        }
      }
    };
    __publicField(_PostScriptStack, "MAX_STACK_SIZE", 100);
    PostScriptStack = _PostScriptStack;
    PostScriptEvaluator = class {
      constructor(e3) {
        this.operators = e3;
      }
      execute(e3) {
        const t3 = new PostScriptStack(e3);
        let i3 = 0;
        const a3 = this.operators, s3 = a3.length;
        let n3, r3, o3;
        for (; i3 < s3; ) if (n3 = a3[i3++], "number" != typeof n3) switch (n3) {
          case "jz":
            o3 = t3.pop(), r3 = t3.pop(), r3 || (i3 = o3);
            break;
          case "j":
            r3 = t3.pop(), i3 = r3;
            break;
          case "abs":
            r3 = t3.pop(), t3.push(Math.abs(r3));
            break;
          case "add":
            o3 = t3.pop(), r3 = t3.pop(), t3.push(r3 + o3);
            break;
          case "and":
            o3 = t3.pop(), r3 = t3.pop(), "boolean" == typeof r3 && "boolean" == typeof o3 ? t3.push(r3 && o3) : t3.push(r3 & o3);
            break;
          case "atan":
            o3 = t3.pop(), r3 = t3.pop(), r3 = Math.atan2(r3, o3) / Math.PI * 180, r3 < 0 && (r3 += 360), t3.push(r3);
            break;
          case "bitshift":
            o3 = t3.pop(), r3 = t3.pop(), r3 > 0 ? t3.push(r3 << o3) : t3.push(r3 >> o3);
            break;
          case "ceiling":
            r3 = t3.pop(), t3.push(Math.ceil(r3));
            break;
          case "copy":
            r3 = t3.pop(), t3.copy(r3);
            break;
          case "cos":
            r3 = t3.pop(), t3.push(Math.cos(r3 % 360 / 180 * Math.PI));
            break;
          case "cvi":
            r3 = 0 | t3.pop(), t3.push(r3);
            break;
          case "cvr":
            break;
          case "div":
            o3 = t3.pop(), r3 = t3.pop(), t3.push(r3 / o3);
            break;
          case "dup":
            t3.copy(1);
            break;
          case "eq":
            o3 = t3.pop(), r3 = t3.pop(), t3.push(r3 === o3);
            break;
          case "exch":
            t3.roll(2, 1);
            break;
          case "exp":
            o3 = t3.pop(), r3 = t3.pop(), t3.push(r3 ** o3);
            break;
          case "false":
            t3.push(false);
            break;
          case "floor":
            r3 = t3.pop(), t3.push(Math.floor(r3));
            break;
          case "ge":
            o3 = t3.pop(), r3 = t3.pop(), t3.push(r3 >= o3);
            break;
          case "gt":
            o3 = t3.pop(), r3 = t3.pop(), t3.push(r3 > o3);
            break;
          case "idiv":
            o3 = t3.pop(), r3 = t3.pop(), t3.push(r3 / o3 | 0);
            break;
          case "index":
            r3 = t3.pop(), t3.index(r3);
            break;
          case "le":
            o3 = t3.pop(), r3 = t3.pop(), t3.push(r3 <= o3);
            break;
          case "ln":
            r3 = t3.pop(), t3.push(Math.log(r3));
            break;
          case "log":
            r3 = t3.pop(), t3.push(Math.log10(r3));
            break;
          case "lt":
            o3 = t3.pop(), r3 = t3.pop(), t3.push(r3 < o3);
            break;
          case "mod":
            o3 = t3.pop(), r3 = t3.pop(), t3.push(r3 % o3);
            break;
          case "mul":
            o3 = t3.pop(), r3 = t3.pop(), t3.push(r3 * o3);
            break;
          case "ne":
            o3 = t3.pop(), r3 = t3.pop(), t3.push(r3 !== o3);
            break;
          case "neg":
            r3 = t3.pop(), t3.push(-r3);
            break;
          case "not":
            r3 = t3.pop(), "boolean" == typeof r3 ? t3.push(!r3) : t3.push(~r3);
            break;
          case "or":
            o3 = t3.pop(), r3 = t3.pop(), "boolean" == typeof r3 && "boolean" == typeof o3 ? t3.push(r3 || o3) : t3.push(r3 | o3);
            break;
          case "pop":
            t3.pop();
            break;
          case "roll":
            o3 = t3.pop(), r3 = t3.pop(), t3.roll(r3, o3);
            break;
          case "round":
            r3 = t3.pop(), t3.push(Math.round(r3));
            break;
          case "sin":
            r3 = t3.pop(), t3.push(Math.sin(r3 % 360 / 180 * Math.PI));
            break;
          case "sqrt":
            r3 = t3.pop(), t3.push(Math.sqrt(r3));
            break;
          case "sub":
            o3 = t3.pop(), r3 = t3.pop(), t3.push(r3 - o3);
            break;
          case "true":
            t3.push(true);
            break;
          case "truncate":
            r3 = t3.pop(), r3 = r3 < 0 ? Math.ceil(r3) : Math.floor(r3), t3.push(r3);
            break;
          case "xor":
            o3 = t3.pop(), r3 = t3.pop(), "boolean" == typeof r3 && "boolean" == typeof o3 ? t3.push(r3 !== o3) : t3.push(r3 ^ o3);
            break;
          default:
            throw new FormatError(`Unknown operator ${n3}`);
        }
        else t3.push(n3);
        return t3.stack;
      }
    };
    AstNode = class {
      constructor(e3) {
        this.type = e3;
      }
      visit(e3) {
        unreachable("abstract method");
      }
    };
    AstArgument = class extends AstNode {
      constructor(e3, t3, i3) {
        super("args"), this.index = e3, this.min = t3, this.max = i3;
      }
      visit(e3) {
        e3.visitArgument(this);
      }
    };
    AstLiteral = class extends AstNode {
      constructor(e3) {
        super("literal"), this.number = e3, this.min = e3, this.max = e3;
      }
      visit(e3) {
        e3.visitLiteral(this);
      }
    };
    AstBinaryOperation = class extends AstNode {
      constructor(e3, t3, i3, a3, s3) {
        super("binary"), this.op = e3, this.arg1 = t3, this.arg2 = i3, this.min = a3, this.max = s3;
      }
      visit(e3) {
        e3.visitBinaryOperation(this);
      }
    };
    AstMin = class extends AstNode {
      constructor(e3, t3) {
        super("max"), this.arg = e3, this.min = e3.min, this.max = t3;
      }
      visit(e3) {
        e3.visitMin(this);
      }
    };
    AstVariable = class extends AstNode {
      constructor(e3, t3, i3) {
        super("var"), this.index = e3, this.min = t3, this.max = i3;
      }
      visit(e3) {
        e3.visitVariable(this);
      }
    };
    AstVariableDefinition = class extends AstNode {
      constructor(e3, t3) {
        super("definition"), this.variable = e3, this.arg = t3;
      }
      visit(e3) {
        e3.visitVariableDefinition(this);
      }
    };
    ExpressionBuilderVisitor = class {
      constructor() {
        this.parts = [];
      }
      visitArgument(e3) {
        this.parts.push("Math.max(", e3.min, ", Math.min(", e3.max, ", src[srcOffset + ", e3.index, "]))");
      }
      visitVariable(e3) {
        this.parts.push("v", e3.index);
      }
      visitLiteral(e3) {
        this.parts.push(e3.number);
      }
      visitBinaryOperation(e3) {
        this.parts.push("("), e3.arg1.visit(this), this.parts.push(" ", e3.op, " "), e3.arg2.visit(this), this.parts.push(")");
      }
      visitVariableDefinition(e3) {
        this.parts.push("var "), e3.variable.visit(this), this.parts.push(" = "), e3.arg.visit(this), this.parts.push(";");
      }
      visitMin(e3) {
        this.parts.push("Math.min("), e3.arg.visit(this), this.parts.push(", ", e3.max, ")");
      }
      toString() {
        return this.parts.join("");
      }
    };
    PostScriptCompiler = class {
      compile(e3, t3, i3) {
        const a3 = [], s3 = [], n3 = t3.length >> 1, r3 = i3.length >> 1;
        let o3, g3, c3, h3, l3, C3, d3, u3, Q3 = 0;
        for (let e4 = 0; e4 < n3; e4++) a3.push(new AstArgument(e4, t3[2 * e4], t3[2 * e4 + 1]));
        for (let t4 = 0, i4 = e3.length; t4 < i4; t4++) if (u3 = e3[t4], "number" != typeof u3) switch (u3) {
          case "add":
            if (a3.length < 2) return null;
            h3 = a3.pop(), c3 = a3.pop(), a3.push(buildAddOperation(c3, h3));
            break;
          case "cvr":
            if (a3.length < 1) return null;
            break;
          case "mul":
            if (a3.length < 2) return null;
            h3 = a3.pop(), c3 = a3.pop(), a3.push(buildMulOperation(c3, h3));
            break;
          case "sub":
            if (a3.length < 2) return null;
            h3 = a3.pop(), c3 = a3.pop(), a3.push(buildSubOperation(c3, h3));
            break;
          case "exch":
            if (a3.length < 2) return null;
            l3 = a3.pop(), C3 = a3.pop(), a3.push(l3, C3);
            break;
          case "pop":
            if (a3.length < 1) return null;
            a3.pop();
            break;
          case "index":
            if (a3.length < 1) return null;
            if (c3 = a3.pop(), "literal" !== c3.type) return null;
            if (o3 = c3.number, o3 < 0 || !Number.isInteger(o3) || a3.length < o3) return null;
            if (l3 = a3[a3.length - o3 - 1], "literal" === l3.type || "var" === l3.type) {
              a3.push(l3);
              break;
            }
            d3 = new AstVariable(Q3++, l3.min, l3.max), a3[a3.length - o3 - 1] = d3, a3.push(d3), s3.push(new AstVariableDefinition(d3, l3));
            break;
          case "dup":
            if (a3.length < 1) return null;
            if ("number" == typeof e3[t4 + 1] && "gt" === e3[t4 + 2] && e3[t4 + 3] === t4 + 7 && "jz" === e3[t4 + 4] && "pop" === e3[t4 + 5] && e3[t4 + 6] === e3[t4 + 1]) {
              c3 = a3.pop(), a3.push(buildMinOperation(c3, e3[t4 + 1])), t4 += 6;
              break;
            }
            if (l3 = a3.at(-1), "literal" === l3.type || "var" === l3.type) {
              a3.push(l3);
              break;
            }
            d3 = new AstVariable(Q3++, l3.min, l3.max), a3[a3.length - 1] = d3, a3.push(d3), s3.push(new AstVariableDefinition(d3, l3));
            break;
          case "roll":
            if (a3.length < 2) return null;
            if (h3 = a3.pop(), c3 = a3.pop(), "literal" !== h3.type || "literal" !== c3.type) return null;
            if (g3 = h3.number, o3 = c3.number, o3 <= 0 || !Number.isInteger(o3) || !Number.isInteger(g3) || a3.length < o3) return null;
            if (g3 = (g3 % o3 + o3) % o3, 0 === g3) break;
            a3.push(...a3.splice(a3.length - o3, o3 - g3));
            break;
          default:
            return null;
        }
        else a3.push(new AstLiteral(u3));
        if (a3.length !== r3) return null;
        const f3 = [];
        for (const e4 of s3) {
          const t4 = new ExpressionBuilderVisitor();
          e4.visit(t4), f3.push(t4.toString());
        }
        for (let e4 = 0, t4 = a3.length; e4 < t4; e4++) {
          const t5 = a3[e4], s4 = new ExpressionBuilderVisitor();
          t5.visit(s4);
          const n4 = i3[2 * e4], r4 = i3[2 * e4 + 1], o4 = [s4.toString()];
          n4 > t5.min && (o4.unshift("Math.max(", n4, ", "), o4.push(")")), r4 < t5.max && (o4.unshift("Math.min(", r4, ", "), o4.push(")")), o4.unshift("dest[destOffset + ", e4, "] = "), o4.push(";"), f3.push(o4.join(""));
        }
        return f3.join("\n");
      }
    };
    Jo = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"];
    Yo = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
    Po = [];
    Oo = [];
    Ko = { style: "normal", weight: "normal" };
    qo = { style: "normal", weight: "bold" };
    _o2 = { style: "italic", weight: "normal" };
    Wo = { style: "italic", weight: "bold" };
    jo = /* @__PURE__ */ new Map([["Times-Roman", { local: ["Times New Roman", "Times-Roman", "Times", "Liberation Serif", "Nimbus Roman", "Nimbus Roman L", "Tinos", "Thorndale", "TeX Gyre Termes", "FreeSerif", "Linux Libertine O", "Libertinus Serif", "DejaVu Serif", "Bitstream Vera Serif", "Ubuntu"], style: Ko, ultimate: "serif" }], ["Times-Bold", { alias: "Times-Roman", style: qo, ultimate: "serif" }], ["Times-Italic", { alias: "Times-Roman", style: _o2, ultimate: "serif" }], ["Times-BoldItalic", { alias: "Times-Roman", style: Wo, ultimate: "serif" }], ["Helvetica", { local: ["Helvetica", "Helvetica Neue", "Arial", "Arial Nova", "Liberation Sans", "Arimo", "Nimbus Sans", "Nimbus Sans L", "A030", "TeX Gyre Heros", "FreeSans", "DejaVu Sans", "Albany", "Bitstream Vera Sans", "Arial Unicode MS", "Microsoft Sans Serif", "Apple Symbols", "Cantarell"], path: "LiberationSans-Regular.ttf", style: Ko, ultimate: "sans-serif" }], ["Helvetica-Bold", { alias: "Helvetica", path: "LiberationSans-Bold.ttf", style: qo, ultimate: "sans-serif" }], ["Helvetica-Oblique", { alias: "Helvetica", path: "LiberationSans-Italic.ttf", style: _o2, ultimate: "sans-serif" }], ["Helvetica-BoldOblique", { alias: "Helvetica", path: "LiberationSans-BoldItalic.ttf", style: Wo, ultimate: "sans-serif" }], ["Courier", { local: ["Courier", "Courier New", "Liberation Mono", "Nimbus Mono", "Nimbus Mono L", "Cousine", "Cumberland", "TeX Gyre Cursor", "FreeMono", "Linux Libertine Mono O", "Libertinus Mono"], style: Ko, ultimate: "monospace" }], ["Courier-Bold", { alias: "Courier", style: qo, ultimate: "monospace" }], ["Courier-Oblique", { alias: "Courier", style: _o2, ultimate: "monospace" }], ["Courier-BoldOblique", { alias: "Courier", style: Wo, ultimate: "monospace" }], ["ArialBlack", { local: ["Arial Black"], style: { style: "normal", weight: "900" }, fallback: "Helvetica-Bold" }], ["ArialBlack-Bold", { alias: "ArialBlack" }], ["ArialBlack-Italic", { alias: "ArialBlack", style: { style: "italic", weight: "900" }, fallback: "Helvetica-BoldOblique" }], ["ArialBlack-BoldItalic", { alias: "ArialBlack-Italic" }], ["ArialNarrow", { local: ["Arial Narrow", "Liberation Sans Narrow", "Helvetica Condensed", "Nimbus Sans Narrow", "TeX Gyre Heros Cn"], style: Ko, fallback: "Helvetica" }], ["ArialNarrow-Bold", { alias: "ArialNarrow", style: qo, fallback: "Helvetica-Bold" }], ["ArialNarrow-Italic", { alias: "ArialNarrow", style: _o2, fallback: "Helvetica-Oblique" }], ["ArialNarrow-BoldItalic", { alias: "ArialNarrow", style: Wo, fallback: "Helvetica-BoldOblique" }], ["Calibri", { local: ["Calibri", "Carlito"], style: Ko, fallback: "Helvetica" }], ["Calibri-Bold", { alias: "Calibri", style: qo, fallback: "Helvetica-Bold" }], ["Calibri-Italic", { alias: "Calibri", style: _o2, fallback: "Helvetica-Oblique" }], ["Calibri-BoldItalic", { alias: "Calibri", style: Wo, fallback: "Helvetica-BoldOblique" }], ["Wingdings", { local: ["Wingdings", "URW Dingbats"], style: Ko }], ["Wingdings-Regular", { alias: "Wingdings" }], ["Wingdings-Bold", { alias: "Wingdings" }]]);
    Xo = /* @__PURE__ */ new Map([["Arial-Black", "ArialBlack"]]);
    ImageResizer = class _ImageResizer {
      constructor(e3, t3) {
        this._imgData = e3, this._isMask = t3;
      }
      static needsToBeResized(e3, t3) {
        if (e3 <= this._goodSquareLength && t3 <= this._goodSquareLength) return false;
        const { MAX_DIM: i3 } = this;
        if (e3 > i3 || t3 > i3) return true;
        const a3 = e3 * t3;
        if (this._hasMaxArea) return a3 > this.MAX_AREA;
        if (a3 < this._goodSquareLength ** 2) return false;
        if (this._areGoodDims(e3, t3)) return this._goodSquareLength = Math.max(this._goodSquareLength, Math.floor(Math.sqrt(e3 * t3))), false;
        this._goodSquareLength = this._guessMax(this._goodSquareLength, i3, 128, 0);
        return a3 > (this.MAX_AREA = this._goodSquareLength ** 2);
      }
      static get MAX_DIM() {
        return shadow(this, "MAX_DIM", this._guessMax(2048, 65537, 0, 1));
      }
      static get MAX_AREA() {
        return this._hasMaxArea = true, shadow(this, "MAX_AREA", this._guessMax(_ImageResizer._goodSquareLength, this.MAX_DIM, 128, 0) ** 2);
      }
      static set MAX_AREA(e3) {
        e3 >= 0 && (this._hasMaxArea = true, shadow(this, "MAX_AREA", e3));
      }
      static setMaxArea(e3) {
        this._hasMaxArea || (this.MAX_AREA = e3 >> 2);
      }
      static _areGoodDims(e3, t3) {
        try {
          const i3 = new OffscreenCanvas(e3, t3), a3 = i3.getContext("2d");
          a3.fillRect(0, 0, 1, 1);
          const s3 = a3.getImageData(0, 0, 1, 1).data[3];
          return i3.width = i3.height = 1, 0 !== s3;
        } catch {
          return false;
        }
      }
      static _guessMax(e3, t3, i3, a3) {
        for (; e3 + i3 + 1 < t3; ) {
          const i4 = Math.floor((e3 + t3) / 2), s3 = a3 || i4;
          this._areGoodDims(i4, s3) ? e3 = i4 : t3 = i4;
        }
        return e3;
      }
      static async createImage(e3, t3 = false) {
        return new _ImageResizer(e3, t3)._createImage();
      }
      async _createImage() {
        const e3 = this._encodeBMP(), t3 = new Blob([e3.buffer], { type: "image/bmp" }), i3 = createImageBitmap(t3), { MAX_AREA: a3, MAX_DIM: s3 } = _ImageResizer, { _imgData: n3 } = this, { width: r3, height: o3 } = n3, g3 = Math.max(r3 / s3, o3 / s3, Math.sqrt(r3 * o3 / a3)), c3 = Math.max(g3, 2), h3 = Math.round(10 * (g3 + 1.25)) / 10 / c3, l3 = Math.floor(Math.log2(h3)), C3 = new Array(l3 + 2).fill(2);
        C3[0] = c3, C3.splice(-1, 1, h3 / (1 << l3));
        let d3 = r3, u3 = o3, Q3 = await i3;
        for (const e4 of C3) {
          const t4 = d3, i4 = u3;
          d3 = Math.floor(d3 / e4) - 1, u3 = Math.floor(u3 / e4) - 1;
          const a4 = new OffscreenCanvas(d3, u3);
          a4.getContext("2d").drawImage(Q3, 0, 0, t4, i4, 0, 0, d3, u3), Q3 = a4.transferToImageBitmap();
        }
        return n3.data = null, n3.bitmap = Q3, n3.width = d3, n3.height = u3, n3;
      }
      _encodeBMP() {
        const { width: e3, height: t3, kind: i3 } = this._imgData;
        let a3, s3 = this._imgData.data, n3 = new Uint8Array(0), r3 = n3, o3 = 0;
        switch (i3) {
          case WA: {
            a3 = 1, n3 = new Uint8Array(this._isMask ? [255, 255, 255, 255, 0, 0, 0, 0] : [0, 0, 0, 0, 255, 255, 255, 255]);
            const i5 = e3 + 7 >> 3, r4 = i5 + 3 & -4;
            if (i5 !== r4) {
              const e4 = new Uint8Array(r4 * t3);
              let a4 = 0;
              for (let n4 = 0, o4 = t3 * i5; n4 < o4; n4 += i5, a4 += r4) e4.set(s3.subarray(n4, n4 + i5), a4);
              s3 = e4;
            }
            break;
          }
          case jA:
            if (a3 = 24, 3 & e3) {
              const i5 = 3 * e3, a4 = i5 + 3 & -4, n4 = a4 - i5, r4 = new Uint8Array(a4 * t3);
              let o4 = 0;
              for (let e4 = 0, a5 = t3 * i5; e4 < a5; e4 += i5) {
                const t4 = s3.subarray(e4, e4 + i5);
                for (let e5 = 0; e5 < i5; e5 += 3) r4[o4++] = t4[e5 + 2], r4[o4++] = t4[e5 + 1], r4[o4++] = t4[e5];
                o4 += n4;
              }
              s3 = r4;
            } else for (let e4 = 0, t4 = s3.length; e4 < t4; e4 += 3) {
              const t5 = s3[e4];
              s3[e4] = s3[e4 + 2], s3[e4 + 2] = t5;
            }
            break;
          case XA:
            a3 = 32, o3 = 3, r3 = new Uint8Array(68);
            const i4 = new DataView(r3.buffer);
            FeatureTest.isLittleEndian ? (i4.setUint32(0, 255, true), i4.setUint32(4, 65280, true), i4.setUint32(8, 16711680, true), i4.setUint32(12, 4278190080, true)) : (i4.setUint32(0, 4278190080, true), i4.setUint32(4, 16711680, true), i4.setUint32(8, 65280, true), i4.setUint32(12, 255, true));
            break;
          default:
            throw new Error("invalid format");
        }
        let g3 = 0;
        const c3 = 40 + r3.length, h3 = 14 + c3 + n3.length + s3.length, l3 = new Uint8Array(h3), C3 = new DataView(l3.buffer);
        return C3.setUint16(g3, 19778, true), g3 += 2, C3.setUint32(g3, h3, true), g3 += 4, C3.setUint32(g3, 0, true), g3 += 4, C3.setUint32(g3, 14 + c3 + n3.length, true), g3 += 4, C3.setUint32(g3, c3, true), g3 += 4, C3.setInt32(g3, e3, true), g3 += 4, C3.setInt32(g3, -t3, true), g3 += 4, C3.setUint16(g3, 1, true), g3 += 2, C3.setUint16(g3, a3, true), g3 += 2, C3.setUint32(g3, o3, true), g3 += 4, C3.setUint32(g3, 0, true), g3 += 4, C3.setInt32(g3, 0, true), g3 += 4, C3.setInt32(g3, 0, true), g3 += 4, C3.setUint32(g3, n3.length / 4, true), g3 += 4, C3.setUint32(g3, 0, true), g3 += 4, l3.set(r3, g3), g3 += r3.length, l3.set(n3, g3), g3 += n3.length, l3.set(s3, g3), l3;
      }
    };
    ImageResizer._goodSquareLength = 2048;
    Vo = 3285377520;
    Zo = 4294901760;
    zo = 65535;
    MurmurHash3_64 = class {
      constructor(e3) {
        this.h1 = e3 ? 4294967295 & e3 : Vo, this.h2 = e3 ? 4294967295 & e3 : Vo;
      }
      update(e3) {
        let t3, i3;
        if ("string" == typeof e3) {
          t3 = new Uint8Array(2 * e3.length), i3 = 0;
          for (let a4 = 0, s4 = e3.length; a4 < s4; a4++) {
            const s5 = e3.charCodeAt(a4);
            s5 <= 255 ? t3[i3++] = s5 : (t3[i3++] = s5 >>> 8, t3[i3++] = 255 & s5);
          }
        } else {
          if (!ArrayBuffer.isView(e3)) throw new Error("Invalid data format, must be a string or TypedArray.");
          t3 = e3.slice(), i3 = t3.byteLength;
        }
        const a3 = i3 >> 2, s3 = i3 - 4 * a3, n3 = new Uint32Array(t3.buffer, 0, a3);
        let r3 = 0, o3 = 0, g3 = this.h1, c3 = this.h2;
        const h3 = 3432918353, l3 = 461845907, C3 = 11601, d3 = 13715;
        for (let e4 = 0; e4 < a3; e4++) 1 & e4 ? (r3 = n3[e4], r3 = r3 * h3 & Zo | r3 * C3 & zo, r3 = r3 << 15 | r3 >>> 17, r3 = r3 * l3 & Zo | r3 * d3 & zo, g3 ^= r3, g3 = g3 << 13 | g3 >>> 19, g3 = 5 * g3 + 3864292196) : (o3 = n3[e4], o3 = o3 * h3 & Zo | o3 * C3 & zo, o3 = o3 << 15 | o3 >>> 17, o3 = o3 * l3 & Zo | o3 * d3 & zo, c3 ^= o3, c3 = c3 << 13 | c3 >>> 19, c3 = 5 * c3 + 3864292196);
        switch (r3 = 0, s3) {
          case 3:
            r3 ^= t3[4 * a3 + 2] << 16;
          case 2:
            r3 ^= t3[4 * a3 + 1] << 8;
          case 1:
            r3 ^= t3[4 * a3], r3 = r3 * h3 & Zo | r3 * C3 & zo, r3 = r3 << 15 | r3 >>> 17, r3 = r3 * l3 & Zo | r3 * d3 & zo, 1 & a3 ? g3 ^= r3 : c3 ^= r3;
        }
        this.h1 = g3, this.h2 = c3;
      }
      hexdigest() {
        let e3 = this.h1, t3 = this.h2;
        return e3 ^= t3 >>> 1, e3 = 3981806797 * e3 & Zo | 36045 * e3 & zo, t3 = 4283543511 * t3 & Zo | (2950163797 * (t3 << 16 | e3 >>> 16) & Zo) >>> 16, e3 ^= t3 >>> 1, e3 = 444984403 * e3 & Zo | 60499 * e3 & zo, t3 = 3301882366 * t3 & Zo | (3120437893 * (t3 << 16 | e3 >>> 16) & Zo) >>> 16, e3 ^= t3 >>> 1, (e3 >>> 0).toString(16).padStart(8, "0") + (t3 >>> 0).toString(16).padStart(8, "0");
      }
    };
    $o = [];
    addState($o, [ia, sa, ms, aa], null, function(e3, t3) {
      const i3 = e3.fnArray, a3 = (t3 - (e3.iCurr - 3)) % 4;
      switch (a3) {
        case 0:
          return i3[t3] === ia;
        case 1:
          return i3[t3] === sa;
        case 2:
          return i3[t3] === ms;
        case 3:
          return i3[t3] === aa;
      }
      throw new Error(`iterateInlineImageGroup - invalid pos: ${a3}`);
    }, function(e3, t3) {
      const i3 = e3.fnArray, a3 = e3.argsArray, s3 = e3.iCurr, n3 = s3 - 3, r3 = s3 - 2, o3 = s3 - 1, g3 = Math.min(Math.floor((t3 - n3) / 4), 200);
      if (g3 < 10) return t3 - (t3 - n3) % 4;
      let c3 = 0;
      const h3 = [];
      let l3 = 0, C3 = 1, d3 = 1;
      for (let e4 = 0; e4 < g3; e4++) {
        const t4 = a3[r3 + (e4 << 2)], i4 = a3[o3 + (e4 << 2)][0];
        C3 + i4.width > 1e3 && (c3 = Math.max(c3, C3), d3 += l3 + 2, C3 = 0, l3 = 0), h3.push({ transform: t4, x: C3, y: d3, w: i4.width, h: i4.height }), C3 += i4.width + 2, l3 = Math.max(l3, i4.height);
      }
      const u3 = Math.max(c3, C3) + 1, Q3 = d3 + l3 + 1, f3 = new Uint8Array(u3 * Q3 * 4), p3 = u3 << 2;
      for (let e4 = 0; e4 < g3; e4++) {
        const t4 = a3[o3 + (e4 << 2)][0].data, i4 = h3[e4].w << 2;
        let s4 = 0, n4 = h3[e4].x + h3[e4].y * u3 << 2;
        f3.set(t4.subarray(0, i4), n4 - p3);
        for (let a4 = 0, r4 = h3[e4].h; a4 < r4; a4++) f3.set(t4.subarray(s4, s4 + i4), n4), s4 += i4, n4 += p3;
        for (f3.set(t4.subarray(s4 - i4, s4), n4); n4 >= 0; ) t4[n4 - 4] = t4[n4], t4[n4 - 3] = t4[n4 + 1], t4[n4 - 2] = t4[n4 + 2], t4[n4 - 1] = t4[n4 + 3], t4[n4 + i4] = t4[n4 + i4 - 4], t4[n4 + i4 + 1] = t4[n4 + i4 - 3], t4[n4 + i4 + 2] = t4[n4 + i4 - 2], t4[n4 + i4 + 3] = t4[n4 + i4 - 1], n4 -= p3;
      }
      const m3 = { width: u3, height: Q3 };
      if (e3.isOffscreenCanvasSupported) {
        const e4 = new OffscreenCanvas(u3, Q3);
        e4.getContext("2d").putImageData(new ImageData(new Uint8ClampedArray(f3.buffer), u3, Q3), 0, 0), m3.bitmap = e4.transferToImageBitmap(), m3.data = null;
      } else m3.kind = XA, m3.data = f3;
      return i3.splice(n3, 4 * g3, ys), a3.splice(n3, 4 * g3, [m3, h3]), n3 + 1;
    }), addState($o, [ia, sa, Es, aa], null, function(e3, t3) {
      const i3 = e3.fnArray, a3 = (t3 - (e3.iCurr - 3)) % 4;
      switch (a3) {
        case 0:
          return i3[t3] === ia;
        case 1:
          return i3[t3] === sa;
        case 2:
          return i3[t3] === Es;
        case 3:
          return i3[t3] === aa;
      }
      throw new Error(`iterateImageMaskGroup - invalid pos: ${a3}`);
    }, function(e3, t3) {
      const i3 = e3.fnArray, a3 = e3.argsArray, s3 = e3.iCurr, n3 = s3 - 3, r3 = s3 - 2, o3 = s3 - 1;
      let g3 = Math.floor((t3 - n3) / 4);
      if (g3 < 10) return t3 - (t3 - n3) % 4;
      let c3, h3, l3 = false;
      const C3 = a3[o3][0], d3 = a3[r3][0], u3 = a3[r3][1], Q3 = a3[r3][2], f3 = a3[r3][3];
      if (u3 === Q3) {
        l3 = true, c3 = r3 + 4;
        let e4 = o3 + 4;
        for (let t4 = 1; t4 < g3; t4++, c3 += 4, e4 += 4) if (h3 = a3[c3], a3[e4][0] !== C3 || h3[0] !== d3 || h3[1] !== u3 || h3[2] !== Q3 || h3[3] !== f3) {
          t4 < 10 ? l3 = false : g3 = t4;
          break;
        }
      }
      if (l3) {
        g3 = Math.min(g3, 1e3);
        const e4 = new Float32Array(2 * g3);
        c3 = r3;
        for (let t4 = 0; t4 < g3; t4++, c3 += 4) h3 = a3[c3], e4[t4 << 1] = h3[4], e4[1 + (t4 << 1)] = h3[5];
        i3.splice(n3, 4 * g3, bs), a3.splice(n3, 4 * g3, [C3, d3, u3, Q3, f3, e4]);
      } else {
        g3 = Math.min(g3, 100);
        const e4 = [];
        for (let t4 = 0; t4 < g3; t4++) {
          h3 = a3[r3 + (t4 << 2)];
          const i4 = a3[o3 + (t4 << 2)][0];
          e4.push({ data: i4.data, width: i4.width, height: i4.height, interpolate: i4.interpolate, count: i4.count, transform: h3 });
        }
        i3.splice(n3, 4 * g3, fs), a3.splice(n3, 4 * g3, [e4]);
      }
      return n3 + 1;
    }), addState($o, [ia, sa, ps, aa], function(e3) {
      const t3 = e3.argsArray, i3 = e3.iCurr - 2;
      return 0 === t3[i3][1] && 0 === t3[i3][2];
    }, function(e3, t3) {
      const i3 = e3.fnArray, a3 = e3.argsArray, s3 = (t3 - (e3.iCurr - 3)) % 4;
      switch (s3) {
        case 0:
          return i3[t3] === ia;
        case 1:
          if (i3[t3] !== sa) return false;
          const s4 = e3.iCurr - 2, n3 = a3[s4][0], r3 = a3[s4][3];
          return a3[t3][0] === n3 && 0 === a3[t3][1] && 0 === a3[t3][2] && a3[t3][3] === r3;
        case 2:
          if (i3[t3] !== ps) return false;
          const o3 = a3[e3.iCurr - 1][0];
          return a3[t3][0] === o3;
        case 3:
          return i3[t3] === aa;
      }
      throw new Error(`iterateImageGroup - invalid pos: ${s3}`);
    }, function(e3, t3) {
      const i3 = e3.fnArray, a3 = e3.argsArray, s3 = e3.iCurr, n3 = s3 - 3, r3 = s3 - 2, o3 = a3[s3 - 1][0], g3 = a3[r3][0], c3 = a3[r3][3], h3 = Math.min(Math.floor((t3 - n3) / 4), 1e3);
      if (h3 < 3) return t3 - (t3 - n3) % 4;
      const l3 = new Float32Array(2 * h3);
      let C3 = r3;
      for (let e4 = 0; e4 < h3; e4++, C3 += 4) {
        const t4 = a3[C3];
        l3[e4 << 1] = t4[4], l3[1 + (e4 << 1)] = t4[5];
      }
      const d3 = [o3, g3, c3, l3];
      return i3.splice(n3, 4 * h3, ws), a3.splice(n3, 4 * h3, d3), n3 + 1;
    }), addState($o, [wa, Ra, va, Ua, ba], null, function(e3, t3) {
      const i3 = e3.fnArray, a3 = e3.argsArray, s3 = (t3 - (e3.iCurr - 4)) % 5;
      switch (s3) {
        case 0:
          return i3[t3] === wa;
        case 1:
          return i3[t3] === Ra;
        case 2:
          return i3[t3] === va;
        case 3:
          if (i3[t3] !== Ua) return false;
          const s4 = e3.iCurr - 3, n3 = a3[s4][0], r3 = a3[s4][1];
          return a3[t3][0] === n3 && a3[t3][1] === r3;
        case 4:
          return i3[t3] === ba;
      }
      throw new Error(`iterateShowTextGroup - invalid pos: ${s3}`);
    }, function(e3, t3) {
      const i3 = e3.fnArray, a3 = e3.argsArray, s3 = e3.iCurr, n3 = s3 - 4, r3 = s3 - 3, o3 = s3 - 2, g3 = s3 - 1, c3 = s3, h3 = a3[r3][0], l3 = a3[r3][1];
      let C3 = Math.min(Math.floor((t3 - n3) / 5), 1e3);
      if (C3 < 3) return t3 - (t3 - n3) % 5;
      let d3 = n3;
      n3 >= 4 && i3[n3 - 4] === i3[r3] && i3[n3 - 3] === i3[o3] && i3[n3 - 2] === i3[g3] && i3[n3 - 1] === i3[c3] && a3[n3 - 4][0] === h3 && a3[n3 - 4][1] === l3 && (C3++, d3 -= 5);
      let u3 = d3 + 4;
      for (let e4 = 1; e4 < C3; e4++) i3.splice(u3, 3), a3.splice(u3, 3), u3 += 2;
      return u3 + 1;
    });
    NullOptimizer = class {
      constructor(e3) {
        this.queue = e3;
      }
      _optimize() {
      }
      push(e3, t3) {
        this.queue.fnArray.push(e3), this.queue.argsArray.push(t3), this._optimize();
      }
      flush() {
      }
      reset() {
      }
    };
    QueueOptimizer = class extends NullOptimizer {
      constructor(e3) {
        super(e3), this.state = null, this.context = { iCurr: 0, fnArray: e3.fnArray, argsArray: e3.argsArray, isOffscreenCanvasSupported: false }, this.match = null, this.lastProcessed = 0;
      }
      set isOffscreenCanvasSupported(e3) {
        this.context.isOffscreenCanvasSupported = e3;
      }
      _optimize() {
        const e3 = this.queue.fnArray;
        let t3 = this.lastProcessed, i3 = e3.length, a3 = this.state, s3 = this.match;
        if (!a3 && !s3 && t3 + 1 === i3 && !$o[e3[t3]]) return void (this.lastProcessed = i3);
        const n3 = this.context;
        for (; t3 < i3; ) {
          if (s3) {
            if ((0, s3.iterateFn)(n3, t3)) {
              t3++;
              continue;
            }
            if (t3 = (0, s3.processFn)(n3, t3 + 1), i3 = e3.length, s3 = null, a3 = null, t3 >= i3) break;
          }
          a3 = (a3 || $o)[e3[t3]], a3 && !Array.isArray(a3) ? (n3.iCurr = t3, t3++, !a3.checkFn || (0, a3.checkFn)(n3) ? (s3 = a3, a3 = null) : a3 = null) : t3++;
        }
        this.state = a3, this.match = s3, this.lastProcessed = t3;
      }
      flush() {
        for (; this.match; ) {
          const e3 = this.queue.fnArray.length;
          this.lastProcessed = (0, this.match.processFn)(this.context, e3), this.match = null, this.state = null, this._optimize();
        }
      }
      reset() {
        this.state = null, this.match = null, this.lastProcessed = 0;
      }
    };
    _OperatorList = class _OperatorList {
      constructor(e3 = 0, t3) {
        this._streamSink = t3, this.fnArray = [], this.argsArray = [], this.optimizer = !t3 || e3 & HA ? new NullOptimizer(this) : new QueueOptimizer(this), this.dependencies = /* @__PURE__ */ new Set(), this._totalLength = 0, this.weight = 0, this._resolved = t3 ? null : Promise.resolve();
      }
      set isOffscreenCanvasSupported(e3) {
        this.optimizer.isOffscreenCanvasSupported = e3;
      }
      get length() {
        return this.argsArray.length;
      }
      get ready() {
        return this._resolved || this._streamSink.ready;
      }
      get totalLength() {
        return this._totalLength + this.length;
      }
      addOp(e3, t3) {
        this.optimizer.push(e3, t3), this.weight++, this._streamSink && (this.weight >= _OperatorList.CHUNK_SIZE || this.weight >= _OperatorList.CHUNK_SIZE_ABOUT && (e3 === aa || e3 === ba)) && this.flush();
      }
      addImageOps(e3, t3, i3) {
        void 0 !== i3 && this.addOp(gs, ["OC", i3]), this.addOp(e3, t3), void 0 !== i3 && this.addOp(cs, []);
      }
      addDependency(e3) {
        this.dependencies.has(e3) || (this.dependencies.add(e3), this.addOp(ji, [e3]));
      }
      addDependencies(e3) {
        for (const t3 of e3) this.addDependency(t3);
      }
      addOpList(e3) {
        if (e3 instanceof _OperatorList) {
          for (const t3 of e3.dependencies) this.dependencies.add(t3);
          for (let t3 = 0, i3 = e3.length; t3 < i3; t3++) this.addOp(e3.fnArray[t3], e3.argsArray[t3]);
        } else warn('addOpList - ignoring invalid "opList" parameter.');
      }
      getIR() {
        return { fnArray: this.fnArray, argsArray: this.argsArray, length: this.length };
      }
      get _transfers() {
        const e3 = [], { fnArray: t3, argsArray: i3, length: a3 } = this;
        for (let s3 = 0; s3 < a3; s3++) switch (t3[s3]) {
          case ms:
          case ys:
          case Es:
            const t4 = i3[s3][0];
            !t4.cached && t4.data?.buffer instanceof ArrayBuffer && e3.push(t4.data.buffer);
        }
        return e3;
      }
      flush(e3 = false, t3 = null) {
        this.optimizer.flush();
        const i3 = this.length;
        this._totalLength += i3, this._streamSink.enqueue({ fnArray: this.fnArray, argsArray: this.argsArray, lastChunk: e3, separateAnnots: t3, length: i3 }, 1, this._transfers), this.dependencies.clear(), this.fnArray.length = 0, this.argsArray.length = 0, this.weight = 0, this.optimizer.reset();
      }
    };
    __publicField(_OperatorList, "CHUNK_SIZE", 1e3);
    __publicField(_OperatorList, "CHUNK_SIZE_ABOUT", _OperatorList.CHUNK_SIZE - 5);
    OperatorList = _OperatorList;
    PDFImage = class _PDFImage {
      constructor({ xref: e3, res: t3, image: i3, isInline: a3 = false, smask: s3 = null, mask: n3 = null, isMask: r3 = false, pdfFunctionFactory: o3, localColorSpaceCache: g3 }) {
        this.image = i3;
        const c3 = i3.dict, h3 = c3.get("F", "Filter");
        let l3;
        if (h3 instanceof Name) l3 = h3.name;
        else if (Array.isArray(h3)) {
          const t4 = e3.fetchIfRef(h3[0]);
          t4 instanceof Name && (l3 = t4.name);
        }
        switch (l3) {
          case "JPXDecode":
            ({ width: i3.width, height: i3.height, componentsCount: i3.numComps, bitsPerComponent: i3.bitsPerComponent } = JpxImage.parseImageProperties(i3.stream)), i3.stream.reset(), this.jpxDecoderOptions = { numComponents: 0, isIndexedColormap: false, smaskInData: c3.has("SMaskInData") };
            break;
          case "JBIG2Decode":
            i3.bitsPerComponent = 1, i3.numComps = 1;
        }
        let C3 = c3.get("W", "Width"), d3 = c3.get("H", "Height");
        if (Number.isInteger(i3.width) && i3.width > 0 && Number.isInteger(i3.height) && i3.height > 0 && (i3.width !== C3 || i3.height !== d3) && (warn("PDFImage - using the Width/Height of the image data, rather than the image dictionary."), C3 = i3.width, d3 = i3.height), C3 < 1 || d3 < 1) throw new FormatError(`Invalid image width: ${C3} or height: ${d3}`);
        this.width = C3, this.height = d3, this.interpolate = c3.get("I", "Interpolate"), this.imageMask = c3.get("IM", "ImageMask") || false, this.matte = c3.get("Matte") || false;
        let u3 = i3.bitsPerComponent;
        if (!u3 && (u3 = c3.get("BPC", "BitsPerComponent"), !u3)) {
          if (!this.imageMask) throw new FormatError(`Bits per component missing in image: ${this.imageMask}`);
          u3 = 1;
        }
        if (this.bpc = u3, !this.imageMask) {
          let s4 = c3.getRaw("CS") || c3.getRaw("ColorSpace");
          const n4 = !!s4;
          if (n4) this.jpxDecoderOptions?.smaskInData && (s4 = Name.get("DeviceRGBA"));
          else if (this.jpxDecoderOptions) s4 = Name.get("DeviceRGBA");
          else switch (i3.numComps) {
            case 1:
              s4 = Name.get("DeviceGray");
              break;
            case 3:
              s4 = Name.get("DeviceRGB");
              break;
            case 4:
              s4 = Name.get("DeviceCMYK");
              break;
            default:
              throw new Error(`Images with ${i3.numComps} color components not supported.`);
          }
          this.colorSpace = ColorSpace.parse({ cs: s4, xref: e3, resources: a3 ? t3 : null, pdfFunctionFactory: o3, localColorSpaceCache: g3 }), this.numComps = this.colorSpace.numComps, this.jpxDecoderOptions && (this.jpxDecoderOptions.numComponents = n4 ? this.numComp : 0, this.jpxDecoderOptions.isIndexedColormap = "Indexed" === this.colorSpace.name);
        }
        if (this.decode = c3.getArray("D", "Decode"), this.needsDecode = false, this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, u3) || r3 && !ColorSpace.isDefaultDecode(this.decode, 1))) {
          this.needsDecode = true;
          const e4 = (1 << u3) - 1;
          this.decodeCoefficients = [], this.decodeAddends = [];
          const t4 = "Indexed" === this.colorSpace?.name;
          for (let i4 = 0, a4 = 0; i4 < this.decode.length; i4 += 2, ++a4) {
            const s4 = this.decode[i4], n4 = this.decode[i4 + 1];
            this.decodeCoefficients[a4] = t4 ? (n4 - s4) / e4 : n4 - s4, this.decodeAddends[a4] = t4 ? s4 : e4 * s4;
          }
        }
        if (s3) this.smask = new _PDFImage({ xref: e3, res: t3, image: s3, isInline: a3, pdfFunctionFactory: o3, localColorSpaceCache: g3 });
        else if (n3) if (n3 instanceof BaseStream) {
          n3.dict.get("IM", "ImageMask") ? this.mask = new _PDFImage({ xref: e3, res: t3, image: n3, isInline: a3, isMask: true, pdfFunctionFactory: o3, localColorSpaceCache: g3 }) : warn("Ignoring /Mask in image without /ImageMask.");
        } else this.mask = n3;
      }
      static async buildImage({ xref: e3, res: t3, image: i3, isInline: a3 = false, pdfFunctionFactory: s3, localColorSpaceCache: n3 }) {
        const r3 = i3;
        let o3 = null, g3 = null;
        const c3 = i3.dict.get("SMask"), h3 = i3.dict.get("Mask");
        return c3 ? c3 instanceof BaseStream ? o3 = c3 : warn("Unsupported /SMask format.") : h3 && (h3 instanceof BaseStream || Array.isArray(h3) ? g3 = h3 : warn("Unsupported /Mask format.")), new _PDFImage({ xref: e3, res: t3, image: r3, isInline: a3, smask: o3, mask: g3, pdfFunctionFactory: s3, localColorSpaceCache: n3 });
      }
      static createRawMask({ imgArray: e3, width: t3, height: i3, imageIsFromDecodeStream: a3, inverseDecode: s3, interpolate: n3 }) {
        const r3 = (t3 + 7 >> 3) * i3, o3 = e3.byteLength;
        let g3, c3;
        if (!a3 || s3 && !(r3 === o3) ? s3 ? (g3 = new Uint8Array(r3), g3.set(e3), g3.fill(255, o3)) : g3 = new Uint8Array(e3) : g3 = e3, s3) for (c3 = 0; c3 < o3; c3++) g3[c3] ^= 255;
        return { data: g3, width: t3, height: i3, interpolate: n3 };
      }
      static async createMask({ imgArray: e3, width: t3, height: i3, imageIsFromDecodeStream: a3, inverseDecode: s3, interpolate: n3, isOffscreenCanvasSupported: r3 = false }) {
        const o3 = 1 === t3 && 1 === i3 && s3 === (0 === e3.length || !!(128 & e3[0]));
        if (o3) return { isSingleOpaquePixel: o3 };
        if (r3) {
          if (ImageResizer.needsToBeResized(t3, i3)) {
            const a5 = new Uint8ClampedArray(t3 * i3 * 4);
            return convertBlackAndWhiteToRGBA({ src: e3, dest: a5, width: t3, height: i3, nonBlackColor: 0, inverseDecode: s3 }), ImageResizer.createImage({ kind: XA, data: a5, width: t3, height: i3, interpolate: n3 });
          }
          const a4 = new OffscreenCanvas(t3, i3), r4 = a4.getContext("2d"), o4 = r4.createImageData(t3, i3);
          convertBlackAndWhiteToRGBA({ src: e3, dest: o4.data, width: t3, height: i3, nonBlackColor: 0, inverseDecode: s3 }), r4.putImageData(o4, 0, 0);
          return { data: null, width: t3, height: i3, interpolate: n3, bitmap: a4.transferToImageBitmap() };
        }
        return this.createRawMask({ imgArray: e3, width: t3, height: i3, inverseDecode: s3, imageIsFromDecodeStream: a3, interpolate: n3 });
      }
      get drawWidth() {
        return Math.max(this.width, this.smask?.width || 0, this.mask?.width || 0);
      }
      get drawHeight() {
        return Math.max(this.height, this.smask?.height || 0, this.mask?.height || 0);
      }
      decodeBuffer(e3) {
        const t3 = this.bpc, i3 = this.numComps, a3 = this.decodeAddends, s3 = this.decodeCoefficients, n3 = (1 << t3) - 1;
        let r3, o3;
        if (1 === t3) {
          for (r3 = 0, o3 = e3.length; r3 < o3; r3++) e3[r3] = +!e3[r3];
          return;
        }
        let g3 = 0;
        for (r3 = 0, o3 = this.width * this.height; r3 < o3; r3++) for (let t4 = 0; t4 < i3; t4++) e3[g3] = decodeAndClamp(e3[g3], a3[t4], s3[t4], n3), g3++;
      }
      getComponents(e3) {
        const t3 = this.bpc;
        if (8 === t3) return e3;
        const i3 = this.width, a3 = this.height, s3 = this.numComps, n3 = i3 * a3 * s3;
        let r3, o3 = 0;
        r3 = t3 <= 8 ? new Uint8Array(n3) : t3 <= 16 ? new Uint16Array(n3) : new Uint32Array(n3);
        const g3 = i3 * s3, c3 = (1 << t3) - 1;
        let h3, l3, C3 = 0;
        if (1 === t3) {
          let t4, i4, s4;
          for (let n4 = 0; n4 < a3; n4++) {
            for (i4 = C3 + (-8 & g3), s4 = C3 + g3; C3 < i4; ) l3 = e3[o3++], r3[C3] = l3 >> 7 & 1, r3[C3 + 1] = l3 >> 6 & 1, r3[C3 + 2] = l3 >> 5 & 1, r3[C3 + 3] = l3 >> 4 & 1, r3[C3 + 4] = l3 >> 3 & 1, r3[C3 + 5] = l3 >> 2 & 1, r3[C3 + 6] = l3 >> 1 & 1, r3[C3 + 7] = 1 & l3, C3 += 8;
            if (C3 < s4) for (l3 = e3[o3++], t4 = 128; C3 < s4; ) r3[C3++] = +!!(l3 & t4), t4 >>= 1;
          }
        } else {
          let i4 = 0;
          for (l3 = 0, C3 = 0, h3 = n3; C3 < h3; ++C3) {
            for (C3 % g3 == 0 && (l3 = 0, i4 = 0); i4 < t3; ) l3 = l3 << 8 | e3[o3++], i4 += 8;
            const a4 = i4 - t3;
            let s4 = l3 >> a4;
            s4 < 0 ? s4 = 0 : s4 > c3 && (s4 = c3), r3[C3] = s4, l3 &= (1 << a4) - 1, i4 = a4;
          }
        }
        return r3;
      }
      async fillOpacity(e3, t3, i3, a3, s3) {
        const n3 = this.smask, r3 = this.mask;
        let o3, g3, c3, h3, l3, C3;
        if (n3) g3 = n3.width, c3 = n3.height, o3 = new Uint8ClampedArray(g3 * c3), await n3.fillGrayBuffer(o3), g3 === t3 && c3 === i3 || (o3 = resizeImageMask(o3, n3.bpc, g3, c3, t3, i3));
        else if (r3) if (r3 instanceof _PDFImage) {
          for (g3 = r3.width, c3 = r3.height, o3 = new Uint8ClampedArray(g3 * c3), r3.numComps = 1, await r3.fillGrayBuffer(o3), h3 = 0, l3 = g3 * c3; h3 < l3; ++h3) o3[h3] = 255 - o3[h3];
          g3 === t3 && c3 === i3 || (o3 = resizeImageMask(o3, r3.bpc, g3, c3, t3, i3));
        } else {
          if (!Array.isArray(r3)) throw new FormatError("Unknown mask format.");
          {
            o3 = new Uint8ClampedArray(t3 * i3);
            const e4 = this.numComps;
            for (h3 = 0, l3 = t3 * i3; h3 < l3; ++h3) {
              let t4 = 0;
              const i4 = h3 * e4;
              for (C3 = 0; C3 < e4; ++C3) {
                const e5 = s3[i4 + C3], a4 = 2 * C3;
                if (e5 < r3[a4] || e5 > r3[a4 + 1]) {
                  t4 = 255;
                  break;
                }
              }
              o3[h3] = t4;
            }
          }
        }
        if (o3) for (h3 = 0, C3 = 3, l3 = t3 * a3; h3 < l3; ++h3, C3 += 4) e3[C3] = o3[h3];
        else for (h3 = 0, C3 = 3, l3 = t3 * a3; h3 < l3; ++h3, C3 += 4) e3[C3] = 255;
      }
      undoPreblend(e3, t3, i3) {
        const a3 = this.smask?.matte;
        if (!a3) return;
        const s3 = this.colorSpace.getRgb(a3, 0), n3 = s3[0], r3 = s3[1], o3 = s3[2], g3 = t3 * i3 * 4;
        for (let t4 = 0; t4 < g3; t4 += 4) {
          const i4 = e3[t4 + 3];
          if (0 === i4) {
            e3[t4] = 255, e3[t4 + 1] = 255, e3[t4 + 2] = 255;
            continue;
          }
          const a4 = 255 / i4;
          e3[t4] = (e3[t4] - n3) * a4 + n3, e3[t4 + 1] = (e3[t4 + 1] - r3) * a4 + r3, e3[t4 + 2] = (e3[t4 + 2] - o3) * a4 + o3;
        }
      }
      async createImageData(e3 = false, t3 = false) {
        const i3 = this.drawWidth, a3 = this.drawHeight, s3 = { width: i3, height: a3, interpolate: this.interpolate, kind: 0, data: null }, n3 = this.numComps, r3 = this.width, o3 = this.height, g3 = this.bpc, c3 = r3 * n3 * g3 + 7 >> 3, h3 = t3 && ImageResizer.needsToBeResized(i3, a3);
        if ("DeviceRGBA" === this.colorSpace.name) {
          s3.kind = XA;
          const e4 = s3.data = await this.getImageBytes(o3 * r3 * 4, {});
          return t3 ? h3 ? ImageResizer.createImage(s3, false) : this.createBitmap(XA, i3, a3, e4) : s3;
        }
        if (!e3) {
          let e4;
          if ("DeviceGray" === this.colorSpace.name && 1 === g3 ? e4 = WA : "DeviceRGB" !== this.colorSpace.name || 8 !== g3 || this.needsDecode || (e4 = jA), e4 && !this.smask && !this.mask && i3 === r3 && a3 === o3) {
            const n4 = await this.getImageBytes(o3 * c3, {});
            if (t3) return h3 ? ImageResizer.createImage({ data: n4, kind: e4, width: i3, height: a3, interpolate: this.interpolate }, this.needsDecode) : this.createBitmap(e4, r3, o3, n4);
            if (s3.kind = e4, s3.data = n4, this.needsDecode) {
              assert(e4 === WA, "PDFImage.createImageData: The image must be grayscale.");
              const t4 = s3.data;
              for (let e5 = 0, i4 = t4.length; e5 < i4; e5++) t4[e5] ^= 255;
            }
            return s3;
          }
          if (this.image instanceof JpegStream && !this.smask && !this.mask && !this.needsDecode) {
            let e5 = o3 * c3;
            if (t3 && !h3) {
              let t4 = false;
              switch (this.colorSpace.name) {
                case "DeviceGray":
                  e5 *= 4, t4 = true;
                  break;
                case "DeviceRGB":
                  e5 = e5 / 3 * 4, t4 = true;
                  break;
                case "DeviceCMYK":
                  t4 = true;
              }
              if (t4) {
                const t5 = await this.getImageBytes(e5, { drawWidth: i3, drawHeight: a3, forceRGBA: true });
                return this.createBitmap(XA, i3, a3, t5);
              }
            } else switch (this.colorSpace.name) {
              case "DeviceGray":
                e5 *= 3;
              case "DeviceRGB":
              case "DeviceCMYK":
                return s3.kind = jA, s3.data = await this.getImageBytes(e5, { drawWidth: i3, drawHeight: a3, forceRGB: true }), h3 ? ImageResizer.createImage(s3) : s3;
            }
          }
        }
        const l3 = await this.getImageBytes(o3 * c3, { internal: true }), C3 = 0 | l3.length / c3 * a3 / o3, d3 = this.getComponents(l3);
        let u3, Q3, f3, p3, m3, y3;
        if (t3 && !h3 && (f3 = new OffscreenCanvas(i3, a3), p3 = f3.getContext("2d"), m3 = p3.createImageData(i3, a3), y3 = m3.data), s3.kind = XA, e3 || this.smask || this.mask) t3 && !h3 || (y3 = new Uint8ClampedArray(i3 * a3 * 4)), u3 = 1, Q3 = true, await this.fillOpacity(y3, i3, a3, C3, d3);
        else {
          if (!t3 || h3) s3.kind = jA, y3 = new Uint8ClampedArray(i3 * a3 * 3), u3 = 0;
          else {
            new Uint32Array(y3.buffer).fill(FeatureTest.isLittleEndian ? 4278190080 : 255), u3 = 1;
          }
          Q3 = false;
        }
        if (this.needsDecode && this.decodeBuffer(d3), this.colorSpace.fillRgb(y3, r3, o3, i3, a3, C3, g3, d3, u3), Q3 && this.undoPreblend(y3, i3, C3), t3 && !h3) {
          p3.putImageData(m3, 0, 0);
          return { data: null, width: i3, height: a3, bitmap: f3.transferToImageBitmap(), interpolate: this.interpolate };
        }
        return s3.data = y3, h3 ? ImageResizer.createImage(s3) : s3;
      }
      async fillGrayBuffer(e3) {
        const t3 = this.numComps;
        if (1 !== t3) throw new FormatError(`Reading gray scale from a color image: ${t3}`);
        const i3 = this.width, a3 = this.height, s3 = this.bpc, n3 = i3 * t3 * s3 + 7 >> 3, r3 = await this.getImageBytes(a3 * n3, { internal: true }), o3 = this.getComponents(r3);
        let g3, c3;
        if (1 === s3) {
          if (c3 = i3 * a3, this.needsDecode) for (g3 = 0; g3 < c3; ++g3) e3[g3] = o3[g3] - 1 & 255;
          else for (g3 = 0; g3 < c3; ++g3) e3[g3] = 255 & -o3[g3];
          return;
        }
        this.needsDecode && this.decodeBuffer(o3), c3 = i3 * a3;
        const h3 = 255 / ((1 << s3) - 1);
        for (g3 = 0; g3 < c3; ++g3) e3[g3] = h3 * o3[g3];
      }
      createBitmap(e3, t3, i3, a3) {
        const s3 = new OffscreenCanvas(t3, i3), n3 = s3.getContext("2d");
        let r3;
        e3 === XA ? r3 = new ImageData(a3, t3, i3) : (r3 = n3.createImageData(t3, i3), convertToRGBA({ kind: e3, src: a3, dest: new Uint32Array(r3.data.buffer), width: t3, height: i3, inverseDecode: this.needsDecode })), n3.putImageData(r3, 0, 0);
        return { data: null, width: t3, height: i3, bitmap: s3.transferToImageBitmap(), interpolate: this.interpolate };
      }
      async getImageBytes(e3, { drawWidth: t3, drawHeight: i3, forceRGBA: a3 = false, forceRGB: s3 = false, internal: n3 = false }) {
        this.image.reset(), this.image.drawWidth = t3 || this.width, this.image.drawHeight = i3 || this.height, this.image.forceRGBA = !!a3, this.image.forceRGB = !!s3;
        const r3 = await this.image.getImageData(e3, this.jpxDecoderOptions);
        return n3 || this.image instanceof DecodeStream ? r3 : (assert(r3 instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported "imageBytes" type.'), new Uint8Array(r3));
      }
    };
    eg = Object.freeze({ maxImageSize: -1, disableFontFace: false, ignoreErrors: false, isEvalSupported: true, isOffscreenCanvasSupported: false, canvasMaxAreaInBytes: -1, fontExtraProperties: false, useSystemFonts: true, cMapUrl: null, standardFontDataUrl: null });
    tg = 1;
    Ag = 2;
    ig = Promise.resolve();
    _TimeSlotManager = class _TimeSlotManager {
      constructor() {
        this.reset();
      }
      check() {
        return !(++this.checked < _TimeSlotManager.CHECK_TIME_EVERY) && (this.checked = 0, this.endTime <= Date.now());
      }
      reset() {
        this.endTime = Date.now() + _TimeSlotManager.TIME_SLOT_DURATION_MS, this.checked = 0;
      }
    };
    __publicField(_TimeSlotManager, "TIME_SLOT_DURATION_MS", 20);
    __publicField(_TimeSlotManager, "CHECK_TIME_EVERY", 100);
    TimeSlotManager = _TimeSlotManager;
    PartialEvaluator = class _PartialEvaluator {
      constructor({ xref: e3, handler: t3, pageIndex: i3, idFactory: a3, fontCache: s3, builtInCMapCache: n3, standardFontDataCache: r3, globalImageCache: o3, systemFontCache: g3, options: c3 = null }) {
        this.xref = e3, this.handler = t3, this.pageIndex = i3, this.idFactory = a3, this.fontCache = s3, this.builtInCMapCache = n3, this.standardFontDataCache = r3, this.globalImageCache = o3, this.systemFontCache = g3, this.options = c3 || eg, this.type3FontRefs = null, this._regionalImageCache = new RegionalImageCache(), this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this), ImageResizer.setMaxArea(this.options.canvasMaxAreaInBytes);
      }
      get _pdfFunctionFactory() {
        return shadow(this, "_pdfFunctionFactory", new PDFFunctionFactory({ xref: this.xref, isEvalSupported: this.options.isEvalSupported }));
      }
      get parsingType3Font() {
        return !!this.type3FontRefs;
      }
      clone(e3 = null) {
        const t3 = Object.create(this);
        return t3.options = Object.assign(/* @__PURE__ */ Object.create(null), this.options, e3), t3;
      }
      hasBlendModes(e3, t3) {
        if (!(e3 instanceof Dict)) return false;
        if (e3.objId && t3.has(e3.objId)) return false;
        const i3 = new RefSet(t3);
        e3.objId && i3.put(e3.objId);
        const a3 = [e3], s3 = this.xref;
        for (; a3.length; ) {
          const e4 = a3.shift(), t4 = e4.get("ExtGState");
          if (t4 instanceof Dict) for (let e5 of t4.getRawValues()) {
            if (e5 instanceof Ref) {
              if (i3.has(e5)) continue;
              try {
                e5 = s3.fetch(e5);
              } catch (t6) {
                i3.put(e5), info(`hasBlendModes - ignoring ExtGState: "${t6}".`);
                continue;
              }
            }
            if (!(e5 instanceof Dict)) continue;
            e5.objId && i3.put(e5.objId);
            const t5 = e5.get("BM");
            if (t5 instanceof Name) {
              if ("Normal" !== t5.name) return true;
            } else if (void 0 !== t5 && Array.isArray(t5)) {
              for (const e6 of t5) if (e6 instanceof Name && "Normal" !== e6.name) return true;
            }
          }
          const n3 = e4.get("XObject");
          if (n3 instanceof Dict) for (let e5 of n3.getRawValues()) {
            if (e5 instanceof Ref) {
              if (i3.has(e5)) continue;
              try {
                e5 = s3.fetch(e5);
              } catch (t6) {
                i3.put(e5), info(`hasBlendModes - ignoring XObject: "${t6}".`);
                continue;
              }
            }
            if (!(e5 instanceof BaseStream)) continue;
            e5.dict.objId && i3.put(e5.dict.objId);
            const t5 = e5.dict.get("Resources");
            t5 instanceof Dict && (t5.objId && i3.has(t5.objId) || (a3.push(t5), t5.objId && i3.put(t5.objId)));
          }
        }
        for (const e4 of i3) t3.put(e4);
        return false;
      }
      async fetchBuiltInCMap(e3) {
        const t3 = this.builtInCMapCache.get(e3);
        if (t3) return t3;
        let i3;
        if (null !== this.options.cMapUrl) {
          const t4 = `${this.options.cMapUrl}${e3}.bcmap`, a3 = await fetch(t4);
          if (!a3.ok) throw new Error(`fetchBuiltInCMap: failed to fetch file "${t4}" with "${a3.statusText}".`);
          i3 = { cMapData: new Uint8Array(await a3.arrayBuffer()), compressionType: Wi };
        } else i3 = await this.handler.sendWithPromise("FetchBuiltInCMap", { name: e3 });
        return i3.compressionType !== _i && this.builtInCMapCache.set(e3, i3), i3;
      }
      async fetchStandardFontData(e3) {
        const t3 = this.standardFontDataCache.get(e3);
        if (t3) return new Stream(t3);
        if (this.options.useSystemFonts && "Symbol" !== e3 && "ZapfDingbats" !== e3) return null;
        const i3 = Qr()[e3];
        let a3;
        if (null !== this.options.standardFontDataUrl) {
          const e4 = `${this.options.standardFontDataUrl}${i3}`, t4 = await fetch(e4);
          t4.ok ? a3 = new Uint8Array(await t4.arrayBuffer()) : warn(`fetchStandardFontData: failed to fetch file "${e4}" with "${t4.statusText}".`);
        } else try {
          a3 = await this.handler.sendWithPromise("FetchStandardFontData", { filename: i3 });
        } catch (e4) {
          warn(`fetchStandardFontData: failed to fetch file "${i3}" with "${e4}".`);
        }
        return a3 ? (this.standardFontDataCache.set(e3, a3), new Stream(a3)) : null;
      }
      async buildFormXObject(e3, t3, i3, a3, s3, n3, r3) {
        const o3 = t3.dict, g3 = lookupMatrix(o3.getArray("Matrix"), null), c3 = lookupNormalRect(o3.getArray("BBox"), null);
        let h3, l3;
        o3.has("OC") && (h3 = await this.parseMarkedContentProps(o3.get("OC"), e3)), void 0 !== h3 && a3.addOp(gs, ["OC", h3]);
        const C3 = o3.get("Group");
        if (C3) {
          l3 = { matrix: g3, bbox: c3, smask: i3, isolated: false, knockout: false };
          let t4 = null;
          if (isName(C3.get("S"), "Transparency") && (l3.isolated = C3.get("I") || false, l3.knockout = C3.get("K") || false, C3.has("CS"))) {
            const i4 = C3.getRaw("CS"), a4 = ColorSpace.getCached(i4, this.xref, r3);
            t4 = a4 || await this.parseColorSpace({ cs: i4, resources: e3, localColorSpaceCache: r3 });
          }
          i3?.backdrop && (t4 || (t4 = ColorSpace.singletons.rgb), i3.backdrop = t4.getRgb(i3.backdrop, 0)), a3.addOp(ds, [l3]);
        }
        const d3 = C3 ? [g3, null] : [g3, c3];
        a3.addOp(Is, d3), await this.getOperatorList({ stream: t3, task: s3, resources: o3.get("Resources") || e3, operatorList: a3, initialState: n3 }), a3.addOp(Cs, []), C3 && a3.addOp(Bs, [l3]), void 0 !== h3 && a3.addOp(cs, []);
      }
      _sendImgData(e3, t3, i3 = false) {
        const a3 = t3 ? [t3.bitmap || t3.data.buffer] : null;
        return this.parsingType3Font || i3 ? this.handler.send("commonobj", [e3, "Image", t3], a3) : this.handler.send("obj", [e3, this.pageIndex, "Image", t3], a3);
      }
      async buildPaintImageXObject({ resources: e3, image: t3, isInline: i3 = false, operatorList: a3, cacheKey: s3, localImageCache: n3, localColorSpaceCache: r3 }) {
        const o3 = t3.dict, g3 = o3.objId, c3 = o3.get("W", "Width"), h3 = o3.get("H", "Height");
        if (!c3 || "number" != typeof c3 || !h3 || "number" != typeof h3) return void warn("Image dimensions are missing, or not numbers.");
        const l3 = this.options.maxImageSize;
        if (-1 !== l3 && c3 * h3 > l3) {
          const e4 = "Image exceeded maximum allowed size and was removed.";
          if (this.options.ignoreErrors) return void warn(e4);
          throw new Error(e4);
        }
        let C3;
        o3.has("OC") && (C3 = await this.parseMarkedContentProps(o3.get("OC"), e3));
        let d3, u3;
        if (o3.get("IM", "ImageMask") || false) {
          const e4 = o3.get("I", "Interpolate"), i4 = c3 + 7 >> 3, r4 = t3.getBytes(i4 * h3), l4 = o3.getArray("D", "Decode");
          if (this.parsingType3Font) {
            if (d3 = PDFImage.createRawMask({ imgArray: r4, width: c3, height: h3, imageIsFromDecodeStream: t3 instanceof DecodeStream, inverseDecode: l4?.[0] > 0, interpolate: e4 }), d3.cached = !!s3, u3 = [d3], a3.addImageOps(Es, u3, C3), s3) {
              const e5 = { fn: Es, args: u3, optionalContent: C3 };
              n3.set(s3, g3, e5), g3 && this._regionalImageCache.set(null, g3, e5);
            }
            return;
          }
          if (d3 = await PDFImage.createMask({ imgArray: r4, width: c3, height: h3, imageIsFromDecodeStream: t3 instanceof DecodeStream, inverseDecode: l4?.[0] > 0, interpolate: e4, isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported }), d3.isSingleOpaquePixel) {
            if (a3.addImageOps(Ds, [], C3), s3) {
              const e5 = { fn: Ds, args: [], optionalContent: C3 };
              n3.set(s3, g3, e5), g3 && this._regionalImageCache.set(null, g3, e5);
            }
            return;
          }
          const Q4 = `mask_${this.idFactory.createObjId()}`;
          if (a3.addDependency(Q4), d3.dataLen = d3.bitmap ? d3.width * d3.height * 4 : d3.data.length, this._sendImgData(Q4, d3), u3 = [{ data: Q4, width: d3.width, height: d3.height, interpolate: d3.interpolate, count: 1 }], a3.addImageOps(Es, u3, C3), s3) {
            const e5 = { objId: Q4, fn: Es, args: u3, optionalContent: C3 };
            n3.set(s3, g3, e5), g3 && this._regionalImageCache.set(null, g3, e5);
          }
          return;
        }
        if (i3 && c3 + h3 < 200 && !o3.has("SMask") && !o3.has("Mask")) {
          try {
            const s4 = new PDFImage({ xref: this.xref, res: e3, image: t3, isInline: i3, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache: r3 });
            d3 = await s4.createImageData(true, false), a3.isOffscreenCanvasSupported = this.options.isOffscreenCanvasSupported, a3.addImageOps(ms, [d3], C3);
          } catch (e4) {
            const t4 = `Unable to decode inline image: "${e4}".`;
            if (!this.options.ignoreErrors) throw new Error(t4);
            warn(t4);
          }
          return;
        }
        let Q3 = `img_${this.idFactory.createObjId()}`, f3 = false;
        if (this.parsingType3Font ? Q3 = `${this.idFactory.getDocId()}_type3_${Q3}` : s3 && g3 && (f3 = this.globalImageCache.shouldCache(g3, this.pageIndex), f3 && (assert(!i3, "Cannot cache an inline image globally."), Q3 = `${this.idFactory.getDocId()}_${Q3}`)), a3.addDependency(Q3), u3 = [Q3, c3, h3], a3.addImageOps(ps, u3, C3), f3) {
          if (this.globalImageCache.hasDecodeFailed(g3)) return this.globalImageCache.setData(g3, { objId: Q3, fn: ps, args: u3, optionalContent: C3, byteSize: 0 }), void this._sendImgData(Q3, null, f3);
          if (c3 * h3 > 25e4 || o3.has("SMask") || o3.has("Mask")) {
            const e4 = await this.handler.sendWithPromise("commonobj", [Q3, "CopyLocalImage", { imageRef: g3 }]);
            if (e4) return this.globalImageCache.setData(g3, { objId: Q3, fn: ps, args: u3, optionalContent: C3, byteSize: 0 }), void this.globalImageCache.addByteSize(g3, e4);
          }
        }
        if (PDFImage.buildImage({ xref: this.xref, res: e3, image: t3, isInline: i3, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache: r3 }).then(async (e4) => (d3 = await e4.createImageData(false, this.options.isOffscreenCanvasSupported), d3.dataLen = d3.bitmap ? d3.width * d3.height * 4 : d3.data.length, d3.ref = g3, f3 && this.globalImageCache.addByteSize(g3, d3.dataLen), this._sendImgData(Q3, d3, f3))).catch((e4) => (warn(`Unable to decode image "${Q3}": "${e4}".`), g3 && this.globalImageCache.addDecodeFailed(g3), this._sendImgData(Q3, null, f3))), s3) {
          const e4 = { objId: Q3, fn: ps, args: u3, optionalContent: C3 };
          n3.set(s3, g3, e4), g3 && (this._regionalImageCache.set(null, g3, e4), f3 && this.globalImageCache.setData(g3, { objId: Q3, fn: ps, args: u3, optionalContent: C3, byteSize: 0 }));
        }
      }
      handleSMask(e3, t3, i3, a3, s3, n3) {
        const r3 = e3.get("G"), o3 = { subtype: e3.get("S").name, backdrop: e3.get("BC") }, g3 = e3.get("TR");
        if (isPDFFunction(g3)) {
          const e4 = this._pdfFunctionFactory.create(g3), t4 = new Uint8Array(256), i4 = new Float32Array(1);
          for (let a4 = 0; a4 < 256; a4++) i4[0] = a4 / 255, e4(i4, 0, i4, 0), t4[a4] = 255 * i4[0] | 0;
          o3.transferMap = t4;
        }
        return this.buildFormXObject(t3, r3, o3, i3, a3, s3.state.clone(), n3);
      }
      handleTransferFunction(e3) {
        let t3;
        if (Array.isArray(e3)) t3 = e3;
        else {
          if (!isPDFFunction(e3)) return null;
          t3 = [e3];
        }
        const i3 = [];
        let a3 = 0, s3 = 0;
        for (const e4 of t3) {
          const t4 = this.xref.fetchIfRef(e4);
          if (a3++, isName(t4, "Identity")) {
            i3.push(null);
            continue;
          }
          if (!isPDFFunction(t4)) return null;
          const n3 = this._pdfFunctionFactory.create(t4), r3 = new Uint8Array(256), o3 = new Float32Array(1);
          for (let e5 = 0; e5 < 256; e5++) o3[0] = e5 / 255, n3(o3, 0, o3, 0), r3[e5] = 255 * o3[0] | 0;
          i3.push(r3), s3++;
        }
        return 1 !== a3 && 4 !== a3 || 0 === s3 ? null : i3;
      }
      handleTilingType(e3, t3, i3, a3, s3, n3, r3, o3) {
        const g3 = new OperatorList(), c3 = Dict.merge({ xref: this.xref, dictArray: [s3.get("Resources"), i3] });
        return this.getOperatorList({ stream: a3, task: r3, resources: c3, operatorList: g3 }).then(function() {
          const i4 = g3.getIR(), a4 = getTilingPatternIR(i4, s3, t3);
          n3.addDependencies(g3.dependencies), n3.addOp(e3, a4), s3.objId && o3.set(null, s3.objId, { operatorListIR: i4, dict: s3 });
        }).catch((e4) => {
          if (!(e4 instanceof AbortException)) {
            if (!this.options.ignoreErrors) throw e4;
            warn(`handleTilingType - ignoring pattern: "${e4}".`);
          }
        });
      }
      async handleSetFont(e3, t3, i3, a3, s3, n3, r3 = null, o3 = null) {
        const g3 = t3?.[0] instanceof Name ? t3[0].name : null;
        let c3 = await this.loadFont(g3, i3, e3, r3, o3);
        if (c3.font.isType3Font) try {
          await c3.loadType3Data(this, e3, s3), a3.addDependencies(c3.type3Dependencies);
        } catch (e4) {
          c3 = new TranslatedFont({ loadedName: "g_font_error", font: new ErrorFont(`Type3 font load error: ${e4}`), dict: c3.font, evaluatorOptions: this.options });
        }
        return n3.font = c3.font, c3.send(this.handler), c3.loadedName;
      }
      handleText(e3, t3) {
        const i3 = t3.font, a3 = i3.charsToGlyphs(e3);
        if (i3.data) {
          (!!(t3.textRenderingMode & _A) || "Pattern" === t3.fillColorSpace.name || i3.disableFontFace || this.options.disableFontFace) && _PartialEvaluator.buildFontPaths(i3, a3, this.handler, this.options);
        }
        return a3;
      }
      ensureStateFont(e3) {
        if (e3.font) return;
        const t3 = new FormatError("Missing setFont (Tf) operator before text rendering operator.");
        if (!this.options.ignoreErrors) throw t3;
        warn(`ensureStateFont: "${t3}".`);
      }
      async setGState({ resources: e3, gState: t3, operatorList: i3, cacheKey: a3, task: s3, stateManager: n3, localGStateCache: r3, localColorSpaceCache: o3 }) {
        const g3 = t3.objId;
        let c3 = true;
        const h3 = [];
        let l3 = Promise.resolve();
        for (const a4 of t3.getKeys()) {
          const r4 = t3.get(a4);
          switch (a4) {
            case "Type":
              break;
            case "LW":
            case "LC":
            case "LJ":
            case "ML":
            case "D":
            case "RI":
            case "FL":
            case "CA":
            case "ca":
              h3.push([a4, r4]);
              break;
            case "Font":
              c3 = false, l3 = l3.then(() => this.handleSetFont(e3, null, r4[0], i3, s3, n3.state).then(function(e4) {
                i3.addDependency(e4), h3.push([a4, [e4, r4[1]]]);
              }));
              break;
            case "BM":
              h3.push([a4, normalizeBlendMode(r4)]);
              break;
            case "SMask":
              if (isName(r4, "None")) {
                h3.push([a4, false]);
                break;
              }
              r4 instanceof Dict ? (c3 = false, l3 = l3.then(() => this.handleSMask(r4, e3, i3, s3, n3, o3)), h3.push([a4, true])) : warn("Unsupported SMask type");
              break;
            case "TR":
              const t4 = this.handleTransferFunction(r4);
              h3.push([a4, t4]);
              break;
            case "OP":
            case "op":
            case "OPM":
            case "BG":
            case "BG2":
            case "UCR":
            case "UCR2":
            case "TR2":
            case "HT":
            case "SM":
            case "SA":
            case "AIS":
            case "TK":
              info("graphic state operator " + a4);
              break;
            default:
              info("Unknown graphic state operator " + a4);
          }
        }
        await l3, h3.length > 0 && i3.addOp(Aa, [h3]), c3 && r3.set(a3, g3, h3);
      }
      loadFont(e3, t3, i3, a3 = null, s3 = null) {
        const errorFont = async () => new TranslatedFont({ loadedName: "g_font_error", font: new ErrorFont(`Font "${e3}" is not available.`), dict: t3, evaluatorOptions: this.options });
        let n3;
        if (t3) t3 instanceof Ref && (n3 = t3);
        else {
          const t4 = i3.get("Font");
          t4 && (n3 = t4.getRaw(e3));
        }
        if (n3) {
          if (this.type3FontRefs?.has(n3)) return errorFont();
          if (this.fontCache.has(n3)) return this.fontCache.get(n3);
          try {
            t3 = this.xref.fetchIfRef(n3);
          } catch (e4) {
            warn(`loadFont - lookup failed: "${e4}".`);
          }
        }
        if (!(t3 instanceof Dict)) {
          if (!this.options.ignoreErrors && !this.parsingType3Font) return warn(`Font "${e3}" is not available.`), errorFont();
          warn(`Font "${e3}" is not available -- attempting to fallback to a default font.`), t3 = a3 || _PartialEvaluator.fallbackFontDict;
        }
        if (t3.cacheKey && this.fontCache.has(t3.cacheKey)) return this.fontCache.get(t3.cacheKey);
        const { promise: r3, resolve: o3 } = Promise.withResolvers();
        let g3;
        try {
          g3 = this.preEvaluateFont(t3), g3.cssFontInfo = s3;
        } catch (e4) {
          return warn(`loadFont - preEvaluateFont failed: "${e4}".`), errorFont();
        }
        const { descriptor: c3, hash: h3 } = g3, l3 = n3 instanceof Ref;
        let C3;
        if (h3 && c3 instanceof Dict) {
          const e4 = c3.fontAliases || (c3.fontAliases = /* @__PURE__ */ Object.create(null));
          if (e4[h3]) {
            const t4 = e4[h3].aliasRef;
            if (l3 && t4 && this.fontCache.has(t4)) return this.fontCache.putAlias(n3, t4), this.fontCache.get(n3);
          } else e4[h3] = { fontID: this.idFactory.createFontId() };
          l3 && (e4[h3].aliasRef = n3), C3 = e4[h3].fontID;
        } else C3 = this.idFactory.createFontId();
        return assert(C3?.startsWith("f"), 'The "fontID" must be (correctly) defined.'), l3 ? this.fontCache.put(n3, r3) : (t3.cacheKey = `cacheKey_${C3}`, this.fontCache.put(t3.cacheKey, r3)), t3.loadedName = `${this.idFactory.getDocId()}_${C3}`, this.translateFont(g3).then((e4) => {
          o3(new TranslatedFont({ loadedName: t3.loadedName, font: e4, dict: t3, evaluatorOptions: this.options }));
        }).catch((e4) => {
          warn(`loadFont - translateFont failed: "${e4}".`), o3(new TranslatedFont({ loadedName: t3.loadedName, font: new ErrorFont(e4 instanceof Error ? e4.message : e4), dict: t3, evaluatorOptions: this.options }));
        }), r3;
      }
      buildPath(e3, t3, i3, a3 = false) {
        const s3 = e3.length - 1;
        if (i3 || (i3 = []), s3 < 0 || e3.fnArray[s3] !== Ss) {
          let s4;
          switch (a3 && (warn(`Encountered path operator "${t3}" inside of a text object.`), e3.addOp(ia, null)), t3) {
            case la:
              const e4 = i3[0] + i3[2], t4 = i3[1] + i3[3];
              s4 = [Math.min(i3[0], e4), Math.min(i3[1], t4), Math.max(i3[0], e4), Math.max(i3[1], t4)];
              break;
            case na:
            case ra:
              s4 = [i3[0], i3[1], i3[0], i3[1]];
              break;
            default:
              s4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          }
          e3.addOp(Ss, [[t3], i3, s4]), a3 && e3.addOp(aa, null);
        } else {
          const a4 = e3.argsArray[s3];
          a4[0].push(t3), a4[1].push(...i3);
          const n3 = a4[2];
          switch (t3) {
            case la:
              const e4 = i3[0] + i3[2], t4 = i3[1] + i3[3];
              n3[0] = Math.min(n3[0], i3[0], e4), n3[1] = Math.min(n3[1], i3[1], t4), n3[2] = Math.max(n3[2], i3[0], e4), n3[3] = Math.max(n3[3], i3[1], t4);
              break;
            case na:
            case ra:
              n3[0] = Math.min(n3[0], i3[0]), n3[1] = Math.min(n3[1], i3[1]), n3[2] = Math.max(n3[2], i3[0]), n3[3] = Math.max(n3[3], i3[1]);
          }
        }
      }
      parseColorSpace({ cs: e3, resources: t3, localColorSpaceCache: i3 }) {
        return ColorSpace.parseAsync({ cs: e3, xref: this.xref, resources: t3, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache: i3 }).catch((e4) => {
          if (e4 instanceof AbortException) return null;
          if (this.options.ignoreErrors) return warn(`parseColorSpace - ignoring ColorSpace: "${e4}".`), null;
          throw e4;
        });
      }
      parseShading({ shading: e3, resources: t3, localColorSpaceCache: i3, localShadingPatternCache: a3 }) {
        let s3, n3 = a3.get(e3);
        if (n3) return n3;
        try {
          s3 = Pattern.parseShading(e3, this.xref, t3, this._pdfFunctionFactory, i3).getIR();
        } catch (t4) {
          if (t4 instanceof AbortException) return null;
          if (this.options.ignoreErrors) return warn(`parseShading - ignoring shading: "${t4}".`), a3.set(e3, null), null;
          throw t4;
        }
        return n3 = `pattern_${this.idFactory.createObjId()}`, this.parsingType3Font && (n3 = `${this.idFactory.getDocId()}_type3_${n3}`), a3.set(e3, n3), this.parsingType3Font ? this.handler.send("commonobj", [n3, "Pattern", s3]) : this.handler.send("obj", [n3, this.pageIndex, "Pattern", s3]), n3;
      }
      handleColorN(e3, t3, i3, a3, s3, n3, r3, o3, g3, c3) {
        const h3 = i3.pop();
        if (h3 instanceof Name) {
          const l3 = s3.getRaw(h3.name), C3 = l3 instanceof Ref && g3.getByRef(l3);
          if (C3) try {
            const s4 = a3.base ? a3.base.getRgb(i3, 0) : null, n4 = getTilingPatternIR(C3.operatorListIR, C3.dict, s4);
            return void e3.addOp(t3, n4);
          } catch {
          }
          const d3 = this.xref.fetchIfRef(l3);
          if (d3) {
            const s4 = d3 instanceof BaseStream ? d3.dict : d3, h4 = s4.get("PatternType");
            if (h4 === tg) {
              const o4 = a3.base ? a3.base.getRgb(i3, 0) : null;
              return this.handleTilingType(t3, o4, n3, d3, s4, e3, r3, g3);
            }
            if (h4 === Ag) {
              const i4 = s4.get("Shading"), a4 = this.parseShading({ shading: i4, resources: n3, localColorSpaceCache: o3, localShadingPatternCache: c3 });
              if (a4) {
                const i5 = lookupMatrix(s4.getArray("Matrix"), null);
                e3.addOp(t3, ["Shading", a4, i5]);
              }
              return;
            }
            throw new FormatError(`Unknown PatternType: ${h4}`);
          }
        }
        throw new FormatError(`Unknown PatternName: ${h3}`);
      }
      _parseVisibilityExpression(e3, t3, i3) {
        if (++t3 > 10) return void warn("Visibility expression is too deeply nested");
        const a3 = e3.length, s3 = this.xref.fetchIfRef(e3[0]);
        if (!(a3 < 2) && s3 instanceof Name) {
          switch (s3.name) {
            case "And":
            case "Or":
            case "Not":
              i3.push(s3.name);
              break;
            default:
              return void warn(`Invalid operator ${s3.name} in visibility expression`);
          }
          for (let s4 = 1; s4 < a3; s4++) {
            const a4 = e3[s4], n3 = this.xref.fetchIfRef(a4);
            if (Array.isArray(n3)) {
              const e4 = [];
              i3.push(e4), this._parseVisibilityExpression(n3, t3, e4);
            } else a4 instanceof Ref && i3.push(a4.toString());
          }
        } else warn("Invalid visibility expression");
      }
      async parseMarkedContentProps(e3, t3) {
        let i3;
        if (e3 instanceof Name) {
          i3 = t3.get("Properties").get(e3.name);
        } else {
          if (!(e3 instanceof Dict)) throw new FormatError("Optional content properties malformed.");
          i3 = e3;
        }
        const a3 = i3.get("Type")?.name;
        if ("OCG" === a3) return { type: a3, id: i3.objId };
        if ("OCMD" === a3) {
          const e4 = i3.get("VE");
          if (Array.isArray(e4)) {
            const t5 = [];
            if (this._parseVisibilityExpression(e4, 0, t5), t5.length > 0) return { type: "OCMD", expression: t5 };
          }
          const t4 = i3.get("OCGs");
          if (Array.isArray(t4) || t4 instanceof Dict) {
            const e5 = [];
            if (Array.isArray(t4)) for (const i4 of t4) e5.push(i4.toString());
            else e5.push(t4.objId);
            return { type: a3, ids: e5, policy: i3.get("P") instanceof Name ? i3.get("P").name : null, expression: null };
          }
          if (t4 instanceof Ref) return { type: a3, id: t4.toString() };
        }
        return null;
      }
      getOperatorList({ stream: e3, task: t3, resources: i3, operatorList: a3, initialState: s3 = null, fallbackFontDict: n3 = null }) {
        if (i3 || (i3 = Dict.empty), s3 || (s3 = new EvalState()), !a3) throw new Error('getOperatorList: missing "operatorList" parameter');
        const r3 = this, o3 = this.xref;
        let g3 = false;
        const c3 = new LocalImageCache(), h3 = new LocalColorSpaceCache(), l3 = new LocalGStateCache(), C3 = new LocalTilingPatternCache(), d3 = /* @__PURE__ */ new Map(), u3 = i3.get("XObject") || Dict.empty, Q3 = i3.get("Pattern") || Dict.empty, f3 = new StateManager(s3), p3 = new EvaluatorPreprocessor(e3, o3, f3), m3 = new TimeSlotManager();
        function closePendingRestoreOPS(e4) {
          for (let e5 = 0, t4 = p3.savedStatesDepth; e5 < t4; e5++) a3.addOp(aa, []);
        }
        return new Promise(function promiseBody(e4, s4) {
          const next = function(t4) {
            Promise.all([t4, a3.ready]).then(function() {
              try {
                promiseBody(e4, s4);
              } catch (e5) {
                s4(e5);
              }
            }, s4);
          };
          t3.ensureNotTerminated(), m3.reset();
          const y3 = {};
          let w3, b3, D3, S3, F3, k3;
          for (; !(w3 = m3.check()) && (y3.args = null, p3.read(y3)); ) {
            let e5 = y3.args, s5 = y3.fn;
            switch (0 | s5) {
              case ss:
                if (k3 = e5[0] instanceof Name, F3 = e5[0].name, k3) {
                  const t4 = c3.getByName(F3);
                  if (t4) {
                    addLocallyCachedImageOps(a3, t4), e5 = null;
                    continue;
                  }
                }
                return void next(new Promise(function(e6, s6) {
                  if (!k3) throw new FormatError("XObject must be referred to by name.");
                  let n4 = u3.getRaw(F3);
                  if (n4 instanceof Ref) {
                    const t4 = c3.getByRef(n4) || r3._regionalImageCache.getByRef(n4);
                    if (t4) return addLocallyCachedImageOps(a3, t4), void e6();
                    const i4 = r3.globalImageCache.getData(n4, r3.pageIndex);
                    if (i4) return a3.addDependency(i4.objId), a3.addImageOps(i4.fn, i4.args, i4.optionalContent), void e6();
                    n4 = o3.fetch(n4);
                  }
                  if (!(n4 instanceof BaseStream)) throw new FormatError("XObject should be a stream");
                  const g4 = n4.dict.get("Subtype");
                  if (!(g4 instanceof Name)) throw new FormatError("XObject should have a Name subtype");
                  if ("Form" === g4.name) return f3.save(), void r3.buildFormXObject(i3, n4, null, a3, t3, f3.state.clone(), h3).then(function() {
                    f3.restore(), e6();
                  }, s6);
                  if ("Image" !== g4.name) {
                    if ("PS" !== g4.name) throw new FormatError(`Unhandled XObject subtype ${g4.name}`);
                    info("Ignored XObject subtype PS"), e6();
                  } else r3.buildPaintImageXObject({ resources: i3, image: n4, operatorList: a3, cacheKey: F3, localImageCache: c3, localColorSpaceCache: h3 }).then(e6, s6);
                }).catch(function(e6) {
                  if (!(e6 instanceof AbortException)) {
                    if (!r3.options.ignoreErrors) throw e6;
                    warn(`getOperatorList - ignoring XObject: "${e6}".`);
                  }
                }));
              case Ra:
                var R3 = e5[1];
                return void next(r3.handleSetFont(i3, e5, null, a3, t3, f3.state, n3).then(function(e6) {
                  a3.addDependency(e6), a3.addOp(Ra, [e6, R3]);
                }));
              case wa:
                g3 = true;
                break;
              case ba:
                g3 = false;
                break;
              case as:
                var x3 = e5[0].cacheKey;
                if (x3) {
                  const t4 = c3.getByName(x3);
                  if (t4) {
                    addLocallyCachedImageOps(a3, t4), e5 = null;
                    continue;
                  }
                }
                return void next(r3.buildPaintImageXObject({ resources: i3, image: e5[0], isInline: true, operatorList: a3, cacheKey: x3, localImageCache: c3, localColorSpaceCache: h3 }));
              case Ua:
                if (!f3.state.font) {
                  r3.ensureStateFont(f3.state);
                  continue;
                }
                e5[0] = r3.handleText(e5[0], f3.state);
                break;
              case Ha:
                if (!f3.state.font) {
                  r3.ensureStateFont(f3.state);
                  continue;
                }
                var N3 = [], M3 = f3.state;
                for (const t4 of e5[0]) "string" == typeof t4 ? N3.push(...r3.handleText(t4, M3)) : "number" == typeof t4 && N3.push(t4);
                e5[0] = N3, s5 = Ua;
                break;
              case Ta:
                if (!f3.state.font) {
                  r3.ensureStateFont(f3.state);
                  continue;
                }
                a3.addOp(La), e5[0] = r3.handleText(e5[0], f3.state), s5 = Ua;
                break;
              case Ja:
                if (!f3.state.font) {
                  r3.ensureStateFont(f3.state);
                  continue;
                }
                a3.addOp(La), a3.addOp(Sa, [e5.shift()]), a3.addOp(Da, [e5.shift()]), e5[0] = r3.handleText(e5[0], f3.state), s5 = Ua;
                break;
              case xa:
                f3.state.textRenderingMode = e5[0];
                break;
              case Ka: {
                const t4 = ColorSpace.getCached(e5[0], o3, h3);
                if (t4) {
                  f3.state.fillColorSpace = t4;
                  continue;
                }
                return void next(r3.parseColorSpace({ cs: e5[0], resources: i3, localColorSpaceCache: h3 }).then(function(e6) {
                  f3.state.fillColorSpace = e6 || ColorSpace.singletons.gray;
                }));
              }
              case Oa: {
                const t4 = ColorSpace.getCached(e5[0], o3, h3);
                if (t4) {
                  f3.state.strokeColorSpace = t4;
                  continue;
                }
                return void next(r3.parseColorSpace({ cs: e5[0], resources: i3, localColorSpaceCache: h3 }).then(function(e6) {
                  f3.state.strokeColorSpace = e6 || ColorSpace.singletons.gray;
                }));
              }
              case Wa:
                S3 = f3.state.fillColorSpace, e5 = S3.getRgb(e5, 0), s5 = za;
                break;
              case qa:
                S3 = f3.state.strokeColorSpace, e5 = S3.getRgb(e5, 0), s5 = Za;
                break;
              case Va:
                f3.state.fillColorSpace = ColorSpace.singletons.gray, e5 = ColorSpace.singletons.gray.getRgb(e5, 0), s5 = za;
                break;
              case Xa:
                f3.state.strokeColorSpace = ColorSpace.singletons.gray, e5 = ColorSpace.singletons.gray.getRgb(e5, 0), s5 = Za;
                break;
              case es:
                f3.state.fillColorSpace = ColorSpace.singletons.cmyk, e5 = ColorSpace.singletons.cmyk.getRgb(e5, 0), s5 = za;
                break;
              case $a:
                f3.state.strokeColorSpace = ColorSpace.singletons.cmyk, e5 = ColorSpace.singletons.cmyk.getRgb(e5, 0), s5 = Za;
                break;
              case za:
                f3.state.fillColorSpace = ColorSpace.singletons.rgb, e5 = ColorSpace.singletons.rgb.getRgb(e5, 0);
                break;
              case Za:
                f3.state.strokeColorSpace = ColorSpace.singletons.rgb, e5 = ColorSpace.singletons.rgb.getRgb(e5, 0);
                break;
              case ja:
                if (S3 = f3.state.patternFillColorSpace, !S3) {
                  e5 = [], s5 = ks;
                  break;
                }
                if ("Pattern" === S3.name) return void next(r3.handleColorN(a3, ja, e5, S3, Q3, i3, t3, h3, C3, d3));
                e5 = S3.getRgb(e5, 0), s5 = za;
                break;
              case _a:
                if (S3 = f3.state.patternStrokeColorSpace, !S3) {
                  e5 = [], s5 = Fs;
                  break;
                }
                if ("Pattern" === S3.name) return void next(r3.handleColorN(a3, _a, e5, S3, Q3, i3, t3, h3, C3, d3));
                e5 = S3.getRgb(e5, 0), s5 = Za;
                break;
              case ts:
                var G3 = i3.get("Shading");
                if (!G3) throw new FormatError("No shading resource found");
                var v3 = G3.get(e5[0].name);
                if (!v3) throw new FormatError("No shading object found");
                const p4 = r3.parseShading({ shading: v3, resources: i3, localColorSpaceCache: h3, localShadingPatternCache: d3 });
                if (!p4) continue;
                e5 = [p4], s5 = ts;
                break;
              case Aa:
                if (k3 = e5[0] instanceof Name, F3 = e5[0].name, k3) {
                  const t4 = l3.getByName(F3);
                  if (t4) {
                    t4.length > 0 && a3.addOp(Aa, [t4]), e5 = null;
                    continue;
                  }
                }
                return void next(new Promise(function(e6, s6) {
                  if (!k3) throw new FormatError("GState must be referred to by name.");
                  const n4 = i3.get("ExtGState");
                  if (!(n4 instanceof Dict)) throw new FormatError("ExtGState should be a dictionary.");
                  const o4 = n4.get(F3);
                  if (!(o4 instanceof Dict)) throw new FormatError("GState should be a dictionary.");
                  r3.setGState({ resources: i3, gState: o4, operatorList: a3, cacheKey: F3, task: t3, stateManager: f3, localGStateCache: l3, localColorSpaceCache: h3 }).then(e6, s6);
                }).catch(function(e6) {
                  if (!(e6 instanceof AbortException)) {
                    if (!r3.options.ignoreErrors) throw e6;
                    warn(`getOperatorList - ignoring ExtGState: "${e6}".`);
                  }
                }));
              case na:
              case ra:
              case oa:
              case ga:
              case ca:
              case ha:
              case la:
                r3.buildPath(a3, s5, e5, g3);
                continue;
              case ns:
              case rs:
              case hs:
              case ls:
                continue;
              case gs:
                if (!(e5[0] instanceof Name)) {
                  warn(`Expected name for beginMarkedContentProps arg0=${e5[0]}`), a3.addOp(gs, ["OC", null]);
                  continue;
                }
                if ("OC" === e5[0].name) return void next(r3.parseMarkedContentProps(e5[1], i3).then((e6) => {
                  a3.addOp(gs, ["OC", e6]);
                }).catch((e6) => {
                  if (!(e6 instanceof AbortException)) {
                    if (r3.options.ignoreErrors) return warn(`getOperatorList - ignoring beginMarkedContentProps: "${e6}".`), void a3.addOp(gs, ["OC", null]);
                    throw e6;
                  }
                }));
                e5 = [e5[0].name, e5[1] instanceof Dict ? e5[1].get("MCID") : null];
                break;
              default:
                if (null !== e5) {
                  for (b3 = 0, D3 = e5.length; b3 < D3 && !(e5[b3] instanceof Dict); b3++) ;
                  if (b3 < D3) {
                    warn("getOperatorList - ignoring operator: " + s5);
                    continue;
                  }
                }
            }
            a3.addOp(s5, e5);
          }
          w3 ? next(ig) : (closePendingRestoreOPS(), e4());
        }).catch((e4) => {
          if (!(e4 instanceof AbortException)) {
            if (this.options.ignoreErrors) return warn(`getOperatorList - ignoring errors during "${t3.name}" task: "${e4}".`), void closePendingRestoreOPS();
            throw e4;
          }
        });
      }
      getTextContent({ stream: e3, task: t3, resources: i3, stateManager: a3 = null, includeMarkedContent: s3 = false, sink: n3, seenStyles: r3 = /* @__PURE__ */ new Set(), viewBox: o3, lang: g3 = null, markedContentData: c3 = null, disableNormalization: h3 = false, keepWhiteSpace: l3 = false }) {
        i3 || (i3 = Dict.empty), a3 || (a3 = new StateManager(new TextState())), s3 && (c3 || (c3 = { level: 0 }));
        const C3 = { items: [], styles: /* @__PURE__ */ Object.create(null), lang: g3 }, d3 = { initialized: false, str: [], totalWidth: 0, totalHeight: 0, width: 0, height: 0, vertical: false, prevTransform: null, textAdvanceScale: 0, spaceInFlowMin: 0, spaceInFlowMax: 0, trackingSpaceMin: 1 / 0, negativeSpaceMax: -1 / 0, notASpace: -1 / 0, transform: null, fontName: null, hasEOL: false }, u3 = [" ", " "];
        let Q3 = 0;
        function saveLastChar(e4) {
          const t4 = (Q3 + 1) % 2, i4 = " " !== u3[Q3] && " " === u3[t4];
          return u3[Q3] = e4, Q3 = t4, !l3 && i4;
        }
        function shouldAddWhitepsace() {
          return !l3 && " " !== u3[Q3] && " " === u3[(Q3 + 1) % 2];
        }
        function resetLastChars() {
          u3[0] = u3[1] = " ", Q3 = 0;
        }
        const f3 = this, p3 = this.xref, m3 = [];
        let y3 = null;
        const w3 = new LocalImageCache(), b3 = new LocalGStateCache(), D3 = new EvaluatorPreprocessor(e3, p3, a3);
        let S3;
        function pushWhitespace({ width: e4 = 0, height: t4 = 0, transform: i4 = d3.prevTransform, fontName: a4 = d3.fontName }) {
          C3.items.push({ str: " ", dir: "ltr", width: e4, height: t4, transform: i4, fontName: a4, hasEOL: false });
        }
        function getCurrentTextTransform() {
          const e4 = S3.font, t4 = [S3.fontSize * S3.textHScale, 0, 0, S3.fontSize, 0, S3.textRise];
          if (e4.isType3Font && (S3.fontSize <= 1 || e4.isCharBBox) && !isArrayEqual(S3.fontMatrix, SA)) {
            const i4 = e4.bbox[3] - e4.bbox[1];
            i4 > 0 && (t4[3] *= i4 * S3.fontMatrix[3]);
          }
          return Util.transform(S3.ctm, Util.transform(S3.textMatrix, t4));
        }
        function ensureTextContentItem() {
          if (d3.initialized) return d3;
          const { font: e4, loadedName: t4 } = S3;
          if (!r3.has(t4) && (r3.add(t4), C3.styles[t4] = { fontFamily: e4.fallbackName, ascent: e4.ascent, descent: e4.descent, vertical: e4.vertical }, f3.options.fontExtraProperties && e4.systemFontInfo)) {
            const i5 = C3.styles[t4];
            i5.fontSubstitution = e4.systemFontInfo.css, i5.fontSubstitutionLoadedName = e4.systemFontInfo.loadedName;
          }
          d3.fontName = t4;
          const i4 = d3.transform = getCurrentTextTransform();
          e4.vertical ? (d3.width = d3.totalWidth = Math.hypot(i4[0], i4[1]), d3.height = d3.totalHeight = 0, d3.vertical = true) : (d3.width = d3.totalWidth = 0, d3.height = d3.totalHeight = Math.hypot(i4[2], i4[3]), d3.vertical = false);
          const a4 = Math.hypot(S3.textLineMatrix[0], S3.textLineMatrix[1]), s4 = Math.hypot(S3.ctm[0], S3.ctm[1]);
          d3.textAdvanceScale = s4 * a4;
          const { fontSize: n4 } = S3;
          return d3.trackingSpaceMin = 0.102 * n4, d3.notASpace = 0.03 * n4, d3.negativeSpaceMax = -0.2 * n4, d3.spaceInFlowMin = 0.102 * n4, d3.spaceInFlowMax = 0.6 * n4, d3.hasEOL = false, d3.initialized = true, d3;
        }
        function updateAdvanceScale() {
          if (!d3.initialized) return;
          const e4 = Math.hypot(S3.textLineMatrix[0], S3.textLineMatrix[1]), t4 = Math.hypot(S3.ctm[0], S3.ctm[1]) * e4;
          t4 !== d3.textAdvanceScale && (d3.vertical ? (d3.totalHeight += d3.height * d3.textAdvanceScale, d3.height = 0) : (d3.totalWidth += d3.width * d3.textAdvanceScale, d3.width = 0), d3.textAdvanceScale = t4);
        }
        function runBidiTransform(e4) {
          let t4 = e4.str.join("");
          var i4;
          h3 || (i4 = t4, Ls || (Ls = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, Us = /* @__PURE__ */ new Map([["\uFB05", "\u017Ft"]])), t4 = i4.replaceAll(Ls, (e5, t5, i5) => t5 ? t5.normalize("NFKC") : Us.get(i5)));
          const a4 = bidi(t4, -1, e4.vertical);
          return { str: a4.str, dir: a4.dir, width: Math.abs(e4.totalWidth), height: Math.abs(e4.totalHeight), transform: e4.transform, fontName: e4.fontName, hasEOL: e4.hasEOL };
        }
        async function handleSetFont(e4, a4) {
          const s4 = await f3.loadFont(e4, a4, i3);
          if (s4.font.isType3Font) try {
            await s4.loadType3Data(f3, i3, t3);
          } catch {
          }
          S3.loadedName = s4.loadedName, S3.font = s4.font, S3.fontMatrix = s4.font.fontMatrix || SA;
        }
        function applyInverseRotation(e4, t4, i4) {
          const a4 = Math.hypot(i4[0], i4[1]);
          return [(i4[0] * e4 + i4[1] * t4) / a4, (i4[2] * e4 + i4[3] * t4) / a4];
        }
        function compareWithLastPosition(e4) {
          const t4 = getCurrentTextTransform();
          let i4 = t4[4], a4 = t4[5];
          if (S3.font?.vertical) {
            if (i4 < o3[0] || i4 > o3[2] || a4 + e4 < o3[1] || a4 > o3[3]) return false;
          } else if (i4 + e4 < o3[0] || i4 > o3[2] || a4 < o3[1] || a4 > o3[3]) return false;
          if (!S3.font || !d3.prevTransform) return true;
          let s4 = d3.prevTransform[4], n4 = d3.prevTransform[5];
          if (s4 === i4 && n4 === a4) return true;
          let r4 = -1;
          switch (t4[0] && 0 === t4[1] && 0 === t4[2] ? r4 = t4[0] > 0 ? 0 : 180 : t4[1] && 0 === t4[0] && 0 === t4[3] && (r4 = t4[1] > 0 ? 90 : 270), r4) {
            case 0:
              break;
            case 90:
              [i4, a4] = [a4, i4], [s4, n4] = [n4, s4];
              break;
            case 180:
              [i4, a4, s4, n4] = [-i4, -a4, -s4, -n4];
              break;
            case 270:
              [i4, a4] = [-a4, -i4], [s4, n4] = [-n4, -s4];
              break;
            default:
              [i4, a4] = applyInverseRotation(i4, a4, t4), [s4, n4] = applyInverseRotation(s4, n4, d3.prevTransform);
          }
          if (S3.font.vertical) {
            const e5 = (n4 - a4) / d3.textAdvanceScale, t5 = i4 - s4, r5 = Math.sign(d3.height);
            return e5 < r5 * d3.negativeSpaceMax ? Math.abs(t5) > 0.5 * d3.width ? (appendEOL(), true) : (resetLastChars(), flushTextContentItem(), true) : Math.abs(t5) > d3.width ? (appendEOL(), true) : (e5 <= r5 * d3.notASpace && resetLastChars(), e5 <= r5 * d3.trackingSpaceMin ? shouldAddWhitepsace() ? (resetLastChars(), flushTextContentItem(), pushWhitespace({ height: Math.abs(e5) })) : d3.height += e5 : addFakeSpaces(e5, d3.prevTransform, r5) || (0 === d3.str.length ? (resetLastChars(), pushWhitespace({ height: Math.abs(e5) })) : d3.height += e5), Math.abs(t5) > 0.25 * d3.width && flushTextContentItem(), true);
          }
          const g4 = (i4 - s4) / d3.textAdvanceScale, c4 = a4 - n4, h4 = Math.sign(d3.width);
          return g4 < h4 * d3.negativeSpaceMax ? Math.abs(c4) > 0.5 * d3.height ? (appendEOL(), true) : (resetLastChars(), flushTextContentItem(), true) : Math.abs(c4) > d3.height ? (appendEOL(), true) : (g4 <= h4 * d3.notASpace && resetLastChars(), g4 <= h4 * d3.trackingSpaceMin ? shouldAddWhitepsace() ? (resetLastChars(), flushTextContentItem(), pushWhitespace({ width: Math.abs(g4) })) : d3.width += g4 : addFakeSpaces(g4, d3.prevTransform, h4) || (0 === d3.str.length ? (resetLastChars(), pushWhitespace({ width: Math.abs(g4) })) : d3.width += g4), Math.abs(c4) > 0.25 * d3.height && flushTextContentItem(), true);
        }
        function buildTextContentItem({ chars: e4, extraSpacing: t4 }) {
          const i4 = S3.font;
          if (!e4) {
            const e5 = S3.charSpacing + t4;
            return e5 && (i4.vertical ? S3.translateTextMatrix(0, -e5) : S3.translateTextMatrix(e5 * S3.textHScale, 0)), void (l3 && compareWithLastPosition(0));
          }
          const a4 = i4.charsToGlyphs(e4), s4 = S3.fontMatrix[0] * S3.fontSize;
          for (let e5 = 0, n4 = a4.length; e5 < n4; e5++) {
            const r4 = a4[e5], { category: o4 } = r4;
            if (o4.isInvisibleFormatMark) continue;
            let g4 = S3.charSpacing + (e5 + 1 === n4 ? t4 : 0), c4 = r4.width;
            i4.vertical && (c4 = r4.vmetric ? r4.vmetric[0] : -c4);
            let h4 = c4 * s4;
            if (!l3 && o4.isWhitespace) {
              i4.vertical ? (g4 += -h4 + S3.wordSpacing, S3.translateTextMatrix(0, -g4)) : (g4 += h4 + S3.wordSpacing, S3.translateTextMatrix(g4 * S3.textHScale, 0)), saveLastChar(" ");
              continue;
            }
            if (!o4.isZeroWidthDiacritic && !compareWithLastPosition(h4)) {
              i4.vertical ? S3.translateTextMatrix(0, h4) : S3.translateTextMatrix(h4 * S3.textHScale, 0);
              continue;
            }
            const C4 = ensureTextContentItem();
            o4.isZeroWidthDiacritic && (h4 = 0), i4.vertical ? (S3.translateTextMatrix(0, h4), h4 = Math.abs(h4), C4.height += h4) : (h4 *= S3.textHScale, S3.translateTextMatrix(h4, 0), C4.width += h4), h4 && (C4.prevTransform = getCurrentTextTransform());
            const d4 = r4.unicode;
            saveLastChar(d4) && C4.str.push(" "), C4.str.push(d4), g4 && (i4.vertical ? S3.translateTextMatrix(0, -g4) : S3.translateTextMatrix(g4 * S3.textHScale, 0));
          }
        }
        function appendEOL() {
          resetLastChars(), d3.initialized ? (d3.hasEOL = true, flushTextContentItem()) : C3.items.push({ str: "", dir: "ltr", width: 0, height: 0, transform: getCurrentTextTransform(), fontName: S3.loadedName, hasEOL: true });
        }
        function addFakeSpaces(e4, t4, i4) {
          if (i4 * d3.spaceInFlowMin <= e4 && e4 <= i4 * d3.spaceInFlowMax) return d3.initialized && (resetLastChars(), d3.str.push(" ")), false;
          const a4 = d3.fontName;
          let s4 = 0;
          return d3.vertical && (s4 = e4, e4 = 0), flushTextContentItem(), resetLastChars(), pushWhitespace({ width: Math.abs(e4), height: Math.abs(s4), transform: t4 || getCurrentTextTransform(), fontName: a4 }), true;
        }
        function flushTextContentItem() {
          d3.initialized && d3.str && (d3.vertical ? d3.totalHeight += d3.height * d3.textAdvanceScale : d3.totalWidth += d3.width * d3.textAdvanceScale, C3.items.push(runBidiTransform(d3)), d3.initialized = false, d3.str.length = 0);
        }
        function enqueueChunk(e4 = false) {
          const t4 = C3.items.length;
          0 !== t4 && (e4 && t4 < 10 || (n3.enqueue(C3, t4), C3.items = [], C3.styles = /* @__PURE__ */ Object.create(null)));
        }
        const F3 = new TimeSlotManager();
        return new Promise(function promiseBody(e4, d4) {
          const next = function(t4) {
            enqueueChunk(true), Promise.all([t4, n3.ready]).then(function() {
              try {
                promiseBody(e4, d4);
              } catch (e5) {
                d4(e5);
              }
            }, d4);
          };
          t3.ensureNotTerminated(), F3.reset();
          const u4 = {};
          let Q4, k3 = [];
          for (; !(Q4 = F3.check()) && (k3.length = 0, u4.args = k3, D3.read(u4)); ) {
            const e5 = S3;
            S3 = a3.state;
            const d5 = u4.fn;
            switch (k3 = u4.args, 0 | d5) {
              case Ra:
                var R3 = k3[0].name, x3 = k3[1];
                if (S3.font && R3 === S3.fontName && x3 === S3.fontSize) break;
                return flushTextContentItem(), S3.fontName = R3, S3.fontSize = x3, void next(handleSetFont(R3, null));
              case Na:
                S3.textRise = k3[0];
                break;
              case Fa:
                S3.textHScale = k3[0] / 100;
                break;
              case ka:
                S3.leading = k3[0];
                break;
              case Ma:
                S3.translateTextLineMatrix(k3[0], k3[1]), S3.textMatrix = S3.textLineMatrix.slice();
                break;
              case Ga:
                S3.leading = -k3[1], S3.translateTextLineMatrix(k3[0], k3[1]), S3.textMatrix = S3.textLineMatrix.slice();
                break;
              case La:
                S3.carriageReturn();
                break;
              case va:
                S3.setTextMatrix(k3[0], k3[1], k3[2], k3[3], k3[4], k3[5]), S3.setTextLineMatrix(k3[0], k3[1], k3[2], k3[3], k3[4], k3[5]), updateAdvanceScale();
                break;
              case Da:
                S3.charSpacing = k3[0];
                break;
              case Sa:
                S3.wordSpacing = k3[0];
                break;
              case wa:
                S3.textMatrix = DA.slice(), S3.textLineMatrix = DA.slice();
                break;
              case Ha:
                if (!a3.state.font) {
                  f3.ensureStateFont(a3.state);
                  continue;
                }
                const d6 = (S3.font.vertical ? 1 : -1) * S3.fontSize / 1e3, u5 = k3[0];
                for (let e6 = 0, t4 = u5.length; e6 < t4; e6++) {
                  const t5 = u5[e6];
                  if ("string" == typeof t5) m3.push(t5);
                  else if ("number" == typeof t5 && 0 !== t5) {
                    const e7 = m3.join("");
                    m3.length = 0, buildTextContentItem({ chars: e7, extraSpacing: t5 * d6 });
                  }
                }
                if (m3.length > 0) {
                  const e6 = m3.join("");
                  m3.length = 0, buildTextContentItem({ chars: e6, extraSpacing: 0 });
                }
                break;
              case Ua:
                if (!a3.state.font) {
                  f3.ensureStateFont(a3.state);
                  continue;
                }
                buildTextContentItem({ chars: k3[0], extraSpacing: 0 });
                break;
              case Ta:
                if (!a3.state.font) {
                  f3.ensureStateFont(a3.state);
                  continue;
                }
                S3.carriageReturn(), buildTextContentItem({ chars: k3[0], extraSpacing: 0 });
                break;
              case Ja:
                if (!a3.state.font) {
                  f3.ensureStateFont(a3.state);
                  continue;
                }
                S3.wordSpacing = k3[0], S3.charSpacing = k3[1], S3.carriageReturn(), buildTextContentItem({ chars: k3[2], extraSpacing: 0 });
                break;
              case ss:
                flushTextContentItem(), y3 || (y3 = i3.get("XObject") || Dict.empty);
                var N3 = k3[0] instanceof Name, M3 = k3[0].name;
                if (N3 && w3.getByName(M3)) break;
                return void next(new Promise(function(e6, C4) {
                  if (!N3) throw new FormatError("XObject must be referred to by name.");
                  let d7 = y3.getRaw(M3);
                  if (d7 instanceof Ref) {
                    if (w3.getByRef(d7)) return void e6();
                    if (f3.globalImageCache.getData(d7, f3.pageIndex)) return void e6();
                    d7 = p3.fetch(d7);
                  }
                  if (!(d7 instanceof BaseStream)) throw new FormatError("XObject should be a stream");
                  const u6 = d7.dict.get("Subtype");
                  if (!(u6 instanceof Name)) throw new FormatError("XObject should have a Name subtype");
                  if ("Form" !== u6.name) return w3.set(M3, d7.dict.objId, true), void e6();
                  const Q5 = a3.state.clone(), m4 = new StateManager(Q5), b4 = lookupMatrix(d7.dict.getArray("Matrix"), null);
                  b4 && m4.transform(b4), enqueueChunk();
                  const D4 = { enqueueInvoked: false, enqueue(e7, t4) {
                    this.enqueueInvoked = true, n3.enqueue(e7, t4);
                  }, get desiredSize() {
                    return n3.desiredSize;
                  }, get ready() {
                    return n3.ready;
                  } };
                  f3.getTextContent({ stream: d7, task: t3, resources: d7.dict.get("Resources") || i3, stateManager: m4, includeMarkedContent: s3, sink: D4, seenStyles: r3, viewBox: o3, lang: g3, markedContentData: c3, disableNormalization: h3, keepWhiteSpace: l3 }).then(function() {
                    D4.enqueueInvoked || w3.set(M3, d7.dict.objId, true), e6();
                  }, C4);
                }).catch(function(e6) {
                  if (!(e6 instanceof AbortException)) {
                    if (!f3.options.ignoreErrors) throw e6;
                    warn(`getTextContent - ignoring XObject: "${e6}".`);
                  }
                }));
              case Aa:
                if (N3 = k3[0] instanceof Name, M3 = k3[0].name, N3 && b3.getByName(M3)) break;
                return void next(new Promise(function(e6, t4) {
                  if (!N3) throw new FormatError("GState must be referred to by name.");
                  const a4 = i3.get("ExtGState");
                  if (!(a4 instanceof Dict)) throw new FormatError("ExtGState should be a dictionary.");
                  const s4 = a4.get(M3);
                  if (!(s4 instanceof Dict)) throw new FormatError("GState should be a dictionary.");
                  const n4 = s4.get("Font");
                  if (!n4) return b3.set(M3, s4.objId, true), void e6();
                  flushTextContentItem(), S3.fontName = null, S3.fontSize = n4[1], handleSetFont(null, n4[0]).then(e6, t4);
                }).catch(function(e6) {
                  if (!(e6 instanceof AbortException)) {
                    if (!f3.options.ignoreErrors) throw e6;
                    warn(`getTextContent - ignoring ExtGState: "${e6}".`);
                  }
                }));
              case os:
                flushTextContentItem(), s3 && (c3.level++, C3.items.push({ type: "beginMarkedContent", tag: k3[0] instanceof Name ? k3[0].name : null }));
                break;
              case gs:
                if (flushTextContentItem(), s3) {
                  c3.level++;
                  let e6 = null;
                  k3[1] instanceof Dict && (e6 = k3[1].get("MCID")), C3.items.push({ type: "beginMarkedContentProps", id: Number.isInteger(e6) ? `${f3.idFactory.getPageObjId()}_mc${e6}` : null, tag: k3[0] instanceof Name ? k3[0].name : null });
                }
                break;
              case cs:
                if (flushTextContentItem(), s3) {
                  if (0 === c3.level) break;
                  c3.level--, C3.items.push({ type: "endMarkedContent" });
                }
                break;
              case aa:
                !e5 || e5.font === S3.font && e5.fontSize === S3.fontSize && e5.fontName === S3.fontName || flushTextContentItem();
            }
            if (C3.items.length >= n3.desiredSize) {
              Q4 = true;
              break;
            }
          }
          Q4 ? next(ig) : (flushTextContentItem(), enqueueChunk(), e4());
        }).catch((e4) => {
          if (!(e4 instanceof AbortException)) {
            if (this.options.ignoreErrors) return warn(`getTextContent - ignoring errors during "${t3.name}" task: "${e4}".`), flushTextContentItem(), void enqueueChunk();
            throw e4;
          }
        });
      }
      async extractDataStructures(e3, t3) {
        const i3 = this.xref;
        let a3;
        const s3 = this.readToUnicode(t3.toUnicode);
        if (t3.composite) {
          const i4 = e3.get("CIDSystemInfo");
          i4 instanceof Dict && (t3.cidSystemInfo = { registry: stringToPDFString(i4.get("Registry")), ordering: stringToPDFString(i4.get("Ordering")), supplement: i4.get("Supplement") });
          try {
            const t4 = e3.get("CIDToGIDMap");
            t4 instanceof BaseStream && (a3 = t4.getBytes());
          } catch (e4) {
            if (!this.options.ignoreErrors) throw e4;
            warn(`extractDataStructures - ignoring CIDToGIDMap data: "${e4}".`);
          }
        }
        const n3 = [];
        let r3, o3 = null;
        if (e3.has("Encoding")) {
          if (r3 = e3.get("Encoding"), r3 instanceof Dict) {
            if (o3 = r3.get("BaseEncoding"), o3 = o3 instanceof Name ? o3.name : null, r3.has("Differences")) {
              const e4 = r3.get("Differences");
              let t4 = 0;
              for (const a4 of e4) {
                const e5 = i3.fetchIfRef(a4);
                if ("number" == typeof e5) t4 = e5;
                else {
                  if (!(e5 instanceof Name)) throw new FormatError(`Invalid entry in 'Differences' array: ${e5}`);
                  n3[t4++] = e5.name;
                }
              }
            }
          } else if (r3 instanceof Name) o3 = r3.name;
          else {
            const e4 = "Encoding is not a Name nor a Dict";
            if (!this.options.ignoreErrors) throw new FormatError(e4);
            warn(e4);
          }
          "MacRomanEncoding" !== o3 && "MacExpertEncoding" !== o3 && "WinAnsiEncoding" !== o3 && (o3 = null);
        }
        const g3 = !t3.file || t3.isInternalFont, c3 = pr()[t3.name];
        if (o3 && g3 && c3 && (o3 = null), o3) t3.defaultEncoding = getEncoding(o3);
        else {
          const e4 = !!(t3.flags & lr), i4 = !!(t3.flags & Ir);
          r3 = _n2, "TrueType" !== t3.type || i4 || (r3 = Wn), (e4 || c3) && (r3 = qn, g3 && (/Symbol/i.test(t3.name) ? r3 = jn : /Dingbats/i.test(t3.name) ? r3 = Xn : /Wingdings/i.test(t3.name) && (r3 = Wn))), t3.defaultEncoding = r3;
        }
        t3.differences = n3, t3.baseEncodingName = o3, t3.hasEncoding = !!o3 || n3.length > 0, t3.dict = e3, t3.toUnicode = await s3;
        const h3 = await this.buildToUnicode(t3);
        return t3.toUnicode = h3, a3 && (t3.cidToGidMap = this.readCidToGidMap(a3, h3)), t3;
      }
      _simpleFontToUnicode(e3, t3 = false) {
        assert(!e3.composite, "Must be a simple font.");
        const i3 = [], a3 = e3.defaultEncoding.slice(), s3 = e3.baseEncodingName, n3 = e3.differences;
        for (const e4 in n3) {
          const t4 = n3[e4];
          ".notdef" !== t4 && (a3[e4] = t4);
        }
        const r3 = ir();
        for (const n4 in a3) {
          let o3 = a3[n4];
          if ("" === o3) continue;
          let g3 = r3[o3];
          if (void 0 !== g3) {
            i3[n4] = String.fromCharCode(g3);
            continue;
          }
          let c3 = 0;
          switch (o3[0]) {
            case "G":
              3 === o3.length && (c3 = parseInt(o3.substring(1), 16));
              break;
            case "g":
              5 === o3.length && (c3 = parseInt(o3.substring(1), 16));
              break;
            case "C":
            case "c":
              if (o3.length >= 3 && o3.length <= 4) {
                const i4 = o3.substring(1);
                if (t3) {
                  c3 = parseInt(i4, 16);
                  break;
                }
                if (c3 = +i4, Number.isNaN(c3) && Number.isInteger(parseInt(i4, 16))) return this._simpleFontToUnicode(e3, true);
              }
              break;
            case "u":
              g3 = getUnicodeForGlyph(o3, r3), -1 !== g3 && (c3 = g3);
              break;
            default:
              switch (o3) {
                case "f_h":
                case "f_t":
                case "T_h":
                  i3[n4] = o3.replaceAll("_", "");
                  continue;
              }
          }
          if (c3 > 0 && c3 <= 1114111 && Number.isInteger(c3)) {
            if (s3 && c3 === +n4) {
              const e4 = getEncoding(s3);
              if (e4 && (o3 = e4[n4])) {
                i3[n4] = String.fromCharCode(r3[o3]);
                continue;
              }
            }
            i3[n4] = String.fromCodePoint(c3);
          }
        }
        return i3;
      }
      async buildToUnicode(e3) {
        if (e3.hasIncludedToUnicodeMap = e3.toUnicode?.length > 0, e3.hasIncludedToUnicodeMap) return !e3.composite && e3.hasEncoding && (e3.fallbackToUnicode = this._simpleFontToUnicode(e3)), e3.toUnicode;
        if (!e3.composite) return new ToUnicodeMap(this._simpleFontToUnicode(e3));
        if (e3.composite && (e3.cMap.builtInCMap && !(e3.cMap instanceof IdentityCMap) || "Adobe" === e3.cidSystemInfo?.registry && ("GB1" === e3.cidSystemInfo.ordering || "CNS1" === e3.cidSystemInfo.ordering || "Japan1" === e3.cidSystemInfo.ordering || "Korea1" === e3.cidSystemInfo.ordering))) {
          const { registry: t3, ordering: i3 } = e3.cidSystemInfo, a3 = Name.get(`${t3}-${i3}-UCS2`), s3 = await CMapFactory.create({ encoding: a3, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null }), n3 = [], r3 = [];
          return e3.cMap.forEach(function(e4, t4) {
            if (t4 > 65535) throw new FormatError("Max size of CID is 65,535");
            const i4 = s3.lookup(t4);
            if (i4) {
              r3.length = 0;
              for (let e5 = 0, t5 = i4.length; e5 < t5; e5 += 2) r3.push((i4.charCodeAt(e5) << 8) + i4.charCodeAt(e5 + 1));
              n3[e4] = String.fromCharCode(...r3);
            }
          }), new ToUnicodeMap(n3);
        }
        return new IdentityToUnicodeMap(e3.firstChar, e3.lastChar);
      }
      async readToUnicode(e3) {
        if (!e3) return null;
        if (e3 instanceof Name) {
          const t3 = await CMapFactory.create({ encoding: e3, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
          return t3 instanceof IdentityCMap ? new IdentityToUnicodeMap(0, 65535) : new ToUnicodeMap(t3.getMap());
        }
        if (e3 instanceof BaseStream) try {
          const t3 = await CMapFactory.create({ encoding: e3, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
          if (t3 instanceof IdentityCMap) return new IdentityToUnicodeMap(0, 65535);
          const i3 = new Array(t3.length);
          return t3.forEach(function(e4, t4) {
            if ("number" == typeof t4) return void (i3[e4] = String.fromCodePoint(t4));
            t4.length % 2 != 0 && (t4 = "\0" + t4);
            const a3 = [];
            for (let e5 = 0; e5 < t4.length; e5 += 2) {
              const i4 = t4.charCodeAt(e5) << 8 | t4.charCodeAt(e5 + 1);
              if (55296 != (63488 & i4)) {
                a3.push(i4);
                continue;
              }
              e5 += 2;
              const s3 = t4.charCodeAt(e5) << 8 | t4.charCodeAt(e5 + 1);
              a3.push(((1023 & i4) << 10) + (1023 & s3) + 65536);
            }
            i3[e4] = String.fromCodePoint(...a3);
          }), new ToUnicodeMap(i3);
        } catch (e4) {
          if (e4 instanceof AbortException) return null;
          if (this.options.ignoreErrors) return warn(`readToUnicode - ignoring ToUnicode data: "${e4}".`), null;
          throw e4;
        }
        return null;
      }
      readCidToGidMap(e3, t3) {
        const i3 = [];
        for (let a3 = 0, s3 = e3.length; a3 < s3; a3++) {
          const s4 = e3[a3++] << 8 | e3[a3], n3 = a3 >> 1;
          (0 !== s4 || t3.has(n3)) && (i3[n3] = s4);
        }
        return i3;
      }
      extractWidths(e3, t3, i3) {
        const a3 = this.xref;
        let s3 = [], n3 = 0;
        const r3 = [];
        let o3;
        if (i3.composite) {
          const t4 = e3.get("DW");
          n3 = "number" == typeof t4 ? Math.ceil(t4) : 1e3;
          const g4 = e3.get("W");
          if (Array.isArray(g4)) for (let e4 = 0, t5 = g4.length; e4 < t5; e4++) {
            let t6 = a3.fetchIfRef(g4[e4++]);
            if (!Number.isInteger(t6)) break;
            const i4 = a3.fetchIfRef(g4[e4]);
            if (Array.isArray(i4)) for (const e5 of i4) {
              const i5 = a3.fetchIfRef(e5);
              "number" == typeof i5 && (s3[t6] = i5), t6++;
            }
            else {
              if (!Number.isInteger(i4)) break;
              {
                const n4 = a3.fetchIfRef(g4[++e4]);
                if ("number" != typeof n4) continue;
                for (let e5 = t6; e5 <= i4; e5++) s3[e5] = n4;
              }
            }
          }
          if (i3.vertical) {
            const t5 = e3.getArray("DW2");
            let i4 = isNumberArray(t5, 2) ? t5 : [880, -1e3];
            if (o3 = [i4[1], 0.5 * n3, i4[0]], i4 = e3.get("W2"), Array.isArray(i4)) for (let e4 = 0, t6 = i4.length; e4 < t6; e4++) {
              let t7 = a3.fetchIfRef(i4[e4++]);
              if (!Number.isInteger(t7)) break;
              const s4 = a3.fetchIfRef(i4[e4]);
              if (Array.isArray(s4)) for (let e5 = 0, i5 = s4.length; e5 < i5; e5++) {
                const i6 = [a3.fetchIfRef(s4[e5++]), a3.fetchIfRef(s4[e5++]), a3.fetchIfRef(s4[e5])];
                isNumberArray(i6, null) && (r3[t7] = i6), t7++;
              }
              else {
                if (!Number.isInteger(s4)) break;
                {
                  const n4 = [a3.fetchIfRef(i4[++e4]), a3.fetchIfRef(i4[++e4]), a3.fetchIfRef(i4[++e4])];
                  if (!isNumberArray(n4, null)) continue;
                  for (let e5 = t7; e5 <= s4; e5++) r3[e5] = n4;
                }
              }
            }
          }
        } else {
          const r4 = e3.get("Widths");
          if (Array.isArray(r4)) {
            let e4 = i3.firstChar;
            for (const t4 of r4) {
              const i4 = a3.fetchIfRef(t4);
              "number" == typeof i4 && (s3[e4] = i4), e4++;
            }
            const o4 = t3.get("MissingWidth");
            n3 = "number" == typeof o4 ? o4 : 0;
          } else {
            const t4 = e3.get("BaseFont");
            if (t4 instanceof Name) {
              const e4 = this.getBaseFontMetrics(t4.name);
              s3 = this.buildCharCodeToWidth(e4.widths, i3), n3 = e4.defaultWidth;
            }
          }
        }
        let g3 = true, c3 = n3;
        for (const e4 in s3) {
          const t4 = s3[e4];
          if (t4) if (c3) {
            if (c3 !== t4) {
              g3 = false;
              break;
            }
          } else c3 = t4;
        }
        g3 ? i3.flags |= cr : i3.flags &= ~cr, i3.defaultWidth = n3, i3.widths = s3, i3.defaultVMetrics = o3, i3.vmetrics = r3;
      }
      isSerifFont(e3) {
        const t3 = e3.split("-", 1)[0];
        return t3 in fr() || /serif/gi.test(t3);
      }
      getBaseFontMetrics(e3) {
        let t3 = 0, i3 = /* @__PURE__ */ Object.create(null), a3 = false;
        let s3 = ur()[e3] || e3;
        const n3 = Dr();
        s3 in n3 || (s3 = this.isSerifFont(e3) ? "Times-Roman" : "Helvetica");
        const r3 = n3[s3];
        return "number" == typeof r3 ? (t3 = r3, a3 = true) : i3 = r3(), { defaultWidth: t3, monospace: a3, widths: i3 };
      }
      buildCharCodeToWidth(e3, t3) {
        const i3 = /* @__PURE__ */ Object.create(null), a3 = t3.differences, s3 = t3.defaultEncoding;
        for (let t4 = 0; t4 < 256; t4++) t4 in a3 && e3[a3[t4]] ? i3[t4] = e3[a3[t4]] : t4 in s3 && e3[s3[t4]] && (i3[t4] = e3[s3[t4]]);
        return i3;
      }
      preEvaluateFont(e3) {
        const t3 = e3;
        let i3 = e3.get("Subtype");
        if (!(i3 instanceof Name)) throw new FormatError("invalid font Subtype");
        let a3, s3 = false;
        if ("Type0" === i3.name) {
          const t4 = e3.get("DescendantFonts");
          if (!t4) throw new FormatError("Descendant fonts are not specified");
          if (!((e3 = Array.isArray(t4) ? this.xref.fetchIfRef(t4[0]) : t4) instanceof Dict)) throw new FormatError("Descendant font is not a dictionary.");
          if (i3 = e3.get("Subtype"), !(i3 instanceof Name)) throw new FormatError("invalid font Subtype");
          s3 = true;
        }
        let n3 = e3.get("FirstChar");
        Number.isInteger(n3) || (n3 = 0);
        let r3 = e3.get("LastChar");
        Number.isInteger(r3) || (r3 = s3 ? 65535 : 255);
        const o3 = e3.get("FontDescriptor"), g3 = e3.get("ToUnicode") || t3.get("ToUnicode");
        if (o3) {
          a3 = new MurmurHash3_64();
          const i4 = t3.getRaw("Encoding");
          if (i4 instanceof Name) a3.update(i4.name);
          else if (i4 instanceof Ref) a3.update(i4.toString());
          else if (i4 instanceof Dict) {
            for (const e4 of i4.getRawValues()) if (e4 instanceof Name) a3.update(e4.name);
            else if (e4 instanceof Ref) a3.update(e4.toString());
            else if (Array.isArray(e4)) {
              const t4 = e4.length, i5 = new Array(t4);
              for (let a4 = 0; a4 < t4; a4++) {
                const t5 = e4[a4];
                t5 instanceof Name ? i5[a4] = t5.name : ("number" == typeof t5 || t5 instanceof Ref) && (i5[a4] = t5.toString());
              }
              a3.update(i5.join());
            }
          }
          if (a3.update(`${n3}-${r3}`), g3 instanceof BaseStream) {
            const e4 = g3.str || g3, t4 = e4.buffer ? new Uint8Array(e4.buffer.buffer, 0, e4.bufferLength) : new Uint8Array(e4.bytes.buffer, e4.start, e4.end - e4.start);
            a3.update(t4);
          } else g3 instanceof Name && a3.update(g3.name);
          const o4 = e3.get("Widths") || t3.get("Widths");
          if (Array.isArray(o4)) {
            const e4 = [];
            for (const t4 of o4) ("number" == typeof t4 || t4 instanceof Ref) && e4.push(t4.toString());
            a3.update(e4.join());
          }
          if (s3) {
            a3.update("compositeFont");
            const i5 = e3.get("W") || t3.get("W");
            if (Array.isArray(i5)) {
              const e4 = [];
              for (const t4 of i5) if ("number" == typeof t4 || t4 instanceof Ref) e4.push(t4.toString());
              else if (Array.isArray(t4)) {
                const i6 = [];
                for (const e5 of t4) ("number" == typeof e5 || e5 instanceof Ref) && i6.push(e5.toString());
                e4.push(`[${i6.join()}]`);
              }
              a3.update(e4.join());
            }
            const s4 = e3.getRaw("CIDToGIDMap") || t3.getRaw("CIDToGIDMap");
            s4 instanceof Name ? a3.update(s4.name) : s4 instanceof Ref ? a3.update(s4.toString()) : s4 instanceof BaseStream && a3.update(s4.peekBytes());
          }
        }
        return { descriptor: o3, dict: e3, baseDict: t3, composite: s3, type: i3.name, firstChar: n3, lastChar: r3, toUnicode: g3, hash: a3 ? a3.hexdigest() : "" };
      }
      async translateFont({ descriptor: e3, dict: t3, baseDict: i3, composite: a3, type: s3, firstChar: n3, lastChar: r3, toUnicode: o3, cssFontInfo: g3 }) {
        const c3 = "Type3" === s3;
        if (!e3) {
          if (!c3) {
            let e4 = t3.get("BaseFont");
            if (!(e4 instanceof Name)) throw new FormatError("Base font is not specified");
            e4 = e4.name.replaceAll(/[,_]/g, "-");
            const a4 = this.getBaseFontMetrics(e4), g4 = e4.split("-", 1)[0], h4 = (this.isSerifFont(g4) ? hr : 0) | (a4.monospace ? cr : 0) | (pr()[g4] ? lr : Ir), l4 = { type: s3, name: e4, loadedName: i3.loadedName, systemFontInfo: null, widths: a4.widths, defaultWidth: a4.defaultWidth, isSimulatedFlags: true, flags: h4, firstChar: n3, lastChar: r3, toUnicode: o3, xHeight: 0, capHeight: 0, italicAngle: 0, isType3Font: c3 }, C4 = t3.get("Widths"), d4 = getStandardFontName(e4);
            let u4 = null;
            d4 && (u4 = await this.fetchStandardFontData(d4), l4.isInternalFont = !!u4), !l4.isInternalFont && this.options.useSystemFonts && (l4.systemFontInfo = getFontSubstitution(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, e4, d4, s3));
            const Q4 = await this.extractDataStructures(t3, l4);
            if (Array.isArray(C4)) {
              const e5 = [];
              let t4 = n3;
              for (const i4 of C4) {
                const a5 = this.xref.fetchIfRef(i4);
                "number" == typeof a5 && (e5[t4] = a5), t4++;
              }
              Q4.widths = e5;
            } else Q4.widths = this.buildCharCodeToWidth(a4.widths, Q4);
            return new Font(e4, u4, Q4);
          }
          {
            const i4 = lookupNormalRect(t3.getArray("FontBBox"), [0, 0, 0, 0]);
            (e3 = new Dict(null)).set("FontName", Name.get(s3)), e3.set("FontBBox", i4);
          }
        }
        let h3 = e3.get("FontName"), l3 = t3.get("BaseFont");
        "string" == typeof h3 && (h3 = Name.get(h3)), "string" == typeof l3 && (l3 = Name.get(l3));
        const C3 = h3?.name, d3 = l3?.name;
        if (c3 || C3 === d3 || (info(`The FontDescriptor's FontName is "${C3}" but should be the same as the Font's BaseFont "${d3}".`), C3 && d3 && (d3.startsWith(C3) || !isKnownFontName(C3) && isKnownFontName(d3)) && (h3 = null)), h3 || (h3 = l3), !(h3 instanceof Name)) throw new FormatError("invalid font name");
        let u3, Q3, f3, p3, m3;
        try {
          u3 = e3.get("FontFile", "FontFile2", "FontFile3");
        } catch (e4) {
          if (!this.options.ignoreErrors) throw e4;
          warn(`translateFont - fetching "${h3.name}" font file: "${e4}".`), u3 = new NullStream();
        }
        let y3 = false, w3 = null, b3 = null;
        if (u3) {
          if (u3.dict) {
            const e4 = u3.dict.get("Subtype");
            e4 instanceof Name && (Q3 = e4.name), f3 = u3.dict.get("Length1"), p3 = u3.dict.get("Length2"), m3 = u3.dict.get("Length3");
          }
        } else if (g3) {
          const e4 = getXfaFontName(h3.name);
          e4 && (g3.fontFamily = `${g3.fontFamily}-PdfJS-XFA`, g3.metrics = e4.metrics || null, w3 = e4.factors || null, u3 = await this.fetchStandardFontData(e4.name), y3 = !!u3, i3 = t3 = getXfaFontDict(h3.name), a3 = true);
        } else if (!c3) {
          const e4 = getStandardFontName(h3.name);
          e4 && (u3 = await this.fetchStandardFontData(e4), y3 = !!u3), !y3 && this.options.useSystemFonts && (b3 = getFontSubstitution(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, h3.name, e4, s3));
        }
        const D3 = lookupMatrix(t3.getArray("FontMatrix"), SA), S3 = lookupNormalRect(e3.getArray("FontBBox") || t3.getArray("FontBBox"), void 0);
        let F3 = e3.get("Ascent");
        "number" != typeof F3 && (F3 = void 0);
        let k3 = e3.get("Descent");
        "number" != typeof k3 && (k3 = void 0);
        let R3 = e3.get("XHeight");
        "number" != typeof R3 && (R3 = 0);
        let x3 = e3.get("CapHeight");
        "number" != typeof x3 && (x3 = 0);
        let N3 = e3.get("Flags");
        Number.isInteger(N3) || (N3 = 0);
        let M3 = e3.get("ItalicAngle");
        "number" != typeof M3 && (M3 = 0);
        const G3 = { type: s3, name: h3.name, subtype: Q3, file: u3, length1: f3, length2: p3, length3: m3, isInternalFont: y3, loadedName: i3.loadedName, composite: a3, fixedPitch: false, fontMatrix: D3, firstChar: n3, lastChar: r3, toUnicode: o3, bbox: S3, ascent: F3, descent: k3, xHeight: R3, capHeight: x3, flags: N3, italicAngle: M3, isType3Font: c3, cssFontInfo: g3, scaleFactors: w3, systemFontInfo: b3 };
        if (a3) {
          const e4 = i3.get("Encoding");
          e4 instanceof Name && (G3.cidEncoding = e4.name);
          const t4 = await CMapFactory.create({ encoding: e4, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
          G3.cMap = t4, G3.vertical = G3.cMap.vertical;
        }
        const v3 = await this.extractDataStructures(t3, G3);
        return this.extractWidths(t3, e3, v3), new Font(h3.name, u3, v3);
      }
      static buildFontPaths(e3, t3, i3, a3) {
        function buildPath(t4) {
          const s3 = `${e3.loadedName}_path_${t4}`;
          try {
            if (e3.renderer.hasBuiltPath(t4)) return;
            i3.send("commonobj", [s3, "FontPath", e3.renderer.getPathJs(t4)]);
          } catch (e4) {
            if (a3.ignoreErrors) return void warn(`buildFontPaths - ignoring ${s3} glyph: "${e4}".`);
            throw e4;
          }
        }
        for (const e4 of t3) {
          buildPath(e4.fontChar);
          const t4 = e4.accent;
          t4?.fontChar && buildPath(t4.fontChar);
        }
      }
      static get fallbackFontDict() {
        const e3 = new Dict();
        return e3.set("BaseFont", Name.get("Helvetica")), e3.set("Type", Name.get("FallbackType")), e3.set("Subtype", Name.get("FallbackType")), e3.set("Encoding", Name.get("WinAnsiEncoding")), shadow(this, "fallbackFontDict", e3);
      }
    };
    TranslatedFont = class {
      constructor({ loadedName: e3, font: t3, dict: i3, evaluatorOptions: a3 }) {
        this.loadedName = e3, this.font = t3, this.dict = i3, this._evaluatorOptions = a3 || eg, this.type3Loaded = null, this.type3Dependencies = t3.isType3Font ? /* @__PURE__ */ new Set() : null, this.sent = false;
      }
      send(e3) {
        this.sent || (this.sent = true, e3.send("commonobj", [this.loadedName, "Font", this.font.exportData(this._evaluatorOptions.fontExtraProperties)]));
      }
      fallback(e3) {
        this.font.data && (this.font.disableFontFace = true, PartialEvaluator.buildFontPaths(this.font, this.font.glyphCacheValues, e3, this._evaluatorOptions));
      }
      loadType3Data(e3, t3, i3) {
        if (this.type3Loaded) return this.type3Loaded;
        if (!this.font.isType3Font) throw new Error("Must be a Type3 font.");
        const a3 = e3.clone({ ignoreErrors: false }), s3 = new RefSet(e3.type3FontRefs);
        this.dict.objId && !s3.has(this.dict.objId) && s3.put(this.dict.objId), a3.type3FontRefs = s3;
        const n3 = this.font, r3 = this.type3Dependencies;
        let o3 = Promise.resolve();
        const g3 = this.dict.get("CharProcs"), c3 = this.dict.get("Resources") || t3, h3 = /* @__PURE__ */ Object.create(null), l3 = Util.normalizeRect(n3.bbox || [0, 0, 0, 0]), C3 = l3[2] - l3[0], d3 = l3[3] - l3[1], u3 = Math.hypot(C3, d3);
        for (const e4 of g3.getKeys()) o3 = o3.then(() => {
          const t4 = g3.get(e4), s4 = new OperatorList();
          return a3.getOperatorList({ stream: t4, task: i3, resources: c3, operatorList: s4 }).then(() => {
            s4.fnArray[0] === Pa && this._removeType3ColorOperators(s4, u3), h3[e4] = s4.getIR();
            for (const e5 of s4.dependencies) r3.add(e5);
          }).catch(function(t5) {
            warn(`Type3 font resource "${e4}" is not available.`);
            const i4 = new OperatorList();
            h3[e4] = i4.getIR();
          });
        });
        return this.type3Loaded = o3.then(() => {
          n3.charProcOperatorList = h3, this._bbox && (n3.isCharBBox = true, n3.bbox = this._bbox);
        }), this.type3Loaded;
      }
      _removeType3ColorOperators(e3, t3 = NaN) {
        const i3 = Util.normalizeRect(e3.argsArray[0].slice(2)), a3 = i3[2] - i3[0], s3 = i3[3] - i3[1], n3 = Math.hypot(a3, s3);
        0 === a3 || 0 === s3 ? (e3.fnArray.splice(0, 1), e3.argsArray.splice(0, 1)) : (0 === t3 || Math.round(n3 / t3) >= 10) && (this._bbox || (this._bbox = [1 / 0, 1 / 0, -1 / 0, -1 / 0]), this._bbox[0] = Math.min(this._bbox[0], i3[0]), this._bbox[1] = Math.min(this._bbox[1], i3[1]), this._bbox[2] = Math.max(this._bbox[2], i3[2]), this._bbox[3] = Math.max(this._bbox[3], i3[3]));
        let r3 = 0, o3 = e3.length;
        for (; r3 < o3; ) {
          switch (e3.fnArray[r3]) {
            case Pa:
              break;
            case Oa:
            case Ka:
            case qa:
            case _a:
            case Wa:
            case ja:
            case Xa:
            case Va:
            case Za:
            case za:
            case $a:
            case es:
            case ts:
            case ea:
              e3.fnArray.splice(r3, 1), e3.argsArray.splice(r3, 1), o3--;
              continue;
            case Aa:
              const [t4] = e3.argsArray[r3];
              let i4 = 0, a4 = t4.length;
              for (; i4 < a4; ) {
                const [e4] = t4[i4];
                switch (e4) {
                  case "TR":
                  case "TR2":
                  case "HT":
                  case "BG":
                  case "BG2":
                  case "UCR":
                  case "UCR2":
                    t4.splice(i4, 1), a4--;
                    continue;
                }
                i4++;
              }
          }
          r3++;
        }
      }
    };
    StateManager = class {
      constructor(e3 = new EvalState()) {
        this.state = e3, this.stateStack = [];
      }
      save() {
        const e3 = this.state;
        this.stateStack.push(this.state), this.state = e3.clone();
      }
      restore() {
        const e3 = this.stateStack.pop();
        e3 && (this.state = e3);
      }
      transform(e3) {
        this.state.ctm = Util.transform(this.state.ctm, e3);
      }
    };
    TextState = class {
      constructor() {
        this.ctm = new Float32Array(DA), this.fontName = null, this.fontSize = 0, this.loadedName = null, this.font = null, this.fontMatrix = SA, this.textMatrix = DA.slice(), this.textLineMatrix = DA.slice(), this.charSpacing = 0, this.wordSpacing = 0, this.leading = 0, this.textHScale = 1, this.textRise = 0;
      }
      setTextMatrix(e3, t3, i3, a3, s3, n3) {
        const r3 = this.textMatrix;
        r3[0] = e3, r3[1] = t3, r3[2] = i3, r3[3] = a3, r3[4] = s3, r3[5] = n3;
      }
      setTextLineMatrix(e3, t3, i3, a3, s3, n3) {
        const r3 = this.textLineMatrix;
        r3[0] = e3, r3[1] = t3, r3[2] = i3, r3[3] = a3, r3[4] = s3, r3[5] = n3;
      }
      translateTextMatrix(e3, t3) {
        const i3 = this.textMatrix;
        i3[4] = i3[0] * e3 + i3[2] * t3 + i3[4], i3[5] = i3[1] * e3 + i3[3] * t3 + i3[5];
      }
      translateTextLineMatrix(e3, t3) {
        const i3 = this.textLineMatrix;
        i3[4] = i3[0] * e3 + i3[2] * t3 + i3[4], i3[5] = i3[1] * e3 + i3[3] * t3 + i3[5];
      }
      carriageReturn() {
        this.translateTextLineMatrix(0, -this.leading), this.textMatrix = this.textLineMatrix.slice();
      }
      clone() {
        const e3 = Object.create(this);
        return e3.textMatrix = this.textMatrix.slice(), e3.textLineMatrix = this.textLineMatrix.slice(), e3.fontMatrix = this.fontMatrix.slice(), e3;
      }
    };
    EvalState = class {
      constructor() {
        this.ctm = new Float32Array(DA), this.font = null, this.textRenderingMode = qA, this._fillColorSpace = ColorSpace.singletons.gray, this._strokeColorSpace = ColorSpace.singletons.gray, this.patternFillColorSpace = null, this.patternStrokeColorSpace = null;
      }
      get fillColorSpace() {
        return this._fillColorSpace;
      }
      set fillColorSpace(e3) {
        this._fillColorSpace = this.patternFillColorSpace = e3;
      }
      get strokeColorSpace() {
        return this._strokeColorSpace;
      }
      set strokeColorSpace(e3) {
        this._strokeColorSpace = this.patternStrokeColorSpace = e3;
      }
      clone() {
        return Object.create(this);
      }
    };
    _EvaluatorPreprocessor = class _EvaluatorPreprocessor {
      static get opMap() {
        return shadow(this, "opMap", Object.assign(/* @__PURE__ */ Object.create(null), { w: { id: Xi, numArgs: 1, variableArgs: false }, J: { id: Vi, numArgs: 1, variableArgs: false }, j: { id: Zi, numArgs: 1, variableArgs: false }, M: { id: zi, numArgs: 1, variableArgs: false }, d: { id: $i, numArgs: 2, variableArgs: false }, ri: { id: ea, numArgs: 1, variableArgs: false }, i: { id: ta, numArgs: 1, variableArgs: false }, gs: { id: Aa, numArgs: 1, variableArgs: false }, q: { id: ia, numArgs: 0, variableArgs: false }, Q: { id: aa, numArgs: 0, variableArgs: false }, cm: { id: sa, numArgs: 6, variableArgs: false }, m: { id: na, numArgs: 2, variableArgs: false }, l: { id: ra, numArgs: 2, variableArgs: false }, c: { id: oa, numArgs: 6, variableArgs: false }, v: { id: ga, numArgs: 4, variableArgs: false }, y: { id: ca, numArgs: 4, variableArgs: false }, h: { id: ha, numArgs: 0, variableArgs: false }, re: { id: la, numArgs: 4, variableArgs: false }, S: { id: Ia, numArgs: 0, variableArgs: false }, s: { id: Ca, numArgs: 0, variableArgs: false }, f: { id: da, numArgs: 0, variableArgs: false }, F: { id: da, numArgs: 0, variableArgs: false }, "f*": { id: Ba, numArgs: 0, variableArgs: false }, B: { id: ua, numArgs: 0, variableArgs: false }, "B*": { id: Qa, numArgs: 0, variableArgs: false }, b: { id: Ea, numArgs: 0, variableArgs: false }, "b*": { id: fa, numArgs: 0, variableArgs: false }, n: { id: pa, numArgs: 0, variableArgs: false }, W: { id: ma, numArgs: 0, variableArgs: false }, "W*": { id: ya, numArgs: 0, variableArgs: false }, BT: { id: wa, numArgs: 0, variableArgs: false }, ET: { id: ba, numArgs: 0, variableArgs: false }, Tc: { id: Da, numArgs: 1, variableArgs: false }, Tw: { id: Sa, numArgs: 1, variableArgs: false }, Tz: { id: Fa, numArgs: 1, variableArgs: false }, TL: { id: ka, numArgs: 1, variableArgs: false }, Tf: { id: Ra, numArgs: 2, variableArgs: false }, Tr: { id: xa, numArgs: 1, variableArgs: false }, Ts: { id: Na, numArgs: 1, variableArgs: false }, Td: { id: Ma, numArgs: 2, variableArgs: false }, TD: { id: Ga, numArgs: 2, variableArgs: false }, Tm: { id: va, numArgs: 6, variableArgs: false }, "T*": { id: La, numArgs: 0, variableArgs: false }, Tj: { id: Ua, numArgs: 1, variableArgs: false }, TJ: { id: Ha, numArgs: 1, variableArgs: false }, "'": { id: Ta, numArgs: 1, variableArgs: false }, '"': { id: Ja, numArgs: 3, variableArgs: false }, d0: { id: Ya, numArgs: 2, variableArgs: false }, d1: { id: Pa, numArgs: 6, variableArgs: false }, CS: { id: Oa, numArgs: 1, variableArgs: false }, cs: { id: Ka, numArgs: 1, variableArgs: false }, SC: { id: qa, numArgs: 4, variableArgs: true }, SCN: { id: _a, numArgs: 33, variableArgs: true }, sc: { id: Wa, numArgs: 4, variableArgs: true }, scn: { id: ja, numArgs: 33, variableArgs: true }, G: { id: Xa, numArgs: 1, variableArgs: false }, g: { id: Va, numArgs: 1, variableArgs: false }, RG: { id: Za, numArgs: 3, variableArgs: false }, rg: { id: za, numArgs: 3, variableArgs: false }, K: { id: $a, numArgs: 4, variableArgs: false }, k: { id: es, numArgs: 4, variableArgs: false }, sh: { id: ts, numArgs: 1, variableArgs: false }, BI: { id: As, numArgs: 0, variableArgs: false }, ID: { id: is, numArgs: 0, variableArgs: false }, EI: { id: as, numArgs: 1, variableArgs: false }, Do: { id: ss, numArgs: 1, variableArgs: false }, MP: { id: ns, numArgs: 1, variableArgs: false }, DP: { id: rs, numArgs: 2, variableArgs: false }, BMC: { id: os, numArgs: 1, variableArgs: false }, BDC: { id: gs, numArgs: 2, variableArgs: false }, EMC: { id: cs, numArgs: 0, variableArgs: false }, BX: { id: hs, numArgs: 0, variableArgs: false }, EX: { id: ls, numArgs: 0, variableArgs: false }, BM: null, BD: null, true: null, fa: null, fal: null, fals: null, false: null, nu: null, nul: null, null: null }));
      }
      constructor(e3, t3, i3 = new StateManager()) {
        this.parser = new Parser({ lexer: new Lexer(e3, _EvaluatorPreprocessor.opMap), xref: t3 }), this.stateManager = i3, this.nonProcessedArgs = [], this._isPathOp = false, this._numInvalidPathOPS = 0;
      }
      get savedStatesDepth() {
        return this.stateManager.stateStack.length;
      }
      read(e3) {
        let t3 = e3.args;
        for (; ; ) {
          const i3 = this.parser.getObj();
          if (i3 instanceof Cmd) {
            const a3 = i3.cmd, s3 = _EvaluatorPreprocessor.opMap[a3];
            if (!s3) {
              warn(`Unknown command "${a3}".`);
              continue;
            }
            const n3 = s3.id, r3 = s3.numArgs;
            let o3 = null !== t3 ? t3.length : 0;
            if (this._isPathOp || (this._numInvalidPathOPS = 0), this._isPathOp = n3 >= na && n3 <= pa, s3.variableArgs) o3 > r3 && info(`Command ${a3}: expected [0, ${r3}] args, but received ${o3} args.`);
            else {
              if (o3 !== r3) {
                const e4 = this.nonProcessedArgs;
                for (; o3 > r3; ) e4.push(t3.shift()), o3--;
                for (; o3 < r3 && 0 !== e4.length; ) null === t3 && (t3 = []), t3.unshift(e4.pop()), o3++;
              }
              if (o3 < r3) {
                const e4 = `command ${a3}: expected ${r3} args, but received ${o3} args.`;
                if (this._isPathOp && ++this._numInvalidPathOPS > _EvaluatorPreprocessor.MAX_INVALID_PATH_OPS) throw new FormatError(`Invalid ${e4}`);
                warn(`Skipping ${e4}`), null !== t3 && (t3.length = 0);
                continue;
              }
            }
            return this.preprocessCommand(n3, t3), e3.fn = n3, e3.args = t3, true;
          }
          if (i3 === Xs) return false;
          if (null !== i3 && (null === t3 && (t3 = []), t3.push(i3), t3.length > 33)) throw new FormatError("Too many arguments");
        }
      }
      preprocessCommand(e3, t3) {
        switch (0 | e3) {
          case ia:
            this.stateManager.save();
            break;
          case aa:
            this.stateManager.restore();
            break;
          case sa:
            this.stateManager.transform(t3);
        }
      }
    };
    __publicField(_EvaluatorPreprocessor, "MAX_INVALID_PATH_OPS", 10);
    EvaluatorPreprocessor = _EvaluatorPreprocessor;
    DefaultAppearanceEvaluator = class extends EvaluatorPreprocessor {
      constructor(e3) {
        super(new StringStream(e3));
      }
      parse() {
        const e3 = { fn: 0, args: [] }, t3 = { fontSize: 0, fontName: "", fontColor: new Uint8ClampedArray(3) };
        try {
          for (; e3.args.length = 0, this.read(e3); ) {
            if (0 !== this.savedStatesDepth) continue;
            const { fn: i3, args: a3 } = e3;
            switch (0 | i3) {
              case Ra:
                const [e4, i4] = a3;
                e4 instanceof Name && (t3.fontName = e4.name), "number" == typeof i4 && i4 > 0 && (t3.fontSize = i4);
                break;
              case za:
                ColorSpace.singletons.rgb.getRgbItem(a3, 0, t3.fontColor, 0);
                break;
              case Va:
                ColorSpace.singletons.gray.getRgbItem(a3, 0, t3.fontColor, 0);
                break;
              case es:
                ColorSpace.singletons.cmyk.getRgbItem(a3, 0, t3.fontColor, 0);
            }
          }
        } catch (e4) {
          warn(`parseDefaultAppearance - ignoring errors: "${e4}".`);
        }
        return t3;
      }
    };
    AppearanceStreamEvaluator = class extends EvaluatorPreprocessor {
      constructor(e3, t3, i3) {
        super(e3), this.stream = e3, this.evaluatorOptions = t3, this.xref = i3, this.resources = e3.dict?.get("Resources");
      }
      parse() {
        const e3 = { fn: 0, args: [] };
        let t3 = { scaleFactor: 1, fontSize: 0, fontName: "", fontColor: new Uint8ClampedArray(3), fillColorSpace: ColorSpace.singletons.gray }, i3 = false;
        const a3 = [];
        try {
          for (; e3.args.length = 0, !i3 && this.read(e3); ) {
            const { fn: s3, args: n3 } = e3;
            switch (0 | s3) {
              case ia:
                a3.push({ scaleFactor: t3.scaleFactor, fontSize: t3.fontSize, fontName: t3.fontName, fontColor: t3.fontColor.slice(), fillColorSpace: t3.fillColorSpace });
                break;
              case aa:
                t3 = a3.pop() || t3;
                break;
              case va:
                t3.scaleFactor *= Math.hypot(n3[0], n3[1]);
                break;
              case Ra:
                const [e4, s4] = n3;
                e4 instanceof Name && (t3.fontName = e4.name), "number" == typeof s4 && s4 > 0 && (t3.fontSize = s4 * t3.scaleFactor);
                break;
              case Ka:
                t3.fillColorSpace = ColorSpace.parse({ cs: n3[0], xref: this.xref, resources: this.resources, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache: this._localColorSpaceCache });
                break;
              case Wa:
                t3.fillColorSpace.getRgbItem(n3, 0, t3.fontColor, 0);
                break;
              case za:
                ColorSpace.singletons.rgb.getRgbItem(n3, 0, t3.fontColor, 0);
                break;
              case Va:
                ColorSpace.singletons.gray.getRgbItem(n3, 0, t3.fontColor, 0);
                break;
              case es:
                ColorSpace.singletons.cmyk.getRgbItem(n3, 0, t3.fontColor, 0);
                break;
              case Ua:
              case Ha:
              case Ta:
              case Ja:
                i3 = true;
            }
          }
        } catch (e4) {
          warn(`parseAppearanceStream - ignoring errors: "${e4}".`);
        }
        return this.stream.reset(), delete t3.scaleFactor, delete t3.fillColorSpace, t3;
      }
      get _localColorSpaceCache() {
        return shadow(this, "_localColorSpaceCache", new LocalColorSpaceCache());
      }
      get _pdfFunctionFactory() {
        return shadow(this, "_pdfFunctionFactory", new PDFFunctionFactory({ xref: this.xref, isEvalSupported: this.evaluatorOptions.isEvalSupported }));
      }
    };
    FakeUnicodeFont = class _FakeUnicodeFont {
      constructor(e3, t3) {
        this.xref = e3, this.widths = null, this.firstChar = 1 / 0, this.lastChar = -1 / 0, this.fontFamily = t3;
        const i3 = new OffscreenCanvas(1, 1);
        this.ctxMeasure = i3.getContext("2d", { willReadFrequently: true }), _FakeUnicodeFont._fontNameId || (_FakeUnicodeFont._fontNameId = 1), this.fontName = Name.get(`InvalidPDFjsFont_${t3}_${_FakeUnicodeFont._fontNameId++}`);
      }
      get fontDescriptorRef() {
        if (!_FakeUnicodeFont._fontDescriptorRef) {
          const e3 = new Dict(this.xref);
          e3.set("Type", Name.get("FontDescriptor")), e3.set("FontName", this.fontName), e3.set("FontFamily", "MyriadPro Regular"), e3.set("FontBBox", [0, 0, 0, 0]), e3.set("FontStretch", Name.get("Normal")), e3.set("FontWeight", 400), e3.set("ItalicAngle", 0), _FakeUnicodeFont._fontDescriptorRef = this.xref.getNewPersistentRef(e3);
        }
        return _FakeUnicodeFont._fontDescriptorRef;
      }
      get descendantFontRef() {
        const e3 = new Dict(this.xref);
        e3.set("BaseFont", this.fontName), e3.set("Type", Name.get("Font")), e3.set("Subtype", Name.get("CIDFontType0")), e3.set("CIDToGIDMap", Name.get("Identity")), e3.set("FirstChar", this.firstChar), e3.set("LastChar", this.lastChar), e3.set("FontDescriptor", this.fontDescriptorRef), e3.set("DW", 1e3);
        const t3 = [], i3 = [...this.widths.entries()].sort();
        let a3 = null, s3 = null;
        for (const [e4, n4] of i3) a3 ? e4 === a3 + s3.length ? s3.push(n4) : (t3.push(a3, s3), a3 = e4, s3 = [n4]) : (a3 = e4, s3 = [n4]);
        a3 && t3.push(a3, s3), e3.set("W", t3);
        const n3 = new Dict(this.xref);
        return n3.set("Ordering", "Identity"), n3.set("Registry", "Adobe"), n3.set("Supplement", 0), e3.set("CIDSystemInfo", n3), this.xref.getNewPersistentRef(e3);
      }
      get baseFontRef() {
        const e3 = new Dict(this.xref);
        return e3.set("BaseFont", this.fontName), e3.set("Type", Name.get("Font")), e3.set("Subtype", Name.get("Type0")), e3.set("Encoding", Name.get("Identity-H")), e3.set("DescendantFonts", [this.descendantFontRef]), e3.set("ToUnicode", Name.get("Identity-H")), this.xref.getNewPersistentRef(e3);
      }
      get resources() {
        const e3 = new Dict(this.xref), t3 = new Dict(this.xref);
        return t3.set(this.fontName.name, this.baseFontRef), e3.set("Font", t3), e3;
      }
      _createContext() {
        return this.widths = /* @__PURE__ */ new Map(), this.ctxMeasure.font = `1000px ${this.fontFamily}`, this.ctxMeasure;
      }
      createFontResources(e3) {
        const t3 = this._createContext();
        for (const i3 of e3.split(/\r\n?|\n/)) for (const e4 of i3.split("")) {
          const i4 = e4.charCodeAt(0);
          if (this.widths.has(i4)) continue;
          const a3 = t3.measureText(e4), s3 = Math.ceil(a3.width);
          this.widths.set(i4, s3), this.firstChar = Math.min(i4, this.firstChar), this.lastChar = Math.max(i4, this.lastChar);
        }
        return this.resources;
      }
      static getFirstPositionInfo(e3, t3, i3) {
        const [a3, s3, n3, r3] = e3;
        let o3 = n3 - a3, g3 = r3 - s3;
        t3 % 180 != 0 && ([o3, g3] = [g3, o3]);
        const c3 = FA * i3;
        return { coords: [0, g3 + kA * i3 - c3], bbox: [0, 0, o3, g3], matrix: 0 !== t3 ? getRotationMatrix(t3, g3, c3) : void 0 };
      }
      createAppearance(e3, t3, i3, a3, s3, n3) {
        const r3 = this._createContext(), o3 = [];
        let g3 = -1 / 0;
        for (const t4 of e3.split(/\r\n?|\n/)) {
          o3.push(t4);
          const e4 = r3.measureText(t4).width;
          g3 = Math.max(g3, e4);
          for (const e5 of codePointIter(t4)) {
            const t5 = String.fromCodePoint(e5);
            let i4 = this.widths.get(e5);
            if (void 0 === i4) {
              const a4 = r3.measureText(t5);
              i4 = Math.ceil(a4.width), this.widths.set(e5, i4), this.firstChar = Math.min(e5, this.firstChar), this.lastChar = Math.max(e5, this.lastChar);
            }
          }
        }
        g3 *= a3 / 1e3;
        const [c3, h3, l3, C3] = t3;
        let d3 = l3 - c3, u3 = C3 - h3;
        i3 % 180 != 0 && ([d3, u3] = [u3, d3]);
        let Q3 = 1;
        g3 > d3 && (Q3 = d3 / g3);
        let f3 = 1;
        const p3 = FA * a3, m3 = kA * a3, y3 = p3 * o3.length;
        y3 > u3 && (f3 = u3 / y3);
        const w3 = a3 * Math.min(Q3, f3), b3 = ["q", `0 0 ${numberToString(d3)} ${numberToString(u3)} re W n`, "BT", `1 0 0 1 0 ${numberToString(u3 + m3)} Tm 0 Tc ${getPdfColor(s3, true)}`, `/${this.fontName.name} ${numberToString(w3)} Tf`], { resources: D3 } = this;
        if (1 !== (n3 = "number" == typeof n3 && n3 >= 0 && n3 <= 1 ? n3 : 1)) {
          b3.push("/R0 gs");
          const e4 = new Dict(this.xref), t4 = new Dict(this.xref);
          t4.set("ca", n3), t4.set("CA", n3), t4.set("Type", Name.get("ExtGState")), e4.set("R0", t4), D3.set("ExtGState", e4);
        }
        const S3 = numberToString(p3);
        for (const e4 of o3) b3.push(`0 -${S3} Td <${stringToUTF16HexString(e4)}> Tj`);
        b3.push("ET", "Q");
        const F3 = b3.join("\n"), k3 = new Dict(this.xref);
        if (k3.set("Subtype", Name.get("Form")), k3.set("Type", Name.get("XObject")), k3.set("BBox", [0, 0, d3, u3]), k3.set("Length", F3.length), k3.set("Resources", D3), i3) {
          const e4 = getRotationMatrix(i3, d3, u3);
          k3.set("Matrix", e4);
        }
        const R3 = new StringStream(F3);
        return R3.dict = k3, R3;
      }
    };
    NameOrNumberTree = class {
      constructor(e3, t3, i3) {
        this.root = e3, this.xref = t3, this._type = i3;
      }
      getAll() {
        const e3 = /* @__PURE__ */ new Map();
        if (!this.root) return e3;
        const t3 = this.xref, i3 = new RefSet();
        i3.put(this.root);
        const a3 = [this.root];
        for (; a3.length > 0; ) {
          const s3 = t3.fetchIfRef(a3.shift());
          if (!(s3 instanceof Dict)) continue;
          if (s3.has("Kids")) {
            const e4 = s3.get("Kids");
            if (!Array.isArray(e4)) continue;
            for (const t4 of e4) {
              if (i3.has(t4)) throw new FormatError(`Duplicate entry in "${this._type}" tree.`);
              a3.push(t4), i3.put(t4);
            }
            continue;
          }
          const n3 = s3.get(this._type);
          if (Array.isArray(n3)) for (let i4 = 0, a4 = n3.length; i4 < a4; i4 += 2) e3.set(t3.fetchIfRef(n3[i4]), t3.fetchIfRef(n3[i4 + 1]));
        }
        return e3;
      }
      get(e3) {
        if (!this.root) return null;
        const t3 = this.xref;
        let i3 = t3.fetchIfRef(this.root), a3 = 0;
        for (; i3.has("Kids"); ) {
          if (++a3 > 10) return warn(`Search depth limit reached for "${this._type}" tree.`), null;
          const s4 = i3.get("Kids");
          if (!Array.isArray(s4)) return null;
          let n3 = 0, r3 = s4.length - 1;
          for (; n3 <= r3; ) {
            const a4 = n3 + r3 >> 1, o3 = t3.fetchIfRef(s4[a4]), g3 = o3.get("Limits");
            if (e3 < t3.fetchIfRef(g3[0])) r3 = a4 - 1;
            else {
              if (!(e3 > t3.fetchIfRef(g3[1]))) {
                i3 = o3;
                break;
              }
              n3 = a4 + 1;
            }
          }
          if (n3 > r3) return null;
        }
        const s3 = i3.get(this._type);
        if (Array.isArray(s3)) {
          let i4 = 0, a4 = s3.length - 2;
          for (; i4 <= a4; ) {
            const n3 = i4 + a4 >> 1, r3 = n3 + (1 & n3), o3 = t3.fetchIfRef(s3[r3]);
            if (e3 < o3) a4 = r3 - 2;
            else {
              if (!(e3 > o3)) return t3.fetchIfRef(s3[r3 + 1]);
              i4 = r3 + 2;
            }
          }
        }
        return null;
      }
    };
    NameTree = class extends NameOrNumberTree {
      constructor(e3, t3) {
        super(e3, t3, "Names");
      }
    };
    NumberTree = class extends NameOrNumberTree {
      constructor(e3, t3) {
        super(e3, t3, "Nums");
      }
    };
    FileSpec = class {
      constructor(e3, t3, i3 = false) {
        __privateAdd(this, _F, false);
        e3 instanceof Dict && (this.xref = t3, this.root = e3, e3.has("FS") && (this.fs = e3.get("FS")), e3.has("RF") && warn("Related file specifications are not supported"), i3 || (e3.has("EF") ? __privateSet(this, _F, true) : warn("Non-embedded file specifications are not supported")));
      }
      get filename() {
        let e3 = "";
        const t3 = pickPlatformItem(this.root);
        return t3 && "string" == typeof t3 && (e3 = stringToPDFString(t3).replaceAll("\\\\", "\\").replaceAll("\\/", "/").replaceAll("\\", "/")), shadow(this, "filename", e3 || "unnamed");
      }
      get content() {
        if (!__privateGet(this, _F)) return null;
        this._contentRef || (this._contentRef = pickPlatformItem(this.root?.get("EF")));
        let e3 = null;
        if (this._contentRef) {
          const t3 = this.xref.fetchIfRef(this._contentRef);
          t3 instanceof BaseStream ? e3 = t3.getBytes() : warn("Embedded file specification points to non-existing/invalid content");
        } else warn("Embedded file specification does not have any content");
        return e3;
      }
      get description() {
        let e3 = "";
        const t3 = this.root?.get("Desc");
        return t3 && "string" == typeof t3 && (e3 = stringToPDFString(t3)), shadow(this, "description", e3);
      }
      get serializable() {
        return { rawFilename: this.filename, filename: (e3 = this.filename, e3.substring(e3.lastIndexOf("/") + 1)), content: this.content, description: this.description };
        var e3;
      }
    };
    _F = new WeakMap();
    ag = 0;
    sg = -2;
    ng = -3;
    rg = -4;
    og = -5;
    gg = -6;
    cg = -9;
    XMLParserBase = class {
      _resolveEntities(e3) {
        return e3.replaceAll(/&([^;]+);/g, (e4, t3) => {
          if ("#x" === t3.substring(0, 2)) return String.fromCodePoint(parseInt(t3.substring(2), 16));
          if ("#" === t3.substring(0, 1)) return String.fromCodePoint(parseInt(t3.substring(1), 10));
          switch (t3) {
            case "lt":
              return "<";
            case "gt":
              return ">";
            case "amp":
              return "&";
            case "quot":
              return '"';
            case "apos":
              return "'";
          }
          return this.onResolveEntity(t3);
        });
      }
      _parseContent(e3, t3) {
        const i3 = [];
        let a3 = t3;
        function skipWs() {
          for (; a3 < e3.length && isWhitespace(e3, a3); ) ++a3;
        }
        for (; a3 < e3.length && !isWhitespace(e3, a3) && ">" !== e3[a3] && "/" !== e3[a3]; ) ++a3;
        const s3 = e3.substring(t3, a3);
        for (skipWs(); a3 < e3.length && ">" !== e3[a3] && "/" !== e3[a3] && "?" !== e3[a3]; ) {
          skipWs();
          let t4 = "", s4 = "";
          for (; a3 < e3.length && !isWhitespace(e3, a3) && "=" !== e3[a3]; ) t4 += e3[a3], ++a3;
          if (skipWs(), "=" !== e3[a3]) return null;
          ++a3, skipWs();
          const n3 = e3[a3];
          if ('"' !== n3 && "'" !== n3) return null;
          const r3 = e3.indexOf(n3, ++a3);
          if (r3 < 0) return null;
          s4 = e3.substring(a3, r3), i3.push({ name: t4, value: this._resolveEntities(s4) }), a3 = r3 + 1, skipWs();
        }
        return { name: s3, attributes: i3, parsed: a3 - t3 };
      }
      _parseProcessingInstruction(e3, t3) {
        let i3 = t3;
        for (; i3 < e3.length && !isWhitespace(e3, i3) && ">" !== e3[i3] && "?" !== e3[i3] && "/" !== e3[i3]; ) ++i3;
        const a3 = e3.substring(t3, i3);
        !function() {
          for (; i3 < e3.length && isWhitespace(e3, i3); ) ++i3;
        }();
        const s3 = i3;
        for (; i3 < e3.length && ("?" !== e3[i3] || ">" !== e3[i3 + 1]); ) ++i3;
        return { name: a3, value: e3.substring(s3, i3), parsed: i3 - t3 };
      }
      parseXml(e3) {
        let t3 = 0;
        for (; t3 < e3.length; ) {
          let i3 = t3;
          if ("<" === e3[t3]) {
            ++i3;
            let t4;
            switch (e3[i3]) {
              case "/":
                if (++i3, t4 = e3.indexOf(">", i3), t4 < 0) return void this.onError(cg);
                this.onEndElement(e3.substring(i3, t4)), i3 = t4 + 1;
                break;
              case "?":
                ++i3;
                const a3 = this._parseProcessingInstruction(e3, i3);
                if ("?>" !== e3.substring(i3 + a3.parsed, i3 + a3.parsed + 2)) return void this.onError(ng);
                this.onPi(a3.name, a3.value), i3 += a3.parsed + 2;
                break;
              case "!":
                if ("--" === e3.substring(i3 + 1, i3 + 3)) {
                  if (t4 = e3.indexOf("-->", i3 + 3), t4 < 0) return void this.onError(og);
                  this.onComment(e3.substring(i3 + 3, t4)), i3 = t4 + 3;
                } else if ("[CDATA[" === e3.substring(i3 + 1, i3 + 8)) {
                  if (t4 = e3.indexOf("]]>", i3 + 8), t4 < 0) return void this.onError(sg);
                  this.onCdata(e3.substring(i3 + 8, t4)), i3 = t4 + 3;
                } else {
                  if ("DOCTYPE" !== e3.substring(i3 + 1, i3 + 8)) return void this.onError(gg);
                  {
                    const a4 = e3.indexOf("[", i3 + 8);
                    let s4 = false;
                    if (t4 = e3.indexOf(">", i3 + 8), t4 < 0) return void this.onError(rg);
                    if (a4 > 0 && t4 > a4) {
                      if (t4 = e3.indexOf("]>", i3 + 8), t4 < 0) return void this.onError(rg);
                      s4 = true;
                    }
                    const n4 = e3.substring(i3 + 8, t4 + (s4 ? 1 : 0));
                    this.onDoctype(n4), i3 = t4 + (s4 ? 2 : 1);
                  }
                }
                break;
              default:
                const s3 = this._parseContent(e3, i3);
                if (null === s3) return void this.onError(gg);
                let n3 = false;
                if ("/>" === e3.substring(i3 + s3.parsed, i3 + s3.parsed + 2)) n3 = true;
                else if (">" !== e3.substring(i3 + s3.parsed, i3 + s3.parsed + 1)) return void this.onError(cg);
                this.onBeginElement(s3.name, s3.attributes, n3), i3 += s3.parsed + (n3 ? 2 : 1);
            }
          } else {
            for (; i3 < e3.length && "<" !== e3[i3]; ) i3++;
            const a3 = e3.substring(t3, i3);
            this.onText(this._resolveEntities(a3));
          }
          t3 = i3;
        }
      }
      onResolveEntity(e3) {
        return `&${e3};`;
      }
      onPi(e3, t3) {
      }
      onComment(e3) {
      }
      onCdata(e3) {
      }
      onDoctype(e3) {
      }
      onText(e3) {
      }
      onBeginElement(e3, t3, i3) {
      }
      onEndElement(e3) {
      }
      onError(e3) {
      }
    };
    SimpleDOMNode = class {
      constructor(e3, t3) {
        this.nodeName = e3, this.nodeValue = t3, Object.defineProperty(this, "parentNode", { value: null, writable: true });
      }
      get firstChild() {
        return this.childNodes?.[0];
      }
      get nextSibling() {
        const e3 = this.parentNode.childNodes;
        if (!e3) return;
        const t3 = e3.indexOf(this);
        return -1 !== t3 ? e3[t3 + 1] : void 0;
      }
      get textContent() {
        return this.childNodes ? this.childNodes.map(function(e3) {
          return e3.textContent;
        }).join("") : this.nodeValue || "";
      }
      get children() {
        return this.childNodes || [];
      }
      hasChildNodes() {
        return this.childNodes?.length > 0;
      }
      searchNode(e3, t3) {
        if (t3 >= e3.length) return this;
        const i3 = e3[t3];
        if (i3.name.startsWith("#") && t3 < e3.length - 1) return this.searchNode(e3, t3 + 1);
        const a3 = [];
        let s3 = this;
        for (; ; ) {
          if (i3.name === s3.nodeName) {
            if (0 !== i3.pos) {
              if (0 === a3.length) return null;
              {
                const [n3] = a3.pop();
                let r3 = 0;
                for (const a4 of n3.childNodes) if (i3.name === a4.nodeName) {
                  if (r3 === i3.pos) return a4.searchNode(e3, t3 + 1);
                  r3++;
                }
                return s3.searchNode(e3, t3 + 1);
              }
            }
            {
              const i4 = s3.searchNode(e3, t3 + 1);
              if (null !== i4) return i4;
            }
          }
          if (s3.childNodes?.length > 0) a3.push([s3, 0]), s3 = s3.childNodes[0];
          else {
            if (0 === a3.length) return null;
            for (; 0 !== a3.length; ) {
              const [e4, t4] = a3.pop(), i4 = t4 + 1;
              if (i4 < e4.childNodes.length) {
                a3.push([e4, i4]), s3 = e4.childNodes[i4];
                break;
              }
            }
            if (0 === a3.length) return null;
          }
        }
      }
      dump(e3) {
        if ("#text" !== this.nodeName) {
          if (e3.push(`<${this.nodeName}`), this.attributes) for (const t3 of this.attributes) e3.push(` ${t3.name}="${encodeToXmlString(t3.value)}"`);
          if (this.hasChildNodes()) {
            e3.push(">");
            for (const t3 of this.childNodes) t3.dump(e3);
            e3.push(`</${this.nodeName}>`);
          } else this.nodeValue ? e3.push(`>${encodeToXmlString(this.nodeValue)}</${this.nodeName}>`) : e3.push("/>");
        } else e3.push(encodeToXmlString(this.nodeValue));
      }
    };
    SimpleXMLParser = class extends XMLParserBase {
      constructor({ hasAttributes: e3 = false, lowerCaseName: t3 = false }) {
        super(), this._currentFragment = null, this._stack = null, this._errorCode = ag, this._hasAttributes = e3, this._lowerCaseName = t3;
      }
      parseFromString(e3) {
        if (this._currentFragment = [], this._stack = [], this._errorCode = ag, this.parseXml(e3), this._errorCode !== ag) return;
        const [t3] = this._currentFragment;
        return t3 ? { documentElement: t3 } : void 0;
      }
      onText(e3) {
        if (function(e4) {
          for (let t4 = 0, i3 = e4.length; t4 < i3; t4++) if (!isWhitespace(e4, t4)) return false;
          return true;
        }(e3)) return;
        const t3 = new SimpleDOMNode("#text", e3);
        this._currentFragment.push(t3);
      }
      onCdata(e3) {
        const t3 = new SimpleDOMNode("#text", e3);
        this._currentFragment.push(t3);
      }
      onBeginElement(e3, t3, i3) {
        this._lowerCaseName && (e3 = e3.toLowerCase());
        const a3 = new SimpleDOMNode(e3);
        a3.childNodes = [], this._hasAttributes && (a3.attributes = t3), this._currentFragment.push(a3), i3 || (this._stack.push(this._currentFragment), this._currentFragment = a3.childNodes);
      }
      onEndElement(e3) {
        this._currentFragment = this._stack.pop() || [];
        const t3 = this._currentFragment.at(-1);
        if (!t3) return null;
        for (const e4 of t3.childNodes) e4.parentNode = t3;
        return t3;
      }
      onError(e3) {
        this._errorCode = e3;
      }
    };
    MetadataParser = class {
      constructor(e3) {
        e3 = this._repair(e3);
        const t3 = new SimpleXMLParser({ lowerCaseName: true }).parseFromString(e3);
        this._metadataMap = /* @__PURE__ */ new Map(), this._data = e3, t3 && this._parse(t3);
      }
      _repair(e3) {
        return e3.replace(/^[^<]+/, "").replaceAll(/>\\376\\377([^<]+)/g, function(e4, t3) {
          const i3 = t3.replaceAll(/\\([0-3])([0-7])([0-7])/g, function(e5, t4, i4, a4) {
            return String.fromCharCode(64 * t4 + 8 * i4 + 1 * a4);
          }).replaceAll(/&(amp|apos|gt|lt|quot);/g, function(e5, t4) {
            switch (t4) {
              case "amp":
                return "&";
              case "apos":
                return "'";
              case "gt":
                return ">";
              case "lt":
                return "<";
              case "quot":
                return '"';
            }
            throw new Error(`_repair: ${t4} isn't defined.`);
          }), a3 = [">"];
          for (let e5 = 0, t4 = i3.length; e5 < t4; e5 += 2) {
            const t5 = 256 * i3.charCodeAt(e5) + i3.charCodeAt(e5 + 1);
            t5 >= 32 && t5 < 127 && 60 !== t5 && 62 !== t5 && 38 !== t5 ? a3.push(String.fromCharCode(t5)) : a3.push("&#x" + (65536 + t5).toString(16).substring(1) + ";");
          }
          return a3.join("");
        });
      }
      _getSequence(e3) {
        const t3 = e3.nodeName;
        return "rdf:bag" !== t3 && "rdf:seq" !== t3 && "rdf:alt" !== t3 ? null : e3.childNodes.filter((e4) => "rdf:li" === e4.nodeName);
      }
      _parseArray(e3) {
        if (!e3.hasChildNodes()) return;
        const [t3] = e3.childNodes, i3 = this._getSequence(t3) || [];
        this._metadataMap.set(e3.nodeName, i3.map((e4) => e4.textContent.trim()));
      }
      _parse(e3) {
        let t3 = e3.documentElement;
        if ("rdf:rdf" !== t3.nodeName) for (t3 = t3.firstChild; t3 && "rdf:rdf" !== t3.nodeName; ) t3 = t3.nextSibling;
        if (t3 && "rdf:rdf" === t3.nodeName && t3.hasChildNodes()) {
          for (const e4 of t3.childNodes) if ("rdf:description" === e4.nodeName) for (const t4 of e4.childNodes) {
            const e5 = t4.nodeName;
            switch (e5) {
              case "#text":
                continue;
              case "dc:creator":
              case "dc:subject":
                this._parseArray(t4);
                continue;
            }
            this._metadataMap.set(e5, t4.textContent.trim());
          }
        }
      }
      get serializable() {
        return { parsedData: this._metadataMap, rawData: this._data };
      }
    };
    DecryptStream = class extends DecodeStream {
      constructor(e3, t3, i3) {
        super(t3), this.str = e3, this.dict = e3.dict, this.decrypt = i3, this.nextChunk = null, this.initialized = false;
      }
      readBlock() {
        let e3;
        if (this.initialized ? e3 = this.nextChunk : (e3 = this.str.getBytes(512), this.initialized = true), !e3 || 0 === e3.length) return void (this.eof = true);
        this.nextChunk = this.str.getBytes(512);
        const t3 = this.nextChunk?.length > 0;
        e3 = (0, this.decrypt)(e3, !t3);
        const i3 = this.bufferLength, a3 = i3 + e3.length;
        this.ensureBuffer(a3).set(e3, i3), this.bufferLength = a3;
      }
    };
    ARCFourCipher = class {
      constructor(e3) {
        this.a = 0, this.b = 0;
        const t3 = new Uint8Array(256), i3 = e3.length;
        for (let e4 = 0; e4 < 256; ++e4) t3[e4] = e4;
        for (let a3 = 0, s3 = 0; a3 < 256; ++a3) {
          const n3 = t3[a3];
          s3 = s3 + n3 + e3[a3 % i3] & 255, t3[a3] = t3[s3], t3[s3] = n3;
        }
        this.s = t3;
      }
      encryptBlock(e3) {
        let t3 = this.a, i3 = this.b;
        const a3 = this.s, s3 = e3.length, n3 = new Uint8Array(s3);
        for (let r3 = 0; r3 < s3; ++r3) {
          t3 = t3 + 1 & 255;
          const s4 = a3[t3];
          i3 = i3 + s4 & 255;
          const o3 = a3[i3];
          a3[t3] = o3, a3[i3] = s4, n3[r3] = e3[r3] ^ a3[s4 + o3 & 255];
        }
        return this.a = t3, this.b = i3, n3;
      }
      decryptBlock(e3) {
        return this.encryptBlock(e3);
      }
      encrypt(e3) {
        return this.encryptBlock(e3);
      }
    };
    hg = function() {
      const e3 = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]), t3 = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
      return function(i3, a3, s3) {
        let n3 = 1732584193, r3 = -271733879, o3 = -1732584194, g3 = 271733878;
        const c3 = s3 + 72 & -64, h3 = new Uint8Array(c3);
        let l3, C3;
        for (l3 = 0; l3 < s3; ++l3) h3[l3] = i3[a3++];
        h3[l3++] = 128;
        const d3 = c3 - 8;
        for (; l3 < d3; ) h3[l3++] = 0;
        h3[l3++] = s3 << 3 & 255, h3[l3++] = s3 >> 5 & 255, h3[l3++] = s3 >> 13 & 255, h3[l3++] = s3 >> 21 & 255, h3[l3++] = s3 >>> 29 & 255, h3[l3++] = 0, h3[l3++] = 0, h3[l3++] = 0;
        const u3 = new Int32Array(16);
        for (l3 = 0; l3 < c3; ) {
          for (C3 = 0; C3 < 16; ++C3, l3 += 4) u3[C3] = h3[l3] | h3[l3 + 1] << 8 | h3[l3 + 2] << 16 | h3[l3 + 3] << 24;
          let i4, a4, s4 = n3, c4 = r3, d4 = o3, Q3 = g3;
          for (C3 = 0; C3 < 64; ++C3) {
            C3 < 16 ? (i4 = c4 & d4 | ~c4 & Q3, a4 = C3) : C3 < 32 ? (i4 = Q3 & c4 | ~Q3 & d4, a4 = 5 * C3 + 1 & 15) : C3 < 48 ? (i4 = c4 ^ d4 ^ Q3, a4 = 3 * C3 + 5 & 15) : (i4 = d4 ^ (c4 | ~Q3), a4 = 7 * C3 & 15);
            const n4 = Q3, r4 = s4 + i4 + t3[C3] + u3[a4] | 0, o4 = e3[C3];
            Q3 = d4, d4 = c4, c4 = c4 + (r4 << o4 | r4 >>> 32 - o4) | 0, s4 = n4;
          }
          n3 = n3 + s4 | 0, r3 = r3 + c4 | 0, o3 = o3 + d4 | 0, g3 = g3 + Q3 | 0;
        }
        return new Uint8Array([255 & n3, n3 >> 8 & 255, n3 >> 16 & 255, n3 >>> 24 & 255, 255 & r3, r3 >> 8 & 255, r3 >> 16 & 255, r3 >>> 24 & 255, 255 & o3, o3 >> 8 & 255, o3 >> 16 & 255, o3 >>> 24 & 255, 255 & g3, g3 >> 8 & 255, g3 >> 16 & 255, g3 >>> 24 & 255]);
      };
    }();
    Word64 = class {
      constructor(e3, t3) {
        this.high = 0 | e3, this.low = 0 | t3;
      }
      and(e3) {
        this.high &= e3.high, this.low &= e3.low;
      }
      xor(e3) {
        this.high ^= e3.high, this.low ^= e3.low;
      }
      or(e3) {
        this.high |= e3.high, this.low |= e3.low;
      }
      shiftRight(e3) {
        e3 >= 32 ? (this.low = this.high >>> e3 - 32 | 0, this.high = 0) : (this.low = this.low >>> e3 | this.high << 32 - e3, this.high = this.high >>> e3 | 0);
      }
      shiftLeft(e3) {
        e3 >= 32 ? (this.high = this.low << e3 - 32, this.low = 0) : (this.high = this.high << e3 | this.low >>> 32 - e3, this.low <<= e3);
      }
      rotateRight(e3) {
        let t3, i3;
        32 & e3 ? (i3 = this.low, t3 = this.high) : (t3 = this.low, i3 = this.high), e3 &= 31, this.low = t3 >>> e3 | i3 << 32 - e3, this.high = i3 >>> e3 | t3 << 32 - e3;
      }
      not() {
        this.high = ~this.high, this.low = ~this.low;
      }
      add(e3) {
        const t3 = (this.low >>> 0) + (e3.low >>> 0);
        let i3 = (this.high >>> 0) + (e3.high >>> 0);
        t3 > 4294967295 && (i3 += 1), this.low = 0 | t3, this.high = 0 | i3;
      }
      copyTo(e3, t3) {
        e3[t3] = this.high >>> 24 & 255, e3[t3 + 1] = this.high >> 16 & 255, e3[t3 + 2] = this.high >> 8 & 255, e3[t3 + 3] = 255 & this.high, e3[t3 + 4] = this.low >>> 24 & 255, e3[t3 + 5] = this.low >> 16 & 255, e3[t3 + 6] = this.low >> 8 & 255, e3[t3 + 7] = 255 & this.low;
      }
      assign(e3) {
        this.high = e3.high, this.low = e3.low;
      }
    };
    lg = /* @__PURE__ */ function() {
      function rotr(e4, t3) {
        return e4 >>> t3 | e4 << 32 - t3;
      }
      function ch(e4, t3, i3) {
        return e4 & t3 ^ ~e4 & i3;
      }
      function maj(e4, t3, i3) {
        return e4 & t3 ^ e4 & i3 ^ t3 & i3;
      }
      function sigma(e4) {
        return rotr(e4, 2) ^ rotr(e4, 13) ^ rotr(e4, 22);
      }
      function sigmaPrime(e4) {
        return rotr(e4, 6) ^ rotr(e4, 11) ^ rotr(e4, 25);
      }
      function littleSigma(e4) {
        return rotr(e4, 7) ^ rotr(e4, 18) ^ e4 >>> 3;
      }
      const e3 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
      return function(t3, i3, a3) {
        let s3 = 1779033703, n3 = 3144134277, r3 = 1013904242, o3 = 2773480762, g3 = 1359893119, c3 = 2600822924, h3 = 528734635, l3 = 1541459225;
        const C3 = 64 * Math.ceil((a3 + 9) / 64), d3 = new Uint8Array(C3);
        let u3, Q3;
        for (u3 = 0; u3 < a3; ++u3) d3[u3] = t3[i3++];
        d3[u3++] = 128;
        const f3 = C3 - 8;
        for (; u3 < f3; ) d3[u3++] = 0;
        d3[u3++] = 0, d3[u3++] = 0, d3[u3++] = 0, d3[u3++] = a3 >>> 29 & 255, d3[u3++] = a3 >> 21 & 255, d3[u3++] = a3 >> 13 & 255, d3[u3++] = a3 >> 5 & 255, d3[u3++] = a3 << 3 & 255;
        const p3 = new Uint32Array(64);
        for (u3 = 0; u3 < C3; ) {
          for (Q3 = 0; Q3 < 16; ++Q3) p3[Q3] = d3[u3] << 24 | d3[u3 + 1] << 16 | d3[u3 + 2] << 8 | d3[u3 + 3], u3 += 4;
          for (Q3 = 16; Q3 < 64; ++Q3) p3[Q3] = 0 | (rotr(m3 = p3[Q3 - 2], 17) ^ rotr(m3, 19) ^ m3 >>> 10) + p3[Q3 - 7] + littleSigma(p3[Q3 - 15]) + p3[Q3 - 16];
          let t4, i4, a4 = s3, C4 = n3, f4 = r3, y3 = o3, w3 = g3, b3 = c3, D3 = h3, S3 = l3;
          for (Q3 = 0; Q3 < 64; ++Q3) t4 = S3 + sigmaPrime(w3) + ch(w3, b3, D3) + e3[Q3] + p3[Q3], i4 = sigma(a4) + maj(a4, C4, f4), S3 = D3, D3 = b3, b3 = w3, w3 = y3 + t4 | 0, y3 = f4, f4 = C4, C4 = a4, a4 = t4 + i4 | 0;
          s3 = s3 + a4 | 0, n3 = n3 + C4 | 0, r3 = r3 + f4 | 0, o3 = o3 + y3 | 0, g3 = g3 + w3 | 0, c3 = c3 + b3 | 0, h3 = h3 + D3 | 0, l3 = l3 + S3 | 0;
        }
        var m3;
        return new Uint8Array([s3 >> 24 & 255, s3 >> 16 & 255, s3 >> 8 & 255, 255 & s3, n3 >> 24 & 255, n3 >> 16 & 255, n3 >> 8 & 255, 255 & n3, r3 >> 24 & 255, r3 >> 16 & 255, r3 >> 8 & 255, 255 & r3, o3 >> 24 & 255, o3 >> 16 & 255, o3 >> 8 & 255, 255 & o3, g3 >> 24 & 255, g3 >> 16 & 255, g3 >> 8 & 255, 255 & g3, c3 >> 24 & 255, c3 >> 16 & 255, c3 >> 8 & 255, 255 & c3, h3 >> 24 & 255, h3 >> 16 & 255, h3 >> 8 & 255, 255 & h3, l3 >> 24 & 255, l3 >> 16 & 255, l3 >> 8 & 255, 255 & l3]);
      };
    }();
    Ig = function() {
      function ch(e4, t3, i3, a3, s3) {
        e4.assign(t3), e4.and(i3), s3.assign(t3), s3.not(), s3.and(a3), e4.xor(s3);
      }
      function maj(e4, t3, i3, a3, s3) {
        e4.assign(t3), e4.and(i3), s3.assign(t3), s3.and(a3), e4.xor(s3), s3.assign(i3), s3.and(a3), e4.xor(s3);
      }
      function sigma(e4, t3, i3) {
        e4.assign(t3), e4.rotateRight(28), i3.assign(t3), i3.rotateRight(34), e4.xor(i3), i3.assign(t3), i3.rotateRight(39), e4.xor(i3);
      }
      function sigmaPrime(e4, t3, i3) {
        e4.assign(t3), e4.rotateRight(14), i3.assign(t3), i3.rotateRight(18), e4.xor(i3), i3.assign(t3), i3.rotateRight(41), e4.xor(i3);
      }
      function littleSigma(e4, t3, i3) {
        e4.assign(t3), e4.rotateRight(1), i3.assign(t3), i3.rotateRight(8), e4.xor(i3), i3.assign(t3), i3.shiftRight(7), e4.xor(i3);
      }
      function littleSigmaPrime(e4, t3, i3) {
        e4.assign(t3), e4.rotateRight(19), i3.assign(t3), i3.rotateRight(61), e4.xor(i3), i3.assign(t3), i3.shiftRight(6), e4.xor(i3);
      }
      const e3 = [new Word64(1116352408, 3609767458), new Word64(1899447441, 602891725), new Word64(3049323471, 3964484399), new Word64(3921009573, 2173295548), new Word64(961987163, 4081628472), new Word64(1508970993, 3053834265), new Word64(2453635748, 2937671579), new Word64(2870763221, 3664609560), new Word64(3624381080, 2734883394), new Word64(310598401, 1164996542), new Word64(607225278, 1323610764), new Word64(1426881987, 3590304994), new Word64(1925078388, 4068182383), new Word64(2162078206, 991336113), new Word64(2614888103, 633803317), new Word64(3248222580, 3479774868), new Word64(3835390401, 2666613458), new Word64(4022224774, 944711139), new Word64(264347078, 2341262773), new Word64(604807628, 2007800933), new Word64(770255983, 1495990901), new Word64(1249150122, 1856431235), new Word64(1555081692, 3175218132), new Word64(1996064986, 2198950837), new Word64(2554220882, 3999719339), new Word64(2821834349, 766784016), new Word64(2952996808, 2566594879), new Word64(3210313671, 3203337956), new Word64(3336571891, 1034457026), new Word64(3584528711, 2466948901), new Word64(113926993, 3758326383), new Word64(338241895, 168717936), new Word64(666307205, 1188179964), new Word64(773529912, 1546045734), new Word64(1294757372, 1522805485), new Word64(1396182291, 2643833823), new Word64(1695183700, 2343527390), new Word64(1986661051, 1014477480), new Word64(2177026350, 1206759142), new Word64(2456956037, 344077627), new Word64(2730485921, 1290863460), new Word64(2820302411, 3158454273), new Word64(3259730800, 3505952657), new Word64(3345764771, 106217008), new Word64(3516065817, 3606008344), new Word64(3600352804, 1432725776), new Word64(4094571909, 1467031594), new Word64(275423344, 851169720), new Word64(430227734, 3100823752), new Word64(506948616, 1363258195), new Word64(659060556, 3750685593), new Word64(883997877, 3785050280), new Word64(958139571, 3318307427), new Word64(1322822218, 3812723403), new Word64(1537002063, 2003034995), new Word64(1747873779, 3602036899), new Word64(1955562222, 1575990012), new Word64(2024104815, 1125592928), new Word64(2227730452, 2716904306), new Word64(2361852424, 442776044), new Word64(2428436474, 593698344), new Word64(2756734187, 3733110249), new Word64(3204031479, 2999351573), new Word64(3329325298, 3815920427), new Word64(3391569614, 3928383900), new Word64(3515267271, 566280711), new Word64(3940187606, 3454069534), new Word64(4118630271, 4000239992), new Word64(116418474, 1914138554), new Word64(174292421, 2731055270), new Word64(289380356, 3203993006), new Word64(460393269, 320620315), new Word64(685471733, 587496836), new Word64(852142971, 1086792851), new Word64(1017036298, 365543100), new Word64(1126000580, 2618297676), new Word64(1288033470, 3409855158), new Word64(1501505948, 4234509866), new Word64(1607167915, 987167468), new Word64(1816402316, 1246189591)];
      return function(t3, i3, a3, s3 = false) {
        let n3, r3, o3, g3, c3, h3, l3, C3;
        s3 ? (n3 = new Word64(3418070365, 3238371032), r3 = new Word64(1654270250, 914150663), o3 = new Word64(2438529370, 812702999), g3 = new Word64(355462360, 4144912697), c3 = new Word64(1731405415, 4290775857), h3 = new Word64(2394180231, 1750603025), l3 = new Word64(3675008525, 1694076839), C3 = new Word64(1203062813, 3204075428)) : (n3 = new Word64(1779033703, 4089235720), r3 = new Word64(3144134277, 2227873595), o3 = new Word64(1013904242, 4271175723), g3 = new Word64(2773480762, 1595750129), c3 = new Word64(1359893119, 2917565137), h3 = new Word64(2600822924, 725511199), l3 = new Word64(528734635, 4215389547), C3 = new Word64(1541459225, 327033209));
        const d3 = 128 * Math.ceil((a3 + 17) / 128), u3 = new Uint8Array(d3);
        let Q3, f3;
        for (Q3 = 0; Q3 < a3; ++Q3) u3[Q3] = t3[i3++];
        u3[Q3++] = 128;
        const p3 = d3 - 16;
        for (; Q3 < p3; ) u3[Q3++] = 0;
        u3[Q3++] = 0, u3[Q3++] = 0, u3[Q3++] = 0, u3[Q3++] = 0, u3[Q3++] = 0, u3[Q3++] = 0, u3[Q3++] = 0, u3[Q3++] = 0, u3[Q3++] = 0, u3[Q3++] = 0, u3[Q3++] = 0, u3[Q3++] = a3 >>> 29 & 255, u3[Q3++] = a3 >> 21 & 255, u3[Q3++] = a3 >> 13 & 255, u3[Q3++] = a3 >> 5 & 255, u3[Q3++] = a3 << 3 & 255;
        const m3 = new Array(80);
        for (Q3 = 0; Q3 < 80; Q3++) m3[Q3] = new Word64(0, 0);
        let y3 = new Word64(0, 0), w3 = new Word64(0, 0), b3 = new Word64(0, 0), D3 = new Word64(0, 0), S3 = new Word64(0, 0), F3 = new Word64(0, 0), k3 = new Word64(0, 0), R3 = new Word64(0, 0);
        const x3 = new Word64(0, 0), N3 = new Word64(0, 0), M3 = new Word64(0, 0), G3 = new Word64(0, 0);
        let v3, L3;
        for (Q3 = 0; Q3 < d3; ) {
          for (f3 = 0; f3 < 16; ++f3) m3[f3].high = u3[Q3] << 24 | u3[Q3 + 1] << 16 | u3[Q3 + 2] << 8 | u3[Q3 + 3], m3[f3].low = u3[Q3 + 4] << 24 | u3[Q3 + 5] << 16 | u3[Q3 + 6] << 8 | u3[Q3 + 7], Q3 += 8;
          for (f3 = 16; f3 < 80; ++f3) v3 = m3[f3], littleSigmaPrime(v3, m3[f3 - 2], G3), v3.add(m3[f3 - 7]), littleSigma(M3, m3[f3 - 15], G3), v3.add(M3), v3.add(m3[f3 - 16]);
          for (y3.assign(n3), w3.assign(r3), b3.assign(o3), D3.assign(g3), S3.assign(c3), F3.assign(h3), k3.assign(l3), R3.assign(C3), f3 = 0; f3 < 80; ++f3) x3.assign(R3), sigmaPrime(M3, S3, G3), x3.add(M3), ch(M3, S3, F3, k3, G3), x3.add(M3), x3.add(e3[f3]), x3.add(m3[f3]), sigma(N3, y3, G3), maj(M3, y3, w3, b3, G3), N3.add(M3), v3 = R3, R3 = k3, k3 = F3, F3 = S3, D3.add(x3), S3 = D3, D3 = b3, b3 = w3, w3 = y3, v3.assign(x3), v3.add(N3), y3 = v3;
          n3.add(y3), r3.add(w3), o3.add(b3), g3.add(D3), c3.add(S3), h3.add(F3), l3.add(k3), C3.add(R3);
        }
        return s3 ? (L3 = new Uint8Array(48), n3.copyTo(L3, 0), r3.copyTo(L3, 8), o3.copyTo(L3, 16), g3.copyTo(L3, 24), c3.copyTo(L3, 32), h3.copyTo(L3, 40)) : (L3 = new Uint8Array(64), n3.copyTo(L3, 0), r3.copyTo(L3, 8), o3.copyTo(L3, 16), g3.copyTo(L3, 24), c3.copyTo(L3, 32), h3.copyTo(L3, 40), l3.copyTo(L3, 48), C3.copyTo(L3, 56)), L3;
      };
    }();
    NullCipher = class {
      decryptBlock(e3) {
        return e3;
      }
      encrypt(e3) {
        return e3;
      }
    };
    AESBaseCipher = class {
      constructor() {
        this._s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]), this._inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]), this._mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]), this._mixCol = new Uint8Array(256);
        for (let e3 = 0; e3 < 256; e3++) this._mixCol[e3] = e3 < 128 ? e3 << 1 : e3 << 1 ^ 27;
        this.buffer = new Uint8Array(16), this.bufferPosition = 0;
      }
      _expandKey(e3) {
        unreachable("Cannot call `_expandKey` on the base class");
      }
      _decrypt(e3, t3) {
        let i3, a3, s3;
        const n3 = new Uint8Array(16);
        n3.set(e3);
        for (let e4 = 0, i4 = this._keySize; e4 < 16; ++e4, ++i4) n3[e4] ^= t3[i4];
        for (let e4 = this._cyclesOfRepetition - 1; e4 >= 1; --e4) {
          i3 = n3[13], n3[13] = n3[9], n3[9] = n3[5], n3[5] = n3[1], n3[1] = i3, i3 = n3[14], a3 = n3[10], n3[14] = n3[6], n3[10] = n3[2], n3[6] = i3, n3[2] = a3, i3 = n3[15], a3 = n3[11], s3 = n3[7], n3[15] = n3[3], n3[11] = i3, n3[7] = a3, n3[3] = s3;
          for (let e5 = 0; e5 < 16; ++e5) n3[e5] = this._inv_s[n3[e5]];
          for (let i4 = 0, a4 = 16 * e4; i4 < 16; ++i4, ++a4) n3[i4] ^= t3[a4];
          for (let e5 = 0; e5 < 16; e5 += 4) {
            const t4 = this._mix[n3[e5]], a4 = this._mix[n3[e5 + 1]], s4 = this._mix[n3[e5 + 2]], r3 = this._mix[n3[e5 + 3]];
            i3 = t4 ^ a4 >>> 8 ^ a4 << 24 ^ s4 >>> 16 ^ s4 << 16 ^ r3 >>> 24 ^ r3 << 8, n3[e5] = i3 >>> 24 & 255, n3[e5 + 1] = i3 >> 16 & 255, n3[e5 + 2] = i3 >> 8 & 255, n3[e5 + 3] = 255 & i3;
          }
        }
        i3 = n3[13], n3[13] = n3[9], n3[9] = n3[5], n3[5] = n3[1], n3[1] = i3, i3 = n3[14], a3 = n3[10], n3[14] = n3[6], n3[10] = n3[2], n3[6] = i3, n3[2] = a3, i3 = n3[15], a3 = n3[11], s3 = n3[7], n3[15] = n3[3], n3[11] = i3, n3[7] = a3, n3[3] = s3;
        for (let e4 = 0; e4 < 16; ++e4) n3[e4] = this._inv_s[n3[e4]], n3[e4] ^= t3[e4];
        return n3;
      }
      _encrypt(e3, t3) {
        const i3 = this._s;
        let a3, s3, n3;
        const r3 = new Uint8Array(16);
        r3.set(e3);
        for (let e4 = 0; e4 < 16; ++e4) r3[e4] ^= t3[e4];
        for (let e4 = 1; e4 < this._cyclesOfRepetition; e4++) {
          for (let e5 = 0; e5 < 16; ++e5) r3[e5] = i3[r3[e5]];
          n3 = r3[1], r3[1] = r3[5], r3[5] = r3[9], r3[9] = r3[13], r3[13] = n3, n3 = r3[2], s3 = r3[6], r3[2] = r3[10], r3[6] = r3[14], r3[10] = n3, r3[14] = s3, n3 = r3[3], s3 = r3[7], a3 = r3[11], r3[3] = r3[15], r3[7] = n3, r3[11] = s3, r3[15] = a3;
          for (let e5 = 0; e5 < 16; e5 += 4) {
            const t4 = r3[e5 + 0], i4 = r3[e5 + 1], s4 = r3[e5 + 2], n4 = r3[e5 + 3];
            a3 = t4 ^ i4 ^ s4 ^ n4, r3[e5 + 0] ^= a3 ^ this._mixCol[t4 ^ i4], r3[e5 + 1] ^= a3 ^ this._mixCol[i4 ^ s4], r3[e5 + 2] ^= a3 ^ this._mixCol[s4 ^ n4], r3[e5 + 3] ^= a3 ^ this._mixCol[n4 ^ t4];
          }
          for (let i4 = 0, a4 = 16 * e4; i4 < 16; ++i4, ++a4) r3[i4] ^= t3[a4];
        }
        for (let e4 = 0; e4 < 16; ++e4) r3[e4] = i3[r3[e4]];
        n3 = r3[1], r3[1] = r3[5], r3[5] = r3[9], r3[9] = r3[13], r3[13] = n3, n3 = r3[2], s3 = r3[6], r3[2] = r3[10], r3[6] = r3[14], r3[10] = n3, r3[14] = s3, n3 = r3[3], s3 = r3[7], a3 = r3[11], r3[3] = r3[15], r3[7] = n3, r3[11] = s3, r3[15] = a3;
        for (let e4 = 0, i4 = this._keySize; e4 < 16; ++e4, ++i4) r3[e4] ^= t3[i4];
        return r3;
      }
      _decryptBlock2(e3, t3) {
        const i3 = e3.length;
        let a3 = this.buffer, s3 = this.bufferPosition;
        const n3 = [];
        let r3 = this.iv;
        for (let t4 = 0; t4 < i3; ++t4) {
          if (a3[s3] = e3[t4], ++s3, s3 < 16) continue;
          const i4 = this._decrypt(a3, this._key);
          for (let e4 = 0; e4 < 16; ++e4) i4[e4] ^= r3[e4];
          r3 = a3, n3.push(i4), a3 = new Uint8Array(16), s3 = 0;
        }
        if (this.buffer = a3, this.bufferLength = s3, this.iv = r3, 0 === n3.length) return new Uint8Array(0);
        let o3 = 16 * n3.length;
        if (t3) {
          const e4 = n3.at(-1);
          let t4 = e4[15];
          if (t4 <= 16) {
            for (let i4 = 15, a4 = 16 - t4; i4 >= a4; --i4) if (e4[i4] !== t4) {
              t4 = 0;
              break;
            }
            o3 -= t4, n3[n3.length - 1] = e4.subarray(0, 16 - t4);
          }
        }
        const g3 = new Uint8Array(o3);
        for (let e4 = 0, t4 = 0, i4 = n3.length; e4 < i4; ++e4, t4 += 16) g3.set(n3[e4], t4);
        return g3;
      }
      decryptBlock(e3, t3, i3 = null) {
        const a3 = e3.length, s3 = this.buffer;
        let n3 = this.bufferPosition;
        if (i3) this.iv = i3;
        else {
          for (let t4 = 0; n3 < 16 && t4 < a3; ++t4, ++n3) s3[n3] = e3[t4];
          if (n3 < 16) return this.bufferLength = n3, new Uint8Array(0);
          this.iv = s3, e3 = e3.subarray(16);
        }
        return this.buffer = new Uint8Array(16), this.bufferLength = 0, this.decryptBlock = this._decryptBlock2, this.decryptBlock(e3, t3);
      }
      encrypt(e3, t3) {
        const i3 = e3.length;
        let a3 = this.buffer, s3 = this.bufferPosition;
        const n3 = [];
        t3 || (t3 = new Uint8Array(16));
        for (let r4 = 0; r4 < i3; ++r4) {
          if (a3[s3] = e3[r4], ++s3, s3 < 16) continue;
          for (let e4 = 0; e4 < 16; ++e4) a3[e4] ^= t3[e4];
          const i4 = this._encrypt(a3, this._key);
          t3 = i4, n3.push(i4), a3 = new Uint8Array(16), s3 = 0;
        }
        if (this.buffer = a3, this.bufferLength = s3, this.iv = t3, 0 === n3.length) return new Uint8Array(0);
        const r3 = 16 * n3.length, o3 = new Uint8Array(r3);
        for (let e4 = 0, t4 = 0, i4 = n3.length; e4 < i4; ++e4, t4 += 16) o3.set(n3[e4], t4);
        return o3;
      }
    };
    AES128Cipher = class extends AESBaseCipher {
      constructor(e3) {
        super(), this._cyclesOfRepetition = 10, this._keySize = 160, this._rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]), this._key = this._expandKey(e3);
      }
      _expandKey(e3) {
        const t3 = this._s, i3 = this._rcon, a3 = new Uint8Array(176);
        a3.set(e3);
        for (let e4 = 16, s3 = 1; e4 < 176; ++s3) {
          let n3 = a3[e4 - 3], r3 = a3[e4 - 2], o3 = a3[e4 - 1], g3 = a3[e4 - 4];
          n3 = t3[n3], r3 = t3[r3], o3 = t3[o3], g3 = t3[g3], n3 ^= i3[s3];
          for (let t4 = 0; t4 < 4; ++t4) a3[e4] = n3 ^= a3[e4 - 16], e4++, a3[e4] = r3 ^= a3[e4 - 16], e4++, a3[e4] = o3 ^= a3[e4 - 16], e4++, a3[e4] = g3 ^= a3[e4 - 16], e4++;
        }
        return a3;
      }
    };
    AES256Cipher = class extends AESBaseCipher {
      constructor(e3) {
        super(), this._cyclesOfRepetition = 14, this._keySize = 224, this._key = this._expandKey(e3);
      }
      _expandKey(e3) {
        const t3 = this._s, i3 = new Uint8Array(240);
        i3.set(e3);
        let a3, s3, n3, r3, o3 = 1;
        for (let e4 = 32, g3 = 1; e4 < 240; ++g3) {
          e4 % 32 == 16 ? (a3 = t3[a3], s3 = t3[s3], n3 = t3[n3], r3 = t3[r3]) : e4 % 32 == 0 && (a3 = i3[e4 - 3], s3 = i3[e4 - 2], n3 = i3[e4 - 1], r3 = i3[e4 - 4], a3 = t3[a3], s3 = t3[s3], n3 = t3[n3], r3 = t3[r3], a3 ^= o3, (o3 <<= 1) >= 256 && (o3 = 255 & (27 ^ o3)));
          for (let t4 = 0; t4 < 4; ++t4) i3[e4] = a3 ^= i3[e4 - 32], e4++, i3[e4] = s3 ^= i3[e4 - 32], e4++, i3[e4] = n3 ^= i3[e4 - 32], e4++, i3[e4] = r3 ^= i3[e4 - 32], e4++;
        }
        return i3;
      }
    };
    PDF17 = class {
      checkOwnerPassword(e3, t3, i3, a3) {
        const s3 = new Uint8Array(e3.length + 56);
        s3.set(e3, 0), s3.set(t3, e3.length), s3.set(i3, e3.length + t3.length);
        return isArrayEqual(lg(s3, 0, s3.length), a3);
      }
      checkUserPassword(e3, t3, i3) {
        const a3 = new Uint8Array(e3.length + 8);
        a3.set(e3, 0), a3.set(t3, e3.length);
        return isArrayEqual(lg(a3, 0, a3.length), i3);
      }
      getOwnerKey(e3, t3, i3, a3) {
        const s3 = new Uint8Array(e3.length + 56);
        s3.set(e3, 0), s3.set(t3, e3.length), s3.set(i3, e3.length + t3.length);
        const n3 = lg(s3, 0, s3.length);
        return new AES256Cipher(n3).decryptBlock(a3, false, new Uint8Array(16));
      }
      getUserKey(e3, t3, i3) {
        const a3 = new Uint8Array(e3.length + 8);
        a3.set(e3, 0), a3.set(t3, e3.length);
        const s3 = lg(a3, 0, a3.length);
        return new AES256Cipher(s3).decryptBlock(i3, false, new Uint8Array(16));
      }
    };
    PDF20 = class {
      _hash(e3, t3, i3) {
        let a3 = lg(t3, 0, t3.length).subarray(0, 32), s3 = [0], n3 = 0;
        for (; n3 < 64 || s3.at(-1) > n3 - 32; ) {
          const t4 = e3.length + a3.length + i3.length, c3 = new Uint8Array(t4);
          let h3 = 0;
          c3.set(e3, h3), h3 += e3.length, c3.set(a3, h3), h3 += a3.length, c3.set(i3, h3);
          const l3 = new Uint8Array(64 * t4);
          for (let e4 = 0, i4 = 0; e4 < 64; e4++, i4 += t4) l3.set(c3, i4);
          s3 = new AES128Cipher(a3.subarray(0, 16)).encrypt(l3, a3.subarray(16, 32));
          const C3 = s3.slice(0, 16).reduce((e4, t5) => e4 + t5, 0) % 3;
          0 === C3 ? a3 = lg(s3, 0, s3.length) : 1 === C3 ? (r3 = s3, o3 = 0, g3 = s3.length, a3 = Ig(r3, o3, g3, true)) : 2 === C3 && (a3 = Ig(s3, 0, s3.length)), n3++;
        }
        var r3, o3, g3;
        return a3.subarray(0, 32);
      }
      checkOwnerPassword(e3, t3, i3, a3) {
        const s3 = new Uint8Array(e3.length + 56);
        s3.set(e3, 0), s3.set(t3, e3.length), s3.set(i3, e3.length + t3.length);
        return isArrayEqual(this._hash(e3, s3, i3), a3);
      }
      checkUserPassword(e3, t3, i3) {
        const a3 = new Uint8Array(e3.length + 8);
        a3.set(e3, 0), a3.set(t3, e3.length);
        return isArrayEqual(this._hash(e3, a3, []), i3);
      }
      getOwnerKey(e3, t3, i3, a3) {
        const s3 = new Uint8Array(e3.length + 56);
        s3.set(e3, 0), s3.set(t3, e3.length), s3.set(i3, e3.length + t3.length);
        const n3 = this._hash(e3, s3, i3);
        return new AES256Cipher(n3).decryptBlock(a3, false, new Uint8Array(16));
      }
      getUserKey(e3, t3, i3) {
        const a3 = new Uint8Array(e3.length + 8);
        a3.set(e3, 0), a3.set(t3, e3.length);
        const s3 = this._hash(e3, a3, []);
        return new AES256Cipher(s3).decryptBlock(i3, false, new Uint8Array(16));
      }
    };
    CipherTransform = class {
      constructor(e3, t3) {
        this.StringCipherConstructor = e3, this.StreamCipherConstructor = t3;
      }
      createStream(e3, t3) {
        const i3 = new this.StreamCipherConstructor();
        return new DecryptStream(e3, t3, function(e4, t4) {
          return i3.decryptBlock(e4, t4);
        });
      }
      decryptString(e3) {
        const t3 = new this.StringCipherConstructor();
        let i3 = stringToBytes(e3);
        return i3 = t3.decryptBlock(i3, true), bytesToString(i3);
      }
      encryptString(e3) {
        const t3 = new this.StringCipherConstructor();
        if (t3 instanceof AESBaseCipher) {
          const i4 = 16 - e3.length % 16;
          e3 += String.fromCharCode(i4).repeat(i4);
          const a3 = new Uint8Array(16);
          if ("undefined" != typeof crypto) crypto.getRandomValues(a3);
          else for (let e4 = 0; e4 < 16; e4++) a3[e4] = Math.floor(256 * Math.random());
          let s3 = stringToBytes(e3);
          s3 = t3.encrypt(s3, a3);
          const n3 = new Uint8Array(16 + s3.length);
          return n3.set(a3), n3.set(s3, 16), bytesToString(n3);
        }
        let i3 = stringToBytes(e3);
        return i3 = t3.encrypt(i3), bytesToString(i3);
      }
    };
    _CipherTransformFactory = class _CipherTransformFactory {
      constructor(e3, t3, i3) {
        __privateAdd(this, _CipherTransformFactory_instances);
        const a3 = e3.get("Filter");
        if (!isName(a3, "Standard")) throw new FormatError("unknown encryption method");
        this.filterName = a3.name, this.dict = e3;
        const s3 = e3.get("V");
        if (!Number.isInteger(s3) || 1 !== s3 && 2 !== s3 && 4 !== s3 && 5 !== s3) throw new FormatError("unsupported encryption algorithm");
        this.algorithm = s3;
        let n3 = e3.get("Length");
        if (!n3) if (s3 <= 3) n3 = 40;
        else {
          const t4 = e3.get("CF"), i4 = e3.get("StmF");
          if (t4 instanceof Dict && i4 instanceof Name) {
            t4.suppressEncryption = true;
            const e4 = t4.get(i4.name);
            n3 = e4?.get("Length") || 128, n3 < 40 && (n3 <<= 3);
          }
        }
        if (!Number.isInteger(n3) || n3 < 40 || n3 % 8 != 0) throw new FormatError("invalid key length");
        const r3 = stringToBytes(e3.get("O")), o3 = stringToBytes(e3.get("U")), g3 = r3.subarray(0, 32), c3 = o3.subarray(0, 32), h3 = e3.get("P"), l3 = e3.get("R"), C3 = (4 === s3 || 5 === s3) && false !== e3.get("EncryptMetadata");
        this.encryptMetadata = C3;
        const d3 = stringToBytes(t3);
        let u3, Q3;
        if (i3) {
          if (6 === l3) try {
            i3 = utf8StringToString(i3);
          } catch {
            warn("CipherTransformFactory: Unable to convert UTF8 encoded password.");
          }
          u3 = stringToBytes(i3);
        }
        if (5 !== s3) Q3 = __privateMethod(this, _CipherTransformFactory_instances, x_fn).call(this, d3, u3, g3, c3, h3, l3, n3, C3);
        else {
          const t4 = r3.subarray(32, 40), i4 = r3.subarray(40, 48), a4 = o3.subarray(0, 48), s4 = o3.subarray(32, 40), n4 = o3.subarray(40, 48), h4 = stringToBytes(e3.get("OE")), C4 = stringToBytes(e3.get("UE")), d4 = stringToBytes(e3.get("Perms"));
          Q3 = __privateMethod(this, _CipherTransformFactory_instances, R_fn).call(this, l3, u3, g3, t4, i4, a4, c3, s4, n4, h4, C4, d4);
        }
        if (!Q3 && !i3) throw new PasswordException("No password given", Rs);
        if (!Q3 && i3) {
          const e4 = __privateMethod(this, _CipherTransformFactory_instances, N_fn).call(this, u3, g3, l3, n3);
          Q3 = __privateMethod(this, _CipherTransformFactory_instances, x_fn).call(this, d3, e4, g3, c3, h3, l3, n3, C3);
        }
        if (!Q3) throw new PasswordException("Incorrect Password", xs);
        if (this.encryptionKey = Q3, s3 >= 4) {
          const t4 = e3.get("CF");
          t4 instanceof Dict && (t4.suppressEncryption = true), this.cf = t4, this.stmf = e3.get("StmF") || Name.get("Identity"), this.strf = e3.get("StrF") || Name.get("Identity"), this.eff = e3.get("EFF") || this.stmf;
        }
      }
      createCipherTransform(e3, t3) {
        if (4 === this.algorithm || 5 === this.algorithm) return new CipherTransform(__privateMethod(this, _CipherTransformFactory_instances, G_fn).call(this, this.cf, this.strf, e3, t3, this.encryptionKey), __privateMethod(this, _CipherTransformFactory_instances, G_fn).call(this, this.cf, this.stmf, e3, t3, this.encryptionKey));
        const i3 = __privateMethod(this, _CipherTransformFactory_instances, M_fn).call(this, e3, t3, this.encryptionKey, false), cipherConstructor = function() {
          return new ARCFourCipher(i3);
        };
        return new CipherTransform(cipherConstructor, cipherConstructor);
      }
    };
    _k = new WeakMap();
    _CipherTransformFactory_instances = new WeakSet();
    R_fn = function(e3, t3, i3, a3, s3, n3, r3, o3, g3, c3, h3, l3) {
      if (t3) {
        const e4 = Math.min(127, t3.length);
        t3 = t3.subarray(0, e4);
      } else t3 = [];
      const C3 = 6 === e3 ? new PDF20() : new PDF17();
      return C3.checkUserPassword(t3, o3, r3) ? C3.getUserKey(t3, g3, h3) : t3.length && C3.checkOwnerPassword(t3, a3, n3, i3) ? C3.getOwnerKey(t3, s3, n3, c3) : null;
    };
    x_fn = function(e3, t3, i3, a3, s3, n3, r3, o3) {
      const g3 = 40 + i3.length + e3.length, c3 = new Uint8Array(g3);
      let h3, l3, C3 = 0;
      if (t3) for (l3 = Math.min(32, t3.length); C3 < l3; ++C3) c3[C3] = t3[C3];
      for (h3 = 0; C3 < 32; ) c3[C3++] = __privateGet(_CipherTransformFactory, _k)[h3++];
      for (h3 = 0, l3 = i3.length; h3 < l3; ++h3) c3[C3++] = i3[h3];
      for (c3[C3++] = 255 & s3, c3[C3++] = s3 >> 8 & 255, c3[C3++] = s3 >> 16 & 255, c3[C3++] = s3 >>> 24 & 255, h3 = 0, l3 = e3.length; h3 < l3; ++h3) c3[C3++] = e3[h3];
      n3 >= 4 && !o3 && (c3[C3++] = 255, c3[C3++] = 255, c3[C3++] = 255, c3[C3++] = 255);
      let d3 = hg(c3, 0, C3);
      const u3 = r3 >> 3;
      if (n3 >= 3) for (h3 = 0; h3 < 50; ++h3) d3 = hg(d3, 0, u3);
      const Q3 = d3.subarray(0, u3);
      let f3, p3;
      if (n3 >= 3) {
        for (C3 = 0; C3 < 32; ++C3) c3[C3] = __privateGet(_CipherTransformFactory, _k)[C3];
        for (h3 = 0, l3 = e3.length; h3 < l3; ++h3) c3[C3++] = e3[h3];
        f3 = new ARCFourCipher(Q3), p3 = f3.encryptBlock(hg(c3, 0, C3)), l3 = Q3.length;
        const t4 = new Uint8Array(l3);
        for (h3 = 1; h3 <= 19; ++h3) {
          for (let e4 = 0; e4 < l3; ++e4) t4[e4] = Q3[e4] ^ h3;
          f3 = new ARCFourCipher(t4), p3 = f3.encryptBlock(p3);
        }
        for (h3 = 0, l3 = p3.length; h3 < l3; ++h3) if (a3[h3] !== p3[h3]) return null;
      } else for (f3 = new ARCFourCipher(Q3), p3 = f3.encryptBlock(__privateGet(_CipherTransformFactory, _k)), h3 = 0, l3 = p3.length; h3 < l3; ++h3) if (a3[h3] !== p3[h3]) return null;
      return Q3;
    };
    N_fn = function(e3, t3, i3, a3) {
      const s3 = new Uint8Array(32);
      let n3 = 0;
      const r3 = Math.min(32, e3.length);
      for (; n3 < r3; ++n3) s3[n3] = e3[n3];
      let o3 = 0;
      for (; n3 < 32; ) s3[n3++] = __privateGet(_CipherTransformFactory, _k)[o3++];
      let g3 = hg(s3, 0, n3);
      const c3 = a3 >> 3;
      if (i3 >= 3) for (o3 = 0; o3 < 50; ++o3) g3 = hg(g3, 0, g3.length);
      let h3, l3;
      if (i3 >= 3) {
        l3 = t3;
        const e4 = new Uint8Array(c3);
        for (o3 = 19; o3 >= 0; o3--) {
          for (let t4 = 0; t4 < c3; ++t4) e4[t4] = g3[t4] ^ o3;
          h3 = new ARCFourCipher(e4), l3 = h3.encryptBlock(l3);
        }
      } else h3 = new ARCFourCipher(g3.subarray(0, c3)), l3 = h3.encryptBlock(t3);
      return l3;
    };
    M_fn = function(e3, t3, i3, a3 = false) {
      const s3 = new Uint8Array(i3.length + 9), n3 = i3.length;
      let r3;
      for (r3 = 0; r3 < n3; ++r3) s3[r3] = i3[r3];
      s3[r3++] = 255 & e3, s3[r3++] = e3 >> 8 & 255, s3[r3++] = e3 >> 16 & 255, s3[r3++] = 255 & t3, s3[r3++] = t3 >> 8 & 255, a3 && (s3[r3++] = 115, s3[r3++] = 65, s3[r3++] = 108, s3[r3++] = 84);
      return hg(s3, 0, r3).subarray(0, Math.min(i3.length + 5, 16));
    };
    G_fn = function(e3, t3, i3, a3, s3) {
      if (!(t3 instanceof Name)) throw new FormatError("Invalid crypt filter name.");
      const n3 = this, r3 = e3.get(t3.name), o3 = r3?.get("CFM");
      if (!o3 || "None" === o3.name) return function() {
        return new NullCipher();
      };
      if ("V2" === o3.name) return function() {
        var _a4;
        return new ARCFourCipher(__privateMethod(_a4 = n3, _CipherTransformFactory_instances, M_fn).call(_a4, i3, a3, s3, false));
      };
      if ("AESV2" === o3.name) return function() {
        var _a4;
        return new AES128Cipher(__privateMethod(_a4 = n3, _CipherTransformFactory_instances, M_fn).call(_a4, i3, a3, s3, true));
      };
      if ("AESV3" === o3.name) return function() {
        return new AES256Cipher(s3);
      };
      throw new FormatError("Unknown crypto method");
    };
    __privateAdd(_CipherTransformFactory, _k, new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]));
    CipherTransformFactory = _CipherTransformFactory;
    Cg = 1;
    dg = 2;
    Bg = 3;
    ug = 4;
    Qg = 5;
    _StructTreeRoot = class _StructTreeRoot {
      constructor(e3, t3) {
        __privateAdd(this, _StructTreeRoot_instances);
        this.dict = e3, this.ref = t3 instanceof Ref ? t3 : null, this.roleMap = /* @__PURE__ */ new Map(), this.structParentIds = null;
      }
      init() {
        this.readRoleMap();
      }
      addAnnotationIdToPage(e3, t3) {
        __privateMethod(this, _StructTreeRoot_instances, v_fn).call(this, e3, t3, ug);
      }
      readRoleMap() {
        const e3 = this.dict.get("RoleMap");
        e3 instanceof Dict && e3.forEach((e4, t3) => {
          t3 instanceof Name && this.roleMap.set(e4, t3.name);
        });
      }
      static async canCreateStructureTree({ catalogRef: e3, pdfManager: t3, newAnnotationsByPage: i3 }) {
        if (!(e3 instanceof Ref)) return warn("Cannot save the struct tree: no catalog reference."), false;
        let a3 = 0, s3 = true;
        for (const [e4, n3] of i3) {
          const { ref: i4 } = await t3.getPage(e4);
          if (!(i4 instanceof Ref)) {
            warn(`Cannot save the struct tree: page ${e4} has no ref.`), s3 = true;
            break;
          }
          for (const e5 of n3) e5.accessibilityData?.type && (e5.parentTreeId = a3++, s3 = false);
        }
        if (s3) {
          for (const e4 of i3.values()) for (const t4 of e4) delete t4.parentTreeId;
          return false;
        }
        return true;
      }
      static async createStructureTree({ newAnnotationsByPage: e3, xref: t3, catalogRef: i3, pdfManager: a3, newRefs: s3 }) {
        const n3 = a3.catalog.cloneDict(), r3 = new RefSetCache();
        r3.put(i3, n3);
        const o3 = t3.getNewTemporaryRef();
        n3.set("StructTreeRoot", o3);
        const g3 = new Dict(t3);
        g3.set("Type", Name.get("StructTreeRoot"));
        const c3 = t3.getNewTemporaryRef();
        g3.set("ParentTree", c3);
        const h3 = [];
        g3.set("K", h3), r3.put(o3, g3);
        const l3 = new Dict(t3), C3 = [];
        l3.set("Nums", C3);
        const d3 = await __privateMethod(this, _StructTreeRoot_static, L_fn).call(this, { newAnnotationsByPage: e3, structTreeRootRef: o3, kids: h3, nums: C3, xref: t3, pdfManager: a3, cache: r3 });
        g3.set("ParentTreeNextKey", d3), r3.put(c3, l3);
        const u3 = [];
        for (const [e4, i4] of r3.items()) u3.length = 0, await writeObject(e4, i4, u3, t3), s3.push({ ref: e4, data: u3.join("") });
      }
      async canUpdateStructTree({ pdfManager: e3, xref: t3, newAnnotationsByPage: i3 }) {
        var _a4;
        if (!this.ref) return warn("Cannot update the struct tree: no root reference."), false;
        let a3 = this.dict.get("ParentTreeNextKey");
        if (!Number.isInteger(a3) || a3 < 0) return warn("Cannot update the struct tree: invalid next key."), false;
        const s3 = this.dict.get("ParentTree");
        if (!(s3 instanceof Dict)) return warn("Cannot update the struct tree: ParentTree isn't a dict."), false;
        const n3 = s3.get("Nums");
        if (!Array.isArray(n3)) return warn("Cannot update the struct tree: nums isn't an array."), false;
        const r3 = new NumberTree(s3, t3);
        for (const t4 of i3.keys()) {
          const { pageDict: i4 } = await e3.getPage(t4);
          if (!i4.has("StructParents")) continue;
          const a4 = i4.get("StructParents");
          if (!Number.isInteger(a4) || !Array.isArray(r3.get(a4))) return warn(`Cannot save the struct tree: page ${t4} has a wrong id.`), false;
        }
        let o3 = true;
        for (const [t4, s4] of i3) {
          const { pageDict: i4 } = await e3.getPage(t4);
          __privateMethod(_a4 = _StructTreeRoot, _StructTreeRoot_static, U_fn).call(_a4, { elements: s4, xref: this.dict.xref, pageDict: i4, numberTree: r3 });
          for (const e4 of s4) e4.accessibilityData?.type && (e4.parentTreeId = a3++, o3 = false);
        }
        if (o3) {
          for (const e4 of i3.values()) for (const t4 of e4) delete t4.parentTreeId, delete t4.structTreeParent;
          return false;
        }
        return true;
      }
      async updateStructureTree({ newAnnotationsByPage: e3, pdfManager: t3, newRefs: i3 }) {
        var _a4;
        const a3 = this.dict.xref, s3 = this.dict.clone(), n3 = this.ref, r3 = new RefSetCache();
        r3.put(n3, s3);
        let o3, g3 = s3.getRaw("ParentTree");
        g3 instanceof Ref ? o3 = a3.fetch(g3) : (o3 = g3, g3 = a3.getNewTemporaryRef(), s3.set("ParentTree", g3)), o3 = o3.clone(), r3.put(g3, o3);
        let c3 = o3.getRaw("Nums"), h3 = null;
        c3 instanceof Ref && (h3 = c3, c3 = a3.fetch(h3)), c3 = c3.slice(), h3 || o3.set("Nums", c3);
        const l3 = await __privateMethod(_a4 = _StructTreeRoot, _StructTreeRoot_static, L_fn).call(_a4, { newAnnotationsByPage: e3, structTreeRootRef: n3, kids: null, nums: c3, xref: a3, pdfManager: t3, cache: r3 });
        s3.set("ParentTreeNextKey", l3), h3 && r3.put(h3, c3);
        const C3 = [];
        for (const [e4, t4] of r3.items()) C3.length = 0, await writeObject(e4, t4, C3, a3), i3.push({ ref: e4, data: C3.join("") });
      }
    };
    _StructTreeRoot_instances = new WeakSet();
    v_fn = function(e3, t3, i3) {
      if (!(e3 instanceof Ref) || t3 < 0) return;
      this.structParentIds || (this.structParentIds = new RefSetCache());
      let a3 = this.structParentIds.get(e3);
      a3 || (a3 = [], this.structParentIds.put(e3, a3)), a3.push([t3, i3]);
    };
    _StructTreeRoot_static = new WeakSet();
    L_fn = async function({ newAnnotationsByPage: e3, structTreeRootRef: t3, kids: i3, nums: a3, xref: s3, pdfManager: n3, cache: r3 }) {
      const o3 = Name.get("OBJR");
      let g3 = -1 / 0;
      for (const [c3, h3] of e3) {
        const { ref: e4 } = await n3.getPage(c3), l3 = e4 instanceof Ref;
        for (const { accessibilityData: n4, ref: c4, parentTreeId: C3, structTreeParent: d3 } of h3) {
          if (!n4?.type) continue;
          const { type: h4, title: u3, lang: Q3, alt: f3, expanded: p3, actualText: m3 } = n4;
          g3 = Math.max(g3, C3);
          const y3 = s3.getNewTemporaryRef(), w3 = new Dict(s3);
          w3.set("S", Name.get(h4)), u3 && w3.set("T", stringToAsciiOrUTF16BE(u3)), Q3 && w3.set("Lang", Q3), f3 && w3.set("Alt", stringToAsciiOrUTF16BE(f3)), p3 && w3.set("E", stringToAsciiOrUTF16BE(p3)), m3 && w3.set("ActualText", stringToAsciiOrUTF16BE(m3)), await __privateMethod(this, _StructTreeRoot_static, H_fn).call(this, { structTreeParent: d3, tagDict: w3, newTagRef: y3, structTreeRootRef: t3, fallbackKids: i3, xref: s3, cache: r3 });
          const b3 = new Dict(s3);
          w3.set("K", b3), b3.set("Type", o3), l3 && b3.set("Pg", e4), b3.set("Obj", c4), r3.put(y3, w3), a3.push(C3, y3);
        }
      }
      return g3 + 1;
    };
    U_fn = function({ elements: e3, xref: t3, pageDict: i3, numberTree: a3 }) {
      const s3 = /* @__PURE__ */ new Map();
      for (const t4 of e3) if (t4.structTreeParentId) {
        const e4 = parseInt(t4.structTreeParentId.split("_mc")[1], 10);
        let i4 = s3.get(e4);
        i4 || (i4 = [], s3.set(e4, i4)), i4.push(t4);
      }
      const n3 = i3.get("StructParents");
      if (!Number.isInteger(n3)) return;
      const r3 = a3.get(n3), updateElement = (e4, i4, a4) => {
        const n4 = s3.get(e4);
        if (n4) {
          const e5 = i4.getRaw("P"), s4 = t3.fetchIfRef(e5);
          if (e5 instanceof Ref && s4 instanceof Dict) {
            const e6 = { ref: a4, dict: i4 };
            for (const t4 of n4) t4.structTreeParent = e6;
          }
          return true;
        }
        return false;
      };
      for (const e4 of r3) {
        if (!(e4 instanceof Ref)) continue;
        const i4 = t3.fetch(e4), a4 = i4.get("K");
        if (Number.isInteger(a4)) updateElement(a4, i4, e4);
        else if (Array.isArray(a4)) for (let s4 of a4) {
          if (s4 = t3.fetchIfRef(s4), Number.isInteger(s4) && updateElement(s4, i4, e4)) break;
          if (!(s4 instanceof Dict)) continue;
          if (!isName(s4.get("Type"), "MCR")) break;
          const a5 = s4.get("MCID");
          if (Number.isInteger(a5) && updateElement(a5, i4, e4)) break;
        }
      }
    };
    H_fn = async function({ structTreeParent: e3, tagDict: t3, newTagRef: i3, structTreeRootRef: a3, fallbackKids: s3, xref: n3, cache: r3 }) {
      let o3, g3 = null;
      e3 ? ({ ref: g3 } = e3, o3 = e3.dict.getRaw("P") || a3) : o3 = a3, t3.set("P", o3);
      const c3 = n3.fetchIfRef(o3);
      if (!c3) return void s3.push(i3);
      let h3 = r3.get(o3);
      h3 || (h3 = c3.clone(), r3.put(o3, h3));
      const l3 = h3.getRaw("K");
      let C3 = l3 instanceof Ref ? r3.get(l3) : null;
      if (!C3) {
        C3 = n3.fetchIfRef(l3), C3 = Array.isArray(C3) ? C3.slice() : [l3];
        const e4 = n3.getNewTemporaryRef();
        h3.set("K", e4), r3.put(e4, C3);
      }
      const d3 = C3.indexOf(g3);
      C3.splice(d3 >= 0 ? d3 + 1 : C3.length, 0, i3);
    };
    __privateAdd(_StructTreeRoot, _StructTreeRoot_static);
    StructTreeRoot = _StructTreeRoot;
    StructElementNode = class {
      constructor(e3, t3) {
        this.tree = e3, this.dict = t3, this.kids = [], this.parseKids();
      }
      get role() {
        const e3 = this.dict.get("S"), t3 = e3 instanceof Name ? e3.name : "", { root: i3 } = this.tree;
        return i3.roleMap.has(t3) ? i3.roleMap.get(t3) : t3;
      }
      parseKids() {
        let e3 = null;
        const t3 = this.dict.getRaw("Pg");
        t3 instanceof Ref && (e3 = t3.toString());
        const i3 = this.dict.get("K");
        if (Array.isArray(i3)) for (const t4 of i3) {
          const i4 = this.parseKid(e3, t4);
          i4 && this.kids.push(i4);
        }
        else {
          const t4 = this.parseKid(e3, i3);
          t4 && this.kids.push(t4);
        }
      }
      parseKid(e3, t3) {
        if (Number.isInteger(t3)) return this.tree.pageDict.objId !== e3 ? null : new StructElement({ type: Cg, mcid: t3, pageObjId: e3 });
        let i3 = null;
        if (t3 instanceof Ref ? i3 = this.dict.xref.fetch(t3) : t3 instanceof Dict && (i3 = t3), !i3) return null;
        const a3 = i3.getRaw("Pg");
        a3 instanceof Ref && (e3 = a3.toString());
        const s3 = i3.get("Type") instanceof Name ? i3.get("Type").name : null;
        if ("MCR" === s3) {
          if (this.tree.pageDict.objId !== e3) return null;
          const t4 = i3.getRaw("Stm");
          return new StructElement({ type: dg, refObjId: t4 instanceof Ref ? t4.toString() : null, pageObjId: e3, mcid: i3.get("MCID") });
        }
        if ("OBJR" === s3) {
          if (this.tree.pageDict.objId !== e3) return null;
          const t4 = i3.getRaw("Obj");
          return new StructElement({ type: Bg, refObjId: t4 instanceof Ref ? t4.toString() : null, pageObjId: e3 });
        }
        return new StructElement({ type: Qg, dict: i3 });
      }
    };
    StructElement = class {
      constructor({ type: e3, dict: t3 = null, mcid: i3 = null, pageObjId: a3 = null, refObjId: s3 = null }) {
        this.type = e3, this.dict = t3, this.mcid = i3, this.pageObjId = a3, this.refObjId = s3, this.parentNode = null;
      }
    };
    StructTreePage = class {
      constructor(e3, t3) {
        this.root = e3, this.rootDict = e3 ? e3.dict : null, this.pageDict = t3, this.nodes = [];
      }
      parse(e3) {
        if (!this.root || !this.rootDict) return;
        const t3 = this.rootDict.get("ParentTree");
        if (!t3) return;
        const i3 = this.pageDict.get("StructParents"), a3 = e3 instanceof Ref && this.root.structParentIds?.get(e3);
        if (!Number.isInteger(i3) && !a3) return;
        const s3 = /* @__PURE__ */ new Map(), n3 = new NumberTree(t3, this.rootDict.xref);
        if (Number.isInteger(i3)) {
          const e4 = n3.get(i3);
          if (Array.isArray(e4)) for (const t4 of e4) t4 instanceof Ref && this.addNode(this.rootDict.xref.fetch(t4), s3);
        }
        if (a3) for (const [e4, t4] of a3) {
          const i4 = n3.get(e4);
          if (i4) {
            const e5 = this.addNode(this.rootDict.xref.fetchIfRef(i4), s3);
            1 === e5?.kids?.length && e5.kids[0].type === Bg && (e5.kids[0].type = t4);
          }
        }
      }
      addNode(e3, t3, i3 = 0) {
        if (i3 > 40) return warn("StructTree MAX_DEPTH reached."), null;
        if (!(e3 instanceof Dict)) return null;
        if (t3.has(e3)) return t3.get(e3);
        const a3 = new StructElementNode(this, e3);
        t3.set(e3, a3);
        const s3 = e3.get("P");
        if (!s3 || isName(s3.get("Type"), "StructTreeRoot")) return this.addTopLevelNode(e3, a3) || t3.delete(e3), a3;
        const n3 = this.addNode(s3, t3, i3 + 1);
        if (!n3) return a3;
        let r3 = false;
        for (const t4 of n3.kids) t4.type === Qg && t4.dict === e3 && (t4.parentNode = a3, r3 = true);
        return r3 || t3.delete(e3), a3;
      }
      addTopLevelNode(e3, t3) {
        const i3 = this.rootDict.get("K");
        if (!i3) return false;
        if (i3 instanceof Dict) return i3.objId === e3.objId && (this.nodes[0] = t3, true);
        if (!Array.isArray(i3)) return true;
        let a3 = false;
        for (let s3 = 0; s3 < i3.length; s3++) {
          const n3 = i3[s3];
          n3?.toString() === e3.objId && (this.nodes[s3] = t3, a3 = true);
        }
        return a3;
      }
      get serializable() {
        function nodeToSerializable(e4, t3, i3 = 0) {
          if (i3 > 40) return void warn("StructTree too deep to be fully serialized.");
          const a3 = /* @__PURE__ */ Object.create(null);
          a3.role = e4.role, a3.children = [], t3.children.push(a3);
          const s3 = e4.dict.get("Alt");
          "string" == typeof s3 && (a3.alt = stringToPDFString(s3));
          const n3 = e4.dict.get("Lang");
          "string" == typeof n3 && (a3.lang = stringToPDFString(n3));
          for (const t4 of e4.kids) {
            const e5 = t4.type === Qg ? t4.parentNode : null;
            e5 ? nodeToSerializable(e5, a3, i3 + 1) : t4.type === Cg || t4.type === dg ? a3.children.push({ type: "content", id: `p${t4.pageObjId}_mc${t4.mcid}` }) : t4.type === Bg ? a3.children.push({ type: "object", id: t4.refObjId }) : t4.type === ug && a3.children.push({ type: "annotation", id: `pdfjs_internal_id_${t4.refObjId}` });
          }
        }
        const e3 = /* @__PURE__ */ Object.create(null);
        e3.children = [], e3.role = "Root";
        for (const t3 of this.nodes) t3 && nodeToSerializable(t3, e3);
        return e3;
      }
    };
    _Catalog = class _Catalog {
      constructor(e3, t3) {
        __privateAdd(this, _Catalog_instances);
        if (this.pdfManager = e3, this.xref = t3, this._catDict = t3.getCatalogObj(), !(this._catDict instanceof Dict)) throw new FormatError("Catalog object is not a dictionary.");
        this.toplevelPagesDict, this._actualNumPages = null, this.fontCache = new RefSetCache(), this.builtInCMapCache = /* @__PURE__ */ new Map(), this.standardFontDataCache = /* @__PURE__ */ new Map(), this.globalImageCache = new GlobalImageCache(), this.pageKidsCountCache = new RefSetCache(), this.pageIndexCache = new RefSetCache(), this.pageDictCache = new RefSetCache(), this.nonBlendModesSet = new RefSet(), this.systemFontCache = /* @__PURE__ */ new Map();
      }
      cloneDict() {
        return this._catDict.clone();
      }
      get version() {
        const e3 = this._catDict.get("Version");
        if (e3 instanceof Name) {
          if ($s.test(e3.name)) return shadow(this, "version", e3.name);
          warn(`Invalid PDF catalog version: ${e3.name}`);
        }
        return shadow(this, "version", null);
      }
      get lang() {
        const e3 = this._catDict.get("Lang");
        return shadow(this, "lang", e3 && "string" == typeof e3 ? stringToPDFString(e3) : null);
      }
      get needsRendering() {
        const e3 = this._catDict.get("NeedsRendering");
        return shadow(this, "needsRendering", "boolean" == typeof e3 && e3);
      }
      get collection() {
        let e3 = null;
        try {
          const t3 = this._catDict.get("Collection");
          t3 instanceof Dict && t3.size > 0 && (e3 = t3);
        } catch (e4) {
          if (e4 instanceof MissingDataException) throw e4;
          info("Cannot fetch Collection entry; assuming no collection is present.");
        }
        return shadow(this, "collection", e3);
      }
      get acroForm() {
        let e3 = null;
        try {
          const t3 = this._catDict.get("AcroForm");
          t3 instanceof Dict && t3.size > 0 && (e3 = t3);
        } catch (e4) {
          if (e4 instanceof MissingDataException) throw e4;
          info("Cannot fetch AcroForm entry; assuming no forms are present.");
        }
        return shadow(this, "acroForm", e3);
      }
      get acroFormRef() {
        const e3 = this._catDict.getRaw("AcroForm");
        return shadow(this, "acroFormRef", e3 instanceof Ref ? e3 : null);
      }
      get metadata() {
        const e3 = this._catDict.getRaw("Metadata");
        if (!(e3 instanceof Ref)) return shadow(this, "metadata", null);
        let t3 = null;
        try {
          const i3 = this.xref.fetch(e3, !this.xref.encrypt?.encryptMetadata);
          if (i3 instanceof BaseStream && i3.dict instanceof Dict) {
            const e4 = i3.dict.get("Type"), a3 = i3.dict.get("Subtype");
            if (isName(e4, "Metadata") && isName(a3, "XML")) {
              const e5 = stringToUTF8String(i3.getString());
              e5 && (t3 = new MetadataParser(e5).serializable);
            }
          }
        } catch (e4) {
          if (e4 instanceof MissingDataException) throw e4;
          info(`Skipping invalid Metadata: "${e4}".`);
        }
        return shadow(this, "metadata", t3);
      }
      get markInfo() {
        let e3 = null;
        try {
          e3 = this._readMarkInfo();
        } catch (e4) {
          if (e4 instanceof MissingDataException) throw e4;
          warn("Unable to read mark info.");
        }
        return shadow(this, "markInfo", e3);
      }
      _readMarkInfo() {
        const e3 = this._catDict.get("MarkInfo");
        if (!(e3 instanceof Dict)) return null;
        const t3 = { Marked: false, UserProperties: false, Suspects: false };
        for (const i3 in t3) {
          const a3 = e3.get(i3);
          "boolean" == typeof a3 && (t3[i3] = a3);
        }
        return t3;
      }
      get structTreeRoot() {
        let e3 = null;
        try {
          e3 = this._readStructTreeRoot();
        } catch (e4) {
          if (e4 instanceof MissingDataException) throw e4;
          warn("Unable read to structTreeRoot info.");
        }
        return shadow(this, "structTreeRoot", e3);
      }
      _readStructTreeRoot() {
        const e3 = this._catDict.getRaw("StructTreeRoot"), t3 = this.xref.fetchIfRef(e3);
        if (!(t3 instanceof Dict)) return null;
        const i3 = new StructTreeRoot(t3, e3);
        return i3.init(), i3;
      }
      get toplevelPagesDict() {
        const e3 = this._catDict.get("Pages");
        if (!(e3 instanceof Dict)) throw new FormatError("Invalid top-level pages dictionary.");
        return shadow(this, "toplevelPagesDict", e3);
      }
      get documentOutline() {
        let e3 = null;
        try {
          e3 = this._readDocumentOutline();
        } catch (e4) {
          if (e4 instanceof MissingDataException) throw e4;
          warn("Unable to read document outline.");
        }
        return shadow(this, "documentOutline", e3);
      }
      _readDocumentOutline() {
        let e3 = this._catDict.get("Outlines");
        if (!(e3 instanceof Dict)) return null;
        if (e3 = e3.getRaw("First"), !(e3 instanceof Ref)) return null;
        const t3 = { items: [] }, i3 = [{ obj: e3, parent: t3 }], a3 = new RefSet();
        a3.put(e3);
        const s3 = this.xref, n3 = new Uint8ClampedArray(3);
        for (; i3.length > 0; ) {
          const t4 = i3.shift(), r3 = s3.fetchIfRef(t4.obj);
          if (null === r3) continue;
          r3.has("Title") || warn("Invalid outline item encountered.");
          const o3 = { url: null, dest: null, action: null };
          _Catalog.parseDestDictionary({ destDict: r3, resultObj: o3, docBaseUrl: this.baseUrl, docAttachments: this.attachments });
          const g3 = r3.get("Title"), c3 = r3.get("F") || 0, h3 = r3.getArray("C"), l3 = r3.get("Count");
          let C3 = n3;
          !isNumberArray(h3, 3) || 0 === h3[0] && 0 === h3[1] && 0 === h3[2] || (C3 = ColorSpace.singletons.rgb.getRgb(h3, 0));
          const d3 = { action: o3.action, attachment: o3.attachment, dest: o3.dest, url: o3.url, unsafeUrl: o3.unsafeUrl, newWindow: o3.newWindow, setOCGState: o3.setOCGState, title: "string" == typeof g3 ? stringToPDFString(g3) : "", color: C3, count: Number.isInteger(l3) ? l3 : void 0, bold: !!(2 & c3), italic: !!(1 & c3), items: [] };
          t4.parent.items.push(d3), e3 = r3.getRaw("First"), e3 instanceof Ref && !a3.has(e3) && (i3.push({ obj: e3, parent: d3 }), a3.put(e3)), e3 = r3.getRaw("Next"), e3 instanceof Ref && !a3.has(e3) && (i3.push({ obj: e3, parent: t4.parent }), a3.put(e3));
        }
        return t3.items.length > 0 ? t3.items : null;
      }
      get permissions() {
        let e3 = null;
        try {
          e3 = this._readPermissions();
        } catch (e4) {
          if (e4 instanceof MissingDataException) throw e4;
          warn("Unable to read permissions.");
        }
        return shadow(this, "permissions", e3);
      }
      _readPermissions() {
        const e3 = this.xref.trailer.get("Encrypt");
        if (!(e3 instanceof Dict)) return null;
        let t3 = e3.get("P");
        if ("number" != typeof t3) return null;
        t3 += 2 ** 32;
        const i3 = [];
        for (const e4 in KA) {
          const a3 = KA[e4];
          t3 & a3 && i3.push(a3);
        }
        return i3;
      }
      get optionalContentConfig() {
        let e3 = null;
        try {
          const t3 = this._catDict.get("OCProperties");
          if (!t3) return shadow(this, "optionalContentConfig", null);
          const i3 = t3.get("D");
          if (!i3) return shadow(this, "optionalContentConfig", null);
          const a3 = t3.get("OCGs");
          if (!Array.isArray(a3)) return shadow(this, "optionalContentConfig", null);
          const s3 = [], n3 = new RefSet();
          for (const e4 of a3) e4 instanceof Ref && !n3.has(e4) && (n3.put(e4), s3.push(__privateMethod(this, _Catalog_instances, T_fn).call(this, e4)));
          e3 = __privateMethod(this, _Catalog_instances, J_fn).call(this, i3, n3), e3.groups = s3;
        } catch (e4) {
          if (e4 instanceof MissingDataException) throw e4;
          warn(`Unable to read optional content config: ${e4}`);
        }
        return shadow(this, "optionalContentConfig", e3);
      }
      setActualNumPages(e3 = null) {
        this._actualNumPages = e3;
      }
      get hasActualNumPages() {
        return null !== this._actualNumPages;
      }
      get _pagesCount() {
        const e3 = this.toplevelPagesDict.get("Count");
        if (!Number.isInteger(e3)) throw new FormatError("Page count in top-level pages dictionary is not an integer.");
        return shadow(this, "_pagesCount", e3);
      }
      get numPages() {
        return this.hasActualNumPages ? this._actualNumPages : this._pagesCount;
      }
      get destinations() {
        const e3 = this._readDests(), t3 = /* @__PURE__ */ Object.create(null);
        if (e3 instanceof NameTree) for (const [i3, a3] of e3.getAll()) {
          const e4 = fetchDest(a3);
          e4 && (t3[stringToPDFString(i3)] = e4);
        }
        else e3 instanceof Dict && e3.forEach(function(e4, i3) {
          const a3 = fetchDest(i3);
          a3 && (t3[e4] = a3);
        });
        return shadow(this, "destinations", t3);
      }
      getDestination(e3) {
        const t3 = this._readDests();
        if (t3 instanceof NameTree) {
          const i3 = fetchDest(t3.get(e3));
          if (i3) return i3;
          const a3 = this.destinations[e3];
          if (a3) return warn(`Found "${e3}" at an incorrect position in the NameTree.`), a3;
        } else if (t3 instanceof Dict) {
          const i3 = fetchDest(t3.get(e3));
          if (i3) return i3;
        }
        return null;
      }
      _readDests() {
        const e3 = this._catDict.get("Names");
        return e3?.has("Dests") ? new NameTree(e3.getRaw("Dests"), this.xref) : this._catDict.has("Dests") ? this._catDict.get("Dests") : void 0;
      }
      get pageLabels() {
        let e3 = null;
        try {
          e3 = this._readPageLabels();
        } catch (e4) {
          if (e4 instanceof MissingDataException) throw e4;
          warn("Unable to read page labels.");
        }
        return shadow(this, "pageLabels", e3);
      }
      _readPageLabels() {
        const e3 = this._catDict.getRaw("PageLabels");
        if (!e3) return null;
        const t3 = new Array(this.numPages);
        let i3 = null, a3 = "";
        const s3 = new NumberTree(e3, this.xref).getAll();
        let n3 = "", r3 = 1;
        for (let e4 = 0, o3 = this.numPages; e4 < o3; e4++) {
          const o4 = s3.get(e4);
          if (void 0 !== o4) {
            if (!(o4 instanceof Dict)) throw new FormatError("PageLabel is not a dictionary.");
            if (o4.has("Type") && !isName(o4.get("Type"), "PageLabel")) throw new FormatError("Invalid type in PageLabel dictionary.");
            if (o4.has("S")) {
              const e5 = o4.get("S");
              if (!(e5 instanceof Name)) throw new FormatError("Invalid style in PageLabel dictionary.");
              i3 = e5.name;
            } else i3 = null;
            if (o4.has("P")) {
              const e5 = o4.get("P");
              if ("string" != typeof e5) throw new FormatError("Invalid prefix in PageLabel dictionary.");
              a3 = stringToPDFString(e5);
            } else a3 = "";
            if (o4.has("St")) {
              const e5 = o4.get("St");
              if (!(Number.isInteger(e5) && e5 >= 1)) throw new FormatError("Invalid start in PageLabel dictionary.");
              r3 = e5;
            } else r3 = 1;
          }
          switch (i3) {
            case "D":
              n3 = r3;
              break;
            case "R":
            case "r":
              n3 = toRomanNumerals(r3, "r" === i3);
              break;
            case "A":
            case "a":
              const e5 = 26, t4 = "a" === i3 ? 97 : 65, a4 = r3 - 1;
              n3 = String.fromCharCode(t4 + a4 % e5).repeat(Math.floor(a4 / e5) + 1);
              break;
            default:
              if (i3) throw new FormatError(`Invalid style "${i3}" in PageLabel dictionary.`);
              n3 = "";
          }
          t3[e4] = a3 + n3, r3++;
        }
        return t3;
      }
      get pageLayout() {
        const e3 = this._catDict.get("PageLayout");
        let t3 = "";
        if (e3 instanceof Name) switch (e3.name) {
          case "SinglePage":
          case "OneColumn":
          case "TwoColumnLeft":
          case "TwoColumnRight":
          case "TwoPageLeft":
          case "TwoPageRight":
            t3 = e3.name;
        }
        return shadow(this, "pageLayout", t3);
      }
      get pageMode() {
        const e3 = this._catDict.get("PageMode");
        let t3 = "UseNone";
        if (e3 instanceof Name) switch (e3.name) {
          case "UseNone":
          case "UseOutlines":
          case "UseThumbs":
          case "FullScreen":
          case "UseOC":
          case "UseAttachments":
            t3 = e3.name;
        }
        return shadow(this, "pageMode", t3);
      }
      get viewerPreferences() {
        const e3 = this._catDict.get("ViewerPreferences");
        if (!(e3 instanceof Dict)) return shadow(this, "viewerPreferences", null);
        let t3 = null;
        for (const i3 of e3.getKeys()) {
          const a3 = e3.get(i3);
          let s3;
          switch (i3) {
            case "HideToolbar":
            case "HideMenubar":
            case "HideWindowUI":
            case "FitWindow":
            case "CenterWindow":
            case "DisplayDocTitle":
            case "PickTrayByPDFSize":
              "boolean" == typeof a3 && (s3 = a3);
              break;
            case "NonFullScreenPageMode":
              if (a3 instanceof Name) switch (a3.name) {
                case "UseNone":
                case "UseOutlines":
                case "UseThumbs":
                case "UseOC":
                  s3 = a3.name;
                  break;
                default:
                  s3 = "UseNone";
              }
              break;
            case "Direction":
              if (a3 instanceof Name) switch (a3.name) {
                case "L2R":
                case "R2L":
                  s3 = a3.name;
                  break;
                default:
                  s3 = "L2R";
              }
              break;
            case "ViewArea":
            case "ViewClip":
            case "PrintArea":
            case "PrintClip":
              if (a3 instanceof Name) switch (a3.name) {
                case "MediaBox":
                case "CropBox":
                case "BleedBox":
                case "TrimBox":
                case "ArtBox":
                  s3 = a3.name;
                  break;
                default:
                  s3 = "CropBox";
              }
              break;
            case "PrintScaling":
              if (a3 instanceof Name) switch (a3.name) {
                case "None":
                case "AppDefault":
                  s3 = a3.name;
                  break;
                default:
                  s3 = "AppDefault";
              }
              break;
            case "Duplex":
              if (a3 instanceof Name) switch (a3.name) {
                case "Simplex":
                case "DuplexFlipShortEdge":
                case "DuplexFlipLongEdge":
                  s3 = a3.name;
                  break;
                default:
                  s3 = "None";
              }
              break;
            case "PrintPageRange":
              if (Array.isArray(a3) && a3.length % 2 == 0) {
                a3.every((e4, t4, i4) => Number.isInteger(e4) && e4 > 0 && (0 === t4 || e4 >= i4[t4 - 1]) && e4 <= this.numPages) && (s3 = a3);
              }
              break;
            case "NumCopies":
              Number.isInteger(a3) && a3 > 0 && (s3 = a3);
              break;
            default:
              warn(`Ignoring non-standard key in ViewerPreferences: ${i3}.`);
              continue;
          }
          void 0 !== s3 ? (t3 || (t3 = /* @__PURE__ */ Object.create(null)), t3[i3] = s3) : warn(`Bad value, for key "${i3}", in ViewerPreferences: ${a3}.`);
        }
        return shadow(this, "viewerPreferences", t3);
      }
      get openAction() {
        const e3 = this._catDict.get("OpenAction"), t3 = /* @__PURE__ */ Object.create(null);
        if (e3 instanceof Dict) {
          const i3 = new Dict(this.xref);
          i3.set("A", e3);
          const a3 = { url: null, dest: null, action: null };
          _Catalog.parseDestDictionary({ destDict: i3, resultObj: a3 }), Array.isArray(a3.dest) ? t3.dest = a3.dest : a3.action && (t3.action = a3.action);
        } else Array.isArray(e3) && (t3.dest = e3);
        return shadow(this, "openAction", objectSize(t3) > 0 ? t3 : null);
      }
      get attachments() {
        const e3 = this._catDict.get("Names");
        let t3 = null;
        if (e3 instanceof Dict && e3.has("EmbeddedFiles")) {
          const i3 = new NameTree(e3.getRaw("EmbeddedFiles"), this.xref);
          for (const [e4, a3] of i3.getAll()) {
            const i4 = new FileSpec(a3, this.xref);
            t3 || (t3 = /* @__PURE__ */ Object.create(null)), t3[stringToPDFString(e4)] = i4.serializable;
          }
        }
        return shadow(this, "attachments", t3);
      }
      get xfaImages() {
        const e3 = this._catDict.get("Names");
        let t3 = null;
        if (e3 instanceof Dict && e3.has("XFAImages")) {
          const i3 = new NameTree(e3.getRaw("XFAImages"), this.xref);
          for (const [e4, a3] of i3.getAll()) t3 || (t3 = new Dict(this.xref)), t3.set(stringToPDFString(e4), a3);
        }
        return shadow(this, "xfaImages", t3);
      }
      _collectJavaScript() {
        const e3 = this._catDict.get("Names");
        let t3 = null;
        function appendIfJavaScriptDict(e4, i4) {
          if (!(i4 instanceof Dict)) return;
          if (!isName(i4.get("S"), "JavaScript")) return;
          let a3 = i4.get("JS");
          if (a3 instanceof BaseStream) a3 = a3.getString();
          else if ("string" != typeof a3) return;
          a3 = stringToPDFString(a3).replaceAll("\0", ""), a3 && (t3 || (t3 = /* @__PURE__ */ new Map())).set(e4, a3);
        }
        if (e3 instanceof Dict && e3.has("JavaScript")) {
          const t4 = new NameTree(e3.getRaw("JavaScript"), this.xref);
          for (const [e4, i4] of t4.getAll()) appendIfJavaScriptDict(stringToPDFString(e4), i4);
        }
        const i3 = this._catDict.get("OpenAction");
        return i3 && appendIfJavaScriptDict("OpenAction", i3), t3;
      }
      get jsActions() {
        const e3 = this._collectJavaScript();
        let t3 = collectActions(this.xref, this._catDict, Pi);
        if (e3) {
          t3 || (t3 = /* @__PURE__ */ Object.create(null));
          for (const [i3, a3] of e3) i3 in t3 ? t3[i3].push(a3) : t3[i3] = [a3];
        }
        return shadow(this, "jsActions", t3);
      }
      async fontFallback(e3, t3) {
        const i3 = await Promise.all(this.fontCache);
        for (const a3 of i3) if (a3.loadedName === e3) return void a3.fallback(t3);
      }
      async cleanup(e3 = false) {
        clearGlobalCaches(), this.globalImageCache.clear(e3), this.pageKidsCountCache.clear(), this.pageIndexCache.clear(), this.pageDictCache.clear(), this.nonBlendModesSet.clear();
        const t3 = await Promise.all(this.fontCache);
        for (const { dict: e4 } of t3) delete e4.cacheKey;
        this.fontCache.clear(), this.builtInCMapCache.clear(), this.standardFontDataCache.clear(), this.systemFontCache.clear();
      }
      async getPageDict(e3) {
        const t3 = [this.toplevelPagesDict], i3 = new RefSet(), a3 = this._catDict.getRaw("Pages");
        a3 instanceof Ref && i3.put(a3);
        const s3 = this.xref, n3 = this.pageKidsCountCache, r3 = this.pageIndexCache, o3 = this.pageDictCache;
        let g3 = 0;
        for (; t3.length; ) {
          const a4 = t3.pop();
          if (a4 instanceof Ref) {
            const c4 = n3.get(a4);
            if (c4 >= 0 && g3 + c4 <= e3) {
              g3 += c4;
              continue;
            }
            if (i3.has(a4)) throw new FormatError("Pages tree contains circular reference.");
            i3.put(a4);
            const h4 = await (o3.get(a4) || s3.fetchAsync(a4));
            if (h4 instanceof Dict) {
              let t4 = h4.getRaw("Type");
              if (t4 instanceof Ref && (t4 = await s3.fetchAsync(t4)), isName(t4, "Page") || !h4.has("Kids")) {
                if (n3.has(a4) || n3.put(a4, 1), r3.has(a4) || r3.put(a4, g3), g3 === e3) return [h4, a4];
                g3++;
                continue;
              }
            }
            t3.push(h4);
            continue;
          }
          if (!(a4 instanceof Dict)) throw new FormatError("Page dictionary kid reference points to wrong type of object.");
          const { objId: c3 } = a4;
          let h3 = a4.getRaw("Count");
          if (h3 instanceof Ref && (h3 = await s3.fetchAsync(h3)), Number.isInteger(h3) && h3 >= 0 && (c3 && !n3.has(c3) && n3.put(c3, h3), g3 + h3 <= e3)) {
            g3 += h3;
            continue;
          }
          let l3 = a4.getRaw("Kids");
          if (l3 instanceof Ref && (l3 = await s3.fetchAsync(l3)), !Array.isArray(l3)) {
            let t4 = a4.getRaw("Type");
            if (t4 instanceof Ref && (t4 = await s3.fetchAsync(t4)), isName(t4, "Page") || !a4.has("Kids")) {
              if (g3 === e3) return [a4, null];
              g3++;
              continue;
            }
            throw new FormatError("Page dictionary kids object is not an array.");
          }
          for (let e4 = l3.length - 1; e4 >= 0; e4--) {
            const i4 = l3[e4];
            t3.push(i4), a4 === this.toplevelPagesDict && i4 instanceof Ref && !o3.has(i4) && o3.put(i4, s3.fetchAsync(i4));
          }
        }
        throw new Error(`Page index ${e3} not found.`);
      }
      async getAllPageDicts(e3 = false) {
        const { ignoreErrors: t3 } = this.pdfManager.evaluatorOptions, i3 = [{ currentNode: this.toplevelPagesDict, posInKids: 0 }], a3 = new RefSet(), s3 = this._catDict.getRaw("Pages");
        s3 instanceof Ref && a3.put(s3);
        const n3 = /* @__PURE__ */ new Map(), r3 = this.xref, o3 = this.pageIndexCache;
        let g3 = 0;
        function addPageError(i4) {
          if (i4 instanceof XRefEntryException && !e3) throw i4;
          e3 && t3 && 0 === g3 && (warn(`getAllPageDicts - Skipping invalid first page: "${i4}".`), i4 = Dict.empty), n3.set(g3++, [i4, null]);
        }
        for (; i3.length > 0; ) {
          const e4 = i3.at(-1), { currentNode: t4, posInKids: s4 } = e4;
          let l3 = t4.getRaw("Kids");
          if (l3 instanceof Ref) try {
            l3 = await r3.fetchAsync(l3);
          } catch (e5) {
            addPageError(e5);
            break;
          }
          if (!Array.isArray(l3)) {
            addPageError(new FormatError("Page dictionary kids object is not an array."));
            break;
          }
          if (s4 >= l3.length) {
            i3.pop();
            continue;
          }
          const C3 = l3[s4];
          let d3;
          if (C3 instanceof Ref) {
            if (a3.has(C3)) {
              addPageError(new FormatError("Pages tree contains circular reference."));
              break;
            }
            a3.put(C3);
            try {
              d3 = await r3.fetchAsync(C3);
            } catch (e5) {
              addPageError(e5);
              break;
            }
          } else d3 = C3;
          if (!(d3 instanceof Dict)) {
            addPageError(new FormatError("Page dictionary kid reference points to wrong type of object."));
            break;
          }
          let u3 = d3.getRaw("Type");
          if (u3 instanceof Ref) try {
            u3 = await r3.fetchAsync(u3);
          } catch (e5) {
            addPageError(e5);
            break;
          }
          isName(u3, "Page") || !d3.has("Kids") ? (c3 = d3, (h3 = C3 instanceof Ref ? C3 : null) && !o3.has(h3) && o3.put(h3, g3), n3.set(g3++, [c3, h3])) : i3.push({ currentNode: d3, posInKids: 0 }), e4.posInKids++;
        }
        var c3, h3;
        return n3;
      }
      getPageIndex(e3) {
        const t3 = this.pageIndexCache.get(e3);
        if (void 0 !== t3) return Promise.resolve(t3);
        const i3 = this.xref;
        let a3 = 0;
        const next = (t4) => function(t5) {
          let a4, s3 = 0;
          return i3.fetchAsync(t5).then(function(i4) {
            if (isRefsEqual(t5, e3) && !isDict(i4, "Page") && !(i4 instanceof Dict && !i4.has("Type") && i4.has("Contents"))) throw new FormatError("The reference does not point to a /Page dictionary.");
            if (!i4) return null;
            if (!(i4 instanceof Dict)) throw new FormatError("Node must be a dictionary.");
            return a4 = i4.getRaw("Parent"), i4.getAsync("Parent");
          }).then(function(e4) {
            if (!e4) return null;
            if (!(e4 instanceof Dict)) throw new FormatError("Parent must be a dictionary.");
            return e4.getAsync("Kids");
          }).then(function(e4) {
            if (!e4) return null;
            const n3 = [];
            let r3 = false;
            for (const a5 of e4) {
              if (!(a5 instanceof Ref)) throw new FormatError("Kid must be a reference.");
              if (isRefsEqual(a5, t5)) {
                r3 = true;
                break;
              }
              n3.push(i3.fetchAsync(a5).then(function(e5) {
                if (!(e5 instanceof Dict)) throw new FormatError("Kid node must be a dictionary.");
                e5.has("Count") ? s3 += e5.get("Count") : s3++;
              }));
            }
            if (!r3) throw new FormatError("Kid reference not found in parent's kids.");
            return Promise.all(n3).then(function() {
              return [s3, a4];
            });
          });
        }(t4).then((t5) => {
          if (!t5) return this.pageIndexCache.put(e3, a3), a3;
          const [i4, s3] = t5;
          return a3 += i4, next(s3);
        });
        return next(e3);
      }
      get baseUrl() {
        const e3 = this._catDict.get("URI");
        if (e3 instanceof Dict) {
          const t3 = e3.get("Base");
          if ("string" == typeof t3) {
            const e4 = createValidAbsoluteUrl(t3, null, { tryConvertEncoding: true });
            if (e4) return shadow(this, "baseUrl", e4.href);
          }
        }
        return shadow(this, "baseUrl", this.pdfManager.docBaseUrl);
      }
      static parseDestDictionary({ destDict: e3, resultObj: t3, docBaseUrl: i3 = null, docAttachments: a3 = null }) {
        if (!(e3 instanceof Dict)) return void warn("parseDestDictionary: `destDict` must be a dictionary.");
        let s3, n3, r3 = e3.get("A");
        if (r3 instanceof Dict || (e3.has("Dest") ? r3 = e3.get("Dest") : (r3 = e3.get("AA"), r3 instanceof Dict && (r3.has("D") ? r3 = r3.get("D") : r3.has("U") && (r3 = r3.get("U"))))), r3 instanceof Dict) {
          const e4 = r3.get("S");
          if (!(e4 instanceof Name)) return void warn("parseDestDictionary: Invalid type in Action dictionary.");
          const i4 = e4.name;
          switch (i4) {
            case "ResetForm":
              const e5 = r3.get("Flags"), o3 = !(1 & ("number" == typeof e5 ? e5 : 0)), g3 = [], c3 = [];
              for (const e6 of r3.get("Fields") || []) e6 instanceof Ref ? c3.push(e6.toString()) : "string" == typeof e6 && g3.push(stringToPDFString(e6));
              t3.resetForm = { fields: g3, refs: c3, include: o3 };
              break;
            case "URI":
              s3 = r3.get("URI"), s3 instanceof Name && (s3 = "/" + s3.name);
              break;
            case "GoTo":
              n3 = r3.get("D");
              break;
            case "Launch":
            case "GoToR":
              const h3 = r3.get("F");
              if (h3 instanceof Dict) {
                const e6 = new FileSpec(h3, null, true), { rawFilename: t4 } = e6.serializable;
                s3 = t4;
              } else "string" == typeof h3 && (s3 = h3);
              const l3 = fetchRemoteDest(r3);
              l3 && "string" == typeof s3 && (s3 = s3.split("#", 1)[0] + "#" + l3);
              const C3 = r3.get("NewWindow");
              "boolean" == typeof C3 && (t3.newWindow = C3);
              break;
            case "GoToE":
              const d3 = r3.get("T");
              let u3;
              if (a3 && d3 instanceof Dict) {
                const e6 = d3.get("R"), t4 = d3.get("N");
                isName(e6, "C") && "string" == typeof t4 && (u3 = a3[stringToPDFString(t4)]);
              }
              if (u3) {
                t3.attachment = u3;
                const e6 = fetchRemoteDest(r3);
                e6 && (t3.attachmentDest = e6);
              } else warn('parseDestDictionary - unimplemented "GoToE" action.');
              break;
            case "Named":
              const Q3 = r3.get("N");
              Q3 instanceof Name && (t3.action = Q3.name);
              break;
            case "SetOCGState":
              const f3 = r3.get("State"), p3 = r3.get("PreserveRB");
              if (!Array.isArray(f3) || 0 === f3.length) break;
              const m3 = [];
              for (const e6 of f3) if (e6 instanceof Name) switch (e6.name) {
                case "ON":
                case "OFF":
                case "Toggle":
                  m3.push(e6.name);
              }
              else e6 instanceof Ref && m3.push(e6.toString());
              if (m3.length !== f3.length) break;
              t3.setOCGState = { state: m3, preserveRB: "boolean" != typeof p3 || p3 };
              break;
            case "JavaScript":
              const y3 = r3.get("JS");
              let w3;
              y3 instanceof BaseStream ? w3 = y3.getString() : "string" == typeof y3 && (w3 = y3);
              const b3 = w3 && recoverJsURL(stringToPDFString(w3));
              if (b3) {
                s3 = b3.url, t3.newWindow = b3.newWindow;
                break;
              }
            default:
              if ("JavaScript" === i4 || "SubmitForm" === i4) break;
              warn(`parseDestDictionary - unsupported action: "${i4}".`);
          }
        } else e3.has("Dest") && (n3 = e3.get("Dest"));
        if ("string" == typeof s3) {
          const e4 = createValidAbsoluteUrl(s3, i3, { addDefaultProtocol: true, tryConvertEncoding: true });
          e4 && (t3.url = e4.href), t3.unsafeUrl = s3;
        }
        n3 && (n3 instanceof Name && (n3 = n3.name), "string" == typeof n3 ? t3.dest = stringToPDFString(n3) : isValidExplicitDest(n3) && (t3.dest = n3));
      }
    };
    _Catalog_instances = new WeakSet();
    T_fn = function(e3) {
      const t3 = this.xref.fetch(e3), i3 = { id: e3.toString(), name: null, intent: null, usage: { print: null, view: null } }, a3 = t3.get("Name");
      "string" == typeof a3 && (i3.name = stringToPDFString(a3));
      let s3 = t3.getArray("Intent");
      Array.isArray(s3) || (s3 = [s3]), s3.every((e4) => e4 instanceof Name) && (i3.intent = s3.map((e4) => e4.name));
      const n3 = t3.get("Usage");
      if (!(n3 instanceof Dict)) return i3;
      const r3 = i3.usage, o3 = n3.get("Print");
      if (o3 instanceof Dict) {
        const e4 = o3.get("PrintState");
        if (e4 instanceof Name) switch (e4.name) {
          case "ON":
          case "OFF":
            r3.print = { printState: e4.name };
        }
      }
      const g3 = n3.get("View");
      if (g3 instanceof Dict) {
        const e4 = g3.get("ViewState");
        if (e4 instanceof Name) switch (e4.name) {
          case "ON":
          case "OFF":
            r3.view = { viewState: e4.name };
        }
      }
      return i3;
    };
    J_fn = function(e3, t3) {
      function parseOnOff(e4) {
        const i4 = [];
        if (Array.isArray(e4)) for (const a4 of e4) a4 instanceof Ref && t3.has(a4) && i4.push(a4.toString());
        return i4;
      }
      function parseOrder(e4, i4 = 0) {
        if (!Array.isArray(e4)) return null;
        const s4 = [];
        for (const n4 of e4) {
          if (n4 instanceof Ref && t3.has(n4)) {
            a3.put(n4), s4.push(n4.toString());
            continue;
          }
          const e5 = parseNestedOrder(n4, i4);
          e5 && s4.push(e5);
        }
        if (i4 > 0) return s4;
        const n3 = [];
        for (const e5 of t3) a3.has(e5) || n3.push(e5.toString());
        return n3.length && s4.push({ name: null, order: n3 }), s4;
      }
      function parseNestedOrder(e4, t4) {
        if (++t4 > s3) return warn("parseNestedOrder - reached MAX_NESTED_LEVELS."), null;
        const a4 = i3.fetchIfRef(e4);
        if (!Array.isArray(a4)) return null;
        const n3 = i3.fetchIfRef(a4[0]);
        if ("string" != typeof n3) return null;
        const r3 = parseOrder(a4.slice(1), t4);
        return r3 && r3.length ? { name: stringToPDFString(n3), order: r3 } : null;
      }
      const i3 = this.xref, a3 = new RefSet(), s3 = 10;
      return { name: "string" == typeof e3.get("Name") ? stringToPDFString(e3.get("Name")) : null, creator: "string" == typeof e3.get("Creator") ? stringToPDFString(e3.get("Creator")) : null, baseState: e3.get("BaseState") instanceof Name ? e3.get("BaseState").name : null, on: parseOnOff(e3.get("ON")), off: parseOnOff(e3.get("OFF")), order: parseOrder(e3.get("Order")), groups: null };
    };
    Catalog = _Catalog;
    ObjectLoader = class {
      constructor(e3, t3, i3) {
        this.dict = e3, this.keys = t3, this.xref = i3, this.refSet = null;
      }
      async load() {
        if (this.xref.stream.isDataLoaded) return;
        const { keys: e3, dict: t3 } = this;
        this.refSet = new RefSet();
        const i3 = [];
        for (const a3 of e3) {
          const e4 = t3.getRaw(a3);
          void 0 !== e4 && i3.push(e4);
        }
        return this._walk(i3);
      }
      async _walk(e3) {
        const t3 = [], i3 = [];
        for (; e3.length; ) {
          let a3 = e3.pop();
          if (a3 instanceof Ref) {
            if (this.refSet.has(a3)) continue;
            try {
              this.refSet.put(a3), a3 = this.xref.fetch(a3);
            } catch (e4) {
              if (!(e4 instanceof MissingDataException)) {
                warn(`ObjectLoader._walk - requesting all data: "${e4}".`), this.refSet = null;
                const { manager: t4 } = this.xref.stream;
                return t4.requestAllChunks();
              }
              t3.push(a3), i3.push({ begin: e4.begin, end: e4.end });
            }
          }
          if (a3 instanceof BaseStream) {
            const e4 = a3.getBaseStreams();
            if (e4) {
              let s3 = false;
              for (const t4 of e4) t4.isDataLoaded || (s3 = true, i3.push({ begin: t4.start, end: t4.end }));
              s3 && t3.push(a3);
            }
          }
          addChildren(a3, e3);
        }
        if (i3.length) {
          await this.xref.stream.manager.requestRanges(i3);
          for (const e4 of t3) e4 instanceof Ref && this.refSet.remove(e4);
          return this._walk(t3);
        }
        this.refSet = null;
      }
    };
    Eg = Symbol();
    fg = Symbol();
    pg = Symbol();
    mg = Symbol();
    yg = Symbol();
    wg = Symbol();
    bg = Symbol();
    Dg = Symbol();
    Sg = Symbol();
    Fg = Symbol("content");
    kg = Symbol("data");
    Rg = Symbol();
    xg = Symbol("extra");
    Ng = Symbol();
    Mg = Symbol();
    Gg = Symbol();
    vg = Symbol();
    Lg = Symbol();
    Ug = Symbol();
    Hg = Symbol();
    Tg = Symbol();
    Jg = Symbol();
    Yg = Symbol();
    Pg = Symbol();
    Og = Symbol();
    Kg = Symbol();
    qg = Symbol();
    _g2 = Symbol();
    Wg = Symbol();
    jg = Symbol();
    Xg = Symbol();
    Vg = Symbol();
    Zg = Symbol();
    zg = Symbol();
    $g = Symbol();
    ec = Symbol();
    tc = Symbol();
    Ac = Symbol();
    ic = Symbol();
    ac = Symbol();
    sc = Symbol();
    nc = Symbol();
    rc = Symbol();
    oc = Symbol();
    gc = Symbol();
    cc = Symbol("namespaceId");
    hc = Symbol("nodeName");
    lc = Symbol();
    Ic = Symbol();
    Cc = Symbol();
    dc = Symbol();
    Bc = Symbol();
    uc = Symbol();
    Qc = Symbol();
    Ec = Symbol();
    fc = Symbol("root");
    pc = Symbol();
    mc = Symbol();
    yc = Symbol();
    wc = Symbol();
    bc = Symbol();
    Dc = Symbol();
    Sc = Symbol();
    Fc = Symbol();
    kc = Symbol();
    Rc = Symbol();
    xc = Symbol();
    Nc = Symbol("uid");
    Mc = Symbol();
    Gc = { config: { id: 0, check: (e3) => e3.startsWith("http://www.xfa.org/schema/xci/") }, connectionSet: { id: 1, check: (e3) => e3.startsWith("http://www.xfa.org/schema/xfa-connection-set/") }, datasets: { id: 2, check: (e3) => e3.startsWith("http://www.xfa.org/schema/xfa-data/") }, form: { id: 3, check: (e3) => e3.startsWith("http://www.xfa.org/schema/xfa-form/") }, localeSet: { id: 4, check: (e3) => e3.startsWith("http://www.xfa.org/schema/xfa-locale-set/") }, pdf: { id: 5, check: (e3) => "http://ns.adobe.com/xdp/pdf/" === e3 }, signature: { id: 6, check: (e3) => "http://www.w3.org/2000/09/xmldsig#" === e3 }, sourceSet: { id: 7, check: (e3) => e3.startsWith("http://www.xfa.org/schema/xfa-source-set/") }, stylesheet: { id: 8, check: (e3) => "http://www.w3.org/1999/XSL/Transform" === e3 }, template: { id: 9, check: (e3) => e3.startsWith("http://www.xfa.org/schema/xfa-template/") }, xdc: { id: 10, check: (e3) => e3.startsWith("http://www.xfa.org/schema/xdc/") }, xdp: { id: 11, check: (e3) => "http://ns.adobe.com/xdp/" === e3 }, xfdf: { id: 12, check: (e3) => "http://ns.adobe.com/xfdf/" === e3 }, xhtml: { id: 13, check: (e3) => "http://www.w3.org/1999/xhtml" === e3 }, xmpmeta: { id: 14, check: (e3) => "http://ns.adobe.com/xmpmeta/" === e3 } };
    vc = { pt: (e3) => e3, cm: (e3) => e3 / 2.54 * 72, mm: (e3) => e3 / 25.4 * 72, in: (e3) => 72 * e3, px: (e3) => e3 };
    Lc = /([+-]?\d+\.?\d*)(.*)/;
    HTMLResult = class _HTMLResult {
      static get FAILURE() {
        return shadow(this, "FAILURE", new _HTMLResult(false, null, null, null));
      }
      static get EMPTY() {
        return shadow(this, "EMPTY", new _HTMLResult(true, null, null, null));
      }
      constructor(e3, t3, i3, a3) {
        this.success = e3, this.html = t3, this.bbox = i3, this.breakNode = a3;
      }
      isBreak() {
        return !!this.breakNode;
      }
      static breakNode(e3) {
        return new _HTMLResult(false, null, null, e3);
      }
      static success(e3, t3 = null) {
        return new _HTMLResult(true, e3, t3, null);
      }
    };
    FontFinder = class {
      constructor(e3) {
        this.fonts = /* @__PURE__ */ new Map(), this.cache = /* @__PURE__ */ new Map(), this.warned = /* @__PURE__ */ new Set(), this.defaultFont = null, this.add(e3);
      }
      add(e3, t3 = null) {
        for (const t4 of e3) this.addPdfFont(t4);
        for (const e4 of this.fonts.values()) e4.regular || (e4.regular = e4.italic || e4.bold || e4.bolditalic);
        if (!t3 || 0 === t3.size) return;
        const i3 = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
        for (const e4 of t3) this.fonts.set(e4, i3);
      }
      addPdfFont(e3) {
        const t3 = e3.cssFontInfo, i3 = t3.fontFamily;
        let a3 = this.fonts.get(i3);
        a3 || (a3 = /* @__PURE__ */ Object.create(null), this.fonts.set(i3, a3), this.defaultFont || (this.defaultFont = a3));
        let s3 = "";
        const n3 = parseFloat(t3.fontWeight);
        0 !== parseFloat(t3.italicAngle) ? s3 = n3 >= 700 ? "bolditalic" : "italic" : n3 >= 700 && (s3 = "bold"), s3 || ((e3.name.includes("Bold") || e3.psName?.includes("Bold")) && (s3 = "bold"), (e3.name.includes("Italic") || e3.name.endsWith("It") || e3.psName?.includes("Italic") || e3.psName?.endsWith("It")) && (s3 += "italic")), s3 || (s3 = "regular"), a3[s3] = e3;
      }
      getDefault() {
        return this.defaultFont;
      }
      find(e3, t3 = true) {
        let i3 = this.fonts.get(e3) || this.cache.get(e3);
        if (i3) return i3;
        const a3 = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
        let s3 = e3.replaceAll(a3, "");
        if (i3 = this.fonts.get(s3), i3) return this.cache.set(e3, i3), i3;
        s3 = s3.toLowerCase();
        const n3 = [];
        for (const [e4, t4] of this.fonts.entries()) e4.replaceAll(a3, "").toLowerCase().startsWith(s3) && n3.push(t4);
        if (0 === n3.length) for (const [, e4] of this.fonts.entries()) e4.regular.name?.replaceAll(a3, "").toLowerCase().startsWith(s3) && n3.push(e4);
        if (0 === n3.length) {
          s3 = s3.replaceAll(/psmt|mt/gi, "");
          for (const [e4, t4] of this.fonts.entries()) e4.replaceAll(a3, "").toLowerCase().startsWith(s3) && n3.push(t4);
        }
        if (0 === n3.length) for (const e4 of this.fonts.values()) e4.regular.name?.replaceAll(a3, "").toLowerCase().startsWith(s3) && n3.push(e4);
        return n3.length >= 1 ? (1 !== n3.length && t3 && warn(`XFA - Too many choices to guess the correct font: ${e3}`), this.cache.set(e3, n3[0]), n3[0]) : (t3 && !this.warned.has(e3) && (this.warned.add(e3), warn(`XFA - Cannot find the font: ${e3}`)), null);
      }
    };
    FontInfo = class {
      constructor(e3, t3, i3, a3) {
        if (this.lineHeight = i3, this.paraMargin = t3 || { top: 0, bottom: 0, left: 0, right: 0 }, !e3) return void ([this.pdfFont, this.xfaFont] = this.defaultFont(a3));
        this.xfaFont = { typeface: e3.typeface, posture: e3.posture, weight: e3.weight, size: e3.size, letterSpacing: e3.letterSpacing };
        const s3 = a3.find(e3.typeface);
        s3 ? (this.pdfFont = selectFont(e3, s3), this.pdfFont || ([this.pdfFont, this.xfaFont] = this.defaultFont(a3))) : [this.pdfFont, this.xfaFont] = this.defaultFont(a3);
      }
      defaultFont(e3) {
        const t3 = e3.find("Helvetica", false) || e3.find("Myriad Pro", false) || e3.find("Arial", false) || e3.getDefault();
        if (t3?.regular) {
          const e4 = t3.regular;
          return [e4, { typeface: e4.cssFontInfo.fontFamily, posture: "normal", weight: "normal", size: 10, letterSpacing: 0 }];
        }
        return [null, { typeface: "Courier", posture: "normal", weight: "normal", size: 10, letterSpacing: 0 }];
      }
    };
    FontSelector = class {
      constructor(e3, t3, i3, a3) {
        this.fontFinder = a3, this.stack = [new FontInfo(e3, t3, i3, a3)];
      }
      pushData(e3, t3, i3) {
        const a3 = this.stack.at(-1);
        for (const t4 of ["typeface", "posture", "weight", "size", "letterSpacing"]) e3[t4] || (e3[t4] = a3.xfaFont[t4]);
        for (const e4 of ["top", "bottom", "left", "right"]) isNaN(t3[e4]) && (t3[e4] = a3.paraMargin[e4]);
        const s3 = new FontInfo(e3, t3, i3 || a3.lineHeight, this.fontFinder);
        s3.pdfFont || (s3.pdfFont = a3.pdfFont), this.stack.push(s3);
      }
      popFont() {
        this.stack.pop();
      }
      topFont() {
        return this.stack.at(-1);
      }
    };
    TextMeasure = class {
      constructor(e3, t3, i3, a3) {
        this.glyphs = [], this.fontSelector = new FontSelector(e3, t3, i3, a3), this.extraHeight = 0;
      }
      pushData(e3, t3, i3) {
        this.fontSelector.pushData(e3, t3, i3);
      }
      popFont(e3) {
        return this.fontSelector.popFont();
      }
      addPara() {
        const e3 = this.fontSelector.topFont();
        this.extraHeight += e3.paraMargin.top + e3.paraMargin.bottom;
      }
      addString(e3) {
        if (!e3) return;
        const t3 = this.fontSelector.topFont(), i3 = t3.xfaFont.size;
        if (t3.pdfFont) {
          const a3 = t3.xfaFont.letterSpacing, s3 = t3.pdfFont, n3 = s3.lineHeight || 1.2, r3 = t3.lineHeight || Math.max(1.2, n3) * i3, o3 = n3 - (void 0 === s3.lineGap ? 0.2 : s3.lineGap), g3 = Math.max(1, o3) * i3, c3 = i3 / 1e3, h3 = s3.defaultWidth || s3.charsToGlyphs(" ")[0].width;
          for (const t4 of e3.split(/[\u2029\n]/)) {
            const e4 = s3.encodeString(t4).join(""), i4 = s3.charsToGlyphs(e4);
            for (const e5 of i4) {
              const t5 = e5.width || h3;
              this.glyphs.push([t5 * c3 + a3, r3, g3, e5.unicode, false]);
            }
            this.glyphs.push([0, 0, 0, "\n", true]);
          }
          this.glyphs.pop();
        } else {
          for (const t4 of e3.split(/[\u2029\n]/)) {
            for (const e4 of t4.split("")) this.glyphs.push([i3, 1.2 * i3, i3, e4, false]);
            this.glyphs.push([0, 0, 0, "\n", true]);
          }
          this.glyphs.pop();
        }
      }
      compute(e3) {
        let t3 = -1, i3 = 0, a3 = 0, s3 = 0, n3 = 0, r3 = 0, o3 = false, g3 = true;
        for (let c3 = 0, h3 = this.glyphs.length; c3 < h3; c3++) {
          const [h4, l3, C3, d3, u3] = this.glyphs[c3], Q3 = " " === d3, f3 = g3 ? C3 : l3;
          u3 ? (a3 = Math.max(a3, n3), n3 = 0, s3 += r3, r3 = f3, t3 = -1, i3 = 0, g3 = false) : Q3 ? n3 + h4 > e3 ? (a3 = Math.max(a3, n3), n3 = 0, s3 += r3, r3 = f3, t3 = -1, i3 = 0, o3 = true, g3 = false) : (r3 = Math.max(f3, r3), i3 = n3, n3 += h4, t3 = c3) : n3 + h4 > e3 ? (s3 += r3, r3 = f3, -1 !== t3 ? (c3 = t3, a3 = Math.max(a3, i3), n3 = 0, t3 = -1, i3 = 0) : (a3 = Math.max(a3, n3), n3 = h4), o3 = true, g3 = false) : (n3 += h4, r3 = Math.max(f3, r3));
        }
        return a3 = Math.max(a3, n3), s3 += r3 + this.extraHeight, { width: 1.02 * a3, height: s3, isBroken: o3 };
      }
    };
    Uc = /^[^.[]+/;
    Hc = /^[^\]]+/;
    Tc = 0;
    Jc = 1;
    Yc = 2;
    Pc = 3;
    Oc = 4;
    Kc = /* @__PURE__ */ new Map([["$data", (e3, t3) => e3.datasets ? e3.datasets.data : e3], ["$record", (e3, t3) => (e3.datasets ? e3.datasets.data : e3)[Og]()[0]], ["$template", (e3, t3) => e3.template], ["$connectionSet", (e3, t3) => e3.connectionSet], ["$form", (e3, t3) => e3.form], ["$layout", (e3, t3) => e3.layout], ["$host", (e3, t3) => e3.host], ["$dataWindow", (e3, t3) => e3.dataWindow], ["$event", (e3, t3) => e3.event], ["!", (e3, t3) => e3.datasets], ["$xfa", (e3, t3) => e3], ["xfa", (e3, t3) => e3], ["$", (e3, t3) => t3]]);
    qc = /* @__PURE__ */ new WeakMap();
    _c2 = Symbol();
    Wc = Symbol();
    jc = Symbol();
    Xc = Symbol("_children");
    Vc = Symbol();
    Zc = Symbol();
    zc = Symbol();
    $c = Symbol();
    eh = Symbol();
    th = Symbol();
    Ah = Symbol();
    ih = Symbol();
    ah = Symbol();
    sh = Symbol("parent");
    nh = Symbol();
    rh = Symbol();
    oh = Symbol();
    gh = 0;
    hh = Gc.datasets.id;
    XFAObject = class _XFAObject {
      constructor(e3, t3, i3 = false) {
        this[cc] = e3, this[hc] = t3, this[Ah] = i3, this[sh] = null, this[Xc] = [], this[Nc] = `${t3}${gh++}`, this[Xg] = null;
      }
      get isXFAObject() {
        return true;
      }
      get isXFAObjectArray() {
        return false;
      }
      createNodes(e3) {
        let t3 = this, i3 = null;
        for (const { name: a3, index: s3 } of e3) {
          for (let e4 = 0, n3 = isFinite(s3) ? s3 : 0; e4 <= n3; e4++) {
            const e5 = t3[cc] === hh ? -1 : t3[cc];
            i3 = new XmlObject(e5, a3), t3[pg](i3);
          }
          t3 = i3;
        }
        return i3;
      }
      [Ic](e3) {
        if (!this[Ah] || !this[Cc](e3)) return false;
        const t3 = e3[hc], i3 = this[t3];
        if (!(i3 instanceof XFAObjectArray)) return null !== i3 && this[Ec](i3), this[t3] = e3, this[pg](e3), true;
        if (i3.push(e3)) return this[pg](e3), true;
        let a3 = "";
        return this.id ? a3 = ` (id: ${this.id})` : this.name && (a3 = ` (name: ${this.name} ${this.h.value})`), warn(`XFA - node "${this[hc]}"${a3} has already enough "${t3}"!`), false;
      }
      [Cc](e3) {
        return this.hasOwnProperty(e3[hc]) && e3[cc] === this[cc];
      }
      [ac]() {
        return false;
      }
      [Eg]() {
        return false;
      }
      [ec]() {
        return false;
      }
      [tc]() {
        return false;
      }
      [uc]() {
        this.para && this[jg]()[xg].paraStack.pop();
      }
      [Qc]() {
        this[jg]()[xg].paraStack.push(this.para);
      }
      [yc](e3) {
        this.id && this[cc] === Gc.template.id && e3.set(this.id, this);
      }
      [jg]() {
        return this[Xg].template;
      }
      [sc]() {
        return false;
      }
      [nc]() {
        return false;
      }
      [pg](e3) {
        e3[sh] = this, this[Xc].push(e3), !e3[Xg] && this[Xg] && (e3[Xg] = this[Xg]);
      }
      [Ec](e3) {
        const t3 = this[Xc].indexOf(e3);
        this[Xc].splice(t3, 1);
      }
      [Vg]() {
        return this.hasOwnProperty("value");
      }
      [bc](e3) {
      }
      [dc](e3) {
      }
      [Ng]() {
      }
      [yg](e3) {
        delete this[Ah], this[bg] && (e3.clean(this[bg]), delete this[bg]);
      }
      [zg](e3) {
        return this[Xc].indexOf(e3);
      }
      [$g](e3, t3) {
        t3[sh] = this, this[Xc].splice(e3, 0, t3), !t3[Xg] && this[Xg] && (t3[Xg] = this[Xg]);
      }
      [rc]() {
        return !this.name;
      }
      [gc]() {
        return "";
      }
      [Sc]() {
        return 0 === this[Xc].length ? this[Fg] : this[Xc].map((e3) => e3[Sc]()).join("");
      }
      get [jc]() {
        const e3 = Object.getPrototypeOf(this);
        if (!e3._attributes) {
          const t3 = e3._attributes = /* @__PURE__ */ new Set();
          for (const e4 of Object.getOwnPropertyNames(this)) {
            if (null === this[e4] || this[e4] instanceof _XFAObject || this[e4] instanceof XFAObjectArray) break;
            t3.add(e4);
          }
        }
        return shadow(this, jc, e3._attributes);
      }
      [ic](e3) {
        let t3 = this;
        for (; t3; ) {
          if (t3 === e3) return true;
          t3 = t3[Wg]();
        }
        return false;
      }
      [Wg]() {
        return this[sh];
      }
      [_g2]() {
        return this[Wg]();
      }
      [Og](e3 = null) {
        return e3 ? this[e3] : this[Xc];
      }
      [Rg]() {
        const e3 = /* @__PURE__ */ Object.create(null);
        this[Fg] && (e3.$content = this[Fg]);
        for (const t3 of Object.getOwnPropertyNames(this)) {
          const i3 = this[t3];
          null !== i3 && (i3 instanceof _XFAObject ? e3[t3] = i3[Rg]() : i3 instanceof XFAObjectArray ? i3.isEmpty() || (e3[t3] = i3.dump()) : e3[t3] = i3);
        }
        return e3;
      }
      [xc]() {
        return null;
      }
      [kc]() {
        return HTMLResult.EMPTY;
      }
      *[Kg]() {
        for (const e3 of this[Og]()) yield e3;
      }
      *[$c](e3, t3) {
        for (const i3 of this[Kg]()) if (!e3 || t3 === e3.has(i3[hc])) {
          const e4 = this[Lg](), t4 = i3[kc](e4);
          t4.success || (this[xg].failingNode = i3), yield t4;
        }
      }
      [Mg]() {
        return null;
      }
      [fg](e3, t3) {
        this[xg].children.push(e3);
      }
      [Lg]() {
      }
      [mg]({ filter: e3 = null, include: t3 = true }) {
        if (this[xg].generator) {
          const e4 = this[Lg](), t4 = this[xg].failingNode[kc](e4);
          if (!t4.success) return t4;
          t4.html && this[fg](t4.html, t4.bbox), delete this[xg].failingNode;
        } else this[xg].generator = this[$c](e3, t3);
        for (; ; ) {
          const e4 = this[xg].generator.next();
          if (e4.done) break;
          const t4 = e4.value;
          if (!t4.success) return t4;
          t4.html && this[fg](t4.html, t4.bbox);
        }
        return this[xg].generator = null, HTMLResult.EMPTY;
      }
      [wc](e3) {
        this[rh] = new Set(Object.keys(e3));
      }
      [th](e3) {
        const t3 = this[jc], i3 = this[rh];
        return [...e3].filter((e4) => t3.has(e4) && !i3.has(e4));
      }
      [pc](e3, t3 = /* @__PURE__ */ new Set()) {
        for (const i3 of this[Xc]) i3[nh](e3, t3);
      }
      [nh](e3, t3) {
        const i3 = this[eh](e3, t3);
        i3 ? this[_c2](i3, e3, t3) : this[pc](e3, t3);
      }
      [eh](e3, t3) {
        const { use: i3, usehref: a3 } = this;
        if (!i3 && !a3) return null;
        let s3 = null, n3 = null, r3 = null, o3 = i3;
        if (a3 ? (o3 = a3, a3.startsWith("#som(") && a3.endsWith(")") ? n3 = a3.slice(5, -1) : a3.startsWith(".#som(") && a3.endsWith(")") ? n3 = a3.slice(6, -1) : a3.startsWith("#") ? r3 = a3.slice(1) : a3.startsWith(".#") && (r3 = a3.slice(2))) : i3.startsWith("#") ? r3 = i3.slice(1) : n3 = i3, this.use = this.usehref = "", r3 ? s3 = e3.get(r3) : (s3 = searchNode(e3.get(fc), this, n3, true, false), s3 && (s3 = s3[0])), !s3) return warn(`XFA - Invalid prototype reference: ${o3}.`), null;
        if (s3[hc] !== this[hc]) return warn(`XFA - Incompatible prototype: ${s3[hc]} !== ${this[hc]}.`), null;
        if (t3.has(s3)) return warn("XFA - Cycle detected in prototypes use."), null;
        t3.add(s3);
        const g3 = s3[eh](e3, t3);
        return g3 && s3[_c2](g3, e3, t3), s3[pc](e3, t3), t3.delete(s3), s3;
      }
      [_c2](e3, t3, i3) {
        if (i3.has(e3)) return void warn("XFA - Cycle detected in prototypes use.");
        !this[Fg] && e3[Fg] && (this[Fg] = e3[Fg]);
        new Set(i3).add(e3);
        for (const t4 of this[th](e3[rh])) this[t4] = e3[t4], this[rh] && this[rh].add(t4);
        for (const a3 of Object.getOwnPropertyNames(this)) {
          if (this[jc].has(a3)) continue;
          const s3 = this[a3], n3 = e3[a3];
          if (s3 instanceof XFAObjectArray) {
            for (const e4 of s3[Xc]) e4[nh](t3, i3);
            for (let a4 = s3[Xc].length, r3 = n3[Xc].length; a4 < r3; a4++) {
              const n4 = e3[Xc][a4][Dg]();
              if (!s3.push(n4)) break;
              n4[sh] = this, this[Xc].push(n4), n4[nh](t3, i3);
            }
          } else if (null === s3) {
            if (null !== n3) {
              const e4 = n3[Dg]();
              e4[sh] = this, this[a3] = e4, this[Xc].push(e4), e4[nh](t3, i3);
            }
          } else s3[pc](t3, i3), n3 && s3[_c2](n3, t3, i3);
        }
      }
      static [Vc](e3) {
        return Array.isArray(e3) ? e3.map((e4) => _XFAObject[Vc](e4)) : "object" == typeof e3 && null !== e3 ? Object.assign({}, e3) : e3;
      }
      [Dg]() {
        const e3 = Object.create(Object.getPrototypeOf(this));
        for (const t3 of Object.getOwnPropertySymbols(this)) try {
          e3[t3] = this[t3];
        } catch {
          shadow(e3, t3, this[t3]);
        }
        e3[Nc] = `${e3[hc]}${gh++}`, e3[Xc] = [];
        for (const t3 of Object.getOwnPropertyNames(this)) {
          if (this[jc].has(t3)) {
            e3[t3] = _XFAObject[Vc](this[t3]);
            continue;
          }
          const i3 = this[t3];
          e3[t3] = i3 instanceof XFAObjectArray ? new XFAObjectArray(i3[ih]) : null;
        }
        for (const t3 of this[Xc]) {
          const i3 = t3[hc], a3 = t3[Dg]();
          e3[Xc].push(a3), a3[sh] = e3, null === e3[i3] ? e3[i3] = a3 : e3[i3][Xc].push(a3);
        }
        return e3;
      }
      [Og](e3 = null) {
        return e3 ? this[Xc].filter((t3) => t3[hc] === e3) : this[Xc];
      }
      [Ug](e3) {
        return this[e3];
      }
      [Hg](e3, t3, i3 = true) {
        return Array.from(this[Tg](e3, t3, i3));
      }
      *[Tg](e3, t3, i3 = true) {
        if ("parent" !== e3) {
          for (const i4 of this[Xc]) i4[hc] === e3 && (yield i4), i4.name === e3 && (yield i4), (t3 || i4[rc]()) && (yield* i4[Tg](e3, t3, false));
          i3 && this[jc].has(e3) && (yield new XFAAttribute(this, e3, this[e3]));
        } else yield this[sh];
      }
    };
    XFAObjectArray = class _XFAObjectArray {
      constructor(e3 = 1 / 0) {
        this[ih] = e3, this[Xc] = [];
      }
      get isXFAObject() {
        return false;
      }
      get isXFAObjectArray() {
        return true;
      }
      push(e3) {
        return this[Xc].length <= this[ih] ? (this[Xc].push(e3), true) : (warn(`XFA - node "${e3[hc]}" accepts no more than ${this[ih]} children`), false);
      }
      isEmpty() {
        return 0 === this[Xc].length;
      }
      dump() {
        return 1 === this[Xc].length ? this[Xc][0][Rg]() : this[Xc].map((e3) => e3[Rg]());
      }
      [Dg]() {
        const e3 = new _XFAObjectArray(this[ih]);
        return e3[Xc] = this[Xc].map((e4) => e4[Dg]()), e3;
      }
      get children() {
        return this[Xc];
      }
      clear() {
        this[Xc].length = 0;
      }
    };
    XFAAttribute = class {
      constructor(e3, t3, i3) {
        this[sh] = e3, this[hc] = t3, this[Fg] = i3, this[Sg] = false, this[Nc] = "attribute" + gh++;
      }
      [Wg]() {
        return this[sh];
      }
      [Ac]() {
        return true;
      }
      [Jg]() {
        return this[Fg].trim();
      }
      [bc](e3) {
        e3 = e3.value || "", this[Fg] = e3.toString();
      }
      [Sc]() {
        return this[Fg];
      }
      [ic](e3) {
        return this[sh] === e3 || this[sh][ic](e3);
      }
    };
    XmlObject = class _XmlObject extends XFAObject {
      constructor(e3, t3, i3 = {}) {
        if (super(e3, t3), this[Fg] = "", this[Zc] = null, "#text" !== t3) {
          const e4 = /* @__PURE__ */ new Map();
          this[Wc] = e4;
          for (const [t4, a3] of Object.entries(i3)) e4.set(t4, new XFAAttribute(this, t4, a3));
          if (i3.hasOwnProperty(lc)) {
            const e5 = i3[lc].xfa.dataNode;
            void 0 !== e5 && ("dataGroup" === e5 ? this[Zc] = false : "dataValue" === e5 && (this[Zc] = true));
          }
        }
        this[Sg] = false;
      }
      [Rc](e3) {
        const t3 = this[hc];
        if ("#text" === t3) return void e3.push(encodeToXmlString(this[Fg]));
        const i3 = utf8StringToString(t3), a3 = this[cc] === hh ? "xfa:" : "";
        e3.push(`<${a3}${i3}`);
        for (const [t4, i4] of this[Wc].entries()) {
          const a4 = utf8StringToString(t4);
          e3.push(` ${a4}="${encodeToXmlString(i4[Fg])}"`);
        }
        if (null !== this[Zc] && (this[Zc] ? e3.push(' xfa:dataNode="dataValue"') : e3.push(' xfa:dataNode="dataGroup"')), this[Fg] || 0 !== this[Xc].length) {
          if (e3.push(">"), this[Fg]) "string" == typeof this[Fg] ? e3.push(encodeToXmlString(this[Fg])) : this[Fg][Rc](e3);
          else for (const t4 of this[Xc]) t4[Rc](e3);
          e3.push(`</${a3}${i3}>`);
        } else e3.push("/>");
      }
      [Ic](e3) {
        if (this[Fg]) {
          const e4 = new _XmlObject(this[cc], "#text");
          this[pg](e4), e4[Fg] = this[Fg], this[Fg] = "";
        }
        return this[pg](e3), true;
      }
      [dc](e3) {
        this[Fg] += e3;
      }
      [Ng]() {
        if (this[Fg] && this[Xc].length > 0) {
          const e3 = new _XmlObject(this[cc], "#text");
          this[pg](e3), e3[Fg] = this[Fg], delete this[Fg];
        }
      }
      [kc]() {
        return "#text" === this[hc] ? HTMLResult.success({ name: "#text", value: this[Fg] }) : HTMLResult.EMPTY;
      }
      [Og](e3 = null) {
        return e3 ? this[Xc].filter((t3) => t3[hc] === e3) : this[Xc];
      }
      [vg]() {
        return this[Wc];
      }
      [Ug](e3) {
        const t3 = this[Wc].get(e3);
        return void 0 !== t3 ? t3 : this[Og](e3);
      }
      *[Tg](e3, t3) {
        const i3 = this[Wc].get(e3);
        i3 && (yield i3);
        for (const i4 of this[Xc]) i4[hc] === e3 && (yield i4), t3 && (yield* i4[Tg](e3, t3));
      }
      *[Gg](e3, t3) {
        const i3 = this[Wc].get(e3);
        !i3 || t3 && i3[Sg] || (yield i3);
        for (const i4 of this[Xc]) yield* i4[Gg](e3, t3);
      }
      *[Pg](e3, t3, i3) {
        for (const a3 of this[Xc]) a3[hc] !== e3 || i3 && a3[Sg] || (yield a3), t3 && (yield* a3[Pg](e3, t3, i3));
      }
      [Ac]() {
        return null === this[Zc] ? 0 === this[Xc].length || this[Xc][0][cc] === Gc.xhtml.id : this[Zc];
      }
      [Jg]() {
        return null === this[Zc] ? 0 === this[Xc].length ? this[Fg].trim() : this[Xc][0][cc] === Gc.xhtml.id ? this[Xc][0][Sc]().trim() : null : this[Fg].trim();
      }
      [bc](e3) {
        e3 = e3.value || "", this[Fg] = e3.toString();
      }
      [Rg](e3 = false) {
        const t3 = /* @__PURE__ */ Object.create(null);
        e3 && (t3.$ns = this[cc]), this[Fg] && (t3.$content = this[Fg]), t3.$name = this[hc], t3.children = [];
        for (const i3 of this[Xc]) t3.children.push(i3[Rg](e3));
        t3.attributes = /* @__PURE__ */ Object.create(null);
        for (const [e4, i3] of this[Wc]) t3.attributes[e4] = i3[Fg];
        return t3;
      }
    };
    ContentObject = class extends XFAObject {
      constructor(e3, t3) {
        super(e3, t3), this[Fg] = "";
      }
      [dc](e3) {
        this[Fg] += e3;
      }
      [Ng]() {
      }
    };
    OptionObject = class extends ContentObject {
      constructor(e3, t3, i3) {
        super(e3, t3), this[ah] = i3;
      }
      [Ng]() {
        this[Fg] = getKeyword({ data: this[Fg], defaultValue: this[ah][0], validate: (e3) => this[ah].includes(e3) });
      }
      [yg](e3) {
        super[yg](e3), delete this[ah];
      }
    };
    StringObject = class extends ContentObject {
      [Ng]() {
        this[Fg] = this[Fg].trim();
      }
    };
    IntegerObject = class extends ContentObject {
      constructor(e3, t3, i3, a3) {
        super(e3, t3), this[zc] = i3, this[oh] = a3;
      }
      [Ng]() {
        this[Fg] = getInteger({ data: this[Fg], defaultValue: this[zc], validate: this[oh] });
      }
      [yg](e3) {
        super[yg](e3), delete this[zc], delete this[oh];
      }
    };
    Option01 = class extends IntegerObject {
      constructor(e3, t3) {
        super(e3, t3, 0, (e4) => 1 === e4);
      }
    };
    Option10 = class extends IntegerObject {
      constructor(e3, t3) {
        super(e3, t3, 1, (e4) => 0 === e4);
      }
    };
    lh = { anchorType(e3, t3) {
      const i3 = e3[_g2]();
      if (i3 && (!i3.layout || "position" === i3.layout)) switch ("transform" in t3 || (t3.transform = ""), e3.anchorType) {
        case "bottomCenter":
          t3.transform += "translate(-50%, -100%)";
          break;
        case "bottomLeft":
          t3.transform += "translate(0,-100%)";
          break;
        case "bottomRight":
          t3.transform += "translate(-100%,-100%)";
          break;
        case "middleCenter":
          t3.transform += "translate(-50%,-50%)";
          break;
        case "middleLeft":
          t3.transform += "translate(0,-50%)";
          break;
        case "middleRight":
          t3.transform += "translate(-100%,-50%)";
          break;
        case "topCenter":
          t3.transform += "translate(-50%,0)";
          break;
        case "topRight":
          t3.transform += "translate(-100%,0)";
      }
    }, dimensions(e3, t3) {
      const i3 = e3[_g2]();
      let a3 = e3.w;
      const s3 = e3.h;
      if (i3.layout?.includes("row")) {
        const t4 = i3[xg], s4 = e3.colSpan;
        let n3;
        -1 === s4 ? (n3 = t4.columnWidths.slice(t4.currentColumn).reduce((e4, t5) => e4 + t5, 0), t4.currentColumn = 0) : (n3 = t4.columnWidths.slice(t4.currentColumn, t4.currentColumn + s4).reduce((e4, t5) => e4 + t5, 0), t4.currentColumn = (t4.currentColumn + e3.colSpan) % t4.columnWidths.length), isNaN(n3) || (a3 = e3.w = n3);
      }
      t3.width = "" !== a3 ? measureToString(a3) : "auto", t3.height = "" !== s3 ? measureToString(s3) : "auto";
    }, position(e3, t3) {
      const i3 = e3[_g2]();
      i3?.layout && "position" !== i3.layout || (t3.position = "absolute", t3.left = measureToString(e3.x), t3.top = measureToString(e3.y));
    }, rotate(e3, t3) {
      e3.rotate && ("transform" in t3 || (t3.transform = ""), t3.transform += `rotate(-${e3.rotate}deg)`, t3.transformOrigin = "top left");
    }, presence(e3, t3) {
      switch (e3.presence) {
        case "invisible":
          t3.visibility = "hidden";
          break;
        case "hidden":
        case "inactive":
          t3.display = "none";
      }
    }, hAlign(e3, t3) {
      if ("para" === e3[hc]) switch (e3.hAlign) {
        case "justifyAll":
          t3.textAlign = "justify-all";
          break;
        case "radix":
          t3.textAlign = "left";
          break;
        default:
          t3.textAlign = e3.hAlign;
      }
      else switch (e3.hAlign) {
        case "left":
          t3.alignSelf = "start";
          break;
        case "center":
          t3.alignSelf = "center";
          break;
        case "right":
          t3.alignSelf = "end";
      }
    }, margin(e3, t3) {
      e3.margin && (t3.margin = e3.margin[xc]().margin);
    } };
    Ih = Gc.template.id;
    Ch = "http://www.w3.org/2000/svg";
    dh = /^H(\d+)$/;
    Bh = /* @__PURE__ */ new Set(["image/gif", "image/jpeg", "image/jpg", "image/pjpeg", "image/png", "image/apng", "image/x-png", "image/bmp", "image/x-ms-bmp", "image/tiff", "image/tif", "application/octet-stream"]);
    uh = [[[66, 77], "image/bmp"], [[255, 216, 255], "image/jpeg"], [[73, 73, 42, 0], "image/tiff"], [[77, 77, 0, 42], "image/tiff"], [[71, 73, 70, 56, 57, 97], "image/gif"], [[137, 80, 78, 71, 13, 10, 26, 10], "image/png"]];
    AppearanceFilter = class extends StringObject {
      constructor(e3) {
        super(Ih, "appearanceFilter"), this.id = e3.id || "", this.type = getStringOption(e3.type, ["optional", "required"]), this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    Arc = class extends XFAObject {
      constructor(e3) {
        super(Ih, "arc", true), this.circular = getInteger({ data: e3.circular, defaultValue: 0, validate: (e4) => 1 === e4 }), this.hand = getStringOption(e3.hand, ["even", "left", "right"]), this.id = e3.id || "", this.startAngle = getFloat({ data: e3.startAngle, defaultValue: 0, validate: (e4) => true }), this.sweepAngle = getFloat({ data: e3.sweepAngle, defaultValue: 360, validate: (e4) => true }), this.use = e3.use || "", this.usehref = e3.usehref || "", this.edge = null, this.fill = null;
      }
      [kc]() {
        const e3 = this.edge || new Edge({}), t3 = e3[xc](), i3 = /* @__PURE__ */ Object.create(null);
        let a3;
        "visible" === this.fill?.presence ? Object.assign(i3, this.fill[xc]()) : i3.fill = "transparent", i3.strokeWidth = measureToString("visible" === e3.presence ? e3.thickness : 0), i3.stroke = t3.color;
        const s3 = { xmlns: Ch, style: { width: "100%", height: "100%", overflow: "visible" } };
        if (360 === this.sweepAngle) a3 = { name: "ellipse", attributes: { xmlns: Ch, cx: "50%", cy: "50%", rx: "50%", ry: "50%", style: i3 } };
        else {
          const e4 = this.startAngle * Math.PI / 180, t4 = this.sweepAngle * Math.PI / 180, n4 = this.sweepAngle > 180 ? 1 : 0, [r3, o3, g3, c3] = [50 * (1 + Math.cos(e4)), 50 * (1 - Math.sin(e4)), 50 * (1 + Math.cos(e4 + t4)), 50 * (1 - Math.sin(e4 + t4))];
          a3 = { name: "path", attributes: { xmlns: Ch, d: `M ${r3} ${o3} A 50 50 0 ${n4} 0 ${g3} ${c3}`, vectorEffect: "non-scaling-stroke", style: i3 } }, Object.assign(s3, { viewBox: "0 0 100 100", preserveAspectRatio: "none" });
        }
        const n3 = { name: "svg", children: [a3], attributes: s3 };
        return hasMargin(this[Wg]()[Wg]()) ? HTMLResult.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [n3] }) : (n3.attributes.style.position = "absolute", HTMLResult.success(n3));
      }
    };
    Area = class extends XFAObject {
      constructor(e3) {
        super(Ih, "area", true), this.colSpan = getInteger({ data: e3.colSpan, defaultValue: 1, validate: (e4) => e4 >= 1 || -1 === e4 }), this.id = e3.id || "", this.name = e3.name || "", this.relevant = getRelevant(e3.relevant), this.use = e3.use || "", this.usehref = e3.usehref || "", this.x = getMeasurement(e3.x, "0pt"), this.y = getMeasurement(e3.y, "0pt"), this.desc = null, this.extras = null, this.area = new XFAObjectArray(), this.draw = new XFAObjectArray(), this.exObject = new XFAObjectArray(), this.exclGroup = new XFAObjectArray(), this.field = new XFAObjectArray(), this.subform = new XFAObjectArray(), this.subformSet = new XFAObjectArray();
      }
      *[Kg]() {
        yield* getContainedChildren(this);
      }
      [rc]() {
        return true;
      }
      [tc]() {
        return true;
      }
      [fg](e3, t3) {
        const [i3, a3, s3, n3] = t3;
        this[xg].width = Math.max(this[xg].width, i3 + s3), this[xg].height = Math.max(this[xg].height, a3 + n3), this[xg].children.push(e3);
      }
      [Lg]() {
        return this[xg].availableSpace;
      }
      [kc](e3) {
        const t3 = toStyle(this, "position"), i3 = { style: t3, id: this[Nc], class: ["xfaArea"] };
        isPrintOnly(this) && i3.class.push("xfaPrintOnly"), this.name && (i3.xfaName = this.name);
        const a3 = [];
        this[xg] = { children: a3, width: 0, height: 0, availableSpace: e3 };
        const s3 = this[mg]({ filter: /* @__PURE__ */ new Set(["area", "draw", "field", "exclGroup", "subform", "subformSet"]), include: true });
        if (!s3.success) return s3.isBreak() ? s3 : (delete this[xg], HTMLResult.FAILURE);
        t3.width = measureToString(this[xg].width), t3.height = measureToString(this[xg].height);
        const n3 = { name: "div", attributes: i3, children: a3 }, r3 = [this.x, this.y, this[xg].width, this[xg].height];
        return delete this[xg], HTMLResult.success(n3, r3);
      }
    };
    Assist = class extends XFAObject {
      constructor(e3) {
        super(Ih, "assist", true), this.id = e3.id || "", this.role = e3.role || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.speak = null, this.toolTip = null;
      }
      [kc]() {
        return this.toolTip?.[Fg] || null;
      }
    };
    Barcode = class extends XFAObject {
      constructor(e3) {
        super(Ih, "barcode", true), this.charEncoding = getKeyword({ data: e3.charEncoding ? e3.charEncoding.toLowerCase() : "", defaultValue: "", validate: (e4) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(e4) || e4.match(/iso-8859-\d{2}/) }), this.checksum = getStringOption(e3.checksum, ["none", "1mod10", "1mod10_1mod11", "2mod10", "auto"]), this.dataColumnCount = getInteger({ data: e3.dataColumnCount, defaultValue: -1, validate: (e4) => e4 >= 0 }), this.dataLength = getInteger({ data: e3.dataLength, defaultValue: -1, validate: (e4) => e4 >= 0 }), this.dataPrep = getStringOption(e3.dataPrep, ["none", "flateCompress"]), this.dataRowCount = getInteger({ data: e3.dataRowCount, defaultValue: -1, validate: (e4) => e4 >= 0 }), this.endChar = e3.endChar || "", this.errorCorrectionLevel = getInteger({ data: e3.errorCorrectionLevel, defaultValue: -1, validate: (e4) => e4 >= 0 && e4 <= 8 }), this.id = e3.id || "", this.moduleHeight = getMeasurement(e3.moduleHeight, "5mm"), this.moduleWidth = getMeasurement(e3.moduleWidth, "0.25mm"), this.printCheckDigit = getInteger({ data: e3.printCheckDigit, defaultValue: 0, validate: (e4) => 1 === e4 }), this.rowColumnRatio = getRatio(e3.rowColumnRatio), this.startChar = e3.startChar || "", this.textLocation = getStringOption(e3.textLocation, ["below", "above", "aboveEmbedded", "belowEmbedded", "none"]), this.truncate = getInteger({ data: e3.truncate, defaultValue: 0, validate: (e4) => 1 === e4 }), this.type = getStringOption(e3.type ? e3.type.toLowerCase() : "", ["aztec", "codabar", "code2of5industrial", "code2of5interleaved", "code2of5matrix", "code2of5standard", "code3of9", "code3of9extended", "code11", "code49", "code93", "code128", "code128a", "code128b", "code128c", "code128sscc", "datamatrix", "ean8", "ean8add2", "ean8add5", "ean13", "ean13add2", "ean13add5", "ean13pwcd", "fim", "logmars", "maxicode", "msi", "pdf417", "pdf417macro", "plessey", "postauscust2", "postauscust3", "postausreplypaid", "postausstandard", "postukrm4scc", "postusdpbc", "postusimb", "postusstandard", "postus5zip", "qrcode", "rfid", "rss14", "rss14expanded", "rss14limited", "rss14stacked", "rss14stackedomni", "rss14truncated", "telepen", "ucc128", "ucc128random", "ucc128sscc", "upca", "upcaadd2", "upcaadd5", "upcapwcd", "upce", "upceadd2", "upceadd5", "upcean2", "upcean5", "upsmaxicode"]), this.upsMode = getStringOption(e3.upsMode, ["usCarrier", "internationalCarrier", "secureSymbol", "standardSymbol"]), this.use = e3.use || "", this.usehref = e3.usehref || "", this.wideNarrowRatio = getRatio(e3.wideNarrowRatio), this.encrypt = null, this.extras = null;
      }
    };
    Bind = class extends XFAObject {
      constructor(e3) {
        super(Ih, "bind", true), this.match = getStringOption(e3.match, ["once", "dataRef", "global", "none"]), this.ref = e3.ref || "", this.picture = null;
      }
    };
    BindItems = class extends XFAObject {
      constructor(e3) {
        super(Ih, "bindItems"), this.connection = e3.connection || "", this.labelRef = e3.labelRef || "", this.ref = e3.ref || "", this.valueRef = e3.valueRef || "";
      }
    };
    Bookend = class extends XFAObject {
      constructor(e3) {
        super(Ih, "bookend"), this.id = e3.id || "", this.leader = e3.leader || "", this.trailer = e3.trailer || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    BooleanElement = class extends Option01 {
      constructor(e3) {
        super(Ih, "boolean"), this.id = e3.id || "", this.name = e3.name || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
      [kc](e3) {
        return valueToHtml(1 === this[Fg] ? "1" : "0");
      }
    };
    Border = class extends XFAObject {
      constructor(e3) {
        super(Ih, "border", true), this.break = getStringOption(e3.break, ["close", "open"]), this.hand = getStringOption(e3.hand, ["even", "left", "right"]), this.id = e3.id || "", this.presence = getStringOption(e3.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = getRelevant(e3.relevant), this.use = e3.use || "", this.usehref = e3.usehref || "", this.corner = new XFAObjectArray(4), this.edge = new XFAObjectArray(4), this.extras = null, this.fill = null, this.margin = null;
      }
      [Yg]() {
        if (!this[xg]) {
          const e3 = this.edge.children.slice();
          if (e3.length < 4) {
            const t4 = e3.at(-1) || new Edge({});
            for (let i4 = e3.length; i4 < 4; i4++) e3.push(t4);
          }
          const t3 = e3.map((e4) => e4.thickness), i3 = [0, 0, 0, 0];
          this.margin && (i3[0] = this.margin.topInset, i3[1] = this.margin.rightInset, i3[2] = this.margin.bottomInset, i3[3] = this.margin.leftInset), this[xg] = { widths: t3, insets: i3, edges: e3 };
        }
        return this[xg];
      }
      [xc]() {
        const { edges: e3 } = this[Yg](), t3 = e3.map((e4) => {
          const t4 = e4[xc]();
          return t4.color || (t4.color = "#000000"), t4;
        }), i3 = /* @__PURE__ */ Object.create(null);
        if (this.margin && Object.assign(i3, this.margin[xc]()), "visible" === this.fill?.presence && Object.assign(i3, this.fill[xc]()), this.corner.children.some((e4) => 0 !== e4.radius)) {
          const e4 = this.corner.children.map((e5) => e5[xc]());
          if (2 === e4.length || 3 === e4.length) {
            const t4 = e4.at(-1);
            for (let i4 = e4.length; i4 < 4; i4++) e4.push(t4);
          }
          i3.borderRadius = e4.map((e5) => e5.radius).join(" ");
        }
        switch (this.presence) {
          case "invisible":
          case "hidden":
            i3.borderStyle = "";
            break;
          case "inactive":
            i3.borderStyle = "none";
            break;
          default:
            i3.borderStyle = t3.map((e4) => e4.style).join(" ");
        }
        return i3.borderWidth = t3.map((e4) => e4.width).join(" "), i3.borderColor = t3.map((e4) => e4.color).join(" "), i3;
      }
    };
    Break = class extends XFAObject {
      constructor(e3) {
        super(Ih, "break", true), this.after = getStringOption(e3.after, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]), this.afterTarget = e3.afterTarget || "", this.before = getStringOption(e3.before, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]), this.beforeTarget = e3.beforeTarget || "", this.bookendLeader = e3.bookendLeader || "", this.bookendTrailer = e3.bookendTrailer || "", this.id = e3.id || "", this.overflowLeader = e3.overflowLeader || "", this.overflowTarget = e3.overflowTarget || "", this.overflowTrailer = e3.overflowTrailer || "", this.startNew = getInteger({ data: e3.startNew, defaultValue: 0, validate: (e4) => 1 === e4 }), this.use = e3.use || "", this.usehref = e3.usehref || "", this.extras = null;
      }
    };
    BreakAfter = class extends XFAObject {
      constructor(e3) {
        super(Ih, "breakAfter", true), this.id = e3.id || "", this.leader = e3.leader || "", this.startNew = getInteger({ data: e3.startNew, defaultValue: 0, validate: (e4) => 1 === e4 }), this.target = e3.target || "", this.targetType = getStringOption(e3.targetType, ["auto", "contentArea", "pageArea"]), this.trailer = e3.trailer || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.script = null;
      }
    };
    BreakBefore = class extends XFAObject {
      constructor(e3) {
        super(Ih, "breakBefore", true), this.id = e3.id || "", this.leader = e3.leader || "", this.startNew = getInteger({ data: e3.startNew, defaultValue: 0, validate: (e4) => 1 === e4 }), this.target = e3.target || "", this.targetType = getStringOption(e3.targetType, ["auto", "contentArea", "pageArea"]), this.trailer = e3.trailer || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.script = null;
      }
      [kc](e3) {
        return this[xg] = {}, HTMLResult.FAILURE;
      }
    };
    Button = class extends XFAObject {
      constructor(e3) {
        super(Ih, "button", true), this.highlight = getStringOption(e3.highlight, ["inverted", "none", "outline", "push"]), this.id = e3.id || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.extras = null;
      }
      [kc](e3) {
        const t3 = this[Wg]()[Wg](), i3 = { name: "button", attributes: { id: this[Nc], class: ["xfaButton"], style: {} }, children: [] };
        for (const e4 of t3.event.children) {
          if ("click" !== e4.activity || !e4.script) continue;
          const t4 = recoverJsURL(e4.script[Fg]);
          if (!t4) continue;
          const a3 = fixURL(t4.url);
          a3 && i3.children.push({ name: "a", attributes: { id: "link" + this[Nc], href: a3, newWindow: t4.newWindow, class: ["xfaLink"], style: {} }, children: [] });
        }
        return HTMLResult.success(i3);
      }
    };
    Calculate = class extends XFAObject {
      constructor(e3) {
        super(Ih, "calculate", true), this.id = e3.id || "", this.override = getStringOption(e3.override, ["disabled", "error", "ignore", "warning"]), this.use = e3.use || "", this.usehref = e3.usehref || "", this.extras = null, this.message = null, this.script = null;
      }
    };
    Caption = class extends XFAObject {
      constructor(e3) {
        super(Ih, "caption", true), this.id = e3.id || "", this.placement = getStringOption(e3.placement, ["left", "bottom", "inline", "right", "top"]), this.presence = getStringOption(e3.presence, ["visible", "hidden", "inactive", "invisible"]), this.reserve = Math.ceil(getMeasurement(e3.reserve)), this.use = e3.use || "", this.usehref = e3.usehref || "", this.extras = null, this.font = null, this.margin = null, this.para = null, this.value = null;
      }
      [bc](e3) {
        _setValue(this, e3);
      }
      [Yg](e3) {
        if (!this[xg]) {
          let { width: t3, height: i3 } = e3;
          switch (this.placement) {
            case "left":
            case "right":
            case "inline":
              t3 = this.reserve <= 0 ? t3 : this.reserve;
              break;
            case "top":
            case "bottom":
              i3 = this.reserve <= 0 ? i3 : this.reserve;
          }
          this[xg] = layoutNode(this, { width: t3, height: i3 });
        }
        return this[xg];
      }
      [kc](e3) {
        if (!this.value) return HTMLResult.EMPTY;
        this[Qc]();
        const t3 = this.value[kc](e3).html;
        if (!t3) return this[uc](), HTMLResult.EMPTY;
        const i3 = this.reserve;
        if (this.reserve <= 0) {
          const { w: t4, h: i4 } = this[Yg](e3);
          switch (this.placement) {
            case "left":
            case "right":
            case "inline":
              this.reserve = t4;
              break;
            case "top":
            case "bottom":
              this.reserve = i4;
          }
        }
        const a3 = [];
        "string" == typeof t3 ? a3.push({ name: "#text", value: t3 }) : a3.push(t3);
        const s3 = toStyle(this, "font", "margin", "visibility");
        switch (this.placement) {
          case "left":
          case "right":
            this.reserve > 0 && (s3.width = measureToString(this.reserve));
            break;
          case "top":
          case "bottom":
            this.reserve > 0 && (s3.height = measureToString(this.reserve));
        }
        return setPara(this, null, t3), this[uc](), this.reserve = i3, HTMLResult.success({ name: "div", attributes: { style: s3, class: ["xfaCaption"] }, children: a3 });
      }
    };
    Certificate = class extends StringObject {
      constructor(e3) {
        super(Ih, "certificate"), this.id = e3.id || "", this.name = e3.name || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    Certificates = class extends XFAObject {
      constructor(e3) {
        super(Ih, "certificates", true), this.credentialServerPolicy = getStringOption(e3.credentialServerPolicy, ["optional", "required"]), this.id = e3.id || "", this.url = e3.url || "", this.urlPolicy = e3.urlPolicy || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.encryption = null, this.issuers = null, this.keyUsage = null, this.oids = null, this.signing = null, this.subjectDNs = null;
      }
    };
    CheckButton = class extends XFAObject {
      constructor(e3) {
        super(Ih, "checkButton", true), this.id = e3.id || "", this.mark = getStringOption(e3.mark, ["default", "check", "circle", "cross", "diamond", "square", "star"]), this.shape = getStringOption(e3.shape, ["square", "round"]), this.size = getMeasurement(e3.size, "10pt"), this.use = e3.use || "", this.usehref = e3.usehref || "", this.border = null, this.extras = null, this.margin = null;
      }
      [kc](e3) {
        const t3 = toStyle("margin"), i3 = measureToString(this.size);
        let a3, s3, n3;
        t3.width = t3.height = i3;
        const r3 = this[Wg]()[Wg](), o3 = r3.items.children.length && r3.items.children[0][kc]().html || [], g3 = { on: (void 0 !== o3[0] ? o3[0] : "on").toString(), off: (void 0 !== o3[1] ? o3[1] : "off").toString() }, c3 = (r3.value?.[Sc]() || "off") === g3.on || void 0, h3 = r3[_g2](), l3 = r3[Nc];
        let C3;
        h3 instanceof ExclGroup ? (n3 = h3[Nc], a3 = "radio", s3 = "xfaRadio", C3 = h3[kg]?.[Nc] || h3[Nc]) : (a3 = "checkbox", s3 = "xfaCheckbox", C3 = r3[kg]?.[Nc] || r3[Nc]);
        const d3 = { name: "input", attributes: { class: [s3], style: t3, fieldId: l3, dataId: C3, type: a3, checked: c3, xfaOn: g3.on, xfaOff: g3.off, "aria-label": ariaLabel(r3), "aria-required": false } };
        return n3 && (d3.attributes.name = n3), isRequired(r3) && (d3.attributes["aria-required"] = true, d3.attributes.required = true), HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [d3] });
      }
    };
    ChoiceList = class extends XFAObject {
      constructor(e3) {
        super(Ih, "choiceList", true), this.commitOn = getStringOption(e3.commitOn, ["select", "exit"]), this.id = e3.id || "", this.open = getStringOption(e3.open, ["userControl", "always", "multiSelect", "onEntry"]), this.textEntry = getInteger({ data: e3.textEntry, defaultValue: 0, validate: (e4) => 1 === e4 }), this.use = e3.use || "", this.usehref = e3.usehref || "", this.border = null, this.extras = null, this.margin = null;
      }
      [kc](e3) {
        const t3 = toStyle(this, "border", "margin"), i3 = this[Wg]()[Wg](), a3 = { fontSize: `calc(${i3.font?.size || 10}px * var(--scale-factor))` }, s3 = [];
        if (i3.items.children.length > 0) {
          const e4 = i3.items;
          let t4 = 0, n4 = 0;
          2 === e4.children.length && (t4 = e4.children[0].save, n4 = 1 - t4);
          const r3 = e4.children[t4][kc]().html, o3 = e4.children[n4][kc]().html;
          let g3 = false;
          const c3 = i3.value?.[Sc]() || "";
          for (let e5 = 0, t5 = r3.length; e5 < t5; e5++) {
            const t6 = { name: "option", attributes: { value: o3[e5] || r3[e5], style: a3 }, value: r3[e5] };
            o3[e5] === c3 && (t6.attributes.selected = g3 = true), s3.push(t6);
          }
          g3 || s3.splice(0, 0, { name: "option", attributes: { hidden: true, selected: true }, value: " " });
        }
        const n3 = { class: ["xfaSelect"], fieldId: i3[Nc], dataId: i3[kg]?.[Nc] || i3[Nc], style: t3, "aria-label": ariaLabel(i3), "aria-required": false };
        return isRequired(i3) && (n3["aria-required"] = true, n3.required = true), "multiSelect" === this.open && (n3.multiple = true), HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [{ name: "select", children: s3, attributes: n3 }] });
      }
    };
    Color = class extends XFAObject {
      constructor(e3) {
        super(Ih, "color", true), this.cSpace = getStringOption(e3.cSpace, ["SRGB"]), this.id = e3.id || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.value = e3.value ? function(e4, t3 = [0, 0, 0]) {
          let [i3, a3, s3] = t3;
          if (!e4) return { r: i3, g: a3, b: s3 };
          const n3 = e4.trim().split(/\s*,\s*/).map((e5) => Math.min(Math.max(0, parseInt(e5.trim(), 10)), 255)).map((e5) => isNaN(e5) ? 0 : e5);
          return n3.length < 3 || ([i3, a3, s3] = n3), { r: i3, g: a3, b: s3 };
        }(e3.value) : "", this.extras = null;
      }
      [Vg]() {
        return false;
      }
      [xc]() {
        return this.value ? Util.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
      }
    };
    Comb = class extends XFAObject {
      constructor(e3) {
        super(Ih, "comb"), this.id = e3.id || "", this.numberOfCells = getInteger({ data: e3.numberOfCells, defaultValue: 0, validate: (e4) => e4 >= 0 }), this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    Connect = class extends XFAObject {
      constructor(e3) {
        super(Ih, "connect", true), this.connection = e3.connection || "", this.id = e3.id || "", this.ref = e3.ref || "", this.usage = getStringOption(e3.usage, ["exportAndImport", "exportOnly", "importOnly"]), this.use = e3.use || "", this.usehref = e3.usehref || "", this.picture = null;
      }
    };
    ContentArea = class extends XFAObject {
      constructor(e3) {
        super(Ih, "contentArea", true), this.h = getMeasurement(e3.h), this.id = e3.id || "", this.name = e3.name || "", this.relevant = getRelevant(e3.relevant), this.use = e3.use || "", this.usehref = e3.usehref || "", this.w = getMeasurement(e3.w), this.x = getMeasurement(e3.x, "0pt"), this.y = getMeasurement(e3.y, "0pt"), this.desc = null, this.extras = null;
      }
      [kc](e3) {
        const t3 = { left: measureToString(this.x), top: measureToString(this.y), width: measureToString(this.w), height: measureToString(this.h) }, i3 = ["xfaContentarea"];
        return isPrintOnly(this) && i3.push("xfaPrintOnly"), HTMLResult.success({ name: "div", children: [], attributes: { style: t3, class: i3, id: this[Nc] } });
      }
    };
    Corner = class extends XFAObject {
      constructor(e3) {
        super(Ih, "corner", true), this.id = e3.id || "", this.inverted = getInteger({ data: e3.inverted, defaultValue: 0, validate: (e4) => 1 === e4 }), this.join = getStringOption(e3.join, ["square", "round"]), this.presence = getStringOption(e3.presence, ["visible", "hidden", "inactive", "invisible"]), this.radius = getMeasurement(e3.radius), this.stroke = getStringOption(e3.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]), this.thickness = getMeasurement(e3.thickness, "0.5pt"), this.use = e3.use || "", this.usehref = e3.usehref || "", this.color = null, this.extras = null;
      }
      [xc]() {
        const e3 = toStyle(this, "visibility");
        return e3.radius = measureToString("square" === this.join ? 0 : this.radius), e3;
      }
    };
    DateElement = class extends ContentObject {
      constructor(e3) {
        super(Ih, "date"), this.id = e3.id || "", this.name = e3.name || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
      [Ng]() {
        const e3 = this[Fg].trim();
        this[Fg] = e3 ? new Date(e3) : null;
      }
      [kc](e3) {
        return valueToHtml(this[Fg] ? this[Fg].toString() : "");
      }
    };
    DateTime = class extends ContentObject {
      constructor(e3) {
        super(Ih, "dateTime"), this.id = e3.id || "", this.name = e3.name || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
      [Ng]() {
        const e3 = this[Fg].trim();
        this[Fg] = e3 ? new Date(e3) : null;
      }
      [kc](e3) {
        return valueToHtml(this[Fg] ? this[Fg].toString() : "");
      }
    };
    DateTimeEdit = class extends XFAObject {
      constructor(e3) {
        super(Ih, "dateTimeEdit", true), this.hScrollPolicy = getStringOption(e3.hScrollPolicy, ["auto", "off", "on"]), this.id = e3.id || "", this.picker = getStringOption(e3.picker, ["host", "none"]), this.use = e3.use || "", this.usehref = e3.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
      }
      [kc](e3) {
        const t3 = toStyle(this, "border", "font", "margin"), i3 = this[Wg]()[Wg](), a3 = { name: "input", attributes: { type: "text", fieldId: i3[Nc], dataId: i3[kg]?.[Nc] || i3[Nc], class: ["xfaTextfield"], style: t3, "aria-label": ariaLabel(i3), "aria-required": false } };
        return isRequired(i3) && (a3.attributes["aria-required"] = true, a3.attributes.required = true), HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [a3] });
      }
    };
    Decimal = class extends ContentObject {
      constructor(e3) {
        super(Ih, "decimal"), this.fracDigits = getInteger({ data: e3.fracDigits, defaultValue: 2, validate: (e4) => true }), this.id = e3.id || "", this.leadDigits = getInteger({ data: e3.leadDigits, defaultValue: -1, validate: (e4) => true }), this.name = e3.name || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
      [Ng]() {
        const e3 = parseFloat(this[Fg].trim());
        this[Fg] = isNaN(e3) ? null : e3;
      }
      [kc](e3) {
        return valueToHtml(null !== this[Fg] ? this[Fg].toString() : "");
      }
    };
    DefaultUi = class extends XFAObject {
      constructor(e3) {
        super(Ih, "defaultUi", true), this.id = e3.id || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.extras = null;
      }
    };
    Desc = class extends XFAObject {
      constructor(e3) {
        super(Ih, "desc", true), this.id = e3.id || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.boolean = new XFAObjectArray(), this.date = new XFAObjectArray(), this.dateTime = new XFAObjectArray(), this.decimal = new XFAObjectArray(), this.exData = new XFAObjectArray(), this.float = new XFAObjectArray(), this.image = new XFAObjectArray(), this.integer = new XFAObjectArray(), this.text = new XFAObjectArray(), this.time = new XFAObjectArray();
      }
    };
    DigestMethod = class extends OptionObject {
      constructor(e3) {
        super(Ih, "digestMethod", ["", "SHA1", "SHA256", "SHA512", "RIPEMD160"]), this.id = e3.id || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    DigestMethods = class extends XFAObject {
      constructor(e3) {
        super(Ih, "digestMethods", true), this.id = e3.id || "", this.type = getStringOption(e3.type, ["optional", "required"]), this.use = e3.use || "", this.usehref = e3.usehref || "", this.digestMethod = new XFAObjectArray();
      }
    };
    Draw = class extends XFAObject {
      constructor(e3) {
        super(Ih, "draw", true), this.anchorType = getStringOption(e3.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = getInteger({ data: e3.colSpan, defaultValue: 1, validate: (e4) => e4 >= 1 || -1 === e4 }), this.h = e3.h ? getMeasurement(e3.h) : "", this.hAlign = getStringOption(e3.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = e3.id || "", this.locale = e3.locale || "", this.maxH = getMeasurement(e3.maxH, "0pt"), this.maxW = getMeasurement(e3.maxW, "0pt"), this.minH = getMeasurement(e3.minH, "0pt"), this.minW = getMeasurement(e3.minW, "0pt"), this.name = e3.name || "", this.presence = getStringOption(e3.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = getRelevant(e3.relevant), this.rotate = getInteger({ data: e3.rotate, defaultValue: 0, validate: (e4) => e4 % 90 == 0 }), this.use = e3.use || "", this.usehref = e3.usehref || "", this.w = e3.w ? getMeasurement(e3.w) : "", this.x = getMeasurement(e3.x, "0pt"), this.y = getMeasurement(e3.y, "0pt"), this.assist = null, this.border = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.value = null, this.setProperty = new XFAObjectArray();
      }
      [bc](e3) {
        _setValue(this, e3);
      }
      [kc](e3) {
        if (setTabIndex(this), "hidden" === this.presence || "inactive" === this.presence) return HTMLResult.EMPTY;
        fixDimensions(this), this[Qc]();
        const t3 = this.w, i3 = this.h, { w: a3, h: s3, isBroken: n3 } = layoutNode(this, e3);
        if (a3 && "" === this.w) {
          if (n3 && this[_g2]()[nc]()) return this[uc](), HTMLResult.FAILURE;
          this.w = a3;
        }
        if (s3 && "" === this.h && (this.h = s3), setFirstUnsplittable(this), !checkDimensions(this, e3)) return this.w = t3, this.h = i3, this[uc](), HTMLResult.FAILURE;
        unsetFirstUnsplittable(this);
        const r3 = toStyle(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
        setMinMaxDimensions(this, r3), r3.margin && (r3.padding = r3.margin, delete r3.margin);
        const o3 = ["xfaDraw"];
        this.font && o3.push("xfaFont"), isPrintOnly(this) && o3.push("xfaPrintOnly");
        const g3 = { style: r3, id: this[Nc], class: o3 };
        this.name && (g3.xfaName = this.name);
        const c3 = { name: "div", attributes: g3, children: [] };
        applyAssist(this, g3);
        const h3 = computeBbox(this, c3, e3), l3 = this.value ? this.value[kc](e3).html : null;
        return null === l3 ? (this.w = t3, this.h = i3, this[uc](), HTMLResult.success(createWrapper(this, c3), h3)) : (c3.children.push(l3), setPara(this, r3, l3), this.w = t3, this.h = i3, this[uc](), HTMLResult.success(createWrapper(this, c3), h3));
      }
    };
    Edge = class extends XFAObject {
      constructor(e3) {
        super(Ih, "edge", true), this.cap = getStringOption(e3.cap, ["square", "butt", "round"]), this.id = e3.id || "", this.presence = getStringOption(e3.presence, ["visible", "hidden", "inactive", "invisible"]), this.stroke = getStringOption(e3.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]), this.thickness = getMeasurement(e3.thickness, "0.5pt"), this.use = e3.use || "", this.usehref = e3.usehref || "", this.color = null, this.extras = null;
      }
      [xc]() {
        const e3 = toStyle(this, "visibility");
        if (Object.assign(e3, { linecap: this.cap, width: measureToString(this.thickness), color: this.color ? this.color[xc]() : "#000000", style: "" }), "visible" !== this.presence) e3.style = "none";
        else switch (this.stroke) {
          case "solid":
            e3.style = "solid";
            break;
          case "dashDot":
          case "dashDotDot":
          case "dashed":
            e3.style = "dashed";
            break;
          case "dotted":
            e3.style = "dotted";
            break;
          case "embossed":
            e3.style = "ridge";
            break;
          case "etched":
            e3.style = "groove";
            break;
          case "lowered":
            e3.style = "inset";
            break;
          case "raised":
            e3.style = "outset";
        }
        return e3;
      }
    };
    Encoding = class extends OptionObject {
      constructor(e3) {
        super(Ih, "encoding", ["adbe.x509.rsa_sha1", "adbe.pkcs7.detached", "adbe.pkcs7.sha1"]), this.id = e3.id || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    Encodings = class extends XFAObject {
      constructor(e3) {
        super(Ih, "encodings", true), this.id = e3.id || "", this.type = getStringOption(e3.type, ["optional", "required"]), this.use = e3.use || "", this.usehref = e3.usehref || "", this.encoding = new XFAObjectArray();
      }
    };
    Encrypt = class extends XFAObject {
      constructor(e3) {
        super(Ih, "encrypt", true), this.id = e3.id || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.certificate = null;
      }
    };
    EncryptData = class extends XFAObject {
      constructor(e3) {
        super(Ih, "encryptData", true), this.id = e3.id || "", this.operation = getStringOption(e3.operation, ["encrypt", "decrypt"]), this.target = e3.target || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.filter = null, this.manifest = null;
      }
    };
    Encryption = class extends XFAObject {
      constructor(e3) {
        super(Ih, "encryption", true), this.id = e3.id || "", this.type = getStringOption(e3.type, ["optional", "required"]), this.use = e3.use || "", this.usehref = e3.usehref || "", this.certificate = new XFAObjectArray();
      }
    };
    EncryptionMethod = class extends OptionObject {
      constructor(e3) {
        super(Ih, "encryptionMethod", ["", "AES256-CBC", "TRIPLEDES-CBC", "AES128-CBC", "AES192-CBC"]), this.id = e3.id || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    EncryptionMethods = class extends XFAObject {
      constructor(e3) {
        super(Ih, "encryptionMethods", true), this.id = e3.id || "", this.type = getStringOption(e3.type, ["optional", "required"]), this.use = e3.use || "", this.usehref = e3.usehref || "", this.encryptionMethod = new XFAObjectArray();
      }
    };
    Qh = class extends XFAObject {
      constructor(e3) {
        super(Ih, "event", true), this.activity = getStringOption(e3.activity, ["click", "change", "docClose", "docReady", "enter", "exit", "full", "indexChange", "initialize", "mouseDown", "mouseEnter", "mouseExit", "mouseUp", "postExecute", "postOpen", "postPrint", "postSave", "postSign", "postSubmit", "preExecute", "preOpen", "prePrint", "preSave", "preSign", "preSubmit", "ready", "validationState"]), this.id = e3.id || "", this.listen = getStringOption(e3.listen, ["refOnly", "refAndDescendents"]), this.name = e3.name || "", this.ref = e3.ref || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.extras = null, this.encryptData = null, this.execute = null, this.script = null, this.signData = null, this.submit = null;
      }
    };
    ExData = class extends ContentObject {
      constructor(e3) {
        super(Ih, "exData"), this.contentType = e3.contentType || "", this.href = e3.href || "", this.id = e3.id || "", this.maxLength = getInteger({ data: e3.maxLength, defaultValue: -1, validate: (e4) => e4 >= -1 }), this.name = e3.name || "", this.rid = e3.rid || "", this.transferEncoding = getStringOption(e3.transferEncoding, ["none", "base64", "package"]), this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
      [ec]() {
        return "text/html" === this.contentType;
      }
      [Ic](e3) {
        return ("text/html" === this.contentType && e3[cc] === Gc.xhtml.id || "text/xml" === this.contentType) && (this[Fg] = e3, true);
      }
      [kc](e3) {
        return "text/html" === this.contentType && this[Fg] ? this[Fg][kc](e3) : HTMLResult.EMPTY;
      }
    };
    ExObject = class extends XFAObject {
      constructor(e3) {
        super(Ih, "exObject", true), this.archive = e3.archive || "", this.classId = e3.classId || "", this.codeBase = e3.codeBase || "", this.codeType = e3.codeType || "", this.id = e3.id || "", this.name = e3.name || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.extras = null, this.boolean = new XFAObjectArray(), this.date = new XFAObjectArray(), this.dateTime = new XFAObjectArray(), this.decimal = new XFAObjectArray(), this.exData = new XFAObjectArray(), this.exObject = new XFAObjectArray(), this.float = new XFAObjectArray(), this.image = new XFAObjectArray(), this.integer = new XFAObjectArray(), this.text = new XFAObjectArray(), this.time = new XFAObjectArray();
      }
    };
    ExclGroup = class extends XFAObject {
      constructor(e3) {
        super(Ih, "exclGroup", true), this.access = getStringOption(e3.access, ["open", "nonInteractive", "protected", "readOnly"]), this.accessKey = e3.accessKey || "", this.anchorType = getStringOption(e3.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = getInteger({ data: e3.colSpan, defaultValue: 1, validate: (e4) => e4 >= 1 || -1 === e4 }), this.h = e3.h ? getMeasurement(e3.h) : "", this.hAlign = getStringOption(e3.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = e3.id || "", this.layout = getStringOption(e3.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]), this.maxH = getMeasurement(e3.maxH, "0pt"), this.maxW = getMeasurement(e3.maxW, "0pt"), this.minH = getMeasurement(e3.minH, "0pt"), this.minW = getMeasurement(e3.minW, "0pt"), this.name = e3.name || "", this.presence = getStringOption(e3.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = getRelevant(e3.relevant), this.use = e3.use || "", this.usehref = e3.usehref || "", this.w = e3.w ? getMeasurement(e3.w) : "", this.x = getMeasurement(e3.x, "0pt"), this.y = getMeasurement(e3.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.margin = null, this.para = null, this.traversal = null, this.validate = null, this.connect = new XFAObjectArray(), this.event = new XFAObjectArray(), this.field = new XFAObjectArray(), this.setProperty = new XFAObjectArray();
      }
      [tc]() {
        return true;
      }
      [Vg]() {
        return true;
      }
      [bc](e3) {
        for (const t3 of this.field.children) {
          if (!t3.value) {
            const e4 = new Value({});
            t3[pg](e4), t3.value = e4;
          }
          t3.value[bc](e3);
        }
      }
      [nc]() {
        return this.layout.endsWith("-tb") && 0 === this[xg].attempt && this[xg].numberInLine > 0 || this[Wg]()[nc]();
      }
      [sc]() {
        const e3 = this[_g2]();
        return !!e3[sc]() && (void 0 !== this[xg]._isSplittable ? this[xg]._isSplittable : "position" === this.layout || this.layout.includes("row") ? (this[xg]._isSplittable = false, false) : (!e3.layout?.endsWith("-tb") || 0 === e3[xg].numberInLine) && (this[xg]._isSplittable = true, true));
      }
      [Mg]() {
        return flushHTML(this);
      }
      [fg](e3, t3) {
        addHTML(this, e3, t3);
      }
      [Lg]() {
        return getAvailableSpace(this);
      }
      [kc](e3) {
        if (setTabIndex(this), "hidden" === this.presence || "inactive" === this.presence || 0 === this.h || 0 === this.w) return HTMLResult.EMPTY;
        fixDimensions(this);
        const t3 = [], i3 = { id: this[Nc], class: [] };
        setAccess(this, i3.class), this[xg] || (this[xg] = /* @__PURE__ */ Object.create(null)), Object.assign(this[xg], { children: t3, attributes: i3, attempt: 0, line: null, numberInLine: 0, availableSpace: { width: Math.min(this.w || 1 / 0, e3.width), height: Math.min(this.h || 1 / 0, e3.height) }, width: 0, height: 0, prevHeight: 0, currentWidth: 0 });
        const a3 = this[sc]();
        if (a3 || setFirstUnsplittable(this), !checkDimensions(this, e3)) return HTMLResult.FAILURE;
        const s3 = /* @__PURE__ */ new Set(["field"]);
        if (this.layout.includes("row")) {
          const e4 = this[_g2]().columnWidths;
          Array.isArray(e4) && e4.length > 0 && (this[xg].columnWidths = e4, this[xg].currentColumn = 0);
        }
        const n3 = toStyle(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), r3 = ["xfaExclgroup"], o3 = layoutClass(this);
        o3 && r3.push(o3), isPrintOnly(this) && r3.push("xfaPrintOnly"), i3.style = n3, i3.class = r3, this.name && (i3.xfaName = this.name), this[Qc]();
        const g3 = "lr-tb" === this.layout || "rl-tb" === this.layout, c3 = g3 ? 2 : 1;
        for (; this[xg].attempt < c3; this[xg].attempt++) {
          g3 && 1 === this[xg].attempt && (this[xg].numberInLine = 0);
          const e4 = this[mg]({ filter: s3, include: true });
          if (e4.success) break;
          if (e4.isBreak()) return this[uc](), e4;
          if (g3 && 0 === this[xg].attempt && 0 === this[xg].numberInLine && !this[jg]()[xg].noLayoutFailure) {
            this[xg].attempt = c3;
            break;
          }
        }
        if (this[uc](), a3 || unsetFirstUnsplittable(this), this[xg].attempt === c3) return a3 || delete this[xg], HTMLResult.FAILURE;
        let h3 = 0, l3 = 0;
        this.margin && (h3 = this.margin.leftInset + this.margin.rightInset, l3 = this.margin.topInset + this.margin.bottomInset);
        const C3 = Math.max(this[xg].width + h3, this.w || 0), d3 = Math.max(this[xg].height + l3, this.h || 0), u3 = [this.x, this.y, C3, d3];
        "" === this.w && (n3.width = measureToString(C3)), "" === this.h && (n3.height = measureToString(d3));
        const Q3 = { name: "div", attributes: i3, children: t3 };
        return applyAssist(this, i3), delete this[xg], HTMLResult.success(createWrapper(this, Q3), u3);
      }
    };
    Execute = class extends XFAObject {
      constructor(e3) {
        super(Ih, "execute"), this.connection = e3.connection || "", this.executeType = getStringOption(e3.executeType, ["import", "remerge"]), this.id = e3.id || "", this.runAt = getStringOption(e3.runAt, ["client", "both", "server"]), this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    Extras = class extends XFAObject {
      constructor(e3) {
        super(Ih, "extras", true), this.id = e3.id || "", this.name = e3.name || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.boolean = new XFAObjectArray(), this.date = new XFAObjectArray(), this.dateTime = new XFAObjectArray(), this.decimal = new XFAObjectArray(), this.exData = new XFAObjectArray(), this.extras = new XFAObjectArray(), this.float = new XFAObjectArray(), this.image = new XFAObjectArray(), this.integer = new XFAObjectArray(), this.text = new XFAObjectArray(), this.time = new XFAObjectArray();
      }
    };
    Field = class extends XFAObject {
      constructor(e3) {
        super(Ih, "field", true), this.access = getStringOption(e3.access, ["open", "nonInteractive", "protected", "readOnly"]), this.accessKey = e3.accessKey || "", this.anchorType = getStringOption(e3.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = getInteger({ data: e3.colSpan, defaultValue: 1, validate: (e4) => e4 >= 1 || -1 === e4 }), this.h = e3.h ? getMeasurement(e3.h) : "", this.hAlign = getStringOption(e3.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = e3.id || "", this.locale = e3.locale || "", this.maxH = getMeasurement(e3.maxH, "0pt"), this.maxW = getMeasurement(e3.maxW, "0pt"), this.minH = getMeasurement(e3.minH, "0pt"), this.minW = getMeasurement(e3.minW, "0pt"), this.name = e3.name || "", this.presence = getStringOption(e3.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = getRelevant(e3.relevant), this.rotate = getInteger({ data: e3.rotate, defaultValue: 0, validate: (e4) => e4 % 90 == 0 }), this.use = e3.use || "", this.usehref = e3.usehref || "", this.w = e3.w ? getMeasurement(e3.w) : "", this.x = getMeasurement(e3.x, "0pt"), this.y = getMeasurement(e3.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.format = null, this.items = new XFAObjectArray(2), this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.validate = null, this.value = null, this.bindItems = new XFAObjectArray(), this.connect = new XFAObjectArray(), this.event = new XFAObjectArray(), this.setProperty = new XFAObjectArray();
      }
      [tc]() {
        return true;
      }
      [bc](e3) {
        _setValue(this, e3);
      }
      [kc](e3) {
        if (setTabIndex(this), !this.ui) {
          let e4;
          switch (this.ui = new Ui({}), this.ui[Xg] = this[Xg], this[pg](this.ui), this.items.children.length) {
            case 0:
              e4 = new TextEdit({}), this.ui.textEdit = e4;
              break;
            case 1:
              e4 = new CheckButton({}), this.ui.checkButton = e4;
              break;
            case 2:
              e4 = new ChoiceList({}), this.ui.choiceList = e4;
          }
          this.ui[pg](e4);
        }
        if (!this.ui || "hidden" === this.presence || "inactive" === this.presence || 0 === this.h || 0 === this.w) return HTMLResult.EMPTY;
        this.caption && delete this.caption[xg], this[Qc]();
        const t3 = this.caption ? this.caption[kc](e3).html : null, i3 = this.w, a3 = this.h;
        let s3 = 0, n3 = 0;
        this.margin && (s3 = this.margin.leftInset + this.margin.rightInset, n3 = this.margin.topInset + this.margin.bottomInset);
        let r3 = null;
        if ("" === this.w || "" === this.h) {
          let t4 = null, i4 = null, a4 = 0, o4 = 0;
          if (this.ui.checkButton) a4 = o4 = this.ui.checkButton.size;
          else {
            const { w: t5, h: i5 } = layoutNode(this, e3);
            null !== t5 ? (a4 = t5, o4 = i5) : o4 = function(e4, t6 = false) {
              let i6 = null;
              if (e4) {
                const t7 = stripQuotes(e4.typeface), a6 = e4[Xg].fontFinder.find(t7);
                i6 = selectFont(e4, a6);
              }
              if (!i6) return { lineHeight: 12, lineGap: 2, lineNoGap: 10 };
              const a5 = e4.size || 10, s4 = i6.lineHeight ? Math.max(t6 ? 0 : 1.2, i6.lineHeight) : 1.2, n4 = void 0 === i6.lineGap ? 0.2 : i6.lineGap;
              return { lineHeight: s4 * a5, lineGap: n4 * a5, lineNoGap: Math.max(1, s4 - n4) * a5 };
            }(this.font, true).lineNoGap;
          }
          if (r3 = getBorderDims(this.ui[Yg]()), a4 += r3.w, o4 += r3.h, this.caption) {
            const { w: s4, h: n4, isBroken: r4 } = this.caption[Yg](e3);
            if (r4 && this[_g2]()[nc]()) return this[uc](), HTMLResult.FAILURE;
            switch (t4 = s4, i4 = n4, this.caption.placement) {
              case "left":
              case "right":
              case "inline":
                t4 += a4;
                break;
              case "top":
              case "bottom":
                i4 += o4;
            }
          } else t4 = a4, i4 = o4;
          t4 && "" === this.w && (t4 += s3, this.w = Math.min(this.maxW <= 0 ? 1 / 0 : this.maxW, this.minW + 1 < t4 ? t4 : this.minW)), i4 && "" === this.h && (i4 += n3, this.h = Math.min(this.maxH <= 0 ? 1 / 0 : this.maxH, this.minH + 1 < i4 ? i4 : this.minH));
        }
        if (this[uc](), fixDimensions(this), setFirstUnsplittable(this), !checkDimensions(this, e3)) return this.w = i3, this.h = a3, this[uc](), HTMLResult.FAILURE;
        unsetFirstUnsplittable(this);
        const o3 = toStyle(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
        setMinMaxDimensions(this, o3);
        const g3 = ["xfaField"];
        this.font && g3.push("xfaFont"), isPrintOnly(this) && g3.push("xfaPrintOnly");
        const c3 = { style: o3, id: this[Nc], class: g3 };
        o3.margin && (o3.padding = o3.margin, delete o3.margin), setAccess(this, g3), this.name && (c3.xfaName = this.name);
        const h3 = [], l3 = { name: "div", attributes: c3, children: h3 };
        applyAssist(this, c3);
        const C3 = this.border ? this.border[xc]() : null, d3 = computeBbox(this, l3, e3), u3 = this.ui[kc]().html;
        if (!u3) return Object.assign(o3, C3), HTMLResult.success(createWrapper(this, l3), d3);
        this[Dc] && (u3.children?.[0] ? u3.children[0].attributes.tabindex = this[Dc] : u3.attributes.tabindex = this[Dc]), u3.attributes.style || (u3.attributes.style = /* @__PURE__ */ Object.create(null));
        let Q3 = null;
        if (this.ui.button ? (1 === u3.children.length && ([Q3] = u3.children.splice(0, 1)), Object.assign(u3.attributes.style, C3)) : Object.assign(o3, C3), h3.push(u3), this.value) {
          if (this.ui.imageEdit) u3.children.push(this.value[kc]().html);
          else if (!this.ui.button) {
            let e4 = "";
            if (this.value.exData) e4 = this.value.exData[Sc]();
            else if (this.value.text) e4 = this.value.text[Yg]();
            else {
              const t4 = this.value[kc]().html;
              null !== t4 && (e4 = t4.children[0].value);
            }
            this.ui.textEdit && this.value.text?.maxChars && (u3.children[0].attributes.maxLength = this.value.text.maxChars), e4 && (this.ui.numericEdit && (e4 = parseFloat(e4), e4 = isNaN(e4) ? "" : e4.toString()), "textarea" === u3.children[0].name ? u3.children[0].attributes.textContent = e4 : u3.children[0].attributes.value = e4);
          }
        }
        if (!this.ui.imageEdit && u3.children?.[0] && this.h) {
          r3 = r3 || getBorderDims(this.ui[Yg]());
          let t4 = 0;
          if (this.caption && ["top", "bottom"].includes(this.caption.placement)) {
            t4 = this.caption.reserve, t4 <= 0 && (t4 = this.caption[Yg](e3).h);
            const i4 = this.h - t4 - n3 - r3.h;
            u3.children[0].attributes.style.height = measureToString(i4);
          } else u3.children[0].attributes.style.height = "100%";
        }
        if (Q3 && u3.children.push(Q3), !t3) return u3.attributes.class && u3.attributes.class.push("xfaLeft"), this.w = i3, this.h = a3, HTMLResult.success(createWrapper(this, l3), d3);
        if (this.ui.button) return o3.padding && delete o3.padding, "div" === t3.name && (t3.name = "span"), u3.children.push(t3), HTMLResult.success(l3, d3);
        switch (this.ui.checkButton && (t3.attributes.class[0] = "xfaCaptionForCheckButton"), u3.attributes.class || (u3.attributes.class = []), u3.children.splice(0, 0, t3), this.caption.placement) {
          case "left":
          case "inline":
            u3.attributes.class.push("xfaLeft");
            break;
          case "right":
            u3.attributes.class.push("xfaRight");
            break;
          case "top":
            u3.attributes.class.push("xfaTop");
            break;
          case "bottom":
            u3.attributes.class.push("xfaBottom");
        }
        return this.w = i3, this.h = a3, HTMLResult.success(createWrapper(this, l3), d3);
      }
    };
    Fill = class extends XFAObject {
      constructor(e3) {
        super(Ih, "fill", true), this.id = e3.id || "", this.presence = getStringOption(e3.presence, ["visible", "hidden", "inactive", "invisible"]), this.use = e3.use || "", this.usehref = e3.usehref || "", this.color = null, this.extras = null, this.linear = null, this.pattern = null, this.radial = null, this.solid = null, this.stipple = null;
      }
      [xc]() {
        const e3 = this[Wg](), t3 = e3[Wg]()[Wg](), i3 = /* @__PURE__ */ Object.create(null);
        let a3 = "color", s3 = a3;
        e3 instanceof Border && (a3 = "background-color", s3 = "background", t3 instanceof Ui && (i3.backgroundColor = "white")), (e3 instanceof Rectangle || e3 instanceof Arc) && (a3 = s3 = "fill", i3.fill = "white");
        for (const e4 of Object.getOwnPropertyNames(this)) {
          if ("extras" === e4 || "color" === e4) continue;
          const t4 = this[e4];
          if (!(t4 instanceof XFAObject)) continue;
          const n3 = t4[xc](this.color);
          return n3 && (i3[n3.startsWith("#") ? a3 : s3] = n3), i3;
        }
        if (this.color?.value) {
          const e4 = this.color[xc]();
          i3[e4.startsWith("#") ? a3 : s3] = e4;
        }
        return i3;
      }
    };
    Filter = class extends XFAObject {
      constructor(e3) {
        super(Ih, "filter", true), this.addRevocationInfo = getStringOption(e3.addRevocationInfo, ["", "required", "optional", "none"]), this.id = e3.id || "", this.name = e3.name || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.version = getInteger({ data: this.version, defaultValue: 5, validate: (e4) => e4 >= 1 && e4 <= 5 }), this.appearanceFilter = null, this.certificates = null, this.digestMethods = null, this.encodings = null, this.encryptionMethods = null, this.handler = null, this.lockDocument = null, this.mdp = null, this.reasons = null, this.timeStamp = null;
      }
    };
    Float = class extends ContentObject {
      constructor(e3) {
        super(Ih, "float"), this.id = e3.id || "", this.name = e3.name || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
      [Ng]() {
        const e3 = parseFloat(this[Fg].trim());
        this[Fg] = isNaN(e3) ? null : e3;
      }
      [kc](e3) {
        return valueToHtml(null !== this[Fg] ? this[Fg].toString() : "");
      }
    };
    template_Font = class extends XFAObject {
      constructor(e3) {
        super(Ih, "font", true), this.baselineShift = getMeasurement(e3.baselineShift), this.fontHorizontalScale = getFloat({ data: e3.fontHorizontalScale, defaultValue: 100, validate: (e4) => e4 >= 0 }), this.fontVerticalScale = getFloat({ data: e3.fontVerticalScale, defaultValue: 100, validate: (e4) => e4 >= 0 }), this.id = e3.id || "", this.kerningMode = getStringOption(e3.kerningMode, ["none", "pair"]), this.letterSpacing = getMeasurement(e3.letterSpacing, "0"), this.lineThrough = getInteger({ data: e3.lineThrough, defaultValue: 0, validate: (e4) => 1 === e4 || 2 === e4 }), this.lineThroughPeriod = getStringOption(e3.lineThroughPeriod, ["all", "word"]), this.overline = getInteger({ data: e3.overline, defaultValue: 0, validate: (e4) => 1 === e4 || 2 === e4 }), this.overlinePeriod = getStringOption(e3.overlinePeriod, ["all", "word"]), this.posture = getStringOption(e3.posture, ["normal", "italic"]), this.size = getMeasurement(e3.size, "10pt"), this.typeface = e3.typeface || "Courier", this.underline = getInteger({ data: e3.underline, defaultValue: 0, validate: (e4) => 1 === e4 || 2 === e4 }), this.underlinePeriod = getStringOption(e3.underlinePeriod, ["all", "word"]), this.use = e3.use || "", this.usehref = e3.usehref || "", this.weight = getStringOption(e3.weight, ["normal", "bold"]), this.extras = null, this.fill = null;
      }
      [yg](e3) {
        super[yg](e3), this[Xg].usedTypefaces.add(this.typeface);
      }
      [xc]() {
        const e3 = toStyle(this, "fill"), t3 = e3.color;
        return t3 && ("#000000" === t3 ? delete e3.color : t3.startsWith("#") || (e3.background = t3, e3.backgroundClip = "text", e3.color = "transparent")), this.baselineShift && (e3.verticalAlign = measureToString(this.baselineShift)), e3.fontKerning = "none" === this.kerningMode ? "none" : "normal", e3.letterSpacing = measureToString(this.letterSpacing), 0 !== this.lineThrough && (e3.textDecoration = "line-through", 2 === this.lineThrough && (e3.textDecorationStyle = "double")), 0 !== this.overline && (e3.textDecoration = "overline", 2 === this.overline && (e3.textDecorationStyle = "double")), e3.fontStyle = this.posture, e3.fontSize = measureToString(0.99 * this.size), setFontFamily(this, this, this[Xg].fontFinder, e3), 0 !== this.underline && (e3.textDecoration = "underline", 2 === this.underline && (e3.textDecorationStyle = "double")), e3.fontWeight = this.weight, e3;
      }
    };
    Format = class extends XFAObject {
      constructor(e3) {
        super(Ih, "format", true), this.id = e3.id || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.extras = null, this.picture = null;
      }
    };
    Handler = class extends StringObject {
      constructor(e3) {
        super(Ih, "handler"), this.id = e3.id || "", this.type = getStringOption(e3.type, ["optional", "required"]), this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    Hyphenation = class extends XFAObject {
      constructor(e3) {
        super(Ih, "hyphenation"), this.excludeAllCaps = getInteger({ data: e3.excludeAllCaps, defaultValue: 0, validate: (e4) => 1 === e4 }), this.excludeInitialCap = getInteger({ data: e3.excludeInitialCap, defaultValue: 0, validate: (e4) => 1 === e4 }), this.hyphenate = getInteger({ data: e3.hyphenate, defaultValue: 0, validate: (e4) => 1 === e4 }), this.id = e3.id || "", this.pushCharacterCount = getInteger({ data: e3.pushCharacterCount, defaultValue: 3, validate: (e4) => e4 >= 0 }), this.remainCharacterCount = getInteger({ data: e3.remainCharacterCount, defaultValue: 3, validate: (e4) => e4 >= 0 }), this.use = e3.use || "", this.usehref = e3.usehref || "", this.wordCharacterCount = getInteger({ data: e3.wordCharacterCount, defaultValue: 7, validate: (e4) => e4 >= 0 });
      }
    };
    Eh = class extends StringObject {
      constructor(e3) {
        super(Ih, "image"), this.aspect = getStringOption(e3.aspect, ["fit", "actual", "height", "none", "width"]), this.contentType = e3.contentType || "", this.href = e3.href || "", this.id = e3.id || "", this.name = e3.name || "", this.transferEncoding = getStringOption(e3.transferEncoding, ["base64", "none", "package"]), this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
      [kc]() {
        if (this.contentType && !Bh.has(this.contentType.toLowerCase())) return HTMLResult.EMPTY;
        let e3 = this[Xg].images && this[Xg].images.get(this.href);
        if (!e3 && (this.href || !this[Fg])) return HTMLResult.EMPTY;
        if (e3 || "base64" !== this.transferEncoding || (e3 = stringToBytes(atob(this[Fg]))), !e3) return HTMLResult.EMPTY;
        if (!this.contentType) {
          for (const [t4, i4] of uh) if (e3.length > t4.length && t4.every((t5, i5) => t5 === e3[i5])) {
            this.contentType = i4;
            break;
          }
          if (!this.contentType) return HTMLResult.EMPTY;
        }
        const t3 = new Blob([e3], { type: this.contentType });
        let i3;
        switch (this.aspect) {
          case "fit":
          case "actual":
            break;
          case "height":
            i3 = { height: "100%", objectFit: "fill" };
            break;
          case "none":
            i3 = { width: "100%", height: "100%", objectFit: "fill" };
            break;
          case "width":
            i3 = { width: "100%", objectFit: "fill" };
        }
        const a3 = this[Wg]();
        return HTMLResult.success({ name: "img", attributes: { class: ["xfaImage"], style: i3, src: URL.createObjectURL(t3), alt: a3 ? ariaLabel(a3[Wg]()) : null } });
      }
    };
    ImageEdit = class extends XFAObject {
      constructor(e3) {
        super(Ih, "imageEdit", true), this.data = getStringOption(e3.data, ["link", "embed"]), this.id = e3.id || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.border = null, this.extras = null, this.margin = null;
      }
      [kc](e3) {
        return "embed" === this.data ? HTMLResult.success({ name: "div", children: [], attributes: {} }) : HTMLResult.EMPTY;
      }
    };
    Integer = class extends ContentObject {
      constructor(e3) {
        super(Ih, "integer"), this.id = e3.id || "", this.name = e3.name || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
      [Ng]() {
        const e3 = parseInt(this[Fg].trim(), 10);
        this[Fg] = isNaN(e3) ? null : e3;
      }
      [kc](e3) {
        return valueToHtml(null !== this[Fg] ? this[Fg].toString() : "");
      }
    };
    Issuers = class extends XFAObject {
      constructor(e3) {
        super(Ih, "issuers", true), this.id = e3.id || "", this.type = getStringOption(e3.type, ["optional", "required"]), this.use = e3.use || "", this.usehref = e3.usehref || "", this.certificate = new XFAObjectArray();
      }
    };
    Items = class extends XFAObject {
      constructor(e3) {
        super(Ih, "items", true), this.id = e3.id || "", this.name = e3.name || "", this.presence = getStringOption(e3.presence, ["visible", "hidden", "inactive", "invisible"]), this.ref = e3.ref || "", this.save = getInteger({ data: e3.save, defaultValue: 0, validate: (e4) => 1 === e4 }), this.use = e3.use || "", this.usehref = e3.usehref || "", this.boolean = new XFAObjectArray(), this.date = new XFAObjectArray(), this.dateTime = new XFAObjectArray(), this.decimal = new XFAObjectArray(), this.exData = new XFAObjectArray(), this.float = new XFAObjectArray(), this.image = new XFAObjectArray(), this.integer = new XFAObjectArray(), this.text = new XFAObjectArray(), this.time = new XFAObjectArray();
      }
      [kc]() {
        const e3 = [];
        for (const t3 of this[Og]()) e3.push(t3[Sc]());
        return HTMLResult.success(e3);
      }
    };
    Keep = class extends XFAObject {
      constructor(e3) {
        super(Ih, "keep", true), this.id = e3.id || "";
        const t3 = ["none", "contentArea", "pageArea"];
        this.intact = getStringOption(e3.intact, t3), this.next = getStringOption(e3.next, t3), this.previous = getStringOption(e3.previous, t3), this.use = e3.use || "", this.usehref = e3.usehref || "", this.extras = null;
      }
    };
    KeyUsage = class extends XFAObject {
      constructor(e3) {
        super(Ih, "keyUsage");
        const t3 = ["", "yes", "no"];
        this.crlSign = getStringOption(e3.crlSign, t3), this.dataEncipherment = getStringOption(e3.dataEncipherment, t3), this.decipherOnly = getStringOption(e3.decipherOnly, t3), this.digitalSignature = getStringOption(e3.digitalSignature, t3), this.encipherOnly = getStringOption(e3.encipherOnly, t3), this.id = e3.id || "", this.keyAgreement = getStringOption(e3.keyAgreement, t3), this.keyCertSign = getStringOption(e3.keyCertSign, t3), this.keyEncipherment = getStringOption(e3.keyEncipherment, t3), this.nonRepudiation = getStringOption(e3.nonRepudiation, t3), this.type = getStringOption(e3.type, ["optional", "required"]), this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    Line = class extends XFAObject {
      constructor(e3) {
        super(Ih, "line", true), this.hand = getStringOption(e3.hand, ["even", "left", "right"]), this.id = e3.id || "", this.slope = getStringOption(e3.slope, ["\\", "/"]), this.use = e3.use || "", this.usehref = e3.usehref || "", this.edge = null;
      }
      [kc]() {
        const e3 = this[Wg]()[Wg](), t3 = this.edge || new Edge({}), i3 = t3[xc](), a3 = /* @__PURE__ */ Object.create(null), s3 = "visible" === t3.presence ? t3.thickness : 0;
        let n3, r3, o3, g3;
        a3.strokeWidth = measureToString(s3), a3.stroke = i3.color;
        let c3 = "100%", h3 = "100%";
        e3.w <= s3 ? ([n3, r3, o3, g3] = ["50%", 0, "50%", "100%"], c3 = a3.strokeWidth) : e3.h <= s3 ? ([n3, r3, o3, g3] = [0, "50%", "100%", "50%"], h3 = a3.strokeWidth) : "\\" === this.slope ? [n3, r3, o3, g3] = [0, 0, "100%", "100%"] : [n3, r3, o3, g3] = [0, "100%", "100%", 0];
        const l3 = { name: "svg", children: [{ name: "line", attributes: { xmlns: Ch, x1: n3, y1: r3, x2: o3, y2: g3, style: a3 } }], attributes: { xmlns: Ch, width: c3, height: h3, style: { overflow: "visible" } } };
        return hasMargin(e3) ? HTMLResult.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [l3] }) : (l3.attributes.style.position = "absolute", HTMLResult.success(l3));
      }
    };
    Linear = class extends XFAObject {
      constructor(e3) {
        super(Ih, "linear", true), this.id = e3.id || "", this.type = getStringOption(e3.type, ["toRight", "toBottom", "toLeft", "toTop"]), this.use = e3.use || "", this.usehref = e3.usehref || "", this.color = null, this.extras = null;
      }
      [xc](e3) {
        e3 = e3 ? e3[xc]() : "#FFFFFF";
        return `linear-gradient(${this.type.replace(/([RBLT])/, " $1").toLowerCase()}, ${e3}, ${this.color ? this.color[xc]() : "#000000"})`;
      }
    };
    LockDocument = class extends ContentObject {
      constructor(e3) {
        super(Ih, "lockDocument"), this.id = e3.id || "", this.type = getStringOption(e3.type, ["optional", "required"]), this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
      [Ng]() {
        this[Fg] = getStringOption(this[Fg], ["auto", "0", "1"]);
      }
    };
    Manifest = class extends XFAObject {
      constructor(e3) {
        super(Ih, "manifest", true), this.action = getStringOption(e3.action, ["include", "all", "exclude"]), this.id = e3.id || "", this.name = e3.name || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.extras = null, this.ref = new XFAObjectArray();
      }
    };
    Margin = class extends XFAObject {
      constructor(e3) {
        super(Ih, "margin", true), this.bottomInset = getMeasurement(e3.bottomInset, "0"), this.id = e3.id || "", this.leftInset = getMeasurement(e3.leftInset, "0"), this.rightInset = getMeasurement(e3.rightInset, "0"), this.topInset = getMeasurement(e3.topInset, "0"), this.use = e3.use || "", this.usehref = e3.usehref || "", this.extras = null;
      }
      [xc]() {
        return { margin: measureToString(this.topInset) + " " + measureToString(this.rightInset) + " " + measureToString(this.bottomInset) + " " + measureToString(this.leftInset) };
      }
    };
    Mdp = class extends XFAObject {
      constructor(e3) {
        super(Ih, "mdp"), this.id = e3.id || "", this.permissions = getInteger({ data: e3.permissions, defaultValue: 2, validate: (e4) => 1 === e4 || 3 === e4 }), this.signatureType = getStringOption(e3.signatureType, ["filler", "author"]), this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    Medium = class extends XFAObject {
      constructor(e3) {
        super(Ih, "medium"), this.id = e3.id || "", this.imagingBBox = function(e4) {
          const t3 = -1;
          if (!e4) return { x: t3, y: t3, width: t3, height: t3 };
          const i3 = e4.trim().split(/\s*,\s*/).map((e5) => getMeasurement(e5, "-1"));
          if (i3.length < 4 || i3[2] < 0 || i3[3] < 0) return { x: t3, y: t3, width: t3, height: t3 };
          const [a3, s3, n3, r3] = i3;
          return { x: a3, y: s3, width: n3, height: r3 };
        }(e3.imagingBBox), this.long = getMeasurement(e3.long), this.orientation = getStringOption(e3.orientation, ["portrait", "landscape"]), this.short = getMeasurement(e3.short), this.stock = e3.stock || "", this.trayIn = getStringOption(e3.trayIn, ["auto", "delegate", "pageFront"]), this.trayOut = getStringOption(e3.trayOut, ["auto", "delegate"]), this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    Message = class extends XFAObject {
      constructor(e3) {
        super(Ih, "message", true), this.id = e3.id || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.text = new XFAObjectArray();
      }
    };
    NumericEdit = class extends XFAObject {
      constructor(e3) {
        super(Ih, "numericEdit", true), this.hScrollPolicy = getStringOption(e3.hScrollPolicy, ["auto", "off", "on"]), this.id = e3.id || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
      }
      [kc](e3) {
        const t3 = toStyle(this, "border", "font", "margin"), i3 = this[Wg]()[Wg](), a3 = { name: "input", attributes: { type: "text", fieldId: i3[Nc], dataId: i3[kg]?.[Nc] || i3[Nc], class: ["xfaTextfield"], style: t3, "aria-label": ariaLabel(i3), "aria-required": false } };
        return isRequired(i3) && (a3.attributes["aria-required"] = true, a3.attributes.required = true), HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [a3] });
      }
    };
    Occur = class extends XFAObject {
      constructor(e3) {
        super(Ih, "occur", true), this.id = e3.id || "", this.initial = "" !== e3.initial ? getInteger({ data: e3.initial, defaultValue: "", validate: (e4) => true }) : "", this.max = "" !== e3.max ? getInteger({ data: e3.max, defaultValue: 1, validate: (e4) => true }) : "", this.min = "" !== e3.min ? getInteger({ data: e3.min, defaultValue: 1, validate: (e4) => true }) : "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.extras = null;
      }
      [yg]() {
        const e3 = this[Wg](), t3 = this.min;
        "" === this.min && (this.min = e3 instanceof PageArea || e3 instanceof PageSet ? 0 : 1), "" === this.max && (this.max = "" === t3 ? e3 instanceof PageArea || e3 instanceof PageSet ? -1 : 1 : this.min), -1 !== this.max && this.max < this.min && (this.max = this.min), "" === this.initial && (this.initial = e3 instanceof Template ? 1 : this.min);
      }
    };
    Oid = class extends StringObject {
      constructor(e3) {
        super(Ih, "oid"), this.id = e3.id || "", this.name = e3.name || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    Oids = class extends XFAObject {
      constructor(e3) {
        super(Ih, "oids", true), this.id = e3.id || "", this.type = getStringOption(e3.type, ["optional", "required"]), this.use = e3.use || "", this.usehref = e3.usehref || "", this.oid = new XFAObjectArray();
      }
    };
    Overflow = class extends XFAObject {
      constructor(e3) {
        super(Ih, "overflow"), this.id = e3.id || "", this.leader = e3.leader || "", this.target = e3.target || "", this.trailer = e3.trailer || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
      [Yg]() {
        if (!this[xg]) {
          const e3 = this[Wg](), t3 = this[jg](), i3 = t3[mc](this.target, e3), a3 = t3[mc](this.leader, e3), s3 = t3[mc](this.trailer, e3);
          this[xg] = { target: i3?.[0] || null, leader: a3?.[0] || null, trailer: s3?.[0] || null, addLeader: false, addTrailer: false };
        }
        return this[xg];
      }
    };
    PageArea = class extends XFAObject {
      constructor(e3) {
        super(Ih, "pageArea", true), this.blankOrNotBlank = getStringOption(e3.blankOrNotBlank, ["any", "blank", "notBlank"]), this.id = e3.id || "", this.initialNumber = getInteger({ data: e3.initialNumber, defaultValue: 1, validate: (e4) => true }), this.name = e3.name || "", this.numbered = getInteger({ data: e3.numbered, defaultValue: 1, validate: (e4) => true }), this.oddOrEven = getStringOption(e3.oddOrEven, ["any", "even", "odd"]), this.pagePosition = getStringOption(e3.pagePosition, ["any", "first", "last", "only", "rest"]), this.relevant = getRelevant(e3.relevant), this.use = e3.use || "", this.usehref = e3.usehref || "", this.desc = null, this.extras = null, this.medium = null, this.occur = null, this.area = new XFAObjectArray(), this.contentArea = new XFAObjectArray(), this.draw = new XFAObjectArray(), this.exclGroup = new XFAObjectArray(), this.field = new XFAObjectArray(), this.subform = new XFAObjectArray();
      }
      [oc]() {
        return this[xg] ? !this.occur || -1 === this.occur.max || this[xg].numberOfUse < this.occur.max : (this[xg] = { numberOfUse: 0 }, true);
      }
      [wg]() {
        delete this[xg];
      }
      [qg]() {
        this[xg] || (this[xg] = { numberOfUse: 0 });
        const e3 = this[Wg]();
        return "orderedOccurrence" === e3.relation && this[oc]() ? (this[xg].numberOfUse += 1, this) : e3[qg]();
      }
      [Lg]() {
        return this[xg].space || { width: 0, height: 0 };
      }
      [kc]() {
        this[xg] || (this[xg] = { numberOfUse: 1 });
        const e3 = [];
        this[xg].children = e3;
        const t3 = /* @__PURE__ */ Object.create(null);
        if (this.medium && this.medium.short && this.medium.long) {
          if (t3.width = measureToString(this.medium.short), t3.height = measureToString(this.medium.long), this[xg].space = { width: this.medium.short, height: this.medium.long }, "landscape" === this.medium.orientation) {
            const e4 = t3.width;
            t3.width = t3.height, t3.height = e4, this[xg].space = { width: this.medium.long, height: this.medium.short };
          }
        } else warn("XFA - No medium specified in pageArea: please file a bug.");
        return this[mg]({ filter: /* @__PURE__ */ new Set(["area", "draw", "field", "subform"]), include: true }), this[mg]({ filter: /* @__PURE__ */ new Set(["contentArea"]), include: true }), HTMLResult.success({ name: "div", children: e3, attributes: { class: ["xfaPage"], id: this[Nc], style: t3, xfaName: this.name } });
      }
    };
    PageSet = class _PageSet extends XFAObject {
      constructor(e3) {
        super(Ih, "pageSet", true), this.duplexImposition = getStringOption(e3.duplexImposition, ["longEdge", "shortEdge"]), this.id = e3.id || "", this.name = e3.name || "", this.relation = getStringOption(e3.relation, ["orderedOccurrence", "duplexPaginated", "simplexPaginated"]), this.relevant = getRelevant(e3.relevant), this.use = e3.use || "", this.usehref = e3.usehref || "", this.extras = null, this.occur = null, this.pageArea = new XFAObjectArray(), this.pageSet = new XFAObjectArray();
      }
      [wg]() {
        for (const e3 of this.pageArea.children) e3[wg]();
        for (const e3 of this.pageSet.children) e3[wg]();
      }
      [oc]() {
        return !this.occur || -1 === this.occur.max || this[xg].numberOfUse < this.occur.max;
      }
      [qg]() {
        if (this[xg] || (this[xg] = { numberOfUse: 1, pageIndex: -1, pageSetIndex: -1 }), "orderedOccurrence" === this.relation) {
          if (this[xg].pageIndex + 1 < this.pageArea.children.length) {
            this[xg].pageIndex += 1;
            return this.pageArea.children[this[xg].pageIndex][qg]();
          }
          if (this[xg].pageSetIndex + 1 < this.pageSet.children.length) return this[xg].pageSetIndex += 1, this.pageSet.children[this[xg].pageSetIndex][qg]();
          if (this[oc]()) return this[xg].numberOfUse += 1, this[xg].pageIndex = -1, this[xg].pageSetIndex = -1, this[qg]();
          const e4 = this[Wg]();
          return e4 instanceof _PageSet ? e4[qg]() : (this[wg](), this[qg]());
        }
        const e3 = this[jg]()[xg].pageNumber, t3 = e3 % 2 == 0 ? "even" : "odd", i3 = 0 === e3 ? "first" : "rest";
        let a3 = this.pageArea.children.find((e4) => e4.oddOrEven === t3 && e4.pagePosition === i3);
        return a3 || (a3 = this.pageArea.children.find((e4) => "any" === e4.oddOrEven && e4.pagePosition === i3), a3 || (a3 = this.pageArea.children.find((e4) => "any" === e4.oddOrEven && "any" === e4.pagePosition), a3 || this.pageArea.children[0]));
      }
    };
    Para = class extends XFAObject {
      constructor(e3) {
        super(Ih, "para", true), this.hAlign = getStringOption(e3.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = e3.id || "", this.lineHeight = e3.lineHeight ? getMeasurement(e3.lineHeight, "0pt") : "", this.marginLeft = e3.marginLeft ? getMeasurement(e3.marginLeft, "0pt") : "", this.marginRight = e3.marginRight ? getMeasurement(e3.marginRight, "0pt") : "", this.orphans = getInteger({ data: e3.orphans, defaultValue: 0, validate: (e4) => e4 >= 0 }), this.preserve = e3.preserve || "", this.radixOffset = e3.radixOffset ? getMeasurement(e3.radixOffset, "0pt") : "", this.spaceAbove = e3.spaceAbove ? getMeasurement(e3.spaceAbove, "0pt") : "", this.spaceBelow = e3.spaceBelow ? getMeasurement(e3.spaceBelow, "0pt") : "", this.tabDefault = e3.tabDefault ? getMeasurement(this.tabDefault) : "", this.tabStops = (e3.tabStops || "").trim().split(/\s+/).map((e4, t3) => t3 % 2 == 1 ? getMeasurement(e4) : e4), this.textIndent = e3.textIndent ? getMeasurement(e3.textIndent, "0pt") : "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.vAlign = getStringOption(e3.vAlign, ["top", "bottom", "middle"]), this.widows = getInteger({ data: e3.widows, defaultValue: 0, validate: (e4) => e4 >= 0 }), this.hyphenation = null;
      }
      [xc]() {
        const e3 = toStyle(this, "hAlign");
        return "" !== this.marginLeft && (e3.paddingLeft = measureToString(this.marginLeft)), "" !== this.marginRight && (e3.paddingight = measureToString(this.marginRight)), "" !== this.spaceAbove && (e3.paddingTop = measureToString(this.spaceAbove)), "" !== this.spaceBelow && (e3.paddingBottom = measureToString(this.spaceBelow)), "" !== this.textIndent && (e3.textIndent = measureToString(this.textIndent), fixTextIndent(e3)), this.lineHeight > 0 && (e3.lineHeight = measureToString(this.lineHeight)), "" !== this.tabDefault && (e3.tabSize = measureToString(this.tabDefault)), this.tabStops.length, this.hyphenatation && Object.assign(e3, this.hyphenatation[xc]()), e3;
      }
    };
    PasswordEdit = class extends XFAObject {
      constructor(e3) {
        super(Ih, "passwordEdit", true), this.hScrollPolicy = getStringOption(e3.hScrollPolicy, ["auto", "off", "on"]), this.id = e3.id || "", this.passwordChar = e3.passwordChar || "*", this.use = e3.use || "", this.usehref = e3.usehref || "", this.border = null, this.extras = null, this.margin = null;
      }
    };
    template_Pattern = class extends XFAObject {
      constructor(e3) {
        super(Ih, "pattern", true), this.id = e3.id || "", this.type = getStringOption(e3.type, ["crossHatch", "crossDiagonal", "diagonalLeft", "diagonalRight", "horizontal", "vertical"]), this.use = e3.use || "", this.usehref = e3.usehref || "", this.color = null, this.extras = null;
      }
      [xc](e3) {
        e3 = e3 ? e3[xc]() : "#FFFFFF";
        const t3 = this.color ? this.color[xc]() : "#000000", i3 = "repeating-linear-gradient", a3 = `${e3},${e3} 5px,${t3} 5px,${t3} 10px`;
        switch (this.type) {
          case "crossHatch":
            return `${i3}(to top,${a3}) ${i3}(to right,${a3})`;
          case "crossDiagonal":
            return `${i3}(45deg,${a3}) ${i3}(-45deg,${a3})`;
          case "diagonalLeft":
            return `${i3}(45deg,${a3})`;
          case "diagonalRight":
            return `${i3}(-45deg,${a3})`;
          case "horizontal":
            return `${i3}(to top,${a3})`;
          case "vertical":
            return `${i3}(to right,${a3})`;
        }
        return "";
      }
    };
    Picture = class extends StringObject {
      constructor(e3) {
        super(Ih, "picture"), this.id = e3.id || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    Proto = class extends XFAObject {
      constructor(e3) {
        super(Ih, "proto", true), this.appearanceFilter = new XFAObjectArray(), this.arc = new XFAObjectArray(), this.area = new XFAObjectArray(), this.assist = new XFAObjectArray(), this.barcode = new XFAObjectArray(), this.bindItems = new XFAObjectArray(), this.bookend = new XFAObjectArray(), this.boolean = new XFAObjectArray(), this.border = new XFAObjectArray(), this.break = new XFAObjectArray(), this.breakAfter = new XFAObjectArray(), this.breakBefore = new XFAObjectArray(), this.button = new XFAObjectArray(), this.calculate = new XFAObjectArray(), this.caption = new XFAObjectArray(), this.certificate = new XFAObjectArray(), this.certificates = new XFAObjectArray(), this.checkButton = new XFAObjectArray(), this.choiceList = new XFAObjectArray(), this.color = new XFAObjectArray(), this.comb = new XFAObjectArray(), this.connect = new XFAObjectArray(), this.contentArea = new XFAObjectArray(), this.corner = new XFAObjectArray(), this.date = new XFAObjectArray(), this.dateTime = new XFAObjectArray(), this.dateTimeEdit = new XFAObjectArray(), this.decimal = new XFAObjectArray(), this.defaultUi = new XFAObjectArray(), this.desc = new XFAObjectArray(), this.digestMethod = new XFAObjectArray(), this.digestMethods = new XFAObjectArray(), this.draw = new XFAObjectArray(), this.edge = new XFAObjectArray(), this.encoding = new XFAObjectArray(), this.encodings = new XFAObjectArray(), this.encrypt = new XFAObjectArray(), this.encryptData = new XFAObjectArray(), this.encryption = new XFAObjectArray(), this.encryptionMethod = new XFAObjectArray(), this.encryptionMethods = new XFAObjectArray(), this.event = new XFAObjectArray(), this.exData = new XFAObjectArray(), this.exObject = new XFAObjectArray(), this.exclGroup = new XFAObjectArray(), this.execute = new XFAObjectArray(), this.extras = new XFAObjectArray(), this.field = new XFAObjectArray(), this.fill = new XFAObjectArray(), this.filter = new XFAObjectArray(), this.float = new XFAObjectArray(), this.font = new XFAObjectArray(), this.format = new XFAObjectArray(), this.handler = new XFAObjectArray(), this.hyphenation = new XFAObjectArray(), this.image = new XFAObjectArray(), this.imageEdit = new XFAObjectArray(), this.integer = new XFAObjectArray(), this.issuers = new XFAObjectArray(), this.items = new XFAObjectArray(), this.keep = new XFAObjectArray(), this.keyUsage = new XFAObjectArray(), this.line = new XFAObjectArray(), this.linear = new XFAObjectArray(), this.lockDocument = new XFAObjectArray(), this.manifest = new XFAObjectArray(), this.margin = new XFAObjectArray(), this.mdp = new XFAObjectArray(), this.medium = new XFAObjectArray(), this.message = new XFAObjectArray(), this.numericEdit = new XFAObjectArray(), this.occur = new XFAObjectArray(), this.oid = new XFAObjectArray(), this.oids = new XFAObjectArray(), this.overflow = new XFAObjectArray(), this.pageArea = new XFAObjectArray(), this.pageSet = new XFAObjectArray(), this.para = new XFAObjectArray(), this.passwordEdit = new XFAObjectArray(), this.pattern = new XFAObjectArray(), this.picture = new XFAObjectArray(), this.radial = new XFAObjectArray(), this.reason = new XFAObjectArray(), this.reasons = new XFAObjectArray(), this.rectangle = new XFAObjectArray(), this.ref = new XFAObjectArray(), this.script = new XFAObjectArray(), this.setProperty = new XFAObjectArray(), this.signData = new XFAObjectArray(), this.signature = new XFAObjectArray(), this.signing = new XFAObjectArray(), this.solid = new XFAObjectArray(), this.speak = new XFAObjectArray(), this.stipple = new XFAObjectArray(), this.subform = new XFAObjectArray(), this.subformSet = new XFAObjectArray(), this.subjectDN = new XFAObjectArray(), this.subjectDNs = new XFAObjectArray(), this.submit = new XFAObjectArray(), this.text = new XFAObjectArray(), this.textEdit = new XFAObjectArray(), this.time = new XFAObjectArray(), this.timeStamp = new XFAObjectArray(), this.toolTip = new XFAObjectArray(), this.traversal = new XFAObjectArray(), this.traverse = new XFAObjectArray(), this.ui = new XFAObjectArray(), this.validate = new XFAObjectArray(), this.value = new XFAObjectArray(), this.variables = new XFAObjectArray();
      }
    };
    Radial = class extends XFAObject {
      constructor(e3) {
        super(Ih, "radial", true), this.id = e3.id || "", this.type = getStringOption(e3.type, ["toEdge", "toCenter"]), this.use = e3.use || "", this.usehref = e3.usehref || "", this.color = null, this.extras = null;
      }
      [xc](e3) {
        e3 = e3 ? e3[xc]() : "#FFFFFF";
        const t3 = this.color ? this.color[xc]() : "#000000";
        return `radial-gradient(circle at center, ${"toEdge" === this.type ? `${e3},${t3}` : `${t3},${e3}`})`;
      }
    };
    Reason = class extends StringObject {
      constructor(e3) {
        super(Ih, "reason"), this.id = e3.id || "", this.name = e3.name || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    Reasons = class extends XFAObject {
      constructor(e3) {
        super(Ih, "reasons", true), this.id = e3.id || "", this.type = getStringOption(e3.type, ["optional", "required"]), this.use = e3.use || "", this.usehref = e3.usehref || "", this.reason = new XFAObjectArray();
      }
    };
    Rectangle = class extends XFAObject {
      constructor(e3) {
        super(Ih, "rectangle", true), this.hand = getStringOption(e3.hand, ["even", "left", "right"]), this.id = e3.id || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.corner = new XFAObjectArray(4), this.edge = new XFAObjectArray(4), this.fill = null;
      }
      [kc]() {
        const e3 = this.edge.children.length ? this.edge.children[0] : new Edge({}), t3 = e3[xc](), i3 = /* @__PURE__ */ Object.create(null);
        "visible" === this.fill?.presence ? Object.assign(i3, this.fill[xc]()) : i3.fill = "transparent", i3.strokeWidth = measureToString("visible" === e3.presence ? e3.thickness : 0), i3.stroke = t3.color;
        const a3 = (this.corner.children.length ? this.corner.children[0] : new Corner({}))[xc](), s3 = { name: "svg", children: [{ name: "rect", attributes: { xmlns: Ch, width: "100%", height: "100%", x: 0, y: 0, rx: a3.radius, ry: a3.radius, style: i3 } }], attributes: { xmlns: Ch, style: { overflow: "visible" }, width: "100%", height: "100%" } };
        return hasMargin(this[Wg]()[Wg]()) ? HTMLResult.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [s3] }) : (s3.attributes.style.position = "absolute", HTMLResult.success(s3));
      }
    };
    RefElement = class extends StringObject {
      constructor(e3) {
        super(Ih, "ref"), this.id = e3.id || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    Script = class extends StringObject {
      constructor(e3) {
        super(Ih, "script"), this.binding = e3.binding || "", this.contentType = e3.contentType || "", this.id = e3.id || "", this.name = e3.name || "", this.runAt = getStringOption(e3.runAt, ["client", "both", "server"]), this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    SetProperty = class extends XFAObject {
      constructor(e3) {
        super(Ih, "setProperty"), this.connection = e3.connection || "", this.ref = e3.ref || "", this.target = e3.target || "";
      }
    };
    SignData = class extends XFAObject {
      constructor(e3) {
        super(Ih, "signData", true), this.id = e3.id || "", this.operation = getStringOption(e3.operation, ["sign", "clear", "verify"]), this.ref = e3.ref || "", this.target = e3.target || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.filter = null, this.manifest = null;
      }
    };
    Signature = class extends XFAObject {
      constructor(e3) {
        super(Ih, "signature", true), this.id = e3.id || "", this.type = getStringOption(e3.type, ["PDF1.3", "PDF1.6"]), this.use = e3.use || "", this.usehref = e3.usehref || "", this.border = null, this.extras = null, this.filter = null, this.manifest = null, this.margin = null;
      }
    };
    Signing = class extends XFAObject {
      constructor(e3) {
        super(Ih, "signing", true), this.id = e3.id || "", this.type = getStringOption(e3.type, ["optional", "required"]), this.use = e3.use || "", this.usehref = e3.usehref || "", this.certificate = new XFAObjectArray();
      }
    };
    Solid = class extends XFAObject {
      constructor(e3) {
        super(Ih, "solid", true), this.id = e3.id || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.extras = null;
      }
      [xc](e3) {
        return e3 ? e3[xc]() : "#FFFFFF";
      }
    };
    Speak = class extends StringObject {
      constructor(e3) {
        super(Ih, "speak"), this.disable = getInteger({ data: e3.disable, defaultValue: 0, validate: (e4) => 1 === e4 }), this.id = e3.id || "", this.priority = getStringOption(e3.priority, ["custom", "caption", "name", "toolTip"]), this.rid = e3.rid || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    Stipple = class extends XFAObject {
      constructor(e3) {
        super(Ih, "stipple", true), this.id = e3.id || "", this.rate = getInteger({ data: e3.rate, defaultValue: 50, validate: (e4) => e4 >= 0 && e4 <= 100 }), this.use = e3.use || "", this.usehref = e3.usehref || "", this.color = null, this.extras = null;
      }
      [xc](e3) {
        const t3 = this.rate / 100;
        return Util.makeHexColor(Math.round(e3.value.r * (1 - t3) + this.value.r * t3), Math.round(e3.value.g * (1 - t3) + this.value.g * t3), Math.round(e3.value.b * (1 - t3) + this.value.b * t3));
      }
    };
    Subform = class extends XFAObject {
      constructor(e3) {
        super(Ih, "subform", true), this.access = getStringOption(e3.access, ["open", "nonInteractive", "protected", "readOnly"]), this.allowMacro = getInteger({ data: e3.allowMacro, defaultValue: 0, validate: (e4) => 1 === e4 }), this.anchorType = getStringOption(e3.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = getInteger({ data: e3.colSpan, defaultValue: 1, validate: (e4) => e4 >= 1 || -1 === e4 }), this.columnWidths = (e3.columnWidths || "").trim().split(/\s+/).map((e4) => "-1" === e4 ? -1 : getMeasurement(e4)), this.h = e3.h ? getMeasurement(e3.h) : "", this.hAlign = getStringOption(e3.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = e3.id || "", this.layout = getStringOption(e3.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]), this.locale = e3.locale || "", this.maxH = getMeasurement(e3.maxH, "0pt"), this.maxW = getMeasurement(e3.maxW, "0pt"), this.mergeMode = getStringOption(e3.mergeMode, ["consumeData", "matchTemplate"]), this.minH = getMeasurement(e3.minH, "0pt"), this.minW = getMeasurement(e3.minW, "0pt"), this.name = e3.name || "", this.presence = getStringOption(e3.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = getRelevant(e3.relevant), this.restoreState = getStringOption(e3.restoreState, ["manual", "auto"]), this.scope = getStringOption(e3.scope, ["name", "none"]), this.use = e3.use || "", this.usehref = e3.usehref || "", this.w = e3.w ? getMeasurement(e3.w) : "", this.x = getMeasurement(e3.x, "0pt"), this.y = getMeasurement(e3.y, "0pt"), this.assist = null, this.bind = null, this.bookend = null, this.border = null, this.break = null, this.calculate = null, this.desc = null, this.extras = null, this.keep = null, this.margin = null, this.occur = null, this.overflow = null, this.pageSet = null, this.para = null, this.traversal = null, this.validate = null, this.variables = null, this.area = new XFAObjectArray(), this.breakAfter = new XFAObjectArray(), this.breakBefore = new XFAObjectArray(), this.connect = new XFAObjectArray(), this.draw = new XFAObjectArray(), this.event = new XFAObjectArray(), this.exObject = new XFAObjectArray(), this.exclGroup = new XFAObjectArray(), this.field = new XFAObjectArray(), this.proto = new XFAObjectArray(), this.setProperty = new XFAObjectArray(), this.subform = new XFAObjectArray(), this.subformSet = new XFAObjectArray();
      }
      [_g2]() {
        const e3 = this[Wg]();
        return e3 instanceof SubformSet ? e3[_g2]() : e3;
      }
      [tc]() {
        return true;
      }
      [nc]() {
        return this.layout.endsWith("-tb") && 0 === this[xg].attempt && this[xg].numberInLine > 0 || this[Wg]()[nc]();
      }
      *[Kg]() {
        yield* getContainedChildren(this);
      }
      [Mg]() {
        return flushHTML(this);
      }
      [fg](e3, t3) {
        addHTML(this, e3, t3);
      }
      [Lg]() {
        return getAvailableSpace(this);
      }
      [sc]() {
        const e3 = this[_g2]();
        return !!e3[sc]() && (void 0 !== this[xg]._isSplittable ? this[xg]._isSplittable : "position" === this.layout || this.layout.includes("row") || this.keep && "none" !== this.keep.intact ? (this[xg]._isSplittable = false, false) : (!e3.layout?.endsWith("-tb") || 0 === e3[xg].numberInLine) && (this[xg]._isSplittable = true, true));
      }
      [kc](e3) {
        if (setTabIndex(this), this.break) {
          if ("auto" !== this.break.after || "" !== this.break.afterTarget) {
            const e4 = new BreakAfter({ targetType: this.break.after, target: this.break.afterTarget, startNew: this.break.startNew.toString() });
            e4[Xg] = this[Xg], this[pg](e4), this.breakAfter.push(e4);
          }
          if ("auto" !== this.break.before || "" !== this.break.beforeTarget) {
            const e4 = new BreakBefore({ targetType: this.break.before, target: this.break.beforeTarget, startNew: this.break.startNew.toString() });
            e4[Xg] = this[Xg], this[pg](e4), this.breakBefore.push(e4);
          }
          if ("" !== this.break.overflowTarget) {
            const e4 = new Overflow({ target: this.break.overflowTarget, leader: this.break.overflowLeader, trailer: this.break.overflowTrailer });
            e4[Xg] = this[Xg], this[pg](e4), this.overflow.push(e4);
          }
          this[Ec](this.break), this.break = null;
        }
        if ("hidden" === this.presence || "inactive" === this.presence) return HTMLResult.EMPTY;
        if ((this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) && warn("XFA - Several breakBefore or breakAfter in subforms: please file a bug."), this.breakBefore.children.length >= 1) {
          const e4 = this.breakBefore.children[0];
          if (handleBreak(e4)) return HTMLResult.breakNode(e4);
        }
        if (this[xg]?.afterBreakAfter) return HTMLResult.EMPTY;
        fixDimensions(this);
        const t3 = [], i3 = { id: this[Nc], class: [] };
        setAccess(this, i3.class), this[xg] || (this[xg] = /* @__PURE__ */ Object.create(null)), Object.assign(this[xg], { children: t3, line: null, attributes: i3, attempt: 0, numberInLine: 0, availableSpace: { width: Math.min(this.w || 1 / 0, e3.width), height: Math.min(this.h || 1 / 0, e3.height) }, width: 0, height: 0, prevHeight: 0, currentWidth: 0 });
        const a3 = this[jg](), s3 = a3[xg].noLayoutFailure, n3 = this[sc]();
        if (n3 || setFirstUnsplittable(this), !checkDimensions(this, e3)) return HTMLResult.FAILURE;
        const r3 = /* @__PURE__ */ new Set(["area", "draw", "exclGroup", "field", "subform", "subformSet"]);
        if (this.layout.includes("row")) {
          const e4 = this[_g2]().columnWidths;
          Array.isArray(e4) && e4.length > 0 && (this[xg].columnWidths = e4, this[xg].currentColumn = 0);
        }
        const o3 = toStyle(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), g3 = ["xfaSubform"], c3 = layoutClass(this);
        if (c3 && g3.push(c3), i3.style = o3, i3.class = g3, this.name && (i3.xfaName = this.name), this.overflow) {
          const t4 = this.overflow[Yg]();
          t4.addLeader && (t4.addLeader = false, handleOverflow(this, t4.leader, e3));
        }
        this[Qc]();
        const h3 = "lr-tb" === this.layout || "rl-tb" === this.layout, l3 = h3 ? 2 : 1;
        for (; this[xg].attempt < l3; this[xg].attempt++) {
          h3 && 1 === this[xg].attempt && (this[xg].numberInLine = 0);
          const e4 = this[mg]({ filter: r3, include: true });
          if (e4.success) break;
          if (e4.isBreak()) return this[uc](), e4;
          if (h3 && 0 === this[xg].attempt && 0 === this[xg].numberInLine && !a3[xg].noLayoutFailure) {
            this[xg].attempt = l3;
            break;
          }
        }
        if (this[uc](), n3 || unsetFirstUnsplittable(this), a3[xg].noLayoutFailure = s3, this[xg].attempt === l3) return this.overflow && (this[jg]()[xg].overflowNode = this.overflow), n3 || delete this[xg], HTMLResult.FAILURE;
        if (this.overflow) {
          const t4 = this.overflow[Yg]();
          t4.addTrailer && (t4.addTrailer = false, handleOverflow(this, t4.trailer, e3));
        }
        let C3 = 0, d3 = 0;
        this.margin && (C3 = this.margin.leftInset + this.margin.rightInset, d3 = this.margin.topInset + this.margin.bottomInset);
        const u3 = Math.max(this[xg].width + C3, this.w || 0), Q3 = Math.max(this[xg].height + d3, this.h || 0), f3 = [this.x, this.y, u3, Q3];
        if ("" === this.w && (o3.width = measureToString(u3)), "" === this.h && (o3.height = measureToString(Q3)), ("0px" === o3.width || "0px" === o3.height) && 0 === t3.length) return HTMLResult.EMPTY;
        const p3 = { name: "div", attributes: i3, children: t3 };
        applyAssist(this, i3);
        const m3 = HTMLResult.success(createWrapper(this, p3), f3);
        if (this.breakAfter.children.length >= 1) {
          const e4 = this.breakAfter.children[0];
          if (handleBreak(e4)) return this[xg].afterBreakAfter = m3, HTMLResult.breakNode(e4);
        }
        return delete this[xg], m3;
      }
    };
    SubformSet = class extends XFAObject {
      constructor(e3) {
        super(Ih, "subformSet", true), this.id = e3.id || "", this.name = e3.name || "", this.relation = getStringOption(e3.relation, ["ordered", "choice", "unordered"]), this.relevant = getRelevant(e3.relevant), this.use = e3.use || "", this.usehref = e3.usehref || "", this.bookend = null, this.break = null, this.desc = null, this.extras = null, this.occur = null, this.overflow = null, this.breakAfter = new XFAObjectArray(), this.breakBefore = new XFAObjectArray(), this.subform = new XFAObjectArray(), this.subformSet = new XFAObjectArray();
      }
      *[Kg]() {
        yield* getContainedChildren(this);
      }
      [_g2]() {
        let e3 = this[Wg]();
        for (; !(e3 instanceof Subform); ) e3 = e3[Wg]();
        return e3;
      }
      [tc]() {
        return true;
      }
    };
    SubjectDN = class extends ContentObject {
      constructor(e3) {
        super(Ih, "subjectDN"), this.delimiter = e3.delimiter || ",", this.id = e3.id || "", this.name = e3.name || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
      [Ng]() {
        this[Fg] = new Map(this[Fg].split(this.delimiter).map((e3) => ((e3 = e3.split("=", 2))[0] = e3[0].trim(), e3)));
      }
    };
    SubjectDNs = class extends XFAObject {
      constructor(e3) {
        super(Ih, "subjectDNs", true), this.id = e3.id || "", this.type = getStringOption(e3.type, ["optional", "required"]), this.use = e3.use || "", this.usehref = e3.usehref || "", this.subjectDN = new XFAObjectArray();
      }
    };
    Submit = class extends XFAObject {
      constructor(e3) {
        super(Ih, "submit", true), this.embedPDF = getInteger({ data: e3.embedPDF, defaultValue: 0, validate: (e4) => 1 === e4 }), this.format = getStringOption(e3.format, ["xdp", "formdata", "pdf", "urlencoded", "xfd", "xml"]), this.id = e3.id || "", this.target = e3.target || "", this.textEncoding = getKeyword({ data: e3.textEncoding ? e3.textEncoding.toLowerCase() : "", defaultValue: "", validate: (e4) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(e4) || e4.match(/iso-8859-\d{2}/) }), this.use = e3.use || "", this.usehref = e3.usehref || "", this.xdpContent = e3.xdpContent || "", this.encrypt = null, this.encryptData = new XFAObjectArray(), this.signData = new XFAObjectArray();
      }
    };
    Template = class extends XFAObject {
      constructor(e3) {
        super(Ih, "template", true), this.baseProfile = getStringOption(e3.baseProfile, ["full", "interactiveForms"]), this.extras = null, this.subform = new XFAObjectArray();
      }
      [Ng]() {
        0 === this.subform.children.length && warn("XFA - No subforms in template node."), this.subform.children.length >= 2 && warn("XFA - Several subforms in template node: please file a bug."), this[Dc] = 5e3;
      }
      [sc]() {
        return true;
      }
      [mc](e3, t3) {
        return e3.startsWith("#") ? [this[Zg].get(e3.slice(1))] : searchNode(this, t3, e3, true, true);
      }
      *[Fc]() {
        if (!this.subform.children.length) return HTMLResult.success({ name: "div", children: [] });
        this[xg] = { overflowNode: null, firstUnsplittable: null, currentContentArea: null, currentPageArea: null, noLayoutFailure: false, pageNumber: 1, pagePosition: "first", oddOrEven: "odd", blankOrNotBlank: "nonBlank", paraStack: [] };
        const e3 = this.subform.children[0];
        e3.pageSet[wg]();
        const t3 = e3.pageSet.pageArea.children, i3 = { name: "div", children: [] };
        let a3 = null, s3 = null, n3 = null;
        if (e3.breakBefore.children.length >= 1 ? (s3 = e3.breakBefore.children[0], n3 = s3.target) : e3.subform.children.length >= 1 && e3.subform.children[0].breakBefore.children.length >= 1 ? (s3 = e3.subform.children[0].breakBefore.children[0], n3 = s3.target) : e3.break?.beforeTarget ? (s3 = e3.break, n3 = s3.beforeTarget) : e3.subform.children.length >= 1 && e3.subform.children[0].break?.beforeTarget && (s3 = e3.subform.children[0].break, n3 = s3.beforeTarget), s3) {
          const e4 = this[mc](n3, s3[Wg]());
          e4 instanceof PageArea && (a3 = e4, s3[xg] = {});
        }
        a3 || (a3 = t3[0]), a3[xg] = { numberOfUse: 1 };
        const r3 = a3[Wg]();
        let o3;
        r3[xg] = { numberOfUse: 1, pageIndex: r3.pageArea.children.indexOf(a3), pageSetIndex: 0 };
        let g3 = null, c3 = null, h3 = true, l3 = 0, C3 = 0;
        for (; ; ) {
          if (h3) l3 = 0;
          else if (i3.children.pop(), 3 == ++l3) return warn("XFA - Something goes wrong: please file a bug."), i3;
          o3 = null, this[xg].currentPageArea = a3;
          const t4 = a3[kc]().html;
          i3.children.push(t4), g3 && (this[xg].noLayoutFailure = true, t4.children.push(g3[kc](a3[xg].space).html), g3 = null), c3 && (this[xg].noLayoutFailure = true, t4.children.push(c3[kc](a3[xg].space).html), c3 = null);
          const s4 = a3.contentArea.children, n4 = t4.children.filter((e4) => e4.attributes.class.includes("xfaContentarea"));
          h3 = false, this[xg].firstUnsplittable = null, this[xg].noLayoutFailure = false;
          const flush = (t5) => {
            const i4 = e3[Mg]();
            i4 && (h3 || (h3 = i4.children?.length > 0), n4[t5].children.push(i4));
          };
          for (let t5 = C3, a4 = s4.length; t5 < a4; t5++) {
            const a5 = this[xg].currentContentArea = s4[t5], r4 = { width: a5.w, height: a5.h };
            C3 = 0, g3 && (n4[t5].children.push(g3[kc](r4).html), g3 = null), c3 && (n4[t5].children.push(c3[kc](r4).html), c3 = null);
            const l4 = e3[kc](r4);
            if (l4.success) return l4.html ? (h3 || (h3 = l4.html.children?.length > 0), n4[t5].children.push(l4.html)) : !h3 && i3.children.length > 1 && i3.children.pop(), i3;
            if (l4.isBreak()) {
              const e4 = l4.breakNode;
              if (flush(t5), "auto" === e4.targetType) continue;
              e4.leader && (g3 = this[mc](e4.leader, e4[Wg]()), g3 = g3 ? g3[0] : null), e4.trailer && (c3 = this[mc](e4.trailer, e4[Wg]()), c3 = c3 ? c3[0] : null), "pageArea" === e4.targetType ? (o3 = e4[xg].target, t5 = 1 / 0) : e4[xg].target ? (o3 = e4[xg].target, C3 = e4[xg].index + 1, t5 = 1 / 0) : t5 = e4[xg].index;
            } else if (this[xg].overflowNode) {
              const e4 = this[xg].overflowNode;
              this[xg].overflowNode = null;
              const i4 = e4[Yg](), a6 = i4.target;
              i4.addLeader = null !== i4.leader, i4.addTrailer = null !== i4.trailer, flush(t5);
              const n5 = t5;
              if (t5 = 1 / 0, a6 instanceof PageArea) o3 = a6;
              else if (a6 instanceof ContentArea) {
                const e5 = s4.indexOf(a6);
                -1 !== e5 ? e5 > n5 ? t5 = e5 - 1 : C3 = e5 : (o3 = a6[Wg](), C3 = o3.contentArea.children.indexOf(a6));
              }
            } else flush(t5);
          }
          this[xg].pageNumber += 1, o3 && (o3[oc]() ? o3[xg].numberOfUse += 1 : o3 = null), a3 = o3 || a3[qg](), yield null;
        }
      }
    };
    Text = class extends ContentObject {
      constructor(e3) {
        super(Ih, "text"), this.id = e3.id || "", this.maxChars = getInteger({ data: e3.maxChars, defaultValue: 0, validate: (e4) => e4 >= 0 }), this.name = e3.name || "", this.rid = e3.rid || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
      [Eg]() {
        return true;
      }
      [Ic](e3) {
        return e3[cc] === Gc.xhtml.id ? (this[Fg] = e3, true) : (warn(`XFA - Invalid content in Text: ${e3[hc]}.`), false);
      }
      [dc](e3) {
        this[Fg] instanceof XFAObject || super[dc](e3);
      }
      [Ng]() {
        "string" == typeof this[Fg] && (this[Fg] = this[Fg].replaceAll("\r\n", "\n"));
      }
      [Yg]() {
        return "string" == typeof this[Fg] ? this[Fg].split(/[\u2029\u2028\n]/).reduce((e3, t3) => (t3 && e3.push(t3), e3), []).join("\n") : this[Fg][Sc]();
      }
      [kc](e3) {
        if ("string" == typeof this[Fg]) {
          const e4 = valueToHtml(this[Fg]).html;
          return this[Fg].includes("\u2029") ? (e4.name = "div", e4.children = [], this[Fg].split("\u2029").map((e5) => e5.split(/[\u2028\n]/).reduce((e6, t3) => (e6.push({ name: "span", value: t3 }, { name: "br" }), e6), [])).forEach((t3) => {
            e4.children.push({ name: "p", children: t3 });
          })) : /[\u2028\n]/.test(this[Fg]) && (e4.name = "div", e4.children = [], this[Fg].split(/[\u2028\n]/).forEach((t3) => {
            e4.children.push({ name: "span", value: t3 }, { name: "br" });
          })), HTMLResult.success(e4);
        }
        return this[Fg][kc](e3);
      }
    };
    TextEdit = class extends XFAObject {
      constructor(e3) {
        super(Ih, "textEdit", true), this.allowRichText = getInteger({ data: e3.allowRichText, defaultValue: 0, validate: (e4) => 1 === e4 }), this.hScrollPolicy = getStringOption(e3.hScrollPolicy, ["auto", "off", "on"]), this.id = e3.id || "", this.multiLine = getInteger({ data: e3.multiLine, defaultValue: "", validate: (e4) => 0 === e4 || 1 === e4 }), this.use = e3.use || "", this.usehref = e3.usehref || "", this.vScrollPolicy = getStringOption(e3.vScrollPolicy, ["auto", "off", "on"]), this.border = null, this.comb = null, this.extras = null, this.margin = null;
      }
      [kc](e3) {
        const t3 = toStyle(this, "border", "font", "margin");
        let i3;
        const a3 = this[Wg]()[Wg]();
        return "" === this.multiLine && (this.multiLine = a3 instanceof Draw ? 1 : 0), i3 = 1 === this.multiLine ? { name: "textarea", attributes: { dataId: a3[kg]?.[Nc] || a3[Nc], fieldId: a3[Nc], class: ["xfaTextfield"], style: t3, "aria-label": ariaLabel(a3), "aria-required": false } } : { name: "input", attributes: { type: "text", dataId: a3[kg]?.[Nc] || a3[Nc], fieldId: a3[Nc], class: ["xfaTextfield"], style: t3, "aria-label": ariaLabel(a3), "aria-required": false } }, isRequired(a3) && (i3.attributes["aria-required"] = true, i3.attributes.required = true), HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [i3] });
      }
    };
    Time = class extends StringObject {
      constructor(e3) {
        super(Ih, "time"), this.id = e3.id || "", this.name = e3.name || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
      [Ng]() {
        const e3 = this[Fg].trim();
        this[Fg] = e3 ? new Date(e3) : null;
      }
      [kc](e3) {
        return valueToHtml(this[Fg] ? this[Fg].toString() : "");
      }
    };
    TimeStamp = class extends XFAObject {
      constructor(e3) {
        super(Ih, "timeStamp"), this.id = e3.id || "", this.server = e3.server || "", this.type = getStringOption(e3.type, ["optional", "required"]), this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    ToolTip = class extends StringObject {
      constructor(e3) {
        super(Ih, "toolTip"), this.id = e3.id || "", this.rid = e3.rid || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    Traversal = class extends XFAObject {
      constructor(e3) {
        super(Ih, "traversal", true), this.id = e3.id || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.extras = null, this.traverse = new XFAObjectArray();
      }
    };
    Traverse = class extends XFAObject {
      constructor(e3) {
        super(Ih, "traverse", true), this.id = e3.id || "", this.operation = getStringOption(e3.operation, ["next", "back", "down", "first", "left", "right", "up"]), this.ref = e3.ref || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.extras = null, this.script = null;
      }
      get name() {
        return this.operation;
      }
      [rc]() {
        return false;
      }
    };
    Ui = class extends XFAObject {
      constructor(e3) {
        super(Ih, "ui", true), this.id = e3.id || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.extras = null, this.picture = null, this.barcode = null, this.button = null, this.checkButton = null, this.choiceList = null, this.dateTimeEdit = null, this.defaultUi = null, this.imageEdit = null, this.numericEdit = null, this.passwordEdit = null, this.signature = null, this.textEdit = null;
      }
      [Yg]() {
        if (void 0 === this[xg]) {
          for (const e3 of Object.getOwnPropertyNames(this)) {
            if ("extras" === e3 || "picture" === e3) continue;
            const t3 = this[e3];
            if (t3 instanceof XFAObject) return this[xg] = t3, t3;
          }
          this[xg] = null;
        }
        return this[xg];
      }
      [kc](e3) {
        const t3 = this[Yg]();
        return t3 ? t3[kc](e3) : HTMLResult.EMPTY;
      }
    };
    Validate = class extends XFAObject {
      constructor(e3) {
        super(Ih, "validate", true), this.formatTest = getStringOption(e3.formatTest, ["warning", "disabled", "error"]), this.id = e3.id || "", this.nullTest = getStringOption(e3.nullTest, ["disabled", "error", "warning"]), this.scriptTest = getStringOption(e3.scriptTest, ["error", "disabled", "warning"]), this.use = e3.use || "", this.usehref = e3.usehref || "", this.extras = null, this.message = null, this.picture = null, this.script = null;
      }
    };
    Value = class extends XFAObject {
      constructor(e3) {
        super(Ih, "value", true), this.id = e3.id || "", this.override = getInteger({ data: e3.override, defaultValue: 0, validate: (e4) => 1 === e4 }), this.relevant = getRelevant(e3.relevant), this.use = e3.use || "", this.usehref = e3.usehref || "", this.arc = null, this.boolean = null, this.date = null, this.dateTime = null, this.decimal = null, this.exData = null, this.float = null, this.image = null, this.integer = null, this.line = null, this.rectangle = null, this.text = null, this.time = null;
      }
      [bc](e3) {
        const t3 = this[Wg]();
        if (t3 instanceof Field && t3.ui?.imageEdit) return this.image || (this.image = new Eh({}), this[pg](this.image)), void (this.image[Fg] = e3[Fg]);
        const i3 = e3[hc];
        if (null === this[i3]) {
          for (const e4 of Object.getOwnPropertyNames(this)) {
            const t4 = this[e4];
            t4 instanceof XFAObject && (this[e4] = null, this[Ec](t4));
          }
          this[e3[hc]] = e3, this[pg](e3);
        } else this[i3][Fg] = e3[Fg];
      }
      [Sc]() {
        if (this.exData) return "string" == typeof this.exData[Fg] ? this.exData[Fg].trim() : this.exData[Fg][Sc]().trim();
        for (const e3 of Object.getOwnPropertyNames(this)) {
          if ("image" === e3) continue;
          const t3 = this[e3];
          if (t3 instanceof XFAObject) return (t3[Fg] || "").toString().trim();
        }
        return null;
      }
      [kc](e3) {
        for (const t3 of Object.getOwnPropertyNames(this)) {
          const i3 = this[t3];
          if (i3 instanceof XFAObject) return i3[kc](e3);
        }
        return HTMLResult.EMPTY;
      }
    };
    Variables = class extends XFAObject {
      constructor(e3) {
        super(Ih, "variables", true), this.id = e3.id || "", this.use = e3.use || "", this.usehref = e3.usehref || "", this.boolean = new XFAObjectArray(), this.date = new XFAObjectArray(), this.dateTime = new XFAObjectArray(), this.decimal = new XFAObjectArray(), this.exData = new XFAObjectArray(), this.float = new XFAObjectArray(), this.image = new XFAObjectArray(), this.integer = new XFAObjectArray(), this.manifest = new XFAObjectArray(), this.script = new XFAObjectArray(), this.text = new XFAObjectArray(), this.time = new XFAObjectArray();
      }
      [rc]() {
        return true;
      }
    };
    TemplateNamespace = class _TemplateNamespace {
      static [Mc](e3, t3) {
        if (_TemplateNamespace.hasOwnProperty(e3)) {
          const i3 = _TemplateNamespace[e3](t3);
          return i3[wc](t3), i3;
        }
      }
      static appearanceFilter(e3) {
        return new AppearanceFilter(e3);
      }
      static arc(e3) {
        return new Arc(e3);
      }
      static area(e3) {
        return new Area(e3);
      }
      static assist(e3) {
        return new Assist(e3);
      }
      static barcode(e3) {
        return new Barcode(e3);
      }
      static bind(e3) {
        return new Bind(e3);
      }
      static bindItems(e3) {
        return new BindItems(e3);
      }
      static bookend(e3) {
        return new Bookend(e3);
      }
      static boolean(e3) {
        return new BooleanElement(e3);
      }
      static border(e3) {
        return new Border(e3);
      }
      static break(e3) {
        return new Break(e3);
      }
      static breakAfter(e3) {
        return new BreakAfter(e3);
      }
      static breakBefore(e3) {
        return new BreakBefore(e3);
      }
      static button(e3) {
        return new Button(e3);
      }
      static calculate(e3) {
        return new Calculate(e3);
      }
      static caption(e3) {
        return new Caption(e3);
      }
      static certificate(e3) {
        return new Certificate(e3);
      }
      static certificates(e3) {
        return new Certificates(e3);
      }
      static checkButton(e3) {
        return new CheckButton(e3);
      }
      static choiceList(e3) {
        return new ChoiceList(e3);
      }
      static color(e3) {
        return new Color(e3);
      }
      static comb(e3) {
        return new Comb(e3);
      }
      static connect(e3) {
        return new Connect(e3);
      }
      static contentArea(e3) {
        return new ContentArea(e3);
      }
      static corner(e3) {
        return new Corner(e3);
      }
      static date(e3) {
        return new DateElement(e3);
      }
      static dateTime(e3) {
        return new DateTime(e3);
      }
      static dateTimeEdit(e3) {
        return new DateTimeEdit(e3);
      }
      static decimal(e3) {
        return new Decimal(e3);
      }
      static defaultUi(e3) {
        return new DefaultUi(e3);
      }
      static desc(e3) {
        return new Desc(e3);
      }
      static digestMethod(e3) {
        return new DigestMethod(e3);
      }
      static digestMethods(e3) {
        return new DigestMethods(e3);
      }
      static draw(e3) {
        return new Draw(e3);
      }
      static edge(e3) {
        return new Edge(e3);
      }
      static encoding(e3) {
        return new Encoding(e3);
      }
      static encodings(e3) {
        return new Encodings(e3);
      }
      static encrypt(e3) {
        return new Encrypt(e3);
      }
      static encryptData(e3) {
        return new EncryptData(e3);
      }
      static encryption(e3) {
        return new Encryption(e3);
      }
      static encryptionMethod(e3) {
        return new EncryptionMethod(e3);
      }
      static encryptionMethods(e3) {
        return new EncryptionMethods(e3);
      }
      static event(e3) {
        return new Qh(e3);
      }
      static exData(e3) {
        return new ExData(e3);
      }
      static exObject(e3) {
        return new ExObject(e3);
      }
      static exclGroup(e3) {
        return new ExclGroup(e3);
      }
      static execute(e3) {
        return new Execute(e3);
      }
      static extras(e3) {
        return new Extras(e3);
      }
      static field(e3) {
        return new Field(e3);
      }
      static fill(e3) {
        return new Fill(e3);
      }
      static filter(e3) {
        return new Filter(e3);
      }
      static float(e3) {
        return new Float(e3);
      }
      static font(e3) {
        return new template_Font(e3);
      }
      static format(e3) {
        return new Format(e3);
      }
      static handler(e3) {
        return new Handler(e3);
      }
      static hyphenation(e3) {
        return new Hyphenation(e3);
      }
      static image(e3) {
        return new Eh(e3);
      }
      static imageEdit(e3) {
        return new ImageEdit(e3);
      }
      static integer(e3) {
        return new Integer(e3);
      }
      static issuers(e3) {
        return new Issuers(e3);
      }
      static items(e3) {
        return new Items(e3);
      }
      static keep(e3) {
        return new Keep(e3);
      }
      static keyUsage(e3) {
        return new KeyUsage(e3);
      }
      static line(e3) {
        return new Line(e3);
      }
      static linear(e3) {
        return new Linear(e3);
      }
      static lockDocument(e3) {
        return new LockDocument(e3);
      }
      static manifest(e3) {
        return new Manifest(e3);
      }
      static margin(e3) {
        return new Margin(e3);
      }
      static mdp(e3) {
        return new Mdp(e3);
      }
      static medium(e3) {
        return new Medium(e3);
      }
      static message(e3) {
        return new Message(e3);
      }
      static numericEdit(e3) {
        return new NumericEdit(e3);
      }
      static occur(e3) {
        return new Occur(e3);
      }
      static oid(e3) {
        return new Oid(e3);
      }
      static oids(e3) {
        return new Oids(e3);
      }
      static overflow(e3) {
        return new Overflow(e3);
      }
      static pageArea(e3) {
        return new PageArea(e3);
      }
      static pageSet(e3) {
        return new PageSet(e3);
      }
      static para(e3) {
        return new Para(e3);
      }
      static passwordEdit(e3) {
        return new PasswordEdit(e3);
      }
      static pattern(e3) {
        return new template_Pattern(e3);
      }
      static picture(e3) {
        return new Picture(e3);
      }
      static proto(e3) {
        return new Proto(e3);
      }
      static radial(e3) {
        return new Radial(e3);
      }
      static reason(e3) {
        return new Reason(e3);
      }
      static reasons(e3) {
        return new Reasons(e3);
      }
      static rectangle(e3) {
        return new Rectangle(e3);
      }
      static ref(e3) {
        return new RefElement(e3);
      }
      static script(e3) {
        return new Script(e3);
      }
      static setProperty(e3) {
        return new SetProperty(e3);
      }
      static signData(e3) {
        return new SignData(e3);
      }
      static signature(e3) {
        return new Signature(e3);
      }
      static signing(e3) {
        return new Signing(e3);
      }
      static solid(e3) {
        return new Solid(e3);
      }
      static speak(e3) {
        return new Speak(e3);
      }
      static stipple(e3) {
        return new Stipple(e3);
      }
      static subform(e3) {
        return new Subform(e3);
      }
      static subformSet(e3) {
        return new SubformSet(e3);
      }
      static subjectDN(e3) {
        return new SubjectDN(e3);
      }
      static subjectDNs(e3) {
        return new SubjectDNs(e3);
      }
      static submit(e3) {
        return new Submit(e3);
      }
      static template(e3) {
        return new Template(e3);
      }
      static text(e3) {
        return new Text(e3);
      }
      static textEdit(e3) {
        return new TextEdit(e3);
      }
      static time(e3) {
        return new Time(e3);
      }
      static timeStamp(e3) {
        return new TimeStamp(e3);
      }
      static toolTip(e3) {
        return new ToolTip(e3);
      }
      static traversal(e3) {
        return new Traversal(e3);
      }
      static traverse(e3) {
        return new Traverse(e3);
      }
      static ui(e3) {
        return new Ui(e3);
      }
      static validate(e3) {
        return new Validate(e3);
      }
      static value(e3) {
        return new Value(e3);
      }
      static variables(e3) {
        return new Variables(e3);
      }
    };
    fh = Gc.datasets.id;
    Binder = class {
      constructor(e3) {
        this.root = e3, this.datasets = e3.datasets, this.data = e3.datasets?.data || new XmlObject(Gc.datasets.id, "data"), this.emptyMerge = 0 === this.data[Og]().length, this.root.form = this.form = e3.template[Dg]();
      }
      _isConsumeData() {
        return !this.emptyMerge && this._mergeMode;
      }
      _isMatchTemplate() {
        return !this._isConsumeData();
      }
      bind() {
        return this._bindElement(this.form, this.data), this.form;
      }
      getData() {
        return this.data;
      }
      _bindValue(e3, t3, i3) {
        if (e3[kg] = t3, e3[Vg]()) if (t3[Ac]()) {
          const i4 = t3[Jg]();
          e3[bc](createText(i4));
        } else if (e3 instanceof Field && "multiSelect" === e3.ui?.choiceList?.open) {
          const i4 = t3[Og]().map((e4) => e4[Fg].trim()).join("\n");
          e3[bc](createText(i4));
        } else this._isConsumeData() && warn("XFA - Nodes haven't the same type.");
        else !t3[Ac]() || this._isMatchTemplate() ? this._bindElement(e3, t3) : warn("XFA - Nodes haven't the same type.");
      }
      _findDataByNameToConsume(e3, t3, i3, a3) {
        if (!e3) return null;
        let s3, n3;
        for (let a4 = 0; a4 < 3; a4++) {
          for (s3 = i3[Pg](e3, false, true); n3 = s3.next().value, n3; ) if (t3 === n3[Ac]()) return n3;
          if (i3[cc] === Gc.datasets.id && "data" === i3[hc]) break;
          i3 = i3[Wg]();
        }
        return a3 ? (s3 = this.data[Pg](e3, true, false), n3 = s3.next().value, n3 || (s3 = this.data[Gg](e3, true), n3 = s3.next().value, n3?.[Ac]() ? n3 : null)) : null;
      }
      _setProperties(e3, t3) {
        if (e3.hasOwnProperty("setProperty")) for (const { ref: i3, target: a3, connection: s3 } of e3.setProperty.children) {
          if (s3) continue;
          if (!i3) continue;
          const n3 = searchNode(this.root, t3, i3, false, false);
          if (!n3) {
            warn(`XFA - Invalid reference: ${i3}.`);
            continue;
          }
          const [r3] = n3;
          if (!r3[ic](this.data)) {
            warn("XFA - Invalid node: must be a data node.");
            continue;
          }
          const o3 = searchNode(this.root, e3, a3, false, false);
          if (!o3) {
            warn(`XFA - Invalid target: ${a3}.`);
            continue;
          }
          const [g3] = o3;
          if (!g3[ic](e3)) {
            warn("XFA - Invalid target: must be a property or subproperty.");
            continue;
          }
          const c3 = g3[Wg]();
          if (g3 instanceof SetProperty || c3 instanceof SetProperty) {
            warn("XFA - Invalid target: cannot be a setProperty or one of its properties.");
            continue;
          }
          if (g3 instanceof BindItems || c3 instanceof BindItems) {
            warn("XFA - Invalid target: cannot be a bindItems or one of its properties.");
            continue;
          }
          const h3 = r3[Sc](), l3 = g3[hc];
          if (g3 instanceof XFAAttribute) {
            const e4 = /* @__PURE__ */ Object.create(null);
            e4[l3] = h3;
            const t4 = Reflect.construct(Object.getPrototypeOf(c3).constructor, [e4]);
            c3[l3] = t4[l3];
          } else g3.hasOwnProperty(Fg) ? (g3[kg] = r3, g3[Fg] = h3, g3[Ng]()) : warn("XFA - Invalid node to use in setProperty");
        }
      }
      _bindItems(e3, t3) {
        if (!e3.hasOwnProperty("items") || !e3.hasOwnProperty("bindItems") || e3.bindItems.isEmpty()) return;
        for (const t4 of e3.items.children) e3[Ec](t4);
        e3.items.clear();
        const i3 = new Items({}), a3 = new Items({});
        e3[pg](i3), e3.items.push(i3), e3[pg](a3), e3.items.push(a3);
        for (const { ref: s3, labelRef: n3, valueRef: r3, connection: o3 } of e3.bindItems.children) {
          if (o3) continue;
          if (!s3) continue;
          const e4 = searchNode(this.root, t3, s3, false, false);
          if (e4) for (const t4 of e4) {
            if (!t4[ic](this.datasets)) {
              warn(`XFA - Invalid ref (${s3}): must be a datasets child.`);
              continue;
            }
            const e5 = searchNode(this.root, t4, n3, true, false);
            if (!e5) {
              warn(`XFA - Invalid label: ${n3}.`);
              continue;
            }
            const [o4] = e5;
            if (!o4[ic](this.datasets)) {
              warn("XFA - Invalid label: must be a datasets child.");
              continue;
            }
            const g3 = searchNode(this.root, t4, r3, true, false);
            if (!g3) {
              warn(`XFA - Invalid value: ${r3}.`);
              continue;
            }
            const [c3] = g3;
            if (!c3[ic](this.datasets)) {
              warn("XFA - Invalid value: must be a datasets child.");
              continue;
            }
            const h3 = createText(o4[Sc]()), l3 = createText(c3[Sc]());
            i3[pg](h3), i3.text.push(h3), a3[pg](l3), a3.text.push(l3);
          }
          else warn(`XFA - Invalid reference: ${s3}.`);
        }
      }
      _bindOccurrences(e3, t3, i3) {
        let a3;
        if (t3.length > 1 && (a3 = e3[Dg](), a3[Ec](a3.occur), a3.occur = null), this._bindValue(e3, t3[0], i3), this._setProperties(e3, t3[0]), this._bindItems(e3, t3[0]), 1 === t3.length) return;
        const s3 = e3[Wg](), n3 = e3[hc], r3 = s3[zg](e3);
        for (let e4 = 1, o3 = t3.length; e4 < o3; e4++) {
          const o4 = t3[e4], g3 = a3[Dg]();
          s3[n3].push(g3), s3[$g](r3 + e4, g3), this._bindValue(g3, o4, i3), this._setProperties(g3, o4), this._bindItems(g3, o4);
        }
      }
      _createOccurrences(e3) {
        if (!this.emptyMerge) return;
        const { occur: t3 } = e3;
        if (!t3 || t3.initial <= 1) return;
        const i3 = e3[Wg](), a3 = e3[hc];
        if (!(i3[a3] instanceof XFAObjectArray)) return;
        let s3;
        s3 = e3.name ? i3[a3].children.filter((t4) => t4.name === e3.name).length : i3[a3].children.length;
        const n3 = i3[zg](e3) + 1, r3 = t3.initial - s3;
        if (r3) {
          const t4 = e3[Dg]();
          t4[Ec](t4.occur), t4.occur = null, i3[a3].push(t4), i3[$g](n3, t4);
          for (let e4 = 1; e4 < r3; e4++) {
            const s4 = t4[Dg]();
            i3[a3].push(s4), i3[$g](n3 + e4, s4);
          }
        }
      }
      _getOccurInfo(e3) {
        const { name: t3, occur: i3 } = e3;
        if (!i3 || !t3) return [1, 1];
        const a3 = -1 === i3.max ? 1 / 0 : i3.max;
        return [i3.min, a3];
      }
      _setAndBind(e3, t3) {
        this._setProperties(e3, t3), this._bindItems(e3, t3), this._bindElement(e3, t3);
      }
      _bindElement(e3, t3) {
        const i3 = [];
        this._createOccurrences(e3);
        for (const a3 of e3[Og]()) {
          if (a3[kg]) continue;
          if (void 0 === this._mergeMode && "subform" === a3[hc]) {
            this._mergeMode = "consumeData" === a3.mergeMode;
            const e5 = t3[Og]();
            if (e5.length > 0) this._bindOccurrences(a3, [e5[0]], null);
            else if (this.emptyMerge) {
              const e6 = t3[cc] === fh ? -1 : t3[cc], i4 = a3[kg] = new XmlObject(e6, a3.name || "root");
              t3[pg](i4), this._bindElement(a3, i4);
            }
            continue;
          }
          if (!a3[tc]()) continue;
          let e4 = false, s3 = null, n3 = null, r3 = null;
          if (a3.bind) {
            switch (a3.bind.match) {
              case "none":
                this._setAndBind(a3, t3);
                continue;
              case "global":
                e4 = true;
                break;
              case "dataRef":
                if (!a3.bind.ref) {
                  warn(`XFA - ref is empty in node ${a3[hc]}.`), this._setAndBind(a3, t3);
                  continue;
                }
                n3 = a3.bind.ref;
            }
            a3.bind.picture && (s3 = a3.bind.picture[Fg]);
          }
          const [o3, g3] = this._getOccurInfo(a3);
          if (n3) {
            if (r3 = searchNode(this.root, t3, n3, true, false), null === r3) {
              if (r3 = createDataNode(this.data, t3, n3), !r3) continue;
              this._isConsumeData() && (r3[Sg] = true), this._setAndBind(a3, r3);
              continue;
            }
            this._isConsumeData() && (r3 = r3.filter((e5) => !e5[Sg])), r3.length > g3 ? r3 = r3.slice(0, g3) : 0 === r3.length && (r3 = null), r3 && this._isConsumeData() && r3.forEach((e5) => {
              e5[Sg] = true;
            });
          } else {
            if (!a3.name) {
              this._setAndBind(a3, t3);
              continue;
            }
            if (this._isConsumeData()) {
              const i4 = [];
              for (; i4.length < g3; ) {
                const s4 = this._findDataByNameToConsume(a3.name, a3[Vg](), t3, e4);
                if (!s4) break;
                s4[Sg] = true, i4.push(s4);
              }
              r3 = i4.length > 0 ? i4 : null;
            } else {
              if (r3 = t3[Pg](a3.name, false, this.emptyMerge).next().value, !r3) {
                if (0 === o3) {
                  i3.push(a3);
                  continue;
                }
                const e5 = t3[cc] === fh ? -1 : t3[cc];
                r3 = a3[kg] = new XmlObject(e5, a3.name), this.emptyMerge && (r3[Sg] = true), t3[pg](r3), this._setAndBind(a3, r3);
                continue;
              }
              this.emptyMerge && (r3[Sg] = true), r3 = [r3];
            }
          }
          r3 ? this._bindOccurrences(a3, r3, s3) : o3 > 0 ? this._setAndBind(a3, t3) : i3.push(a3);
        }
        i3.forEach((e4) => e4[Wg]()[Ec](e4));
      }
    };
    DataHandler = class {
      constructor(e3, t3) {
        this.data = t3, this.dataset = e3.datasets || null;
      }
      serialize(e3) {
        const t3 = [[-1, this.data[Og]()]];
        for (; t3.length > 0; ) {
          const i4 = t3.at(-1), [a3, s3] = i4;
          if (a3 + 1 === s3.length) {
            t3.pop();
            continue;
          }
          const n3 = s3[++i4[0]], r3 = e3.get(n3[Nc]);
          if (r3) n3[bc](r3);
          else {
            const t4 = n3[vg]();
            for (const i5 of t4.values()) {
              const t5 = e3.get(i5[Nc]);
              if (t5) {
                i5[bc](t5);
                break;
              }
            }
          }
          const o3 = n3[Og]();
          o3.length > 0 && t3.push([-1, o3]);
        }
        const i3 = ['<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">'];
        if (this.dataset) for (const e4 of this.dataset[Og]()) "data" !== e4[hc] && e4[Rc](i3);
        return this.data[Rc](i3), i3.push("</xfa:datasets>"), i3.join("");
      }
    };
    ph = Gc.config.id;
    Acrobat = class extends XFAObject {
      constructor(e3) {
        super(ph, "acrobat", true), this.acrobat7 = null, this.autoSave = null, this.common = null, this.validate = null, this.validateApprovalSignatures = null, this.submitUrl = new XFAObjectArray();
      }
    };
    Acrobat7 = class extends XFAObject {
      constructor(e3) {
        super(ph, "acrobat7", true), this.dynamicRender = null;
      }
    };
    ADBE_JSConsole = class extends OptionObject {
      constructor(e3) {
        super(ph, "ADBE_JSConsole", ["delegate", "Enable", "Disable"]);
      }
    };
    ADBE_JSDebugger = class extends OptionObject {
      constructor(e3) {
        super(ph, "ADBE_JSDebugger", ["delegate", "Enable", "Disable"]);
      }
    };
    AddSilentPrint = class extends Option01 {
      constructor(e3) {
        super(ph, "addSilentPrint");
      }
    };
    AddViewerPreferences = class extends Option01 {
      constructor(e3) {
        super(ph, "addViewerPreferences");
      }
    };
    AdjustData = class extends Option10 {
      constructor(e3) {
        super(ph, "adjustData");
      }
    };
    AdobeExtensionLevel = class extends IntegerObject {
      constructor(e3) {
        super(ph, "adobeExtensionLevel", 0, (e4) => e4 >= 1 && e4 <= 8);
      }
    };
    Agent = class extends XFAObject {
      constructor(e3) {
        super(ph, "agent", true), this.name = e3.name ? e3.name.trim() : "", this.common = new XFAObjectArray();
      }
    };
    AlwaysEmbed = class extends ContentObject {
      constructor(e3) {
        super(ph, "alwaysEmbed");
      }
    };
    Amd = class extends StringObject {
      constructor(e3) {
        super(ph, "amd");
      }
    };
    config_Area = class extends XFAObject {
      constructor(e3) {
        super(ph, "area"), this.level = getInteger({ data: e3.level, defaultValue: 0, validate: (e4) => e4 >= 1 && e4 <= 3 }), this.name = getStringOption(e3.name, ["", "barcode", "coreinit", "deviceDriver", "font", "general", "layout", "merge", "script", "signature", "sourceSet", "templateCache"]);
      }
    };
    Attributes = class extends OptionObject {
      constructor(e3) {
        super(ph, "attributes", ["preserve", "delegate", "ignore"]);
      }
    };
    AutoSave = class extends OptionObject {
      constructor(e3) {
        super(ph, "autoSave", ["disabled", "enabled"]);
      }
    };
    Base = class extends StringObject {
      constructor(e3) {
        super(ph, "base");
      }
    };
    BatchOutput = class extends XFAObject {
      constructor(e3) {
        super(ph, "batchOutput"), this.format = getStringOption(e3.format, ["none", "concat", "zip", "zipCompress"]);
      }
    };
    BehaviorOverride = class extends ContentObject {
      constructor(e3) {
        super(ph, "behaviorOverride");
      }
      [Ng]() {
        this[Fg] = new Map(this[Fg].trim().split(/\s+/).filter((e3) => e3.includes(":")).map((e3) => e3.split(":", 2)));
      }
    };
    Cache = class extends XFAObject {
      constructor(e3) {
        super(ph, "cache", true), this.templateCache = null;
      }
    };
    Change = class extends Option01 {
      constructor(e3) {
        super(ph, "change");
      }
    };
    Common = class extends XFAObject {
      constructor(e3) {
        super(ph, "common", true), this.data = null, this.locale = null, this.localeSet = null, this.messaging = null, this.suppressBanner = null, this.template = null, this.validationMessaging = null, this.versionControl = null, this.log = new XFAObjectArray();
      }
    };
    Compress = class extends XFAObject {
      constructor(e3) {
        super(ph, "compress"), this.scope = getStringOption(e3.scope, ["imageOnly", "document"]);
      }
    };
    CompressLogicalStructure = class extends Option01 {
      constructor(e3) {
        super(ph, "compressLogicalStructure");
      }
    };
    CompressObjectStream = class extends Option10 {
      constructor(e3) {
        super(ph, "compressObjectStream");
      }
    };
    Compression = class extends XFAObject {
      constructor(e3) {
        super(ph, "compression", true), this.compressLogicalStructure = null, this.compressObjectStream = null, this.level = null, this.type = null;
      }
    };
    Config = class extends XFAObject {
      constructor(e3) {
        super(ph, "config", true), this.acrobat = null, this.present = null, this.trace = null, this.agent = new XFAObjectArray();
      }
    };
    Conformance = class extends OptionObject {
      constructor(e3) {
        super(ph, "conformance", ["A", "B"]);
      }
    };
    ContentCopy = class extends Option01 {
      constructor(e3) {
        super(ph, "contentCopy");
      }
    };
    Copies = class extends IntegerObject {
      constructor(e3) {
        super(ph, "copies", 1, (e4) => e4 >= 1);
      }
    };
    Creator = class extends StringObject {
      constructor(e3) {
        super(ph, "creator");
      }
    };
    CurrentPage = class extends IntegerObject {
      constructor(e3) {
        super(ph, "currentPage", 0, (e4) => e4 >= 0);
      }
    };
    Data = class extends XFAObject {
      constructor(e3) {
        super(ph, "data", true), this.adjustData = null, this.attributes = null, this.incrementalLoad = null, this.outputXSL = null, this.range = null, this.record = null, this.startNode = null, this.uri = null, this.window = null, this.xsl = null, this.excludeNS = new XFAObjectArray(), this.transform = new XFAObjectArray();
      }
    };
    Debug = class extends XFAObject {
      constructor(e3) {
        super(ph, "debug", true), this.uri = null;
      }
    };
    DefaultTypeface = class extends ContentObject {
      constructor(e3) {
        super(ph, "defaultTypeface"), this.writingScript = getStringOption(e3.writingScript, ["*", "Arabic", "Cyrillic", "EastEuropeanRoman", "Greek", "Hebrew", "Japanese", "Korean", "Roman", "SimplifiedChinese", "Thai", "TraditionalChinese", "Vietnamese"]);
      }
    };
    Destination = class extends OptionObject {
      constructor(e3) {
        super(ph, "destination", ["pdf", "pcl", "ps", "webClient", "zpl"]);
      }
    };
    DocumentAssembly = class extends Option01 {
      constructor(e3) {
        super(ph, "documentAssembly");
      }
    };
    Driver = class extends XFAObject {
      constructor(e3) {
        super(ph, "driver", true), this.name = e3.name ? e3.name.trim() : "", this.fontInfo = null, this.xdc = null;
      }
    };
    DuplexOption = class extends OptionObject {
      constructor(e3) {
        super(ph, "duplexOption", ["simplex", "duplexFlipLongEdge", "duplexFlipShortEdge"]);
      }
    };
    DynamicRender = class extends OptionObject {
      constructor(e3) {
        super(ph, "dynamicRender", ["forbidden", "required"]);
      }
    };
    Embed = class extends Option01 {
      constructor(e3) {
        super(ph, "embed");
      }
    };
    config_Encrypt = class extends Option01 {
      constructor(e3) {
        super(ph, "encrypt");
      }
    };
    config_Encryption = class extends XFAObject {
      constructor(e3) {
        super(ph, "encryption", true), this.encrypt = null, this.encryptionLevel = null, this.permissions = null;
      }
    };
    EncryptionLevel = class extends OptionObject {
      constructor(e3) {
        super(ph, "encryptionLevel", ["40bit", "128bit"]);
      }
    };
    Enforce = class extends StringObject {
      constructor(e3) {
        super(ph, "enforce");
      }
    };
    Equate = class extends XFAObject {
      constructor(e3) {
        super(ph, "equate"), this.force = getInteger({ data: e3.force, defaultValue: 1, validate: (e4) => 0 === e4 }), this.from = e3.from || "", this.to = e3.to || "";
      }
    };
    EquateRange = class extends XFAObject {
      constructor(e3) {
        super(ph, "equateRange"), this.from = e3.from || "", this.to = e3.to || "", this._unicodeRange = e3.unicodeRange || "";
      }
      get unicodeRange() {
        const e3 = [], t3 = /U\+([0-9a-fA-F]+)/, i3 = this._unicodeRange;
        for (let a3 of i3.split(",").map((e4) => e4.trim()).filter((e4) => !!e4)) a3 = a3.split("-", 2).map((e4) => {
          const i4 = e4.match(t3);
          return i4 ? parseInt(i4[1], 16) : 0;
        }), 1 === a3.length && a3.push(a3[0]), e3.push(a3);
        return shadow(this, "unicodeRange", e3);
      }
    };
    Exclude = class extends ContentObject {
      constructor(e3) {
        super(ph, "exclude");
      }
      [Ng]() {
        this[Fg] = this[Fg].trim().split(/\s+/).filter((e3) => e3 && ["calculate", "close", "enter", "exit", "initialize", "ready", "validate"].includes(e3));
      }
    };
    ExcludeNS = class extends StringObject {
      constructor(e3) {
        super(ph, "excludeNS");
      }
    };
    FlipLabel = class extends OptionObject {
      constructor(e3) {
        super(ph, "flipLabel", ["usePrinterSetting", "on", "off"]);
      }
    };
    config_FontInfo = class extends XFAObject {
      constructor(e3) {
        super(ph, "fontInfo", true), this.embed = null, this.map = null, this.subsetBelow = null, this.alwaysEmbed = new XFAObjectArray(), this.defaultTypeface = new XFAObjectArray(), this.neverEmbed = new XFAObjectArray();
      }
    };
    FormFieldFilling = class extends Option01 {
      constructor(e3) {
        super(ph, "formFieldFilling");
      }
    };
    GroupParent = class extends StringObject {
      constructor(e3) {
        super(ph, "groupParent");
      }
    };
    IfEmpty = class extends OptionObject {
      constructor(e3) {
        super(ph, "ifEmpty", ["dataValue", "dataGroup", "ignore", "remove"]);
      }
    };
    IncludeXDPContent = class extends StringObject {
      constructor(e3) {
        super(ph, "includeXDPContent");
      }
    };
    IncrementalLoad = class extends OptionObject {
      constructor(e3) {
        super(ph, "incrementalLoad", ["none", "forwardOnly"]);
      }
    };
    IncrementalMerge = class extends Option01 {
      constructor(e3) {
        super(ph, "incrementalMerge");
      }
    };
    Interactive = class extends Option01 {
      constructor(e3) {
        super(ph, "interactive");
      }
    };
    Jog = class extends OptionObject {
      constructor(e3) {
        super(ph, "jog", ["usePrinterSetting", "none", "pageSet"]);
      }
    };
    LabelPrinter = class extends XFAObject {
      constructor(e3) {
        super(ph, "labelPrinter", true), this.name = getStringOption(e3.name, ["zpl", "dpl", "ipl", "tcpl"]), this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
      }
    };
    Layout = class extends OptionObject {
      constructor(e3) {
        super(ph, "layout", ["paginate", "panel"]);
      }
    };
    Level = class extends IntegerObject {
      constructor(e3) {
        super(ph, "level", 0, (e4) => e4 > 0);
      }
    };
    Linearized = class extends Option01 {
      constructor(e3) {
        super(ph, "linearized");
      }
    };
    Locale = class extends StringObject {
      constructor(e3) {
        super(ph, "locale");
      }
    };
    LocaleSet = class extends StringObject {
      constructor(e3) {
        super(ph, "localeSet");
      }
    };
    Log = class extends XFAObject {
      constructor(e3) {
        super(ph, "log", true), this.mode = null, this.threshold = null, this.to = null, this.uri = null;
      }
    };
    MapElement = class extends XFAObject {
      constructor(e3) {
        super(ph, "map", true), this.equate = new XFAObjectArray(), this.equateRange = new XFAObjectArray();
      }
    };
    MediumInfo = class extends XFAObject {
      constructor(e3) {
        super(ph, "mediumInfo", true), this.map = null;
      }
    };
    config_Message = class extends XFAObject {
      constructor(e3) {
        super(ph, "message", true), this.msgId = null, this.severity = null;
      }
    };
    Messaging = class extends XFAObject {
      constructor(e3) {
        super(ph, "messaging", true), this.message = new XFAObjectArray();
      }
    };
    Mode = class extends OptionObject {
      constructor(e3) {
        super(ph, "mode", ["append", "overwrite"]);
      }
    };
    ModifyAnnots = class extends Option01 {
      constructor(e3) {
        super(ph, "modifyAnnots");
      }
    };
    MsgId = class extends IntegerObject {
      constructor(e3) {
        super(ph, "msgId", 1, (e4) => e4 >= 1);
      }
    };
    NameAttr = class extends StringObject {
      constructor(e3) {
        super(ph, "nameAttr");
      }
    };
    NeverEmbed = class extends ContentObject {
      constructor(e3) {
        super(ph, "neverEmbed");
      }
    };
    NumberOfCopies = class extends IntegerObject {
      constructor(e3) {
        super(ph, "numberOfCopies", null, (e4) => e4 >= 2 && e4 <= 5);
      }
    };
    OpenAction = class extends XFAObject {
      constructor(e3) {
        super(ph, "openAction", true), this.destination = null;
      }
    };
    Output = class extends XFAObject {
      constructor(e3) {
        super(ph, "output", true), this.to = null, this.type = null, this.uri = null;
      }
    };
    OutputBin = class extends StringObject {
      constructor(e3) {
        super(ph, "outputBin");
      }
    };
    OutputXSL = class extends XFAObject {
      constructor(e3) {
        super(ph, "outputXSL", true), this.uri = null;
      }
    };
    Overprint = class extends OptionObject {
      constructor(e3) {
        super(ph, "overprint", ["none", "both", "draw", "field"]);
      }
    };
    Packets = class extends StringObject {
      constructor(e3) {
        super(ph, "packets");
      }
      [Ng]() {
        "*" !== this[Fg] && (this[Fg] = this[Fg].trim().split(/\s+/).filter((e3) => ["config", "datasets", "template", "xfdf", "xslt"].includes(e3)));
      }
    };
    PageOffset = class extends XFAObject {
      constructor(e3) {
        super(ph, "pageOffset"), this.x = getInteger({ data: e3.x, defaultValue: "useXDCSetting", validate: (e4) => true }), this.y = getInteger({ data: e3.y, defaultValue: "useXDCSetting", validate: (e4) => true });
      }
    };
    PageRange = class extends StringObject {
      constructor(e3) {
        super(ph, "pageRange");
      }
      [Ng]() {
        const e3 = this[Fg].trim().split(/\s+/).map((e4) => parseInt(e4, 10)), t3 = [];
        for (let i3 = 0, a3 = e3.length; i3 < a3; i3 += 2) t3.push(e3.slice(i3, i3 + 2));
        this[Fg] = t3;
      }
    };
    Pagination = class extends OptionObject {
      constructor(e3) {
        super(ph, "pagination", ["simplex", "duplexShortEdge", "duplexLongEdge"]);
      }
    };
    PaginationOverride = class extends OptionObject {
      constructor(e3) {
        super(ph, "paginationOverride", ["none", "forceDuplex", "forceDuplexLongEdge", "forceDuplexShortEdge", "forceSimplex"]);
      }
    };
    Part = class extends IntegerObject {
      constructor(e3) {
        super(ph, "part", 1, (e4) => false);
      }
    };
    Pcl = class extends XFAObject {
      constructor(e3) {
        super(ph, "pcl", true), this.name = e3.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.pageOffset = null, this.staple = null, this.xdc = null;
      }
    };
    Pdf = class extends XFAObject {
      constructor(e3) {
        super(ph, "pdf", true), this.name = e3.name || "", this.adobeExtensionLevel = null, this.batchOutput = null, this.compression = null, this.creator = null, this.encryption = null, this.fontInfo = null, this.interactive = null, this.linearized = null, this.openAction = null, this.pdfa = null, this.producer = null, this.renderPolicy = null, this.scriptModel = null, this.silentPrint = null, this.submitFormat = null, this.tagged = null, this.version = null, this.viewerPreferences = null, this.xdc = null;
      }
    };
    Pdfa = class extends XFAObject {
      constructor(e3) {
        super(ph, "pdfa", true), this.amd = null, this.conformance = null, this.includeXDPContent = null, this.part = null;
      }
    };
    Permissions = class extends XFAObject {
      constructor(e3) {
        super(ph, "permissions", true), this.accessibleContent = null, this.change = null, this.contentCopy = null, this.documentAssembly = null, this.formFieldFilling = null, this.modifyAnnots = null, this.plaintextMetadata = null, this.print = null, this.printHighQuality = null;
      }
    };
    PickTrayByPDFSize = class extends Option01 {
      constructor(e3) {
        super(ph, "pickTrayByPDFSize");
      }
    };
    config_Picture = class extends StringObject {
      constructor(e3) {
        super(ph, "picture");
      }
    };
    PlaintextMetadata = class extends Option01 {
      constructor(e3) {
        super(ph, "plaintextMetadata");
      }
    };
    Presence = class extends OptionObject {
      constructor(e3) {
        super(ph, "presence", ["preserve", "dissolve", "dissolveStructure", "ignore", "remove"]);
      }
    };
    Present = class extends XFAObject {
      constructor(e3) {
        super(ph, "present", true), this.behaviorOverride = null, this.cache = null, this.common = null, this.copies = null, this.destination = null, this.incrementalMerge = null, this.layout = null, this.output = null, this.overprint = null, this.pagination = null, this.paginationOverride = null, this.script = null, this.validate = null, this.xdp = null, this.driver = new XFAObjectArray(), this.labelPrinter = new XFAObjectArray(), this.pcl = new XFAObjectArray(), this.pdf = new XFAObjectArray(), this.ps = new XFAObjectArray(), this.submitUrl = new XFAObjectArray(), this.webClient = new XFAObjectArray(), this.zpl = new XFAObjectArray();
      }
    };
    Print = class extends Option01 {
      constructor(e3) {
        super(ph, "print");
      }
    };
    PrintHighQuality = class extends Option01 {
      constructor(e3) {
        super(ph, "printHighQuality");
      }
    };
    PrintScaling = class extends OptionObject {
      constructor(e3) {
        super(ph, "printScaling", ["appdefault", "noScaling"]);
      }
    };
    PrinterName = class extends StringObject {
      constructor(e3) {
        super(ph, "printerName");
      }
    };
    Producer = class extends StringObject {
      constructor(e3) {
        super(ph, "producer");
      }
    };
    Ps = class extends XFAObject {
      constructor(e3) {
        super(ph, "ps", true), this.name = e3.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.staple = null, this.xdc = null;
      }
    };
    mh = class extends ContentObject {
      constructor(e3) {
        super(ph, "range");
      }
      [Ng]() {
        this[Fg] = this[Fg].trim().split(/\s*,\s*/, 2).map((e3) => e3.split("-").map((e4) => parseInt(e4.trim(), 10))).filter((e3) => e3.every((e4) => !isNaN(e4))).map((e3) => (1 === e3.length && e3.push(e3[0]), e3));
      }
    };
    Record = class extends ContentObject {
      constructor(e3) {
        super(ph, "record");
      }
      [Ng]() {
        this[Fg] = this[Fg].trim();
        const e3 = parseInt(this[Fg], 10);
        !isNaN(e3) && e3 >= 0 && (this[Fg] = e3);
      }
    };
    Relevant = class extends ContentObject {
      constructor(e3) {
        super(ph, "relevant");
      }
      [Ng]() {
        this[Fg] = this[Fg].trim().split(/\s+/);
      }
    };
    Rename = class extends ContentObject {
      constructor(e3) {
        super(ph, "rename");
      }
      [Ng]() {
        this[Fg] = this[Fg].trim(), (this[Fg].toLowerCase().startsWith("xml") || new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u").test(this[Fg])) && warn("XFA - Rename: invalid XFA name");
      }
    };
    RenderPolicy = class extends OptionObject {
      constructor(e3) {
        super(ph, "renderPolicy", ["server", "client"]);
      }
    };
    RunScripts = class extends OptionObject {
      constructor(e3) {
        super(ph, "runScripts", ["both", "client", "none", "server"]);
      }
    };
    config_Script = class extends XFAObject {
      constructor(e3) {
        super(ph, "script", true), this.currentPage = null, this.exclude = null, this.runScripts = null;
      }
    };
    ScriptModel = class extends OptionObject {
      constructor(e3) {
        super(ph, "scriptModel", ["XFA", "none"]);
      }
    };
    Severity = class extends OptionObject {
      constructor(e3) {
        super(ph, "severity", ["ignore", "error", "information", "trace", "warning"]);
      }
    };
    SilentPrint = class extends XFAObject {
      constructor(e3) {
        super(ph, "silentPrint", true), this.addSilentPrint = null, this.printerName = null;
      }
    };
    Staple = class extends XFAObject {
      constructor(e3) {
        super(ph, "staple"), this.mode = getStringOption(e3.mode, ["usePrinterSetting", "on", "off"]);
      }
    };
    StartNode = class extends StringObject {
      constructor(e3) {
        super(ph, "startNode");
      }
    };
    StartPage = class extends IntegerObject {
      constructor(e3) {
        super(ph, "startPage", 0, (e4) => true);
      }
    };
    SubmitFormat = class extends OptionObject {
      constructor(e3) {
        super(ph, "submitFormat", ["html", "delegate", "fdf", "xml", "pdf"]);
      }
    };
    SubmitUrl = class extends StringObject {
      constructor(e3) {
        super(ph, "submitUrl");
      }
    };
    SubsetBelow = class extends IntegerObject {
      constructor(e3) {
        super(ph, "subsetBelow", 100, (e4) => e4 >= 0 && e4 <= 100);
      }
    };
    SuppressBanner = class extends Option01 {
      constructor(e3) {
        super(ph, "suppressBanner");
      }
    };
    Tagged = class extends Option01 {
      constructor(e3) {
        super(ph, "tagged");
      }
    };
    config_Template = class extends XFAObject {
      constructor(e3) {
        super(ph, "template", true), this.base = null, this.relevant = null, this.startPage = null, this.uri = null, this.xsl = null;
      }
    };
    Threshold = class extends OptionObject {
      constructor(e3) {
        super(ph, "threshold", ["trace", "error", "information", "warning"]);
      }
    };
    To = class extends OptionObject {
      constructor(e3) {
        super(ph, "to", ["null", "memory", "stderr", "stdout", "system", "uri"]);
      }
    };
    TemplateCache = class extends XFAObject {
      constructor(e3) {
        super(ph, "templateCache"), this.maxEntries = getInteger({ data: e3.maxEntries, defaultValue: 5, validate: (e4) => e4 >= 0 });
      }
    };
    Trace = class extends XFAObject {
      constructor(e3) {
        super(ph, "trace", true), this.area = new XFAObjectArray();
      }
    };
    Transform = class extends XFAObject {
      constructor(e3) {
        super(ph, "transform", true), this.groupParent = null, this.ifEmpty = null, this.nameAttr = null, this.picture = null, this.presence = null, this.rename = null, this.whitespace = null;
      }
    };
    Type = class extends OptionObject {
      constructor(e3) {
        super(ph, "type", ["none", "ascii85", "asciiHex", "ccittfax", "flate", "lzw", "runLength", "native", "xdp", "mergedXDP"]);
      }
    };
    Uri = class extends StringObject {
      constructor(e3) {
        super(ph, "uri");
      }
    };
    config_Validate = class extends OptionObject {
      constructor(e3) {
        super(ph, "validate", ["preSubmit", "prePrint", "preExecute", "preSave"]);
      }
    };
    ValidateApprovalSignatures = class extends ContentObject {
      constructor(e3) {
        super(ph, "validateApprovalSignatures");
      }
      [Ng]() {
        this[Fg] = this[Fg].trim().split(/\s+/).filter((e3) => ["docReady", "postSign"].includes(e3));
      }
    };
    ValidationMessaging = class extends OptionObject {
      constructor(e3) {
        super(ph, "validationMessaging", ["allMessagesIndividually", "allMessagesTogether", "firstMessageOnly", "noMessages"]);
      }
    };
    Version = class extends OptionObject {
      constructor(e3) {
        super(ph, "version", ["1.7", "1.6", "1.5", "1.4", "1.3", "1.2"]);
      }
    };
    VersionControl = class extends XFAObject {
      constructor(e3) {
        super(ph, "VersionControl"), this.outputBelow = getStringOption(e3.outputBelow, ["warn", "error", "update"]), this.sourceAbove = getStringOption(e3.sourceAbove, ["warn", "error"]), this.sourceBelow = getStringOption(e3.sourceBelow, ["update", "maintain"]);
      }
    };
    ViewerPreferences = class extends XFAObject {
      constructor(e3) {
        super(ph, "viewerPreferences", true), this.ADBE_JSConsole = null, this.ADBE_JSDebugger = null, this.addViewerPreferences = null, this.duplexOption = null, this.enforce = null, this.numberOfCopies = null, this.pageRange = null, this.pickTrayByPDFSize = null, this.printScaling = null;
      }
    };
    WebClient = class extends XFAObject {
      constructor(e3) {
        super(ph, "webClient", true), this.name = e3.name ? e3.name.trim() : "", this.fontInfo = null, this.xdc = null;
      }
    };
    Whitespace = class extends OptionObject {
      constructor(e3) {
        super(ph, "whitespace", ["preserve", "ltrim", "normalize", "rtrim", "trim"]);
      }
    };
    Window = class extends ContentObject {
      constructor(e3) {
        super(ph, "window");
      }
      [Ng]() {
        const e3 = this[Fg].trim().split(/\s*,\s*/, 2).map((e4) => parseInt(e4, 10));
        e3.some((e4) => isNaN(e4)) ? this[Fg] = [0, 0] : (1 === e3.length && e3.push(e3[0]), this[Fg] = e3);
      }
    };
    Xdc = class extends XFAObject {
      constructor(e3) {
        super(ph, "xdc", true), this.uri = new XFAObjectArray(), this.xsl = new XFAObjectArray();
      }
    };
    Xdp = class extends XFAObject {
      constructor(e3) {
        super(ph, "xdp", true), this.packets = null;
      }
    };
    Xsl = class extends XFAObject {
      constructor(e3) {
        super(ph, "xsl", true), this.debug = null, this.uri = null;
      }
    };
    Zpl = class extends XFAObject {
      constructor(e3) {
        super(ph, "zpl", true), this.name = e3.name ? e3.name.trim() : "", this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
      }
    };
    ConfigNamespace = class _ConfigNamespace {
      static [Mc](e3, t3) {
        if (_ConfigNamespace.hasOwnProperty(e3)) return _ConfigNamespace[e3](t3);
      }
      static acrobat(e3) {
        return new Acrobat(e3);
      }
      static acrobat7(e3) {
        return new Acrobat7(e3);
      }
      static ADBE_JSConsole(e3) {
        return new ADBE_JSConsole(e3);
      }
      static ADBE_JSDebugger(e3) {
        return new ADBE_JSDebugger(e3);
      }
      static addSilentPrint(e3) {
        return new AddSilentPrint(e3);
      }
      static addViewerPreferences(e3) {
        return new AddViewerPreferences(e3);
      }
      static adjustData(e3) {
        return new AdjustData(e3);
      }
      static adobeExtensionLevel(e3) {
        return new AdobeExtensionLevel(e3);
      }
      static agent(e3) {
        return new Agent(e3);
      }
      static alwaysEmbed(e3) {
        return new AlwaysEmbed(e3);
      }
      static amd(e3) {
        return new Amd(e3);
      }
      static area(e3) {
        return new config_Area(e3);
      }
      static attributes(e3) {
        return new Attributes(e3);
      }
      static autoSave(e3) {
        return new AutoSave(e3);
      }
      static base(e3) {
        return new Base(e3);
      }
      static batchOutput(e3) {
        return new BatchOutput(e3);
      }
      static behaviorOverride(e3) {
        return new BehaviorOverride(e3);
      }
      static cache(e3) {
        return new Cache(e3);
      }
      static change(e3) {
        return new Change(e3);
      }
      static common(e3) {
        return new Common(e3);
      }
      static compress(e3) {
        return new Compress(e3);
      }
      static compressLogicalStructure(e3) {
        return new CompressLogicalStructure(e3);
      }
      static compressObjectStream(e3) {
        return new CompressObjectStream(e3);
      }
      static compression(e3) {
        return new Compression(e3);
      }
      static config(e3) {
        return new Config(e3);
      }
      static conformance(e3) {
        return new Conformance(e3);
      }
      static contentCopy(e3) {
        return new ContentCopy(e3);
      }
      static copies(e3) {
        return new Copies(e3);
      }
      static creator(e3) {
        return new Creator(e3);
      }
      static currentPage(e3) {
        return new CurrentPage(e3);
      }
      static data(e3) {
        return new Data(e3);
      }
      static debug(e3) {
        return new Debug(e3);
      }
      static defaultTypeface(e3) {
        return new DefaultTypeface(e3);
      }
      static destination(e3) {
        return new Destination(e3);
      }
      static documentAssembly(e3) {
        return new DocumentAssembly(e3);
      }
      static driver(e3) {
        return new Driver(e3);
      }
      static duplexOption(e3) {
        return new DuplexOption(e3);
      }
      static dynamicRender(e3) {
        return new DynamicRender(e3);
      }
      static embed(e3) {
        return new Embed(e3);
      }
      static encrypt(e3) {
        return new config_Encrypt(e3);
      }
      static encryption(e3) {
        return new config_Encryption(e3);
      }
      static encryptionLevel(e3) {
        return new EncryptionLevel(e3);
      }
      static enforce(e3) {
        return new Enforce(e3);
      }
      static equate(e3) {
        return new Equate(e3);
      }
      static equateRange(e3) {
        return new EquateRange(e3);
      }
      static exclude(e3) {
        return new Exclude(e3);
      }
      static excludeNS(e3) {
        return new ExcludeNS(e3);
      }
      static flipLabel(e3) {
        return new FlipLabel(e3);
      }
      static fontInfo(e3) {
        return new config_FontInfo(e3);
      }
      static formFieldFilling(e3) {
        return new FormFieldFilling(e3);
      }
      static groupParent(e3) {
        return new GroupParent(e3);
      }
      static ifEmpty(e3) {
        return new IfEmpty(e3);
      }
      static includeXDPContent(e3) {
        return new IncludeXDPContent(e3);
      }
      static incrementalLoad(e3) {
        return new IncrementalLoad(e3);
      }
      static incrementalMerge(e3) {
        return new IncrementalMerge(e3);
      }
      static interactive(e3) {
        return new Interactive(e3);
      }
      static jog(e3) {
        return new Jog(e3);
      }
      static labelPrinter(e3) {
        return new LabelPrinter(e3);
      }
      static layout(e3) {
        return new Layout(e3);
      }
      static level(e3) {
        return new Level(e3);
      }
      static linearized(e3) {
        return new Linearized(e3);
      }
      static locale(e3) {
        return new Locale(e3);
      }
      static localeSet(e3) {
        return new LocaleSet(e3);
      }
      static log(e3) {
        return new Log(e3);
      }
      static map(e3) {
        return new MapElement(e3);
      }
      static mediumInfo(e3) {
        return new MediumInfo(e3);
      }
      static message(e3) {
        return new config_Message(e3);
      }
      static messaging(e3) {
        return new Messaging(e3);
      }
      static mode(e3) {
        return new Mode(e3);
      }
      static modifyAnnots(e3) {
        return new ModifyAnnots(e3);
      }
      static msgId(e3) {
        return new MsgId(e3);
      }
      static nameAttr(e3) {
        return new NameAttr(e3);
      }
      static neverEmbed(e3) {
        return new NeverEmbed(e3);
      }
      static numberOfCopies(e3) {
        return new NumberOfCopies(e3);
      }
      static openAction(e3) {
        return new OpenAction(e3);
      }
      static output(e3) {
        return new Output(e3);
      }
      static outputBin(e3) {
        return new OutputBin(e3);
      }
      static outputXSL(e3) {
        return new OutputXSL(e3);
      }
      static overprint(e3) {
        return new Overprint(e3);
      }
      static packets(e3) {
        return new Packets(e3);
      }
      static pageOffset(e3) {
        return new PageOffset(e3);
      }
      static pageRange(e3) {
        return new PageRange(e3);
      }
      static pagination(e3) {
        return new Pagination(e3);
      }
      static paginationOverride(e3) {
        return new PaginationOverride(e3);
      }
      static part(e3) {
        return new Part(e3);
      }
      static pcl(e3) {
        return new Pcl(e3);
      }
      static pdf(e3) {
        return new Pdf(e3);
      }
      static pdfa(e3) {
        return new Pdfa(e3);
      }
      static permissions(e3) {
        return new Permissions(e3);
      }
      static pickTrayByPDFSize(e3) {
        return new PickTrayByPDFSize(e3);
      }
      static picture(e3) {
        return new config_Picture(e3);
      }
      static plaintextMetadata(e3) {
        return new PlaintextMetadata(e3);
      }
      static presence(e3) {
        return new Presence(e3);
      }
      static present(e3) {
        return new Present(e3);
      }
      static print(e3) {
        return new Print(e3);
      }
      static printHighQuality(e3) {
        return new PrintHighQuality(e3);
      }
      static printScaling(e3) {
        return new PrintScaling(e3);
      }
      static printerName(e3) {
        return new PrinterName(e3);
      }
      static producer(e3) {
        return new Producer(e3);
      }
      static ps(e3) {
        return new Ps(e3);
      }
      static range(e3) {
        return new mh(e3);
      }
      static record(e3) {
        return new Record(e3);
      }
      static relevant(e3) {
        return new Relevant(e3);
      }
      static rename(e3) {
        return new Rename(e3);
      }
      static renderPolicy(e3) {
        return new RenderPolicy(e3);
      }
      static runScripts(e3) {
        return new RunScripts(e3);
      }
      static script(e3) {
        return new config_Script(e3);
      }
      static scriptModel(e3) {
        return new ScriptModel(e3);
      }
      static severity(e3) {
        return new Severity(e3);
      }
      static silentPrint(e3) {
        return new SilentPrint(e3);
      }
      static staple(e3) {
        return new Staple(e3);
      }
      static startNode(e3) {
        return new StartNode(e3);
      }
      static startPage(e3) {
        return new StartPage(e3);
      }
      static submitFormat(e3) {
        return new SubmitFormat(e3);
      }
      static submitUrl(e3) {
        return new SubmitUrl(e3);
      }
      static subsetBelow(e3) {
        return new SubsetBelow(e3);
      }
      static suppressBanner(e3) {
        return new SuppressBanner(e3);
      }
      static tagged(e3) {
        return new Tagged(e3);
      }
      static template(e3) {
        return new config_Template(e3);
      }
      static templateCache(e3) {
        return new TemplateCache(e3);
      }
      static threshold(e3) {
        return new Threshold(e3);
      }
      static to(e3) {
        return new To(e3);
      }
      static trace(e3) {
        return new Trace(e3);
      }
      static transform(e3) {
        return new Transform(e3);
      }
      static type(e3) {
        return new Type(e3);
      }
      static uri(e3) {
        return new Uri(e3);
      }
      static validate(e3) {
        return new config_Validate(e3);
      }
      static validateApprovalSignatures(e3) {
        return new ValidateApprovalSignatures(e3);
      }
      static validationMessaging(e3) {
        return new ValidationMessaging(e3);
      }
      static version(e3) {
        return new Version(e3);
      }
      static versionControl(e3) {
        return new VersionControl(e3);
      }
      static viewerPreferences(e3) {
        return new ViewerPreferences(e3);
      }
      static webClient(e3) {
        return new WebClient(e3);
      }
      static whitespace(e3) {
        return new Whitespace(e3);
      }
      static window(e3) {
        return new Window(e3);
      }
      static xdc(e3) {
        return new Xdc(e3);
      }
      static xdp(e3) {
        return new Xdp(e3);
      }
      static xsl(e3) {
        return new Xsl(e3);
      }
      static zpl(e3) {
        return new Zpl(e3);
      }
    };
    yh = Gc.connectionSet.id;
    ConnectionSet = class extends XFAObject {
      constructor(e3) {
        super(yh, "connectionSet", true), this.wsdlConnection = new XFAObjectArray(), this.xmlConnection = new XFAObjectArray(), this.xsdConnection = new XFAObjectArray();
      }
    };
    EffectiveInputPolicy = class extends XFAObject {
      constructor(e3) {
        super(yh, "effectiveInputPolicy"), this.id = e3.id || "", this.name = e3.name || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    EffectiveOutputPolicy = class extends XFAObject {
      constructor(e3) {
        super(yh, "effectiveOutputPolicy"), this.id = e3.id || "", this.name = e3.name || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    Operation = class extends StringObject {
      constructor(e3) {
        super(yh, "operation"), this.id = e3.id || "", this.input = e3.input || "", this.name = e3.name || "", this.output = e3.output || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    RootElement = class extends StringObject {
      constructor(e3) {
        super(yh, "rootElement"), this.id = e3.id || "", this.name = e3.name || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    SoapAction = class extends StringObject {
      constructor(e3) {
        super(yh, "soapAction"), this.id = e3.id || "", this.name = e3.name || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    SoapAddress = class extends StringObject {
      constructor(e3) {
        super(yh, "soapAddress"), this.id = e3.id || "", this.name = e3.name || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    connection_set_Uri = class extends StringObject {
      constructor(e3) {
        super(yh, "uri"), this.id = e3.id || "", this.name = e3.name || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    WsdlAddress = class extends StringObject {
      constructor(e3) {
        super(yh, "wsdlAddress"), this.id = e3.id || "", this.name = e3.name || "", this.use = e3.use || "", this.usehref = e3.usehref || "";
      }
    };
    WsdlConnection = class extends XFAObject {
      constructor(e3) {
        super(yh, "wsdlConnection", true), this.dataDescription = e3.dataDescription || "", this.name = e3.name || "", this.effectiveInputPolicy = null, this.effectiveOutputPolicy = null, this.operation = null, this.soapAction = null, this.soapAddress = null, this.wsdlAddress = null;
      }
    };
    XmlConnection = class extends XFAObject {
      constructor(e3) {
        super(yh, "xmlConnection", true), this.dataDescription = e3.dataDescription || "", this.name = e3.name || "", this.uri = null;
      }
    };
    XsdConnection = class extends XFAObject {
      constructor(e3) {
        super(yh, "xsdConnection", true), this.dataDescription = e3.dataDescription || "", this.name = e3.name || "", this.rootElement = null, this.uri = null;
      }
    };
    ConnectionSetNamespace = class _ConnectionSetNamespace {
      static [Mc](e3, t3) {
        if (_ConnectionSetNamespace.hasOwnProperty(e3)) return _ConnectionSetNamespace[e3](t3);
      }
      static connectionSet(e3) {
        return new ConnectionSet(e3);
      }
      static effectiveInputPolicy(e3) {
        return new EffectiveInputPolicy(e3);
      }
      static effectiveOutputPolicy(e3) {
        return new EffectiveOutputPolicy(e3);
      }
      static operation(e3) {
        return new Operation(e3);
      }
      static rootElement(e3) {
        return new RootElement(e3);
      }
      static soapAction(e3) {
        return new SoapAction(e3);
      }
      static soapAddress(e3) {
        return new SoapAddress(e3);
      }
      static uri(e3) {
        return new connection_set_Uri(e3);
      }
      static wsdlAddress(e3) {
        return new WsdlAddress(e3);
      }
      static wsdlConnection(e3) {
        return new WsdlConnection(e3);
      }
      static xmlConnection(e3) {
        return new XmlConnection(e3);
      }
      static xsdConnection(e3) {
        return new XsdConnection(e3);
      }
    };
    wh = Gc.datasets.id;
    datasets_Data = class extends XmlObject {
      constructor(e3) {
        super(wh, "data", e3);
      }
      [ac]() {
        return true;
      }
    };
    Datasets = class extends XFAObject {
      constructor(e3) {
        super(wh, "datasets", true), this.data = null, this.Signature = null;
      }
      [Ic](e3) {
        const t3 = e3[hc];
        ("data" === t3 && e3[cc] === wh || "Signature" === t3 && e3[cc] === Gc.signature.id) && (this[t3] = e3), this[pg](e3);
      }
    };
    DatasetsNamespace = class _DatasetsNamespace {
      static [Mc](e3, t3) {
        if (_DatasetsNamespace.hasOwnProperty(e3)) return _DatasetsNamespace[e3](t3);
      }
      static datasets(e3) {
        return new Datasets(e3);
      }
      static data(e3) {
        return new datasets_Data(e3);
      }
    };
    bh = Gc.localeSet.id;
    CalendarSymbols = class extends XFAObject {
      constructor(e3) {
        super(bh, "calendarSymbols", true), this.name = "gregorian", this.dayNames = new XFAObjectArray(2), this.eraNames = null, this.meridiemNames = null, this.monthNames = new XFAObjectArray(2);
      }
    };
    CurrencySymbol = class extends StringObject {
      constructor(e3) {
        super(bh, "currencySymbol"), this.name = getStringOption(e3.name, ["symbol", "isoname", "decimal"]);
      }
    };
    CurrencySymbols = class extends XFAObject {
      constructor(e3) {
        super(bh, "currencySymbols", true), this.currencySymbol = new XFAObjectArray(3);
      }
    };
    DatePattern = class extends StringObject {
      constructor(e3) {
        super(bh, "datePattern"), this.name = getStringOption(e3.name, ["full", "long", "med", "short"]);
      }
    };
    DatePatterns = class extends XFAObject {
      constructor(e3) {
        super(bh, "datePatterns", true), this.datePattern = new XFAObjectArray(4);
      }
    };
    DateTimeSymbols = class extends ContentObject {
      constructor(e3) {
        super(bh, "dateTimeSymbols");
      }
    };
    Day = class extends StringObject {
      constructor(e3) {
        super(bh, "day");
      }
    };
    DayNames = class extends XFAObject {
      constructor(e3) {
        super(bh, "dayNames", true), this.abbr = getInteger({ data: e3.abbr, defaultValue: 0, validate: (e4) => 1 === e4 }), this.day = new XFAObjectArray(7);
      }
    };
    Era = class extends StringObject {
      constructor(e3) {
        super(bh, "era");
      }
    };
    EraNames = class extends XFAObject {
      constructor(e3) {
        super(bh, "eraNames", true), this.era = new XFAObjectArray(2);
      }
    };
    locale_set_Locale = class extends XFAObject {
      constructor(e3) {
        super(bh, "locale", true), this.desc = e3.desc || "", this.name = "isoname", this.calendarSymbols = null, this.currencySymbols = null, this.datePatterns = null, this.dateTimeSymbols = null, this.numberPatterns = null, this.numberSymbols = null, this.timePatterns = null, this.typeFaces = null;
      }
    };
    locale_set_LocaleSet = class extends XFAObject {
      constructor(e3) {
        super(bh, "localeSet", true), this.locale = new XFAObjectArray();
      }
    };
    Meridiem = class extends StringObject {
      constructor(e3) {
        super(bh, "meridiem");
      }
    };
    MeridiemNames = class extends XFAObject {
      constructor(e3) {
        super(bh, "meridiemNames", true), this.meridiem = new XFAObjectArray(2);
      }
    };
    Month = class extends StringObject {
      constructor(e3) {
        super(bh, "month");
      }
    };
    MonthNames = class extends XFAObject {
      constructor(e3) {
        super(bh, "monthNames", true), this.abbr = getInteger({ data: e3.abbr, defaultValue: 0, validate: (e4) => 1 === e4 }), this.month = new XFAObjectArray(12);
      }
    };
    NumberPattern = class extends StringObject {
      constructor(e3) {
        super(bh, "numberPattern"), this.name = getStringOption(e3.name, ["full", "long", "med", "short"]);
      }
    };
    NumberPatterns = class extends XFAObject {
      constructor(e3) {
        super(bh, "numberPatterns", true), this.numberPattern = new XFAObjectArray(4);
      }
    };
    NumberSymbol = class extends StringObject {
      constructor(e3) {
        super(bh, "numberSymbol"), this.name = getStringOption(e3.name, ["decimal", "grouping", "percent", "minus", "zero"]);
      }
    };
    NumberSymbols = class extends XFAObject {
      constructor(e3) {
        super(bh, "numberSymbols", true), this.numberSymbol = new XFAObjectArray(5);
      }
    };
    TimePattern = class extends StringObject {
      constructor(e3) {
        super(bh, "timePattern"), this.name = getStringOption(e3.name, ["full", "long", "med", "short"]);
      }
    };
    TimePatterns = class extends XFAObject {
      constructor(e3) {
        super(bh, "timePatterns", true), this.timePattern = new XFAObjectArray(4);
      }
    };
    TypeFace = class extends XFAObject {
      constructor(e3) {
        super(bh, "typeFace", true), this.name = "" | e3.name;
      }
    };
    TypeFaces = class extends XFAObject {
      constructor(e3) {
        super(bh, "typeFaces", true), this.typeFace = new XFAObjectArray();
      }
    };
    LocaleSetNamespace = class _LocaleSetNamespace {
      static [Mc](e3, t3) {
        if (_LocaleSetNamespace.hasOwnProperty(e3)) return _LocaleSetNamespace[e3](t3);
      }
      static calendarSymbols(e3) {
        return new CalendarSymbols(e3);
      }
      static currencySymbol(e3) {
        return new CurrencySymbol(e3);
      }
      static currencySymbols(e3) {
        return new CurrencySymbols(e3);
      }
      static datePattern(e3) {
        return new DatePattern(e3);
      }
      static datePatterns(e3) {
        return new DatePatterns(e3);
      }
      static dateTimeSymbols(e3) {
        return new DateTimeSymbols(e3);
      }
      static day(e3) {
        return new Day(e3);
      }
      static dayNames(e3) {
        return new DayNames(e3);
      }
      static era(e3) {
        return new Era(e3);
      }
      static eraNames(e3) {
        return new EraNames(e3);
      }
      static locale(e3) {
        return new locale_set_Locale(e3);
      }
      static localeSet(e3) {
        return new locale_set_LocaleSet(e3);
      }
      static meridiem(e3) {
        return new Meridiem(e3);
      }
      static meridiemNames(e3) {
        return new MeridiemNames(e3);
      }
      static month(e3) {
        return new Month(e3);
      }
      static monthNames(e3) {
        return new MonthNames(e3);
      }
      static numberPattern(e3) {
        return new NumberPattern(e3);
      }
      static numberPatterns(e3) {
        return new NumberPatterns(e3);
      }
      static numberSymbol(e3) {
        return new NumberSymbol(e3);
      }
      static numberSymbols(e3) {
        return new NumberSymbols(e3);
      }
      static timePattern(e3) {
        return new TimePattern(e3);
      }
      static timePatterns(e3) {
        return new TimePatterns(e3);
      }
      static typeFace(e3) {
        return new TypeFace(e3);
      }
      static typeFaces(e3) {
        return new TypeFaces(e3);
      }
    };
    Dh = Gc.signature.id;
    signature_Signature = class extends XFAObject {
      constructor(e3) {
        super(Dh, "signature", true);
      }
    };
    SignatureNamespace = class _SignatureNamespace {
      static [Mc](e3, t3) {
        if (_SignatureNamespace.hasOwnProperty(e3)) return _SignatureNamespace[e3](t3);
      }
      static signature(e3) {
        return new signature_Signature(e3);
      }
    };
    Sh = Gc.stylesheet.id;
    Stylesheet = class extends XFAObject {
      constructor(e3) {
        super(Sh, "stylesheet", true);
      }
    };
    StylesheetNamespace = class _StylesheetNamespace {
      static [Mc](e3, t3) {
        if (_StylesheetNamespace.hasOwnProperty(e3)) return _StylesheetNamespace[e3](t3);
      }
      static stylesheet(e3) {
        return new Stylesheet(e3);
      }
    };
    Fh = Gc.xdp.id;
    xdp_Xdp = class extends XFAObject {
      constructor(e3) {
        super(Fh, "xdp", true), this.uuid = e3.uuid || "", this.timeStamp = e3.timeStamp || "", this.config = null, this.connectionSet = null, this.datasets = null, this.localeSet = null, this.stylesheet = new XFAObjectArray(), this.template = null;
      }
      [Cc](e3) {
        const t3 = Gc[e3[hc]];
        return t3 && e3[cc] === t3.id;
      }
    };
    XdpNamespace = class _XdpNamespace {
      static [Mc](e3, t3) {
        if (_XdpNamespace.hasOwnProperty(e3)) return _XdpNamespace[e3](t3);
      }
      static xdp(e3) {
        return new xdp_Xdp(e3);
      }
    };
    kh = Gc.xhtml.id;
    Rh = Symbol();
    xh = /* @__PURE__ */ new Set(["color", "font", "font-family", "font-size", "font-stretch", "font-style", "font-weight", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "letter-spacing", "line-height", "orphans", "page-break-after", "page-break-before", "page-break-inside", "tab-interval", "tab-stop", "text-align", "text-decoration", "text-indent", "vertical-align", "widows", "kerning-mode", "xfa-font-horizontal-scale", "xfa-font-vertical-scale", "xfa-spacerun", "xfa-tab-stops"]);
    Nh = /* @__PURE__ */ new Map([["page-break-after", "breakAfter"], ["page-break-before", "breakBefore"], ["page-break-inside", "breakInside"], ["kerning-mode", (e3) => "none" === e3 ? "none" : "normal"], ["xfa-font-horizontal-scale", (e3) => `scaleX(${Math.max(0, Math.min(parseInt(e3) / 100)).toFixed(2)})`], ["xfa-font-vertical-scale", (e3) => `scaleY(${Math.max(0, Math.min(parseInt(e3) / 100)).toFixed(2)})`], ["xfa-spacerun", ""], ["xfa-tab-stops", ""], ["font-size", (e3, t3) => measureToString(0.99 * (e3 = t3.fontSize = getMeasurement(e3)))], ["letter-spacing", (e3) => measureToString(getMeasurement(e3))], ["line-height", (e3) => measureToString(getMeasurement(e3))], ["margin", (e3) => measureToString(getMeasurement(e3))], ["margin-bottom", (e3) => measureToString(getMeasurement(e3))], ["margin-left", (e3) => measureToString(getMeasurement(e3))], ["margin-right", (e3) => measureToString(getMeasurement(e3))], ["margin-top", (e3) => measureToString(getMeasurement(e3))], ["text-indent", (e3) => measureToString(getMeasurement(e3))], ["font-family", (e3) => e3], ["vertical-align", (e3) => measureToString(getMeasurement(e3))]]);
    Mh = /\s+/g;
    Gh = /[\r\n]+/g;
    vh = /\r\n?/g;
    Lh = /* @__PURE__ */ new Set(["body", "html"]);
    XhtmlObject = class extends XmlObject {
      constructor(e3, t3) {
        super(kh, t3), this[Rh] = false, this.style = e3.style || "";
      }
      [yg](e3) {
        var t3;
        super[yg](e3), this.style = (t3 = this).style ? t3.style.trim().split(/\s*;\s*/).filter((e4) => !!e4).map((e4) => e4.split(/\s*:\s*/, 2)).filter(([e4, i3]) => ("font-family" === e4 && t3[Xg].usedTypefaces.add(i3), xh.has(e4))).map((e4) => e4.join(":")).join(";") : "";
      }
      [Eg]() {
        return !Lh.has(this[hc]);
      }
      [dc](e3, t3 = false) {
        t3 ? this[Rh] = true : (e3 = e3.replaceAll(Gh, ""), this.style.includes("xfa-spacerun:yes") || (e3 = e3.replaceAll(Mh, " "))), e3 && (this[Fg] += e3);
      }
      [Bc](e3, t3 = true) {
        const i3 = /* @__PURE__ */ Object.create(null), a3 = { top: NaN, bottom: NaN, left: NaN, right: NaN };
        let s3 = null;
        for (const [e4, t4] of this.style.split(";").map((e5) => e5.split(":", 2))) switch (e4) {
          case "font-family":
            i3.typeface = stripQuotes(t4);
            break;
          case "font-size":
            i3.size = getMeasurement(t4);
            break;
          case "font-weight":
            i3.weight = t4;
            break;
          case "font-style":
            i3.posture = t4;
            break;
          case "letter-spacing":
            i3.letterSpacing = getMeasurement(t4);
            break;
          case "margin":
            const e5 = t4.split(/ \t/).map((e6) => getMeasurement(e6));
            switch (e5.length) {
              case 1:
                a3.top = a3.bottom = a3.left = a3.right = e5[0];
                break;
              case 2:
                a3.top = a3.bottom = e5[0], a3.left = a3.right = e5[1];
                break;
              case 3:
                a3.top = e5[0], a3.bottom = e5[2], a3.left = a3.right = e5[1];
                break;
              case 4:
                a3.top = e5[0], a3.left = e5[1], a3.bottom = e5[2], a3.right = e5[3];
            }
            break;
          case "margin-top":
            a3.top = getMeasurement(t4);
            break;
          case "margin-bottom":
            a3.bottom = getMeasurement(t4);
            break;
          case "margin-left":
            a3.left = getMeasurement(t4);
            break;
          case "margin-right":
            a3.right = getMeasurement(t4);
            break;
          case "line-height":
            s3 = getMeasurement(t4);
        }
        if (e3.pushData(i3, a3, s3), this[Fg]) e3.addString(this[Fg]);
        else for (const t4 of this[Og]()) "#text" !== t4[hc] ? t4[Bc](e3) : e3.addString(t4[Fg]);
        t3 && e3.popFont();
      }
      [kc](e3) {
        const t3 = [];
        if (this[xg] = { children: t3 }, this[mg]({}), 0 === t3.length && !this[Fg]) return HTMLResult.EMPTY;
        let i3;
        return i3 = this[Rh] ? this[Fg] ? this[Fg].replaceAll(vh, "\n") : void 0 : this[Fg] || void 0, HTMLResult.success({ name: this[hc], attributes: { href: this.href, style: mapStyle(this.style, this, this[Rh]) }, children: t3, value: i3 });
      }
    };
    A = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "a"), this.href = fixURL(e3.href) || "";
      }
    };
    B = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "b");
      }
      [Bc](e3) {
        e3.pushFont({ weight: "bold" }), super[Bc](e3), e3.popFont();
      }
    };
    Body = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "body");
      }
      [kc](e3) {
        const t3 = super[kc](e3), { html: i3 } = t3;
        return i3 ? (i3.name = "div", i3.attributes.class = ["xfaRich"], t3) : HTMLResult.EMPTY;
      }
    };
    Br = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "br");
      }
      [Sc]() {
        return "\n";
      }
      [Bc](e3) {
        e3.addString("\n");
      }
      [kc](e3) {
        return HTMLResult.success({ name: "br" });
      }
    };
    Html = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "html");
      }
      [kc](e3) {
        const t3 = [];
        if (this[xg] = { children: t3 }, this[mg]({}), 0 === t3.length) return HTMLResult.success({ name: "div", attributes: { class: ["xfaRich"], style: {} }, value: this[Fg] || "" });
        if (1 === t3.length) {
          const e4 = t3[0];
          if (e4.attributes?.class.includes("xfaRich")) return HTMLResult.success(e4);
        }
        return HTMLResult.success({ name: "div", attributes: { class: ["xfaRich"], style: {} }, children: t3 });
      }
    };
    I = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "i");
      }
      [Bc](e3) {
        e3.pushFont({ posture: "italic" }), super[Bc](e3), e3.popFont();
      }
    };
    Li = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "li");
      }
    };
    Ol = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "ol");
      }
    };
    P = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "p");
      }
      [Bc](e3) {
        super[Bc](e3, false), e3.addString("\n"), e3.addPara(), e3.popFont();
      }
      [Sc]() {
        return this[Wg]()[Og]().at(-1) === this ? super[Sc]() : super[Sc]() + "\n";
      }
    };
    Span = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "span");
      }
    };
    Sub = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "sub");
      }
    };
    Sup = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "sup");
      }
    };
    Ul = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "ul");
      }
    };
    XhtmlNamespace = class _XhtmlNamespace {
      static [Mc](e3, t3) {
        if (_XhtmlNamespace.hasOwnProperty(e3)) return _XhtmlNamespace[e3](t3);
      }
      static a(e3) {
        return new A(e3);
      }
      static b(e3) {
        return new B(e3);
      }
      static body(e3) {
        return new Body(e3);
      }
      static br(e3) {
        return new Br(e3);
      }
      static html(e3) {
        return new Html(e3);
      }
      static i(e3) {
        return new I(e3);
      }
      static li(e3) {
        return new Li(e3);
      }
      static ol(e3) {
        return new Ol(e3);
      }
      static p(e3) {
        return new P(e3);
      }
      static span(e3) {
        return new Span(e3);
      }
      static sub(e3) {
        return new Sub(e3);
      }
      static sup(e3) {
        return new Sup(e3);
      }
      static ul(e3) {
        return new Ul(e3);
      }
    };
    Uh = { config: ConfigNamespace, connection: ConnectionSetNamespace, datasets: DatasetsNamespace, localeSet: LocaleSetNamespace, signature: SignatureNamespace, stylesheet: StylesheetNamespace, template: TemplateNamespace, xdp: XdpNamespace, xhtml: XhtmlNamespace };
    UnknownNamespace = class {
      constructor(e3) {
        this.namespaceId = e3;
      }
      [Mc](e3, t3) {
        return new XmlObject(this.namespaceId, e3, t3);
      }
    };
    Root = class extends XFAObject {
      constructor(e3) {
        super(-1, "root", /* @__PURE__ */ Object.create(null)), this.element = null, this[Zg] = e3;
      }
      [Ic](e3) {
        return this.element = e3, true;
      }
      [Ng]() {
        super[Ng](), this.element.template instanceof Template && (this[Zg].set(fc, this.element), this.element.template[pc](this[Zg]), this.element.template[Zg] = this[Zg]);
      }
    };
    Empty = class extends XFAObject {
      constructor() {
        super(-1, "", /* @__PURE__ */ Object.create(null));
      }
      [Ic](e3) {
        return false;
      }
    };
    Builder = class {
      constructor(e3 = null) {
        this._namespaceStack = [], this._nsAgnosticLevel = 0, this._namespacePrefixes = /* @__PURE__ */ new Map(), this._namespaces = /* @__PURE__ */ new Map(), this._nextNsId = Math.max(...Object.values(Gc).map(({ id: e4 }) => e4)), this._currentNamespace = e3 || new UnknownNamespace(++this._nextNsId);
      }
      buildRoot(e3) {
        return new Root(e3);
      }
      build({ nsPrefix: e3, name: t3, attributes: i3, namespace: a3, prefixes: s3 }) {
        const n3 = null !== a3;
        if (n3 && (this._namespaceStack.push(this._currentNamespace), this._currentNamespace = this._searchNamespace(a3)), s3 && this._addNamespacePrefix(s3), i3.hasOwnProperty(lc)) {
          const e4 = Uh.datasets, t4 = i3[lc];
          let a4 = null;
          for (const [i4, s4] of Object.entries(t4)) {
            if (this._getNamespaceToUse(i4) === e4) {
              a4 = { xfa: s4 };
              break;
            }
          }
          a4 ? i3[lc] = a4 : delete i3[lc];
        }
        const r3 = this._getNamespaceToUse(e3), o3 = r3?.[Mc](t3, i3) || new Empty();
        return o3[ac]() && this._nsAgnosticLevel++, (n3 || s3 || o3[ac]()) && (o3[bg] = { hasNamespace: n3, prefixes: s3, nsAgnostic: o3[ac]() }), o3;
      }
      isNsAgnostic() {
        return this._nsAgnosticLevel > 0;
      }
      _searchNamespace(e3) {
        let t3 = this._namespaces.get(e3);
        if (t3) return t3;
        for (const [i3, { check: a3 }] of Object.entries(Gc)) if (a3(e3)) {
          if (t3 = Uh[i3], t3) return this._namespaces.set(e3, t3), t3;
          break;
        }
        return t3 = new UnknownNamespace(++this._nextNsId), this._namespaces.set(e3, t3), t3;
      }
      _addNamespacePrefix(e3) {
        for (const { prefix: t3, value: i3 } of e3) {
          const e4 = this._searchNamespace(i3);
          let a3 = this._namespacePrefixes.get(t3);
          a3 || (a3 = [], this._namespacePrefixes.set(t3, a3)), a3.push(e4);
        }
      }
      _getNamespaceToUse(e3) {
        if (!e3) return this._currentNamespace;
        const t3 = this._namespacePrefixes.get(e3);
        return t3?.length > 0 ? t3.at(-1) : (warn(`Unknown namespace prefix: ${e3}.`), null);
      }
      clean(e3) {
        const { hasNamespace: t3, prefixes: i3, nsAgnostic: a3 } = e3;
        t3 && (this._currentNamespace = this._namespaceStack.pop()), i3 && i3.forEach(({ prefix: e4 }) => {
          this._namespacePrefixes.get(e4).pop();
        }), a3 && this._nsAgnosticLevel--;
      }
    };
    XFAParser = class _XFAParser extends XMLParserBase {
      constructor(e3 = null, t3 = false) {
        super(), this._builder = new Builder(e3), this._stack = [], this._globalData = { usedTypefaces: /* @__PURE__ */ new Set() }, this._ids = /* @__PURE__ */ new Map(), this._current = this._builder.buildRoot(this._ids), this._errorCode = ag, this._whiteRegex = /^\s+$/, this._nbsps = /\xa0+/g, this._richText = t3;
      }
      parse(e3) {
        if (this.parseXml(e3), this._errorCode === ag) return this._current[Ng](), this._current.element;
      }
      onText(e3) {
        e3 = e3.replace(this._nbsps, (e4) => e4.slice(1) + " "), this._richText || this._current[Eg]() ? this._current[dc](e3, this._richText) : this._whiteRegex.test(e3) || this._current[dc](e3.trim());
      }
      onCdata(e3) {
        this._current[dc](e3);
      }
      _mkAttributes(e3, t3) {
        let i3 = null, a3 = null;
        const s3 = /* @__PURE__ */ Object.create({});
        for (const { name: n3, value: r3 } of e3) if ("xmlns" === n3) i3 ? warn(`XFA - multiple namespace definition in <${t3}>`) : i3 = r3;
        else if (n3.startsWith("xmlns:")) {
          const e4 = n3.substring(6);
          a3 || (a3 = []), a3.push({ prefix: e4, value: r3 });
        } else {
          const e4 = n3.indexOf(":");
          if (-1 === e4) s3[n3] = r3;
          else {
            let t4 = s3[lc];
            t4 || (t4 = s3[lc] = /* @__PURE__ */ Object.create(null));
            const [i4, a4] = [n3.slice(0, e4), n3.slice(e4 + 1)];
            (t4[i4] || (t4[i4] = /* @__PURE__ */ Object.create(null)))[a4] = r3;
          }
        }
        return [i3, a3, s3];
      }
      _getNameAndPrefix(e3, t3) {
        const i3 = e3.indexOf(":");
        return -1 === i3 ? [e3, null] : [e3.substring(i3 + 1), t3 ? "" : e3.substring(0, i3)];
      }
      onBeginElement(e3, t3, i3) {
        const [a3, s3, n3] = this._mkAttributes(t3, e3), [r3, o3] = this._getNameAndPrefix(e3, this._builder.isNsAgnostic()), g3 = this._builder.build({ nsPrefix: o3, name: r3, attributes: n3, namespace: a3, prefixes: s3 });
        if (g3[Xg] = this._globalData, i3) return g3[Ng](), this._current[Ic](g3) && g3[yc](this._ids), void g3[yg](this._builder);
        this._stack.push(this._current), this._current = g3;
      }
      onEndElement(e3) {
        const t3 = this._current;
        if (t3[ec]() && "string" == typeof t3[Fg]) {
          const e4 = new _XFAParser();
          e4._globalData = this._globalData;
          const i3 = e4.parse(t3[Fg]);
          t3[Fg] = null, t3[Ic](i3);
        }
        t3[Ng](), this._current = this._stack.pop(), this._current[Ic](t3) && t3[yc](this._ids), t3[yg](this._builder);
      }
      onError(e3) {
        this._errorCode = e3;
      }
    };
    XFAFactory = class _XFAFactory {
      constructor(e3) {
        try {
          this.root = new XFAParser().parse(_XFAFactory._createDocument(e3));
          const t3 = new Binder(this.root);
          this.form = t3.bind(), this.dataHandler = new DataHandler(this.root, t3.getData()), this.form[Xg].template = this.form;
        } catch (e4) {
          warn(`XFA - an error occurred during parsing and binding: ${e4}`);
        }
      }
      isValid() {
        return this.root && this.form;
      }
      _createPagesHelper() {
        const e3 = this.form[Fc]();
        return new Promise((t3, i3) => {
          const nextIteration = () => {
            try {
              const i4 = e3.next();
              i4.done ? t3(i4.value) : setTimeout(nextIteration, 0);
            } catch (e4) {
              i3(e4);
            }
          };
          setTimeout(nextIteration, 0);
        });
      }
      async _createPages() {
        try {
          this.pages = await this._createPagesHelper(), this.dims = this.pages.children.map((e3) => {
            const { width: t3, height: i3 } = e3.attributes.style;
            return [0, 0, parseInt(t3), parseInt(i3)];
          });
        } catch (e3) {
          warn(`XFA - an error occurred during layout: ${e3}`);
        }
      }
      getBoundingBox(e3) {
        return this.dims[e3];
      }
      async getNumPages() {
        return this.pages || await this._createPages(), this.dims.length;
      }
      setImages(e3) {
        this.form[Xg].images = e3;
      }
      setFonts(e3) {
        this.form[Xg].fontFinder = new FontFinder(e3);
        const t3 = [];
        for (let e4 of this.form[Xg].usedTypefaces) {
          e4 = stripQuotes(e4);
          this.form[Xg].fontFinder.find(e4) || t3.push(e4);
        }
        return t3.length > 0 ? t3 : null;
      }
      appendFonts(e3, t3) {
        this.form[Xg].fontFinder.add(e3, t3);
      }
      async getPages() {
        this.pages || await this._createPages();
        const e3 = this.pages;
        return this.pages = null, e3;
      }
      serializeData(e3) {
        return this.dataHandler.serialize(e3);
      }
      static _createDocument(e3) {
        return e3["/xdp:xdp"] ? Object.values(e3).join("") : e3["xdp:xdp"];
      }
      static getRichTextAsHtml(e3) {
        if (!e3 || "string" != typeof e3) return null;
        try {
          let t3 = new XFAParser(XhtmlNamespace, true).parse(e3);
          if (!["body", "xhtml"].includes(t3[hc])) {
            const e4 = XhtmlNamespace.body({});
            e4[pg](t3), t3 = e4;
          }
          const i3 = t3[kc]();
          if (!i3.success) return null;
          const { html: a3 } = i3, { attributes: s3 } = a3;
          return s3 && (s3.class && (s3.class = s3.class.filter((e4) => !e4.startsWith("xfa"))), s3.dir = "auto"), { html: a3, str: t3[Sc]() };
        } catch (e4) {
          warn(`XFA - an error occurred during parsing of rich text: ${e4}`);
        }
        return null;
      }
    };
    AnnotationFactory = class {
      static createGlobals(e3) {
        return Promise.all([e3.ensureCatalog("acroForm"), e3.ensureDoc("xfaDatasets"), e3.ensureCatalog("structTreeRoot"), e3.ensureCatalog("baseUrl"), e3.ensureCatalog("attachments")]).then(([t3, i3, a3, s3, n3]) => ({ pdfManager: e3, acroForm: t3 instanceof Dict ? t3 : Dict.empty, xfaDatasets: i3, structTreeRoot: a3, baseUrl: s3, attachments: n3 }), (e4) => (warn(`createGlobals: "${e4}".`), null));
      }
      static async create(e3, t3, i3, a3, s3, n3) {
        const r3 = s3 ? await this._getPageIndex(e3, t3, i3.pdfManager) : null;
        return i3.pdfManager.ensure(this, "_create", [e3, t3, i3, a3, s3, r3, n3]);
      }
      static _create(e3, t3, i3, a3, s3 = false, n3 = null, r3 = null) {
        const o3 = e3.fetchIfRef(t3);
        if (!(o3 instanceof Dict)) return;
        const { acroForm: g3, pdfManager: c3 } = i3, h3 = t3 instanceof Ref ? t3.toString() : `annot_${a3.createObjId()}`;
        let l3 = o3.get("Subtype");
        l3 = l3 instanceof Name ? l3.name : null;
        const C3 = { xref: e3, ref: t3, dict: o3, subtype: l3, id: h3, annotationGlobals: i3, collectFields: s3, needAppearances: !s3 && true === g3.get("NeedAppearances"), pageIndex: n3, evaluatorOptions: c3.evaluatorOptions, pageRef: r3 };
        switch (l3) {
          case "Link":
            return new LinkAnnotation(C3);
          case "Text":
            return new TextAnnotation(C3);
          case "Widget":
            let e4 = getInheritableProperty({ dict: o3, key: "FT" });
            switch (e4 = e4 instanceof Name ? e4.name : null, e4) {
              case "Tx":
                return new TextWidgetAnnotation(C3);
              case "Btn":
                return new ButtonWidgetAnnotation(C3);
              case "Ch":
                return new ChoiceWidgetAnnotation(C3);
              case "Sig":
                return new SignatureWidgetAnnotation(C3);
            }
            return warn(`Unimplemented widget field type "${e4}", falling back to base field type.`), new WidgetAnnotation(C3);
          case "Popup":
            return new PopupAnnotation(C3);
          case "FreeText":
            return new FreeTextAnnotation(C3);
          case "Line":
            return new LineAnnotation(C3);
          case "Square":
            return new SquareAnnotation(C3);
          case "Circle":
            return new CircleAnnotation(C3);
          case "PolyLine":
            return new PolylineAnnotation(C3);
          case "Polygon":
            return new PolygonAnnotation(C3);
          case "Caret":
            return new CaretAnnotation(C3);
          case "Ink":
            return new InkAnnotation(C3);
          case "Highlight":
            return new HighlightAnnotation(C3);
          case "Underline":
            return new UnderlineAnnotation(C3);
          case "Squiggly":
            return new SquigglyAnnotation(C3);
          case "StrikeOut":
            return new StrikeOutAnnotation(C3);
          case "Stamp":
            return new StampAnnotation(C3);
          case "FileAttachment":
            return new FileAttachmentAnnotation(C3);
          default:
            return s3 || warn(l3 ? `Unimplemented annotation type "${l3}", falling back to base annotation.` : "Annotation is missing the required /Subtype."), new Annotation(C3);
        }
      }
      static async _getPageIndex(e3, t3, i3) {
        try {
          const a3 = await e3.fetchIfRefAsync(t3);
          if (!(a3 instanceof Dict)) return -1;
          const s3 = a3.getRaw("P");
          if (s3 instanceof Ref) try {
            return await i3.ensureCatalog("getPageIndex", [s3]);
          } catch (e4) {
            info(`_getPageIndex -- not a valid page reference: "${e4}".`);
          }
          if (a3.has("Kids")) return -1;
          const n3 = await i3.ensureDoc("numPages");
          for (let e4 = 0; e4 < n3; e4++) {
            const a4 = await i3.getPage(e4), s4 = await i3.ensure(a4, "annotations");
            for (const i4 of s4) if (i4 instanceof Ref && isRefsEqual(i4, t3)) return e4;
          }
        } catch (e4) {
          warn(`_getPageIndex: "${e4}".`);
        }
        return -1;
      }
      static generateImages(e3, t3, i3) {
        if (!i3) return warn("generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images."), null;
        let a3;
        for (const { bitmapId: i4, bitmap: s3 } of e3) s3 && (a3 || (a3 = /* @__PURE__ */ new Map()), a3.set(i4, StampAnnotation.createImage(s3, t3)));
        return a3;
      }
      static async saveNewAnnotations(e3, t3, i3, a3) {
        const s3 = e3.xref;
        let n3;
        const r3 = [], o3 = [], { isOffscreenCanvasSupported: g3 } = e3.options;
        for (const c3 of i3) if (!c3.deleted) switch (c3.annotationType) {
          case JA:
            if (!n3) {
              const e4 = new Dict(s3);
              e4.set("BaseFont", Name.get("Helvetica")), e4.set("Type", Name.get("Font")), e4.set("Subtype", Name.get("Type1")), e4.set("Encoding", Name.get("WinAnsiEncoding"));
              const t4 = [];
              n3 = s3.getNewTemporaryRef(), await writeObject(n3, e4, t4, s3), r3.push({ ref: n3, data: t4.join("") });
            }
            o3.push(FreeTextAnnotation.createNewAnnotation(s3, c3, r3, { evaluator: e3, task: t3, baseFontRef: n3 }));
            break;
          case YA:
            c3.quadPoints ? o3.push(HighlightAnnotation.createNewAnnotation(s3, c3, r3)) : o3.push(InkAnnotation.createNewAnnotation(s3, c3, r3));
            break;
          case OA:
            o3.push(InkAnnotation.createNewAnnotation(s3, c3, r3));
            break;
          case PA:
            if (!g3) break;
            const i4 = await a3.get(c3.bitmapId);
            if (i4.imageStream) {
              const { imageStream: e4, smaskStream: t4 } = i4, a4 = [];
              if (t4) {
                const i5 = s3.getNewTemporaryRef();
                await writeObject(i5, t4, a4, s3), r3.push({ ref: i5, data: a4.join("") }), e4.dict.set("SMask", i5), a4.length = 0;
              }
              const n4 = i4.imageRef = s3.getNewTemporaryRef();
              await writeObject(n4, e4, a4, s3), r3.push({ ref: n4, data: a4.join("") }), i4.imageStream = i4.smaskStream = null;
            }
            o3.push(StampAnnotation.createNewAnnotation(s3, c3, r3, { image: i4 }));
        }
        return { annotations: await Promise.all(o3), dependencies: r3 };
      }
      static async printNewAnnotations(e3, t3, i3, a3, s3) {
        if (!a3) return null;
        const { options: n3, xref: r3 } = t3, o3 = [];
        for (const g3 of a3) if (!g3.deleted) switch (g3.annotationType) {
          case JA:
            o3.push(FreeTextAnnotation.createNewPrintAnnotation(e3, r3, g3, { evaluator: t3, task: i3, evaluatorOptions: n3 }));
            break;
          case YA:
            g3.quadPoints ? o3.push(HighlightAnnotation.createNewPrintAnnotation(e3, r3, g3, { evaluatorOptions: n3 })) : o3.push(InkAnnotation.createNewPrintAnnotation(e3, r3, g3, { evaluatorOptions: n3 }));
            break;
          case OA:
            o3.push(InkAnnotation.createNewPrintAnnotation(e3, r3, g3, { evaluatorOptions: n3 }));
            break;
          case PA:
            if (!n3.isOffscreenCanvasSupported) break;
            const a4 = await s3.get(g3.bitmapId);
            if (a4.imageStream) {
              const { imageStream: e4, smaskStream: t4 } = a4;
              t4 && e4.dict.set("SMask", t4), a4.imageRef = new JpegStream(e4, e4.length), a4.imageStream = a4.smaskStream = null;
            }
            o3.push(StampAnnotation.createNewPrintAnnotation(e3, r3, g3, { image: a4, evaluatorOptions: n3 }));
        }
        return Promise.all(o3);
      }
    };
    Annotation = class {
      constructor(e3) {
        const { dict: t3, xref: i3, annotationGlobals: a3 } = e3;
        this.setTitle(t3.get("T")), this.setContents(t3.get("Contents")), this.setModificationDate(t3.get("M")), this.setFlags(t3.get("F")), this.setRectangle(t3.getArray("Rect")), this.setColor(t3.getArray("C")), this.setBorderStyle(t3), this.setAppearance(t3), this.setOptionalContent(t3);
        const s3 = t3.get("MK");
        this.setBorderAndBackgroundColors(s3), this.setRotation(s3, t3), this.ref = e3.ref instanceof Ref ? e3.ref : null, this._streams = [], this.appearance && this._streams.push(this.appearance);
        const n3 = !!(this.flags & pi), r3 = !!(this.flags & mi);
        if (a3.structTreeRoot) {
          let i4 = t3.get("StructParent");
          i4 = Number.isInteger(i4) && i4 >= 0 ? i4 : -1, a3.structTreeRoot.addAnnotationIdToPage(e3.pageRef, i4);
        }
        if (this.data = { annotationFlags: this.flags, borderStyle: this.borderStyle, color: this.color, backgroundColor: this.backgroundColor, borderColor: this.borderColor, rotation: this.rotation, contentsObj: this._contents, hasAppearance: !!this.appearance, id: e3.id, modificationDate: this.modificationDate, rect: this.rectangle, subtype: e3.subtype, hasOwnCanvas: false, noRotate: !!(this.flags & Ei), noHTML: n3 && r3, isEditable: false }, e3.collectFields) {
          const a4 = t3.get("Kids");
          if (Array.isArray(a4)) {
            const e4 = [];
            for (const t4 of a4) t4 instanceof Ref && e4.push(t4.toString());
            0 !== e4.length && (this.data.kidIds = e4);
          }
          this.data.actions = collectActions(i3, t3, Yi), this.data.fieldName = this._constructFieldName(t3), this.data.pageIndex = e3.pageIndex;
        }
        this._isOffscreenCanvasSupported = e3.evaluatorOptions.isOffscreenCanvasSupported, this._fallbackFontDict = null, this._needAppearances = false;
      }
      _hasFlag(e3, t3) {
        return !!(e3 & t3);
      }
      _isViewable(e3) {
        return !this._hasFlag(e3, Bi) && !this._hasFlag(e3, fi);
      }
      _isPrintable(e3) {
        return this._hasFlag(e3, Qi) && !this._hasFlag(e3, ui) && !this._hasFlag(e3, Bi);
      }
      mustBeViewed(e3, t3) {
        const i3 = e3?.get(this.data.id)?.noView;
        return void 0 !== i3 ? !i3 : this.viewable && !this._hasFlag(this.flags, ui);
      }
      mustBePrinted(e3) {
        const t3 = e3?.get(this.data.id)?.noPrint;
        return void 0 !== t3 ? !t3 : this.printable;
      }
      mustBeViewedWhenEditing(e3, t3 = null) {
        return e3 ? !this.data.isEditable : !t3?.has(this.data.id);
      }
      get viewable() {
        return null !== this.data.quadPoints && (0 === this.flags || this._isViewable(this.flags));
      }
      get printable() {
        return null !== this.data.quadPoints && (0 !== this.flags && this._isPrintable(this.flags));
      }
      _parseStringHelper(e3) {
        const t3 = "string" == typeof e3 ? stringToPDFString(e3) : "";
        return { str: t3, dir: t3 && "rtl" === bidi(t3).dir ? "rtl" : "ltr" };
      }
      setDefaultAppearance(e3) {
        const { dict: t3, annotationGlobals: i3 } = e3, a3 = getInheritableProperty({ dict: t3, key: "DA" }) || i3.acroForm.get("DA");
        this._defaultAppearance = "string" == typeof a3 ? a3 : "", this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance);
      }
      setTitle(e3) {
        this._title = this._parseStringHelper(e3);
      }
      setContents(e3) {
        this._contents = this._parseStringHelper(e3);
      }
      setModificationDate(e3) {
        this.modificationDate = "string" == typeof e3 ? e3 : null;
      }
      setFlags(e3) {
        this.flags = Number.isInteger(e3) && e3 > 0 ? e3 : 0, this.flags & Bi && "Annotation" !== this.constructor.name && (this.flags ^= Bi);
      }
      hasFlag(e3) {
        return this._hasFlag(this.flags, e3);
      }
      setRectangle(e3) {
        this.rectangle = lookupNormalRect(e3, [0, 0, 0, 0]);
      }
      setColor(e3) {
        this.color = getRgbColor(e3);
      }
      setLineEndings(e3) {
        if (this.lineEndings = ["None", "None"], Array.isArray(e3) && 2 === e3.length) for (let t3 = 0; t3 < 2; t3++) {
          const i3 = e3[t3];
          if (i3 instanceof Name) switch (i3.name) {
            case "None":
              continue;
            case "Square":
            case "Circle":
            case "Diamond":
            case "OpenArrow":
            case "ClosedArrow":
            case "Butt":
            case "ROpenArrow":
            case "RClosedArrow":
            case "Slash":
              this.lineEndings[t3] = i3.name;
              continue;
          }
          warn(`Ignoring invalid lineEnding: ${i3}`);
        }
      }
      setRotation(e3, t3) {
        this.rotation = 0;
        let i3 = e3 instanceof Dict ? e3.get("R") || 0 : t3.get("Rotate") || 0;
        Number.isInteger(i3) && 0 !== i3 && (i3 %= 360, i3 < 0 && (i3 += 360), i3 % 90 == 0 && (this.rotation = i3));
      }
      setBorderAndBackgroundColors(e3) {
        e3 instanceof Dict ? (this.borderColor = getRgbColor(e3.getArray("BC"), null), this.backgroundColor = getRgbColor(e3.getArray("BG"), null)) : this.borderColor = this.backgroundColor = null;
      }
      setBorderStyle(e3) {
        if (this.borderStyle = new AnnotationBorderStyle(), e3 instanceof Dict) if (e3.has("BS")) {
          const t3 = e3.get("BS");
          if (t3 instanceof Dict) {
            const e4 = t3.get("Type");
            e4 && !isName(e4, "Border") || (this.borderStyle.setWidth(t3.get("W"), this.rectangle), this.borderStyle.setStyle(t3.get("S")), this.borderStyle.setDashArray(t3.getArray("D")));
          }
        } else if (e3.has("Border")) {
          const t3 = e3.getArray("Border");
          Array.isArray(t3) && t3.length >= 3 && (this.borderStyle.setHorizontalCornerRadius(t3[0]), this.borderStyle.setVerticalCornerRadius(t3[1]), this.borderStyle.setWidth(t3[2], this.rectangle), 4 === t3.length && this.borderStyle.setDashArray(t3[3], true));
        } else this.borderStyle.setWidth(0);
      }
      setAppearance(e3) {
        this.appearance = null;
        const t3 = e3.get("AP");
        if (!(t3 instanceof Dict)) return;
        const i3 = t3.get("N");
        if (i3 instanceof BaseStream) return void (this.appearance = i3);
        if (!(i3 instanceof Dict)) return;
        const a3 = e3.get("AS");
        if (!(a3 instanceof Name && i3.has(a3.name))) return;
        const s3 = i3.get(a3.name);
        s3 instanceof BaseStream && (this.appearance = s3);
      }
      setOptionalContent(e3) {
        this.oc = null;
        const t3 = e3.get("OC");
        t3 instanceof Name ? warn("setOptionalContent: Support for /Name-entry is not implemented.") : t3 instanceof Dict && (this.oc = t3);
      }
      loadResources(e3, t3) {
        return t3.dict.getAsync("Resources").then((t4) => {
          if (!t4) return;
          return new ObjectLoader(t4, e3, t4.xref).load().then(function() {
            return t4;
          });
        });
      }
      async getOperatorList(e3, t3, i3, a3) {
        const { hasOwnCanvas: s3, id: n3, rect: r3 } = this.data;
        let o3 = this.appearance;
        const g3 = !!(s3 && i3 & NA);
        if (g3 && (r3[0] === r3[2] || r3[1] === r3[3])) return this.data.hasOwnCanvas = false, { opList: new OperatorList(), separateForm: false, separateCanvas: false };
        if (!o3) {
          if (!g3) return { opList: new OperatorList(), separateForm: false, separateCanvas: false };
          o3 = new StringStream(""), o3.dict = new Dict();
        }
        const c3 = o3.dict, h3 = await this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"], o3), l3 = lookupRect(c3.getArray("BBox"), [0, 0, 1, 1]), C3 = lookupMatrix(c3.getArray("Matrix"), DA), d3 = getTransformMatrix(r3, l3, C3), u3 = new OperatorList();
        let Q3;
        return this.oc && (Q3 = await e3.parseMarkedContentProps(this.oc, null)), void 0 !== Q3 && u3.addOp(gs, ["OC", Q3]), u3.addOp(us, [n3, r3, d3, C3, g3]), await e3.getOperatorList({ stream: o3, task: t3, resources: h3, operatorList: u3, fallbackFontDict: this._fallbackFontDict }), u3.addOp(Qs, []), void 0 !== Q3 && u3.addOp(cs, []), this.reset(), { opList: u3, separateForm: false, separateCanvas: g3 };
      }
      async save(e3, t3, i3) {
        return null;
      }
      get hasTextContent() {
        return false;
      }
      async extractTextContent(e3, t3, i3) {
        if (!this.appearance) return;
        const a3 = await this.loadResources(["ExtGState", "Font", "Properties", "XObject"], this.appearance), s3 = [], n3 = [];
        let r3 = null;
        const o3 = { desiredSize: Math.Infinity, ready: true, enqueue(e4, t4) {
          for (const t5 of e4.items) void 0 !== t5.str && (r3 || (r3 = t5.transform.slice(-2)), n3.push(t5.str), t5.hasEOL && (s3.push(n3.join("").trimEnd()), n3.length = 0));
        } };
        if (await e3.getTextContent({ stream: this.appearance, task: t3, resources: a3, includeMarkedContent: true, keepWhiteSpace: true, sink: o3, viewBox: i3 }), this.reset(), n3.length && s3.push(n3.join("").trimEnd()), s3.length > 1 || s3[0]) {
          const e4 = this.appearance.dict, t4 = lookupRect(e4.getArray("BBox"), null), i4 = lookupMatrix(e4.getArray("Matrix"), null);
          this.data.textPosition = this._transformPoint(r3, t4, i4), this.data.textContent = s3;
        }
      }
      _transformPoint(e3, t3, i3) {
        const { rect: a3 } = this.data;
        t3 || (t3 = [0, 0, 1, 1]), i3 || (i3 = [1, 0, 0, 1, 0, 0]);
        const s3 = getTransformMatrix(a3, t3, i3);
        return s3[4] -= a3[0], s3[5] -= a3[1], e3 = Util.applyTransform(e3, s3), Util.applyTransform(e3, i3);
      }
      getFieldObject() {
        return this.data.kidIds ? { id: this.data.id, actions: this.data.actions, name: this.data.fieldName, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, type: "", kidIds: this.data.kidIds, page: this.data.pageIndex, rotation: this.rotation } : null;
      }
      reset() {
        for (const e3 of this._streams) e3.reset();
      }
      _constructFieldName(e3) {
        if (!e3.has("T") && !e3.has("Parent")) return warn("Unknown field name, falling back to empty field name."), "";
        if (!e3.has("Parent")) return stringToPDFString(e3.get("T"));
        const t3 = [];
        e3.has("T") && t3.unshift(stringToPDFString(e3.get("T")));
        let i3 = e3;
        const a3 = new RefSet();
        for (e3.objId && a3.put(e3.objId); i3.has("Parent") && (i3 = i3.get("Parent"), i3 instanceof Dict && (!i3.objId || !a3.has(i3.objId))); ) i3.objId && a3.put(i3.objId), i3.has("T") && t3.unshift(stringToPDFString(i3.get("T")));
        return t3.join(".");
      }
    };
    AnnotationBorderStyle = class {
      constructor() {
        this.width = 1, this.style = Gi, this.dashArray = [3], this.horizontalCornerRadius = 0, this.verticalCornerRadius = 0;
      }
      setWidth(e3, t3 = [0, 0, 0, 0]) {
        if (e3 instanceof Name) this.width = 0;
        else if ("number" == typeof e3) {
          if (e3 > 0) {
            const i3 = (t3[2] - t3[0]) / 2, a3 = (t3[3] - t3[1]) / 2;
            i3 > 0 && a3 > 0 && (e3 > i3 || e3 > a3) && (warn(`AnnotationBorderStyle.setWidth - ignoring width: ${e3}`), e3 = 1);
          }
          this.width = e3;
        }
      }
      setStyle(e3) {
        if (e3 instanceof Name) switch (e3.name) {
          case "S":
            this.style = Gi;
            break;
          case "D":
            this.style = vi;
            break;
          case "B":
            this.style = Hi;
            break;
          case "I":
            this.style = Ti;
            break;
          case "U":
            this.style = Ji;
        }
      }
      setDashArray(e3, t3 = false) {
        if (Array.isArray(e3)) {
          let i3 = true, a3 = true;
          for (const t4 of e3) {
            if (!(+t4 >= 0)) {
              i3 = false;
              break;
            }
            t4 > 0 && (a3 = false);
          }
          0 === e3.length || i3 && !a3 ? (this.dashArray = e3, t3 && this.setStyle(Name.get("D"))) : this.width = 0;
        } else e3 && (this.width = 0);
      }
      setHorizontalCornerRadius(e3) {
        Number.isInteger(e3) && (this.horizontalCornerRadius = e3);
      }
      setVerticalCornerRadius(e3) {
        Number.isInteger(e3) && (this.verticalCornerRadius = e3);
      }
    };
    MarkupAnnotation = class extends Annotation {
      constructor(e3) {
        super(e3);
        const { dict: t3 } = e3;
        if (t3.has("IRT")) {
          const e4 = t3.getRaw("IRT");
          this.data.inReplyTo = e4 instanceof Ref ? e4.toString() : null;
          const i4 = t3.get("RT");
          this.data.replyType = i4 instanceof Name ? i4.name : di;
        }
        let i3 = null;
        if (this.data.replyType === Ci) {
          const e4 = t3.get("IRT");
          this.setTitle(e4.get("T")), this.data.titleObj = this._title, this.setContents(e4.get("Contents")), this.data.contentsObj = this._contents, e4.has("CreationDate") ? (this.setCreationDate(e4.get("CreationDate")), this.data.creationDate = this.creationDate) : this.data.creationDate = null, e4.has("M") ? (this.setModificationDate(e4.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, i3 = e4.getRaw("Popup"), e4.has("C") ? (this.setColor(e4.getArray("C")), this.data.color = this.color) : this.data.color = null;
        } else this.data.titleObj = this._title, this.setCreationDate(t3.get("CreationDate")), this.data.creationDate = this.creationDate, i3 = t3.getRaw("Popup"), t3.has("C") || (this.data.color = null);
        this.data.popupRef = i3 instanceof Ref ? i3.toString() : null, t3.has("RC") && (this.data.richText = XFAFactory.getRichTextAsHtml(t3.get("RC")));
      }
      setCreationDate(e3) {
        this.creationDate = "string" == typeof e3 ? e3 : null;
      }
      _setDefaultAppearance({ xref: e3, extra: t3, strokeColor: i3, fillColor: a3, blendMode: s3, strokeAlpha: n3, fillAlpha: r3, pointsCallback: o3 }) {
        let g3 = Number.MAX_VALUE, c3 = Number.MAX_VALUE, h3 = Number.MIN_VALUE, l3 = Number.MIN_VALUE;
        const C3 = ["q"];
        t3 && C3.push(t3), i3 && C3.push(`${i3[0]} ${i3[1]} ${i3[2]} RG`), a3 && C3.push(`${a3[0]} ${a3[1]} ${a3[2]} rg`);
        let d3 = this.data.quadPoints;
        d3 || (d3 = Float32Array.from([this.rectangle[0], this.rectangle[3], this.rectangle[2], this.rectangle[3], this.rectangle[0], this.rectangle[1], this.rectangle[2], this.rectangle[1]]));
        for (let e4 = 0, t4 = d3.length; e4 < t4; e4 += 8) {
          const [t5, i4, a4, s4] = o3(C3, d3.subarray(e4, e4 + 8));
          g3 = Math.min(g3, t5), h3 = Math.max(h3, i4), c3 = Math.min(c3, a4), l3 = Math.max(l3, s4);
        }
        C3.push("Q");
        const u3 = new Dict(e3), Q3 = new Dict(e3);
        Q3.set("Subtype", Name.get("Form"));
        const f3 = new StringStream(C3.join(" "));
        f3.dict = Q3, u3.set("Fm0", f3);
        const p3 = new Dict(e3);
        s3 && p3.set("BM", Name.get(s3)), "number" == typeof n3 && p3.set("CA", n3), "number" == typeof r3 && p3.set("ca", r3);
        const m3 = new Dict(e3);
        m3.set("GS0", p3);
        const y3 = new Dict(e3);
        y3.set("ExtGState", m3), y3.set("XObject", u3);
        const w3 = new Dict(e3);
        w3.set("Resources", y3);
        const b3 = this.data.rect = [g3, c3, h3, l3];
        w3.set("BBox", b3), this.appearance = new StringStream("/GS0 gs /Fm0 Do"), this.appearance.dict = w3, this._streams.push(this.appearance, f3);
      }
      static async createNewAnnotation(e3, t3, i3, a3) {
        let s3;
        t3.ref ? s3 = (await e3.fetchIfRefAsync(t3.ref)).clone() : t3.ref = e3.getNewTemporaryRef();
        const n3 = t3.ref, r3 = await this.createNewAppearanceStream(t3, e3, a3), o3 = [];
        let g3;
        if (r3) {
          const a4 = e3.getNewTemporaryRef();
          g3 = this.createNewDict(t3, e3, { apRef: a4, oldAnnotation: s3 }), await writeObject(a4, r3, o3, e3), i3.push({ ref: a4, data: o3.join("") });
        } else g3 = this.createNewDict(t3, e3, { oldAnnotation: s3 });
        return Number.isInteger(t3.parentTreeId) && g3.set("StructParent", t3.parentTreeId), o3.length = 0, await writeObject(n3, g3, o3, e3), { ref: n3, data: o3.join("") };
      }
      static async createNewPrintAnnotation(e3, t3, i3, a3) {
        const s3 = await this.createNewAppearanceStream(i3, t3, a3), n3 = this.createNewDict(i3, t3, { ap: s3 }), r3 = new this.prototype.constructor({ dict: n3, xref: t3, annotationGlobals: e3, evaluatorOptions: a3.evaluatorOptions });
        return i3.ref && (r3.ref = r3.refToReplace = i3.ref), r3;
      }
    };
    WidgetAnnotation = class _WidgetAnnotation extends Annotation {
      constructor(e3) {
        super(e3);
        const { dict: t3, xref: i3, annotationGlobals: a3 } = e3, s3 = this.data;
        this._needAppearances = e3.needAppearances, s3.annotationType = Ii, void 0 === s3.fieldName && (s3.fieldName = this._constructFieldName(t3)), void 0 === s3.actions && (s3.actions = collectActions(i3, t3, Yi));
        let n3 = getInheritableProperty({ dict: t3, key: "V", getArray: true });
        s3.fieldValue = this._decodeFormValue(n3);
        const r3 = getInheritableProperty({ dict: t3, key: "DV", getArray: true });
        if (s3.defaultFieldValue = this._decodeFormValue(r3), void 0 === n3 && a3.xfaDatasets) {
          const e4 = this._title.str;
          e4 && (this._hasValueFromXFA = true, s3.fieldValue = n3 = a3.xfaDatasets.getValue(e4));
        }
        void 0 === n3 && null !== s3.defaultFieldValue && (s3.fieldValue = s3.defaultFieldValue), s3.alternativeText = stringToPDFString(t3.get("TU") || ""), this.setDefaultAppearance(e3), s3.hasAppearance || (s3.hasAppearance = this._needAppearances && void 0 !== s3.fieldValue && null !== s3.fieldValue);
        const o3 = getInheritableProperty({ dict: t3, key: "FT" });
        s3.fieldType = o3 instanceof Name ? o3.name : null;
        const g3 = getInheritableProperty({ dict: t3, key: "DR" }), c3 = a3.acroForm.get("DR"), h3 = this.appearance?.dict.get("Resources");
        this._fieldResources = { localResources: g3, acroFormResources: c3, appearanceResources: h3, mergedResources: Dict.merge({ xref: i3, dictArray: [g3, h3, c3], mergeSubDicts: true }) }, s3.fieldFlags = getInheritableProperty({ dict: t3, key: "Ff" }), (!Number.isInteger(s3.fieldFlags) || s3.fieldFlags < 0) && (s3.fieldFlags = 0), s3.readOnly = this.hasFieldFlag(yi), s3.required = this.hasFieldFlag(wi), s3.hidden = this._hasFlag(s3.annotationFlags, ui) || this._hasFlag(s3.annotationFlags, fi);
      }
      _decodeFormValue(e3) {
        return Array.isArray(e3) ? e3.filter((e4) => "string" == typeof e4).map((e4) => stringToPDFString(e4)) : e3 instanceof Name ? stringToPDFString(e3.name) : "string" == typeof e3 ? stringToPDFString(e3) : null;
      }
      hasFieldFlag(e3) {
        return !!(this.data.fieldFlags & e3);
      }
      _isViewable(e3) {
        return true;
      }
      mustBeViewed(e3, t3) {
        return t3 ? this.viewable : super.mustBeViewed(e3, t3) && !this._hasFlag(this.flags, fi);
      }
      getRotationMatrix(e3) {
        let t3 = e3?.get(this.data.id)?.rotation;
        if (void 0 === t3 && (t3 = this.rotation), 0 === t3) return DA;
        return getRotationMatrix(t3, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]);
      }
      getBorderAndBackgroundAppearances(e3) {
        let t3 = e3?.get(this.data.id)?.rotation;
        if (void 0 === t3 && (t3 = this.rotation), !this.backgroundColor && !this.borderColor) return "";
        const i3 = this.data.rect[2] - this.data.rect[0], a3 = this.data.rect[3] - this.data.rect[1], s3 = 0 === t3 || 180 === t3 ? `0 0 ${i3} ${a3} re` : `0 0 ${a3} ${i3} re`;
        let n3 = "";
        if (this.backgroundColor && (n3 = `${getPdfColor(this.backgroundColor, true)} ${s3} f `), this.borderColor) {
          n3 += `${this.borderStyle.width || 1} w ${getPdfColor(this.borderColor, false)} ${s3} S `;
        }
        return n3;
      }
      async getOperatorList(e3, t3, i3, a3) {
        if (i3 & vA && !(this instanceof SignatureWidgetAnnotation) && !this.data.noHTML && !this.data.hasOwnCanvas) return { opList: new OperatorList(), separateForm: true, separateCanvas: false };
        if (!this._hasText) return super.getOperatorList(e3, t3, i3, a3);
        const s3 = await this._getAppearance(e3, t3, i3, a3);
        if (this.appearance && null === s3) return super.getOperatorList(e3, t3, i3, a3);
        const n3 = new OperatorList();
        if (!this._defaultAppearance || null === s3) return { opList: n3, separateForm: false, separateCanvas: false };
        const r3 = !!(this.data.hasOwnCanvas && i3 & NA), o3 = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]], g3 = getTransformMatrix(this.data.rect, o3, [1, 0, 0, 1, 0, 0]);
        let c3;
        this.oc && (c3 = await e3.parseMarkedContentProps(this.oc, null)), void 0 !== c3 && n3.addOp(gs, ["OC", c3]), n3.addOp(us, [this.data.id, this.data.rect, g3, this.getRotationMatrix(a3), r3]);
        const h3 = new StringStream(s3);
        return await e3.getOperatorList({ stream: h3, task: t3, resources: this._fieldResources.mergedResources, operatorList: n3 }), n3.addOp(Qs, []), void 0 !== c3 && n3.addOp(cs, []), { opList: n3, separateForm: false, separateCanvas: r3 };
      }
      _getMKDict(e3) {
        const t3 = new Dict(null);
        return e3 && t3.set("R", e3), this.borderColor && t3.set("BC", getPdfColorArray(this.borderColor)), this.backgroundColor && t3.set("BG", getPdfColorArray(this.backgroundColor)), t3.size > 0 ? t3 : null;
      }
      amendSavedDict(e3, t3) {
      }
      async save(e3, t3, i3) {
        const a3 = i3?.get(this.data.id);
        let s3 = a3?.value, n3 = a3?.rotation;
        if (s3 === this.data.fieldValue || void 0 === s3) {
          if (!this._hasValueFromXFA && void 0 === n3) return null;
          s3 || (s3 = this.data.fieldValue);
        }
        if (void 0 === n3 && !this._hasValueFromXFA && Array.isArray(s3) && Array.isArray(this.data.fieldValue) && s3.length === this.data.fieldValue.length && s3.every((e4, t4) => e4 === this.data.fieldValue[t4])) return null;
        void 0 === n3 && (n3 = this.rotation);
        let r3 = null;
        if (!this._needAppearances && (r3 = await this._getAppearance(e3, t3, GA, i3), null === r3)) return null;
        let o3 = false;
        r3?.needAppearances && (o3 = true, r3 = null);
        const { xref: g3 } = e3, c3 = g3.fetchIfRef(this.ref);
        if (!(c3 instanceof Dict)) return null;
        const h3 = new Dict(g3);
        for (const e4 of c3.getKeys()) "AP" !== e4 && h3.set(e4, c3.getRaw(e4));
        const l3 = { path: this.data.fieldName, value: s3 };
        h3.set("V", Array.isArray(s3) ? s3.map(stringToAsciiOrUTF16BE) : stringToAsciiOrUTF16BE(s3)), this.amendSavedDict(i3, h3);
        const C3 = this._getMKDict(n3);
        C3 && h3.set("MK", C3);
        const d3 = [], u3 = [{ ref: this.ref, data: "", xfa: l3, needAppearances: o3 }];
        if (null !== r3) {
          const e4 = g3.getNewTemporaryRef(), t4 = new Dict(g3);
          h3.set("AP", t4), t4.set("N", e4);
          const a4 = this._getSaveFieldResources(g3), s4 = new StringStream(r3), n4 = s4.dict = new Dict(g3);
          n4.set("Subtype", Name.get("Form")), n4.set("Resources", a4), n4.set("BBox", [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]]);
          const o4 = this.getRotationMatrix(i3);
          o4 !== DA && n4.set("Matrix", o4), await writeObject(e4, s4, d3, g3), u3.push({ ref: e4, data: d3.join(""), xfa: null, needAppearances: false }), d3.length = 0;
        }
        return h3.set("M", `D:${getModificationDate()}`), await writeObject(this.ref, h3, d3, g3), u3[0].data = d3.join(""), u3;
      }
      async _getAppearance(e3, t3, i3, a3) {
        if (this.hasFieldFlag(Di)) return null;
        const s3 = a3?.get(this.data.id);
        let n3, r3;
        if (s3 && (n3 = s3.formattedValue || s3.value, r3 = s3.rotation), void 0 === r3 && void 0 === n3 && !this._needAppearances && (!this._hasValueFromXFA || this.appearance)) return null;
        const o3 = this.getBorderAndBackgroundAppearances(a3);
        if (void 0 === n3 && (n3 = this.data.fieldValue, !n3)) return `/Tx BMC q ${o3}Q EMC`;
        if (Array.isArray(n3) && 1 === n3.length && (n3 = n3[0]), assert("string" == typeof n3, "Expected `value` to be a string."), n3 = n3.trim(), this.data.combo) {
          const e4 = this.data.options.find(({ exportValue: e5 }) => n3 === e5);
          n3 = e4?.displayValue || n3;
        }
        if ("" === n3) return `/Tx BMC q ${o3}Q EMC`;
        void 0 === r3 && (r3 = this.rotation);
        let g3, c3 = -1;
        this.data.multiLine ? (g3 = n3.split(/\r\n?|\n/).map((e4) => e4.normalize("NFC")), c3 = g3.length) : g3 = [n3.replace(/\r\n?|\n/, "").normalize("NFC")];
        let h3 = this.data.rect[3] - this.data.rect[1], l3 = this.data.rect[2] - this.data.rect[0];
        90 !== r3 && 270 !== r3 || ([l3, h3] = [h3, l3]), this._defaultAppearance || (this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
        let C3, d3, u3, Q3 = await _WidgetAnnotation._getFontData(e3, t3, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
        const f3 = [];
        let p3 = false;
        for (const e4 of g3) {
          const t4 = Q3.encodeString(e4);
          t4.length > 1 && (p3 = true), f3.push(t4.join(""));
        }
        if (p3 && i3 & GA) return { needAppearances: true };
        if (p3 && this._isOffscreenCanvasSupported) {
          const i4 = this.data.comb ? "monospace" : "sans-serif", a4 = new FakeUnicodeFont(e3.xref, i4), s4 = a4.createFontResources(g3.join("")), r4 = s4.getRaw("Font");
          if (this._fieldResources.mergedResources.has("Font")) {
            const e4 = this._fieldResources.mergedResources.get("Font");
            for (const t4 of r4.getKeys()) e4.set(t4, r4.getRaw(t4));
          } else this._fieldResources.mergedResources.set("Font", r4);
          const o4 = a4.fontName.name;
          Q3 = await _WidgetAnnotation._getFontData(e3, t3, { fontName: o4, fontSize: 0 }, s4);
          for (let e4 = 0, t4 = f3.length; e4 < t4; e4++) f3[e4] = stringToUTF16String(g3[e4]);
          const p4 = Object.assign(/* @__PURE__ */ Object.create(null), this.data.defaultAppearanceData);
          this.data.defaultAppearanceData.fontSize = 0, this.data.defaultAppearanceData.fontName = o4, [C3, d3, u3] = this._computeFontSize(h3 - 2, l3 - 4, n3, Q3, c3), this.data.defaultAppearanceData = p4;
        } else this._isOffscreenCanvasSupported || warn("_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly."), [C3, d3, u3] = this._computeFontSize(h3 - 2, l3 - 4, n3, Q3, c3);
        let m3 = Q3.descent;
        m3 = isNaN(m3) ? RA * u3 : Math.max(RA * u3, Math.abs(m3) * d3);
        const y3 = Math.min(Math.floor((h3 - d3) / 2), 1), w3 = this.data.textAlignment;
        if (this.data.multiLine) return this._getMultilineAppearance(C3, f3, Q3, d3, l3, h3, w3, 2, y3, m3, u3, a3);
        if (this.data.comb) return this._getCombAppearance(C3, Q3, f3[0], d3, l3, h3, 2, y3, m3, u3, a3);
        const b3 = y3 + m3;
        if (0 === w3 || w3 > 2) return `/Tx BMC q ${o3}BT ` + C3 + ` 1 0 0 1 ${numberToString(2)} ${numberToString(b3)} Tm (${escapeString(f3[0])}) Tj ET Q EMC`;
        return `/Tx BMC q ${o3}BT ` + C3 + ` 1 0 0 1 0 0 Tm ${this._renderText(f3[0], Q3, d3, l3, w3, { shift: 0 }, 2, b3)} ET Q EMC`;
      }
      static async _getFontData(e3, t3, i3, a3) {
        const s3 = new OperatorList(), n3 = { font: null, clone() {
          return this;
        } }, { fontName: r3, fontSize: o3 } = i3;
        return await e3.handleSetFont(a3, [r3 && Name.get(r3), o3], null, s3, t3, n3, null), n3.font;
      }
      _getTextWidth(e3, t3) {
        return t3.charsToGlyphs(e3).reduce((e4, t4) => e4 + t4.width, 0) / 1e3;
      }
      _computeFontSize(e3, t3, i3, a3, s3) {
        let { fontSize: n3 } = this.data.defaultAppearanceData, r3 = (n3 || 12) * FA, o3 = Math.round(e3 / r3);
        if (!n3) {
          const roundWithTwoDigits = (e4) => Math.floor(100 * e4) / 100;
          if (-1 === s3) {
            const s4 = this._getTextWidth(i3, a3);
            n3 = roundWithTwoDigits(Math.min(e3 / FA, s4 > t3 ? t3 / s4 : 1 / 0)), o3 = 1;
          } else {
            const g4 = i3.split(/\r\n?|\n/), c4 = [];
            for (const e4 of g4) {
              const t4 = a3.encodeString(e4).join(""), i4 = a3.charsToGlyphs(t4), s4 = a3.getCharPositions(t4);
              c4.push({ line: t4, glyphs: i4, positions: s4 });
            }
            const isTooBig = (i4) => {
              let s4 = 0;
              for (const n4 of c4) {
                if (s4 += this._splitLine(null, a3, i4, t3, n4).length * i4, s4 > e3) return true;
              }
              return false;
            };
            for (o3 = Math.max(o3, s3); r3 = e3 / o3, n3 = roundWithTwoDigits(r3 / FA), isTooBig(n3); ) o3++;
          }
          const { fontName: g3, fontColor: c3 } = this.data.defaultAppearanceData;
          this._defaultAppearance = function({ fontSize: e4, fontName: t4, fontColor: i4 }) {
            return `/${escapePDFName(t4)} ${e4} Tf ${getPdfColor(i4, true)}`;
          }({ fontSize: n3, fontName: g3, fontColor: c3 });
        }
        return [this._defaultAppearance, n3, e3 / o3];
      }
      _renderText(e3, t3, i3, a3, s3, n3, r3, o3) {
        let g3;
        if (1 === s3) {
          g3 = (a3 - this._getTextWidth(e3, t3) * i3) / 2;
        } else if (2 === s3) {
          g3 = a3 - this._getTextWidth(e3, t3) * i3 - r3;
        } else g3 = r3;
        const c3 = numberToString(g3 - n3.shift);
        return n3.shift = g3, `${c3} ${o3 = numberToString(o3)} Td (${escapeString(e3)}) Tj`;
      }
      _getSaveFieldResources(e3) {
        const { localResources: t3, appearanceResources: i3, acroFormResources: a3 } = this._fieldResources, s3 = this.data.defaultAppearanceData?.fontName;
        if (!s3) return t3 || Dict.empty;
        for (const e4 of [t3, i3]) if (e4 instanceof Dict) {
          const t4 = e4.get("Font");
          if (t4 instanceof Dict && t4.has(s3)) return e4;
        }
        if (a3 instanceof Dict) {
          const i4 = a3.get("Font");
          if (i4 instanceof Dict && i4.has(s3)) {
            const a4 = new Dict(e3);
            a4.set(s3, i4.getRaw(s3));
            const n3 = new Dict(e3);
            return n3.set("Font", a4), Dict.merge({ xref: e3, dictArray: [n3, t3], mergeSubDicts: true });
          }
        }
        return t3 || Dict.empty;
      }
      getFieldObject() {
        return null;
      }
    };
    TextWidgetAnnotation = class extends WidgetAnnotation {
      constructor(e3) {
        super(e3);
        const { dict: t3 } = e3;
        t3.has("PMD") && (this.flags |= ui, this.data.hidden = true, warn("Barcodes are not supported")), this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML, this._hasText = true, "string" != typeof this.data.fieldValue && (this.data.fieldValue = "");
        let i3 = getInheritableProperty({ dict: t3, key: "Q" });
        (!Number.isInteger(i3) || i3 < 0 || i3 > 2) && (i3 = null), this.data.textAlignment = i3;
        let a3 = getInheritableProperty({ dict: t3, key: "MaxLen" });
        (!Number.isInteger(a3) || a3 < 0) && (a3 = 0), this.data.maxLen = a3, this.data.multiLine = this.hasFieldFlag(bi), this.data.comb = this.hasFieldFlag(Mi) && !this.hasFieldFlag(bi) && !this.hasFieldFlag(Di) && !this.hasFieldFlag(Ri) && 0 !== this.data.maxLen, this.data.doNotScroll = this.hasFieldFlag(Ni);
      }
      get hasTextContent() {
        return !!this.appearance && !this._needAppearances;
      }
      _getCombAppearance(e3, t3, i3, a3, s3, n3, r3, o3, g3, c3, h3) {
        const l3 = s3 / this.data.maxLen, C3 = this.getBorderAndBackgroundAppearances(h3), d3 = [], u3 = t3.getCharPositions(i3);
        for (const [e4, t4] of u3) d3.push(`(${escapeString(i3.substring(e4, t4))}) Tj`);
        const Q3 = d3.join(` ${numberToString(l3)} 0 Td `);
        return `/Tx BMC q ${C3}BT ` + e3 + ` 1 0 0 1 ${numberToString(r3)} ${numberToString(o3 + g3)} Tm ${Q3} ET Q EMC`;
      }
      _getMultilineAppearance(e3, t3, i3, a3, s3, n3, r3, o3, g3, c3, h3, l3) {
        const C3 = [], d3 = s3 - 2 * o3, u3 = { shift: 0 };
        for (let e4 = 0, n4 = t3.length; e4 < n4; e4++) {
          const n5 = t3[e4], l4 = this._splitLine(n5, i3, a3, d3);
          for (let t4 = 0, n6 = l4.length; t4 < n6; t4++) {
            const n7 = l4[t4], d4 = 0 === e4 && 0 === t4 ? -g3 - (h3 - c3) : -h3;
            C3.push(this._renderText(n7, i3, a3, s3, r3, u3, o3, d4));
          }
        }
        const Q3 = this.getBorderAndBackgroundAppearances(l3), f3 = C3.join("\n");
        return `/Tx BMC q ${Q3}BT ` + e3 + ` 1 0 0 1 0 ${numberToString(n3)} Tm ${f3} ET Q EMC`;
      }
      _splitLine(e3, t3, i3, a3, s3 = {}) {
        e3 = s3.line || e3;
        const n3 = s3.glyphs || t3.charsToGlyphs(e3);
        if (n3.length <= 1) return [e3];
        const r3 = s3.positions || t3.getCharPositions(e3), o3 = i3 / 1e3, g3 = [];
        let c3 = -1, h3 = -1, l3 = -1, C3 = 0, d3 = 0;
        for (let t4 = 0, i4 = n3.length; t4 < i4; t4++) {
          const [i5, s4] = r3[t4], u3 = n3[t4], Q3 = u3.width * o3;
          " " === u3.unicode ? d3 + Q3 > a3 ? (g3.push(e3.substring(C3, i5)), C3 = i5, d3 = Q3, c3 = -1, l3 = -1) : (d3 += Q3, c3 = i5, h3 = s4, l3 = t4) : d3 + Q3 > a3 ? -1 !== c3 ? (g3.push(e3.substring(C3, h3)), C3 = h3, t4 = l3 + 1, c3 = -1, d3 = 0) : (g3.push(e3.substring(C3, i5)), C3 = i5, d3 = Q3) : d3 += Q3;
        }
        return C3 < e3.length && g3.push(e3.substring(C3, e3.length)), g3;
      }
      getFieldObject() {
        return { id: this.data.id, value: this.data.fieldValue, defaultValue: this.data.defaultFieldValue || "", multiline: this.data.multiLine, password: this.hasFieldFlag(Di), charLimit: this.data.maxLen, comb: this.data.comb, editable: !this.data.readOnly, hidden: this.data.hidden, name: this.data.fieldName, rect: this.data.rect, actions: this.data.actions, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: "text" };
      }
    };
    ButtonWidgetAnnotation = class extends WidgetAnnotation {
      constructor(e3) {
        super(e3), this.checkedAppearance = null, this.uncheckedAppearance = null, this.data.checkBox = !this.hasFieldFlag(Si) && !this.hasFieldFlag(Fi), this.data.radioButton = this.hasFieldFlag(Si) && !this.hasFieldFlag(Fi), this.data.pushButton = this.hasFieldFlag(Fi), this.data.isTooltipOnly = false, this.data.checkBox ? this._processCheckBox(e3) : this.data.radioButton ? this._processRadioButton(e3) : this.data.pushButton ? (this.data.hasOwnCanvas = true, this.data.noHTML = false, this._processPushButton(e3)) : warn("Invalid field flags for button widget annotation");
      }
      async getOperatorList(e3, t3, i3, a3) {
        if (this.data.pushButton) return super.getOperatorList(e3, t3, i3, false, a3);
        let s3 = null, n3 = null;
        if (a3) {
          const e4 = a3.get(this.data.id);
          s3 = e4 ? e4.value : null, n3 = e4 ? e4.rotation : null;
        }
        if (null === s3 && this.appearance) return super.getOperatorList(e3, t3, i3, a3);
        null == s3 && (s3 = this.data.checkBox ? this.data.fieldValue === this.data.exportValue : this.data.fieldValue === this.data.buttonValue);
        const r3 = s3 ? this.checkedAppearance : this.uncheckedAppearance;
        if (r3) {
          const s4 = this.appearance, o3 = lookupMatrix(r3.dict.getArray("Matrix"), DA);
          n3 && r3.dict.set("Matrix", this.getRotationMatrix(a3)), this.appearance = r3;
          const g3 = super.getOperatorList(e3, t3, i3, a3);
          return this.appearance = s4, r3.dict.set("Matrix", o3), g3;
        }
        return { opList: new OperatorList(), separateForm: false, separateCanvas: false };
      }
      async save(e3, t3, i3) {
        return this.data.checkBox ? this._saveCheckbox(e3, t3, i3) : this.data.radioButton ? this._saveRadioButton(e3, t3, i3) : null;
      }
      async _saveCheckbox(e3, t3, i3) {
        if (!i3) return null;
        const a3 = i3.get(this.data.id);
        let s3 = a3?.rotation, n3 = a3?.value;
        if (void 0 === s3) {
          if (void 0 === n3) return null;
          if (this.data.fieldValue === this.data.exportValue === n3) return null;
        }
        const r3 = e3.xref.fetchIfRef(this.ref);
        if (!(r3 instanceof Dict)) return null;
        void 0 === s3 && (s3 = this.rotation), void 0 === n3 && (n3 = this.data.fieldValue === this.data.exportValue);
        const o3 = { path: this.data.fieldName, value: n3 ? this.data.exportValue : "" }, g3 = Name.get(n3 ? this.data.exportValue : "Off");
        r3.set("V", g3), r3.set("AS", g3), r3.set("M", `D:${getModificationDate()}`);
        const c3 = this._getMKDict(s3);
        c3 && r3.set("MK", c3);
        const h3 = [];
        return await writeObject(this.ref, r3, h3, e3.xref), [{ ref: this.ref, data: h3.join(""), xfa: o3 }];
      }
      async _saveRadioButton(e3, t3, i3) {
        if (!i3) return null;
        const a3 = i3.get(this.data.id);
        let s3 = a3?.rotation, n3 = a3?.value;
        if (void 0 === s3) {
          if (void 0 === n3) return null;
          if (this.data.fieldValue === this.data.buttonValue === n3) return null;
        }
        const r3 = e3.xref.fetchIfRef(this.ref);
        if (!(r3 instanceof Dict)) return null;
        void 0 === n3 && (n3 = this.data.fieldValue === this.data.buttonValue), void 0 === s3 && (s3 = this.rotation);
        const o3 = { path: this.data.fieldName, value: n3 ? this.data.buttonValue : "" }, g3 = Name.get(n3 ? this.data.buttonValue : "Off"), c3 = [];
        let h3 = null;
        if (n3) if (this.parent instanceof Ref) {
          const t4 = e3.xref.fetch(this.parent);
          t4.set("V", g3), await writeObject(this.parent, t4, c3, e3.xref), h3 = c3.join(""), c3.length = 0;
        } else this.parent instanceof Dict && this.parent.set("V", g3);
        r3.set("AS", g3), r3.set("M", `D:${getModificationDate()}`);
        const l3 = this._getMKDict(s3);
        l3 && r3.set("MK", l3), await writeObject(this.ref, r3, c3, e3.xref);
        const C3 = [{ ref: this.ref, data: c3.join(""), xfa: o3 }];
        return h3 && C3.push({ ref: this.parent, data: h3, xfa: null }), C3;
      }
      _getDefaultCheckedAppearance(e3, t3) {
        const i3 = this.data.rect[2] - this.data.rect[0], a3 = this.data.rect[3] - this.data.rect[1], s3 = [0, 0, i3, a3], n3 = 0.8 * Math.min(i3, a3);
        let r3, o3;
        "check" === t3 ? (r3 = { width: 0.755 * n3, height: 0.705 * n3 }, o3 = "3") : "disc" === t3 ? (r3 = { width: 0.791 * n3, height: 0.705 * n3 }, o3 = "l") : unreachable(`_getDefaultCheckedAppearance - unsupported type: ${t3}`);
        const g3 = `q BT /PdfJsZaDb ${n3} Tf 0 g ${numberToString((i3 - r3.width) / 2)} ${numberToString((a3 - r3.height) / 2)} Td (${o3}) Tj ET Q`, c3 = new Dict(e3.xref);
        c3.set("FormType", 1), c3.set("Subtype", Name.get("Form")), c3.set("Type", Name.get("XObject")), c3.set("BBox", s3), c3.set("Matrix", [1, 0, 0, 1, 0, 0]), c3.set("Length", g3.length);
        const h3 = new Dict(e3.xref), l3 = new Dict(e3.xref);
        l3.set("PdfJsZaDb", this.fallbackFontDict), h3.set("Font", l3), c3.set("Resources", h3), this.checkedAppearance = new StringStream(g3), this.checkedAppearance.dict = c3, this._streams.push(this.checkedAppearance);
      }
      _processCheckBox(e3) {
        const t3 = e3.dict.get("AP");
        if (!(t3 instanceof Dict)) return;
        const i3 = t3.get("N");
        if (!(i3 instanceof Dict)) return;
        const a3 = this._decodeFormValue(e3.dict.get("AS"));
        "string" == typeof a3 && (this.data.fieldValue = a3);
        const s3 = null !== this.data.fieldValue && "Off" !== this.data.fieldValue ? this.data.fieldValue : "Yes", n3 = i3.getKeys();
        if (0 === n3.length) n3.push("Off", s3);
        else if (1 === n3.length) "Off" === n3[0] ? n3.push(s3) : n3.unshift("Off");
        else if (n3.includes(s3)) n3.length = 0, n3.push("Off", s3);
        else {
          const e4 = n3.find((e5) => "Off" !== e5);
          n3.length = 0, n3.push("Off", e4);
        }
        n3.includes(this.data.fieldValue) || (this.data.fieldValue = "Off"), this.data.exportValue = n3[1];
        const r3 = i3.get(this.data.exportValue);
        this.checkedAppearance = r3 instanceof BaseStream ? r3 : null;
        const o3 = i3.get("Off");
        this.uncheckedAppearance = o3 instanceof BaseStream ? o3 : null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e3, "check"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict, null === this.data.defaultFieldValue && (this.data.defaultFieldValue = "Off");
      }
      _processRadioButton(e3) {
        this.data.buttonValue = null;
        const t3 = e3.dict.get("Parent");
        if (t3 instanceof Dict) {
          this.parent = e3.dict.getRaw("Parent");
          const i4 = t3.get("V");
          i4 instanceof Name && (this.data.fieldValue = this._decodeFormValue(i4));
        }
        const i3 = e3.dict.get("AP");
        if (!(i3 instanceof Dict)) return;
        const a3 = i3.get("N");
        if (!(a3 instanceof Dict)) return;
        for (const e4 of a3.getKeys()) if ("Off" !== e4) {
          this.data.buttonValue = this._decodeFormValue(e4);
          break;
        }
        const s3 = a3.get(this.data.buttonValue);
        this.checkedAppearance = s3 instanceof BaseStream ? s3 : null;
        const n3 = a3.get("Off");
        this.uncheckedAppearance = n3 instanceof BaseStream ? n3 : null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e3, "disc"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict, null === this.data.defaultFieldValue && (this.data.defaultFieldValue = "Off");
      }
      _processPushButton(e3) {
        const { dict: t3, annotationGlobals: i3 } = e3;
        t3.has("A") || t3.has("AA") || this.data.alternativeText ? (this.data.isTooltipOnly = !t3.has("A") && !t3.has("AA"), Catalog.parseDestDictionary({ destDict: t3, resultObj: this.data, docBaseUrl: i3.baseUrl, docAttachments: i3.attachments })) : warn("Push buttons without action dictionaries are not supported");
      }
      getFieldObject() {
        let e3, t3 = "button";
        return this.data.checkBox ? (t3 = "checkbox", e3 = this.data.exportValue) : this.data.radioButton && (t3 = "radiobutton", e3 = this.data.buttonValue), { id: this.data.id, value: this.data.fieldValue || "Off", defaultValue: this.data.defaultFieldValue, exportValues: e3, editable: !this.data.readOnly, name: this.data.fieldName, rect: this.data.rect, hidden: this.data.hidden, actions: this.data.actions, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: t3 };
      }
      get fallbackFontDict() {
        const e3 = new Dict();
        return e3.set("BaseFont", Name.get("ZapfDingbats")), e3.set("Type", Name.get("FallbackType")), e3.set("Subtype", Name.get("FallbackType")), e3.set("Encoding", Name.get("ZapfDingbatsEncoding")), shadow(this, "fallbackFontDict", e3);
      }
    };
    ChoiceWidgetAnnotation = class extends WidgetAnnotation {
      constructor(e3) {
        super(e3);
        const { dict: t3, xref: i3 } = e3;
        this.indices = t3.getArray("I"), this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0, this.data.options = [];
        const a3 = getInheritableProperty({ dict: t3, key: "Opt" });
        if (Array.isArray(a3)) for (let e4 = 0, t4 = a3.length; e4 < t4; e4++) {
          const t5 = i3.fetchIfRef(a3[e4]), s3 = Array.isArray(t5);
          this.data.options[e4] = { exportValue: this._decodeFormValue(s3 ? i3.fetchIfRef(t5[0]) : t5), displayValue: this._decodeFormValue(s3 ? i3.fetchIfRef(t5[1]) : t5) };
        }
        if (this.hasIndices) {
          this.data.fieldValue = [];
          const e4 = this.data.options.length;
          for (const t4 of this.indices) Number.isInteger(t4) && t4 >= 0 && t4 < e4 && this.data.fieldValue.push(this.data.options[t4].exportValue);
        } else "string" == typeof this.data.fieldValue ? this.data.fieldValue = [this.data.fieldValue] : this.data.fieldValue || (this.data.fieldValue = []);
        this.data.combo = this.hasFieldFlag(ki), this.data.multiSelect = this.hasFieldFlag(xi), this._hasText = true;
      }
      getFieldObject() {
        const e3 = this.data.combo ? "combobox" : "listbox", t3 = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
        return { id: this.data.id, value: t3, defaultValue: this.data.defaultFieldValue, editable: !this.data.readOnly, name: this.data.fieldName, rect: this.data.rect, numItems: this.data.fieldValue.length, multipleSelection: this.data.multiSelect, hidden: this.data.hidden, actions: this.data.actions, items: this.data.options, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: e3 };
      }
      amendSavedDict(e3, t3) {
        if (!this.hasIndices) return;
        let i3 = e3?.get(this.data.id)?.value;
        Array.isArray(i3) || (i3 = [i3]);
        const a3 = [], { options: s3 } = this.data;
        for (let e4 = 0, t4 = 0, n3 = s3.length; e4 < n3; e4++) s3[e4].exportValue === i3[t4] && (a3.push(e4), t4 += 1);
        t3.set("I", a3);
      }
      async _getAppearance(e3, t3, i3, a3) {
        if (this.data.combo) return super._getAppearance(e3, t3, i3, a3);
        let s3, n3;
        const r3 = a3?.get(this.data.id);
        if (r3 && (n3 = r3.rotation, s3 = r3.value), void 0 === n3 && void 0 === s3 && !this._needAppearances) return null;
        void 0 === s3 ? s3 = this.data.fieldValue : Array.isArray(s3) || (s3 = [s3]);
        let o3 = this.data.rect[3] - this.data.rect[1], g3 = this.data.rect[2] - this.data.rect[0];
        90 !== n3 && 270 !== n3 || ([g3, o3] = [o3, g3]);
        const c3 = this.data.options.length, h3 = [];
        for (let e4 = 0; e4 < c3; e4++) {
          const { exportValue: t4 } = this.data.options[e4];
          s3.includes(t4) && h3.push(e4);
        }
        this._defaultAppearance || (this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
        const l3 = await WidgetAnnotation._getFontData(e3, t3, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
        let C3, { fontSize: d3 } = this.data.defaultAppearanceData;
        if (d3) C3 = this._defaultAppearance;
        else {
          const e4 = (o3 - 1) / c3;
          let t4, i4 = -1;
          for (const { displayValue: e5 } of this.data.options) {
            const a4 = this._getTextWidth(e5, l3);
            a4 > i4 && (i4 = a4, t4 = e5);
          }
          [C3, d3] = this._computeFontSize(e4, g3 - 4, t4, l3, -1);
        }
        const u3 = d3 * FA, Q3 = (u3 - d3) / 2, f3 = Math.floor(o3 / u3);
        let p3 = 0;
        if (h3.length > 0) {
          const e4 = Math.min(...h3), t4 = Math.max(...h3);
          p3 = Math.max(0, t4 - f3 + 1), p3 > e4 && (p3 = e4);
        }
        const m3 = Math.min(p3 + f3 + 1, c3), y3 = ["/Tx BMC q", `1 1 ${g3} ${o3} re W n`];
        if (h3.length) {
          y3.push("0.600006 0.756866 0.854904 rg");
          for (const e4 of h3) p3 <= e4 && e4 < m3 && y3.push(`1 ${o3 - (e4 - p3 + 1) * u3} ${g3} ${u3} re f`);
        }
        y3.push("BT", C3, `1 0 0 1 0 ${o3} Tm`);
        const w3 = { shift: 0 };
        for (let e4 = p3; e4 < m3; e4++) {
          const { displayValue: t4 } = this.data.options[e4], i4 = e4 === p3 ? Q3 : 0;
          y3.push(this._renderText(t4, l3, d3, g3, 0, w3, 2, -u3 + i4));
        }
        return y3.push("ET Q EMC"), y3.join("\n");
      }
    };
    SignatureWidgetAnnotation = class extends WidgetAnnotation {
      constructor(e3) {
        super(e3), this.data.fieldValue = null, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !this.data.hasOwnCanvas;
      }
      getFieldObject() {
        return { id: this.data.id, value: null, page: this.data.pageIndex, type: "signature" };
      }
    };
    TextAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3), this.data.noRotate = true, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = false;
        const { dict: t3 } = e3;
        this.data.annotationType = VA, this.data.hasAppearance ? this.data.name = "NoIcon" : (this.data.rect[1] = this.data.rect[3] - 22, this.data.rect[2] = this.data.rect[0] + 22, this.data.name = t3.has("Name") ? t3.get("Name").name : "Note"), t3.has("State") ? (this.data.state = t3.get("State") || null, this.data.stateModel = t3.get("StateModel") || null) : (this.data.state = null, this.data.stateModel = null);
      }
    };
    LinkAnnotation = class extends Annotation {
      constructor(e3) {
        var _a4;
        super(e3);
        const { dict: t3, annotationGlobals: i3 } = e3;
        this.data.annotationType = ZA, this.data.noHTML = false;
        const a3 = getQuadPoints(t3, this.rectangle);
        a3 && (this.data.quadPoints = a3), (_a4 = this.data).borderColor || (_a4.borderColor = this.data.color), Catalog.parseDestDictionary({ destDict: t3, resultObj: this.data, docBaseUrl: i3.baseUrl, docAttachments: i3.attachments });
      }
    };
    PopupAnnotation = class extends Annotation {
      constructor(e3) {
        super(e3);
        const { dict: t3 } = e3;
        this.data.annotationType = hi, this.data.noHTML = false, this.data.rect[0] !== this.data.rect[2] && this.data.rect[1] !== this.data.rect[3] || (this.data.rect = null);
        let i3 = t3.get("Parent");
        if (!i3) return void warn("Popup annotation has a missing or invalid parent annotation.");
        this.data.parentRect = lookupNormalRect(i3.getArray("Rect"), null);
        if (isName(i3.get("RT"), Ci) && (i3 = i3.get("IRT")), i3.has("M") ? (this.setModificationDate(i3.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, i3.has("C") ? (this.setColor(i3.getArray("C")), this.data.color = this.color) : this.data.color = null, !this.viewable) {
          const e4 = i3.get("F");
          this._isViewable(e4) && this.setFlags(e4);
        }
        this.setTitle(i3.get("T")), this.data.titleObj = this._title, this.setContents(i3.get("Contents")), this.data.contentsObj = this._contents, i3.has("RC") && (this.data.richText = XFAFactory.getRichTextAsHtml(i3.get("RC"))), this.data.open = !!t3.get("Open");
      }
    };
    FreeTextAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        var _a4;
        super(e3), this.data.hasOwnCanvas = this.data.noRotate, this.data.isEditable = !this.data.noHTML, this.data.noHTML = false;
        const { evaluatorOptions: t3, xref: i3 } = e3;
        if (this.data.annotationType = zA, this.setDefaultAppearance(e3), this._hasAppearance = !!this.appearance, this._hasAppearance) {
          const { fontColor: e4, fontSize: a3 } = function(e5, t4, i4) {
            return new AppearanceStreamEvaluator(e5, t4, i4).parse();
          }(this.appearance, t3, i3);
          this.data.defaultAppearanceData.fontColor = e4, this.data.defaultAppearanceData.fontSize = a3 || 10;
        } else {
          (_a4 = this.data.defaultAppearanceData).fontSize || (_a4.fontSize = 10);
          const { fontColor: t4, fontSize: a3 } = this.data.defaultAppearanceData;
          if (this._contents.str) {
            this.data.textContent = this._contents.str.split(/\r\n?|\n/).map((e5) => e5.trimEnd());
            const { coords: e4, bbox: t5, matrix: i4 } = FakeUnicodeFont.getFirstPositionInfo(this.rectangle, this.rotation, a3);
            this.data.textPosition = this._transformPoint(e4, t5, i4);
          }
          if (this._isOffscreenCanvasSupported) {
            const s3 = e3.dict.get("CA"), n3 = new FakeUnicodeFont(i3, "sans-serif");
            this.appearance = n3.createAppearance(this._contents.str, this.rectangle, this.rotation, a3, t4, s3), this._streams.push(this.appearance);
          } else warn("FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly.");
        }
      }
      get hasTextContent() {
        return this._hasAppearance;
      }
      static createNewDict(e3, t3, { apRef: i3, ap: a3, oldAnnotation: s3 }) {
        const { color: n3, fontSize: r3, rect: o3, rotation: g3, user: c3, value: h3 } = e3, l3 = s3 || new Dict(t3);
        l3.set("Type", Name.get("Annot")), l3.set("Subtype", Name.get("FreeText")), s3 ? (l3.set("M", `D:${getModificationDate()}`), l3.delete("RC")) : l3.set("CreationDate", `D:${getModificationDate()}`), l3.set("Rect", o3);
        const C3 = `/Helv ${r3} Tf ${getPdfColor(n3, true)}`;
        if (l3.set("DA", C3), l3.set("Contents", stringToAsciiOrUTF16BE(h3)), l3.set("F", 4), l3.set("Border", [0, 0, 0]), l3.set("Rotate", g3), c3 && l3.set("T", stringToAsciiOrUTF16BE(c3)), i3 || a3) {
          const e4 = new Dict(t3);
          l3.set("AP", e4), i3 ? e4.set("N", i3) : e4.set("N", a3);
        }
        return l3;
      }
      static async createNewAppearanceStream(e3, t3, i3) {
        const { baseFontRef: a3, evaluator: s3, task: n3 } = i3, { color: r3, fontSize: o3, rect: g3, rotation: c3, value: h3 } = e3, l3 = new Dict(t3), C3 = new Dict(t3);
        if (a3) C3.set("Helv", a3);
        else {
          const e4 = new Dict(t3);
          e4.set("BaseFont", Name.get("Helvetica")), e4.set("Type", Name.get("Font")), e4.set("Subtype", Name.get("Type1")), e4.set("Encoding", Name.get("WinAnsiEncoding")), C3.set("Helv", e4);
        }
        l3.set("Font", C3);
        const d3 = await WidgetAnnotation._getFontData(s3, n3, { fontName: "Helv", fontSize: o3 }, l3), [u3, Q3, f3, p3] = g3;
        let m3 = f3 - u3, y3 = p3 - Q3;
        c3 % 180 != 0 && ([m3, y3] = [y3, m3]);
        const w3 = h3.split("\n"), b3 = o3 / 1e3;
        let D3 = -1 / 0;
        const S3 = [];
        for (let e4 of w3) {
          const t4 = d3.encodeString(e4);
          if (t4.length > 1) return null;
          e4 = t4.join(""), S3.push(e4);
          let i4 = 0;
          const a4 = d3.charsToGlyphs(e4);
          for (const e5 of a4) i4 += e5.width * b3;
          D3 = Math.max(D3, i4);
        }
        let F3 = 1;
        D3 > m3 && (F3 = m3 / D3);
        let k3 = 1;
        const R3 = FA * o3, x3 = 1 * o3, N3 = R3 * w3.length;
        N3 > y3 && (k3 = y3 / N3);
        const M3 = o3 * Math.min(F3, k3);
        let G3, v3, L3;
        switch (c3) {
          case 0:
            L3 = [1, 0, 0, 1], v3 = [g3[0], g3[1], m3, y3], G3 = [g3[0], g3[3] - x3];
            break;
          case 90:
            L3 = [0, 1, -1, 0], v3 = [g3[1], -g3[2], m3, y3], G3 = [g3[1], -g3[0] - x3];
            break;
          case 180:
            L3 = [-1, 0, 0, -1], v3 = [-g3[2], -g3[3], m3, y3], G3 = [-g3[2], -g3[1] - x3];
            break;
          case 270:
            L3 = [0, -1, 1, 0], v3 = [-g3[3], g3[0], m3, y3], G3 = [-g3[3], g3[2] - x3];
        }
        const U3 = ["q", `${L3.join(" ")} 0 0 cm`, `${v3.join(" ")} re W n`, "BT", `${getPdfColor(r3, true)}`, `0 Tc /Helv ${numberToString(M3)} Tf`];
        U3.push(`${G3.join(" ")} Td (${escapeString(S3[0])}) Tj`);
        const H3 = numberToString(R3);
        for (let e4 = 1, t4 = S3.length; e4 < t4; e4++) {
          const t5 = S3[e4];
          U3.push(`0 -${H3} Td (${escapeString(t5)}) Tj`);
        }
        U3.push("ET", "Q");
        const T3 = U3.join("\n"), J3 = new Dict(t3);
        J3.set("FormType", 1), J3.set("Subtype", Name.get("Form")), J3.set("Type", Name.get("XObject")), J3.set("BBox", g3), J3.set("Resources", l3), J3.set("Matrix", [1, 0, 0, 1, -g3[0], -g3[1]]);
        const Y3 = new StringStream(T3);
        return Y3.dict = J3, Y3;
      }
    };
    LineAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3);
        const { dict: t3, xref: i3 } = e3;
        this.data.annotationType = $A, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = false;
        const a3 = lookupRect(t3.getArray("L"), [0, 0, 0, 0]);
        if (this.data.lineCoordinates = Util.normalizeRect(a3), this.setLineEndings(t3.getArray("LE")), this.data.lineEndings = this.lineEndings, !this.appearance) {
          const e4 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], s3 = t3.get("CA"), n3 = getRgbColor(t3.getArray("IC"), null), r3 = n3 ? getPdfColorArray(n3) : null, o3 = r3 ? s3 : null, g3 = this.borderStyle.width || 1, c3 = 2 * g3, h3 = [this.data.lineCoordinates[0] - c3, this.data.lineCoordinates[1] - c3, this.data.lineCoordinates[2] + c3, this.data.lineCoordinates[3] + c3];
          Util.intersect(this.rectangle, h3) || (this.rectangle = h3), this._setDefaultAppearance({ xref: i3, extra: `${g3} w`, strokeColor: e4, fillColor: r3, strokeAlpha: s3, fillAlpha: o3, pointsCallback: (e5, t4) => (e5.push(`${a3[0]} ${a3[1]} m`, `${a3[2]} ${a3[3]} l`, "S"), [t4[0] - g3, t4[2] + g3, t4[7] - g3, t4[3] + g3]) });
        }
      }
    };
    SquareAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3);
        const { dict: t3, xref: i3 } = e3;
        if (this.data.annotationType = ei, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = false, !this.appearance) {
          const e4 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], a3 = t3.get("CA"), s3 = getRgbColor(t3.getArray("IC"), null), n3 = s3 ? getPdfColorArray(s3) : null, r3 = n3 ? a3 : null;
          if (0 === this.borderStyle.width && !n3) return;
          this._setDefaultAppearance({ xref: i3, extra: `${this.borderStyle.width} w`, strokeColor: e4, fillColor: n3, strokeAlpha: a3, fillAlpha: r3, pointsCallback: (e5, t4) => {
            const i4 = t4[4] + this.borderStyle.width / 2, a4 = t4[5] + this.borderStyle.width / 2, s4 = t4[6] - t4[4] - this.borderStyle.width, r4 = t4[3] - t4[7] - this.borderStyle.width;
            return e5.push(`${i4} ${a4} ${s4} ${r4} re`), n3 ? e5.push("B") : e5.push("S"), [t4[0], t4[2], t4[7], t4[3]];
          } });
        }
      }
    };
    CircleAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3);
        const { dict: t3, xref: i3 } = e3;
        if (this.data.annotationType = ti, !this.appearance) {
          const e4 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], a3 = t3.get("CA"), s3 = getRgbColor(t3.getArray("IC"), null), n3 = s3 ? getPdfColorArray(s3) : null, r3 = n3 ? a3 : null;
          if (0 === this.borderStyle.width && !n3) return;
          const o3 = 4 / 3 * Math.tan(Math.PI / 8);
          this._setDefaultAppearance({ xref: i3, extra: `${this.borderStyle.width} w`, strokeColor: e4, fillColor: n3, strokeAlpha: a3, fillAlpha: r3, pointsCallback: (e5, t4) => {
            const i4 = t4[0] + this.borderStyle.width / 2, a4 = t4[1] - this.borderStyle.width / 2, s4 = t4[6] - this.borderStyle.width / 2, r4 = t4[7] + this.borderStyle.width / 2, g3 = i4 + (s4 - i4) / 2, c3 = a4 + (r4 - a4) / 2, h3 = (s4 - i4) / 2 * o3, l3 = (r4 - a4) / 2 * o3;
            return e5.push(`${g3} ${r4} m`, `${g3 + h3} ${r4} ${s4} ${c3 + l3} ${s4} ${c3} c`, `${s4} ${c3 - l3} ${g3 + h3} ${a4} ${g3} ${a4} c`, `${g3 - h3} ${a4} ${i4} ${c3 - l3} ${i4} ${c3} c`, `${i4} ${c3 + l3} ${g3 - h3} ${r4} ${g3} ${r4} c`, "h"), n3 ? e5.push("B") : e5.push("S"), [t4[0], t4[2], t4[7], t4[3]];
          } });
        }
      }
    };
    PolylineAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3);
        const { dict: t3, xref: i3 } = e3;
        this.data.annotationType = ii, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = false, this.data.vertices = null, this instanceof PolygonAnnotation || (this.setLineEndings(t3.getArray("LE")), this.data.lineEndings = this.lineEndings);
        const a3 = t3.getArray("Vertices");
        if (!isNumberArray(a3, null)) return;
        const s3 = this.data.vertices = Float32Array.from(a3);
        if (!this.appearance) {
          const e4 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], a4 = t3.get("CA"), n3 = this.borderStyle.width || 1, r3 = 2 * n3, o3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let e5 = 0, t4 = s3.length; e5 < t4; e5 += 2) o3[0] = Math.min(o3[0], s3[e5] - r3), o3[1] = Math.min(o3[1], s3[e5 + 1] - r3), o3[2] = Math.max(o3[2], s3[e5] + r3), o3[3] = Math.max(o3[3], s3[e5 + 1] + r3);
          Util.intersect(this.rectangle, o3) || (this.rectangle = o3), this._setDefaultAppearance({ xref: i3, extra: `${n3} w`, strokeColor: e4, strokeAlpha: a4, pointsCallback: (e5, t4) => {
            for (let t5 = 0, i4 = s3.length; t5 < i4; t5 += 2) e5.push(`${s3[t5]} ${s3[t5 + 1]} ${0 === t5 ? "m" : "l"}`);
            return e5.push("S"), [t4[0], t4[2], t4[7], t4[3]];
          } });
        }
      }
    };
    PolygonAnnotation = class extends PolylineAnnotation {
      constructor(e3) {
        super(e3), this.data.annotationType = Ai;
      }
    };
    CaretAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3), this.data.annotationType = gi;
      }
    };
    InkAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3), this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = false;
        const { dict: t3, xref: i3 } = e3;
        this.data.annotationType = ci, this.data.inkLists = [];
        const a3 = t3.getArray("InkList");
        if (Array.isArray(a3)) {
          for (let e4 = 0, t4 = a3.length; e4 < t4; ++e4) {
            if (!Array.isArray(a3[e4])) continue;
            const t5 = new Float32Array(a3[e4].length);
            this.data.inkLists.push(t5);
            for (let s3 = 0, n3 = a3[e4].length; s3 < n3; s3 += 2) {
              const n4 = i3.fetchIfRef(a3[e4][s3]), r3 = i3.fetchIfRef(a3[e4][s3 + 1]);
              "number" == typeof n4 && "number" == typeof r3 && (t5[s3] = n4, t5[s3 + 1] = r3);
            }
          }
          if (!this.appearance) {
            const e4 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], a4 = t3.get("CA"), s3 = this.borderStyle.width || 1, n3 = 2 * s3, r3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (const e5 of this.data.inkLists) for (let t4 = 0, i4 = e5.length; t4 < i4; t4 += 2) r3[0] = Math.min(r3[0], e5[t4] - n3), r3[1] = Math.min(r3[1], e5[t4 + 1] - n3), r3[2] = Math.max(r3[2], e5[t4] + n3), r3[3] = Math.max(r3[3], e5[t4 + 1] + n3);
            Util.intersect(this.rectangle, r3) || (this.rectangle = r3), this._setDefaultAppearance({ xref: i3, extra: `${s3} w`, strokeColor: e4, strokeAlpha: a4, pointsCallback: (e5, t4) => {
              for (const t5 of this.data.inkLists) {
                for (let i4 = 0, a5 = t5.length; i4 < a5; i4 += 2) e5.push(`${t5[i4]} ${t5[i4 + 1]} ${0 === i4 ? "m" : "l"}`);
                e5.push("S");
              }
              return [t4[0], t4[2], t4[7], t4[3]];
            } });
          }
        }
      }
      static createNewDict(e3, t3, { apRef: i3, ap: a3 }) {
        const { color: s3, opacity: n3, paths: r3, outlines: o3, rect: g3, rotation: c3, thickness: h3 } = e3, l3 = new Dict(t3);
        l3.set("Type", Name.get("Annot")), l3.set("Subtype", Name.get("Ink")), l3.set("CreationDate", `D:${getModificationDate()}`), l3.set("Rect", g3), l3.set("InkList", o3?.points || r3.map((e4) => e4.points)), l3.set("F", 4), l3.set("Rotate", c3), o3 && l3.set("IT", Name.get("InkHighlight"));
        const C3 = new Dict(t3);
        l3.set("BS", C3), C3.set("W", h3), l3.set("C", Array.from(s3, (e4) => e4 / 255)), l3.set("CA", n3);
        const d3 = new Dict(t3);
        return l3.set("AP", d3), i3 ? d3.set("N", i3) : d3.set("N", a3), l3;
      }
      static async createNewAppearanceStream(e3, t3, i3) {
        if (e3.outlines) return this.createNewAppearanceStreamForHighlight(e3, t3, i3);
        const { color: a3, rect: s3, paths: n3, thickness: r3, opacity: o3 } = e3, g3 = [`${r3} w 1 J 1 j`, `${getPdfColor(a3, false)}`];
        1 !== o3 && g3.push("/R0 gs");
        const c3 = [];
        for (const { bezier: e4 } of n3) {
          if (c3.length = 0, c3.push(`${numberToString(e4[0])} ${numberToString(e4[1])} m`), 2 === e4.length) c3.push(`${numberToString(e4[0])} ${numberToString(e4[1])} l S`);
          else {
            for (let t4 = 2, i4 = e4.length; t4 < i4; t4 += 6) {
              const i5 = e4.slice(t4, t4 + 6).map(numberToString).join(" ");
              c3.push(`${i5} c`);
            }
            c3.push("S");
          }
          g3.push(c3.join("\n"));
        }
        const h3 = g3.join("\n"), l3 = new Dict(t3);
        if (l3.set("FormType", 1), l3.set("Subtype", Name.get("Form")), l3.set("Type", Name.get("XObject")), l3.set("BBox", s3), l3.set("Length", h3.length), 1 !== o3) {
          const e4 = new Dict(t3), i4 = new Dict(t3), a4 = new Dict(t3);
          a4.set("CA", o3), a4.set("Type", Name.get("ExtGState")), i4.set("R0", a4), e4.set("ExtGState", i4), l3.set("Resources", e4);
        }
        const C3 = new StringStream(h3);
        return C3.dict = l3, C3;
      }
      static async createNewAppearanceStreamForHighlight(e3, t3, i3) {
        const { color: a3, rect: s3, outlines: { outline: n3 }, opacity: r3 } = e3, o3 = [`${getPdfColor(a3, true)}`, "/R0 gs"];
        o3.push(`${numberToString(n3[4])} ${numberToString(n3[5])} m`);
        for (let e4 = 6, t4 = n3.length; e4 < t4; e4 += 6) if (isNaN(n3[e4]) || null === n3[e4]) o3.push(`${numberToString(n3[e4 + 4])} ${numberToString(n3[e4 + 5])} l`);
        else {
          const t5 = n3.slice(e4, e4 + 6).map(numberToString).join(" ");
          o3.push(`${t5} c`);
        }
        o3.push("h f");
        const g3 = o3.join("\n"), c3 = new Dict(t3);
        c3.set("FormType", 1), c3.set("Subtype", Name.get("Form")), c3.set("Type", Name.get("XObject")), c3.set("BBox", s3), c3.set("Length", g3.length);
        const h3 = new Dict(t3), l3 = new Dict(t3);
        h3.set("ExtGState", l3), c3.set("Resources", h3);
        const C3 = new Dict(t3);
        l3.set("R0", C3), C3.set("BM", Name.get("Multiply")), 1 !== r3 && (C3.set("ca", r3), C3.set("Type", Name.get("ExtGState")));
        const d3 = new StringStream(g3);
        return d3.dict = c3, d3;
      }
    };
    HighlightAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3);
        const { dict: t3, xref: i3 } = e3;
        this.data.annotationType = ai;
        if (this.data.quadPoints = getQuadPoints(t3, null)) {
          const e4 = this.appearance?.dict.get("Resources");
          if (!this.appearance || !e4?.has("ExtGState")) {
            this.appearance && warn("HighlightAnnotation - ignoring built-in appearance stream.");
            const e5 = this.color ? getPdfColorArray(this.color) : [1, 1, 0], a3 = t3.get("CA");
            this._setDefaultAppearance({ xref: i3, fillColor: e5, blendMode: "Multiply", fillAlpha: a3, pointsCallback: (e6, t4) => (e6.push(`${t4[0]} ${t4[1]} m`, `${t4[2]} ${t4[3]} l`, `${t4[6]} ${t4[7]} l`, `${t4[4]} ${t4[5]} l`, "f"), [t4[0], t4[2], t4[7], t4[3]]) });
          }
        } else this.data.popupRef = null;
      }
      static createNewDict(e3, t3, { apRef: i3, ap: a3 }) {
        const { color: s3, opacity: n3, rect: r3, rotation: o3, user: g3, quadPoints: c3 } = e3, h3 = new Dict(t3);
        if (h3.set("Type", Name.get("Annot")), h3.set("Subtype", Name.get("Highlight")), h3.set("CreationDate", `D:${getModificationDate()}`), h3.set("Rect", r3), h3.set("F", 4), h3.set("Border", [0, 0, 0]), h3.set("Rotate", o3), h3.set("QuadPoints", c3), h3.set("C", Array.from(s3, (e4) => e4 / 255)), h3.set("CA", n3), g3 && h3.set("T", stringToAsciiOrUTF16BE(g3)), i3 || a3) {
          const e4 = new Dict(t3);
          h3.set("AP", e4), e4.set("N", i3 || a3);
        }
        return h3;
      }
      static async createNewAppearanceStream(e3, t3, i3) {
        const { color: a3, rect: s3, outlines: n3, opacity: r3 } = e3, o3 = [`${getPdfColor(a3, true)}`, "/R0 gs"], g3 = [];
        for (const e4 of n3) {
          g3.length = 0, g3.push(`${numberToString(e4[0])} ${numberToString(e4[1])} m`);
          for (let t4 = 2, i4 = e4.length; t4 < i4; t4 += 2) g3.push(`${numberToString(e4[t4])} ${numberToString(e4[t4 + 1])} l`);
          g3.push("h"), o3.push(g3.join("\n"));
        }
        o3.push("f*");
        const c3 = o3.join("\n"), h3 = new Dict(t3);
        h3.set("FormType", 1), h3.set("Subtype", Name.get("Form")), h3.set("Type", Name.get("XObject")), h3.set("BBox", s3), h3.set("Length", c3.length);
        const l3 = new Dict(t3), C3 = new Dict(t3);
        l3.set("ExtGState", C3), h3.set("Resources", l3);
        const d3 = new Dict(t3);
        C3.set("R0", d3), d3.set("BM", Name.get("Multiply")), 1 !== r3 && (d3.set("ca", r3), d3.set("Type", Name.get("ExtGState")));
        const u3 = new StringStream(c3);
        return u3.dict = h3, u3;
      }
    };
    UnderlineAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3);
        const { dict: t3, xref: i3 } = e3;
        this.data.annotationType = si;
        if (this.data.quadPoints = getQuadPoints(t3, null)) {
          if (!this.appearance) {
            const e4 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], a3 = t3.get("CA");
            this._setDefaultAppearance({ xref: i3, extra: "[] 0 d 0.571 w", strokeColor: e4, strokeAlpha: a3, pointsCallback: (e5, t4) => (e5.push(`${t4[4]} ${t4[5] + 1.3} m`, `${t4[6]} ${t4[7] + 1.3} l`, "S"), [t4[0], t4[2], t4[7], t4[3]]) });
          }
        } else this.data.popupRef = null;
      }
    };
    SquigglyAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3);
        const { dict: t3, xref: i3 } = e3;
        this.data.annotationType = ni;
        if (this.data.quadPoints = getQuadPoints(t3, null)) {
          if (!this.appearance) {
            const e4 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], a3 = t3.get("CA");
            this._setDefaultAppearance({ xref: i3, extra: "[] 0 d 1 w", strokeColor: e4, strokeAlpha: a3, pointsCallback: (e5, t4) => {
              const i4 = (t4[1] - t4[5]) / 6;
              let a4 = i4, s3 = t4[4];
              const n3 = t4[5], r3 = t4[6];
              e5.push(`${s3} ${n3 + a4} m`);
              do {
                s3 += 2, a4 = 0 === a4 ? i4 : 0, e5.push(`${s3} ${n3 + a4} l`);
              } while (s3 < r3);
              return e5.push("S"), [t4[4], r3, n3 - 2 * i4, n3 + 2 * i4];
            } });
          }
        } else this.data.popupRef = null;
      }
    };
    StrikeOutAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3);
        const { dict: t3, xref: i3 } = e3;
        this.data.annotationType = ri;
        if (this.data.quadPoints = getQuadPoints(t3, null)) {
          if (!this.appearance) {
            const e4 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], a3 = t3.get("CA");
            this._setDefaultAppearance({ xref: i3, extra: "[] 0 d 1 w", strokeColor: e4, strokeAlpha: a3, pointsCallback: (e5, t4) => (e5.push((t4[0] + t4[4]) / 2 + " " + (t4[1] + t4[5]) / 2 + " m", (t4[2] + t4[6]) / 2 + " " + (t4[3] + t4[7]) / 2 + " l", "S"), [t4[0], t4[2], t4[7], t4[3]]) });
          }
        } else this.data.popupRef = null;
      }
    };
    StampAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3), this.data.annotationType = oi, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = false;
      }
      static async createImage(e3, t3) {
        const { width: i3, height: a3 } = e3, s3 = new OffscreenCanvas(i3, a3), n3 = s3.getContext("2d", { alpha: true });
        n3.drawImage(e3, 0, 0);
        const r3 = n3.getImageData(0, 0, i3, a3).data, o3 = new Uint32Array(r3.buffer), g3 = o3.some(FeatureTest.isLittleEndian ? (e4) => e4 >>> 24 != 255 : (e4) => !!(255 & ~e4));
        g3 && (n3.fillStyle = "white", n3.fillRect(0, 0, i3, a3), n3.drawImage(e3, 0, 0));
        const c3 = s3.convertToBlob({ type: "image/jpeg", quality: 1 }).then((e4) => e4.arrayBuffer()), h3 = Name.get("XObject"), l3 = Name.get("Image"), C3 = new Dict(t3);
        C3.set("Type", h3), C3.set("Subtype", l3), C3.set("BitsPerComponent", 8), C3.set("ColorSpace", Name.get("DeviceRGB")), C3.set("Filter", Name.get("DCTDecode")), C3.set("BBox", [0, 0, i3, a3]), C3.set("Width", i3), C3.set("Height", a3);
        let d3 = null;
        if (g3) {
          const e4 = new Uint8Array(o3.length);
          if (FeatureTest.isLittleEndian) for (let t4 = 0, i4 = o3.length; t4 < i4; t4++) e4[t4] = o3[t4] >>> 24;
          else for (let t4 = 0, i4 = o3.length; t4 < i4; t4++) e4[t4] = 255 & o3[t4];
          const s4 = new Dict(t3);
          s4.set("Type", h3), s4.set("Subtype", l3), s4.set("BitsPerComponent", 8), s4.set("ColorSpace", Name.get("DeviceGray")), s4.set("Width", i3), s4.set("Height", a3), d3 = new Stream(e4, 0, 0, s4);
        }
        return { imageStream: new Stream(await c3, 0, 0, C3), smaskStream: d3, width: i3, height: a3 };
      }
      static createNewDict(e3, t3, { apRef: i3, ap: a3 }) {
        const { rect: s3, rotation: n3, user: r3 } = e3, o3 = new Dict(t3);
        if (o3.set("Type", Name.get("Annot")), o3.set("Subtype", Name.get("Stamp")), o3.set("CreationDate", `D:${getModificationDate()}`), o3.set("Rect", s3), o3.set("F", 4), o3.set("Border", [0, 0, 0]), o3.set("Rotate", n3), r3 && o3.set("T", stringToAsciiOrUTF16BE(r3)), i3 || a3) {
          const e4 = new Dict(t3);
          o3.set("AP", e4), i3 ? e4.set("N", i3) : e4.set("N", a3);
        }
        return o3;
      }
      static async createNewAppearanceStream(e3, t3, i3) {
        const { rotation: a3 } = e3, { imageRef: s3, width: n3, height: r3 } = i3.image, o3 = new Dict(t3), g3 = new Dict(t3);
        o3.set("XObject", g3), g3.set("Im0", s3);
        const c3 = `q ${n3} 0 0 ${r3} 0 0 cm /Im0 Do Q`, h3 = new Dict(t3);
        if (h3.set("FormType", 1), h3.set("Subtype", Name.get("Form")), h3.set("Type", Name.get("XObject")), h3.set("BBox", [0, 0, n3, r3]), h3.set("Resources", o3), a3) {
          const e4 = getRotationMatrix(a3, n3, r3);
          h3.set("Matrix", e4);
        }
        const l3 = new StringStream(c3);
        return l3.dict = h3, l3;
      }
    };
    FileAttachmentAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3);
        const { dict: t3, xref: i3 } = e3, a3 = new FileSpec(t3.get("FS"), i3);
        this.data.annotationType = li, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = false, this.data.file = a3.serializable;
        const s3 = t3.get("Name");
        this.data.name = s3 instanceof Name ? stringToPDFString(s3.name) : "PushPin";
        const n3 = t3.get("ca");
        this.data.fillAlpha = "number" == typeof n3 && n3 >= 0 && n3 <= 1 ? n3 : null;
      }
    };
    DatasetXMLParser = class extends SimpleXMLParser {
      constructor(e3) {
        super(e3), this.node = null;
      }
      onEndElement(e3) {
        const t3 = super.onEndElement(e3);
        if (t3 && "xfa:datasets" === e3) throw this.node = t3, new Error("Aborting DatasetXMLParser.");
      }
    };
    DatasetReader = class {
      constructor(e3) {
        if (e3.datasets) this.node = new SimpleXMLParser({ hasAttributes: true }).parseFromString(e3.datasets).documentElement;
        else {
          const t3 = new DatasetXMLParser({ hasAttributes: true });
          try {
            t3.parseFromString(e3["xdp:xdp"]);
          } catch {
          }
          this.node = t3.node;
        }
      }
      getValue(e3) {
        if (!this.node || !e3) return "";
        const t3 = this.node.searchNode(parseXFAPath(e3), 0);
        if (!t3) return "";
        const i3 = t3.firstChild;
        return "value" === i3?.nodeName ? t3.children.map((e4) => decodeString(e4.textContent)) : decodeString(t3.textContent);
      }
    };
    XRef = class {
      constructor(e3, t3) {
        __privateAdd(this, _Y, null);
        this.stream = e3, this.pdfManager = t3, this.entries = [], this._xrefStms = /* @__PURE__ */ new Set(), this._cacheMap = /* @__PURE__ */ new Map(), this._pendingRefs = new RefSet(), this._newPersistentRefNum = null, this._newTemporaryRefNum = null, this._persistentRefsCache = null;
      }
      getNewPersistentRef(e3) {
        null === this._newPersistentRefNum && (this._newPersistentRefNum = this.entries.length || 1);
        const t3 = this._newPersistentRefNum++;
        return this._cacheMap.set(t3, e3), Ref.get(t3, 0);
      }
      getNewTemporaryRef() {
        if (null === this._newTemporaryRefNum && (this._newTemporaryRefNum = this.entries.length || 1, this._newPersistentRefNum)) {
          this._persistentRefsCache = /* @__PURE__ */ new Map();
          for (let e3 = this._newTemporaryRefNum; e3 < this._newPersistentRefNum; e3++) this._persistentRefsCache.set(e3, this._cacheMap.get(e3)), this._cacheMap.delete(e3);
        }
        return Ref.get(this._newTemporaryRefNum++, 0);
      }
      resetNewTemporaryRef() {
        if (this._newTemporaryRefNum = null, this._persistentRefsCache) for (const [e3, t3] of this._persistentRefsCache) this._cacheMap.set(e3, t3);
        this._persistentRefsCache = null;
      }
      setStartXRef(e3) {
        this.startXRefQueue = [e3];
      }
      parse(e3 = false) {
        let t3, i3, a3;
        e3 ? (warn("Indexing all PDF objects"), t3 = this.indexObjects()) : t3 = this.readXRef(), t3.assignXref(this), this.trailer = t3;
        try {
          i3 = t3.get("Encrypt");
        } catch (e4) {
          if (e4 instanceof MissingDataException) throw e4;
          warn(`XRef.parse - Invalid "Encrypt" reference: "${e4}".`);
        }
        if (i3 instanceof Dict) {
          const e4 = t3.get("ID"), a4 = e4?.length ? e4[0] : "";
          i3.suppressEncryption = true, this.encrypt = new CipherTransformFactory(i3, a4, this.pdfManager.password);
        }
        try {
          a3 = t3.get("Root");
        } catch (e4) {
          if (e4 instanceof MissingDataException) throw e4;
          warn(`XRef.parse - Invalid "Root" reference: "${e4}".`);
        }
        if (a3 instanceof Dict) try {
          if (a3.get("Pages") instanceof Dict) return void (this.root = a3);
        } catch (e4) {
          if (e4 instanceof MissingDataException) throw e4;
          warn(`XRef.parse - Invalid "Pages" reference: "${e4}".`);
        }
        if (!e3) throw new XRefParseException();
        throw new InvalidPDFException("Invalid Root reference.");
      }
      processXRefTable(e3) {
        "tableState" in this || (this.tableState = { entryNum: 0, streamPos: e3.lexer.stream.pos, parserBuf1: e3.buf1, parserBuf2: e3.buf2 });
        if (!isCmd(this.readXRefTable(e3), "trailer")) throw new FormatError("Invalid XRef table: could not find trailer dictionary");
        let t3 = e3.getObj();
        if (t3 instanceof Dict || !t3.dict || (t3 = t3.dict), !(t3 instanceof Dict)) throw new FormatError("Invalid XRef table: could not parse trailer dictionary");
        return delete this.tableState, t3;
      }
      readXRefTable(e3) {
        const t3 = e3.lexer.stream, i3 = this.tableState;
        let a3;
        for (t3.pos = i3.streamPos, e3.buf1 = i3.parserBuf1, e3.buf2 = i3.parserBuf2; ; ) {
          if (!("firstEntryNum" in i3) || !("entryCount" in i3)) {
            if (isCmd(a3 = e3.getObj(), "trailer")) break;
            i3.firstEntryNum = a3, i3.entryCount = e3.getObj();
          }
          let s3 = i3.firstEntryNum;
          const n3 = i3.entryCount;
          if (!Number.isInteger(s3) || !Number.isInteger(n3)) throw new FormatError("Invalid XRef table: wrong types in subsection header");
          for (let a4 = i3.entryNum; a4 < n3; a4++) {
            i3.streamPos = t3.pos, i3.entryNum = a4, i3.parserBuf1 = e3.buf1, i3.parserBuf2 = e3.buf2;
            const r3 = {};
            r3.offset = e3.getObj(), r3.gen = e3.getObj();
            const o3 = e3.getObj();
            if (o3 instanceof Cmd) switch (o3.cmd) {
              case "f":
                r3.free = true;
                break;
              case "n":
                r3.uncompressed = true;
            }
            if (!Number.isInteger(r3.offset) || !Number.isInteger(r3.gen) || !r3.free && !r3.uncompressed) throw new FormatError(`Invalid entry in XRef subsection: ${s3}, ${n3}`);
            0 === a4 && r3.free && 1 === s3 && (s3 = 0), this.entries[a4 + s3] || (this.entries[a4 + s3] = r3);
          }
          i3.entryNum = 0, i3.streamPos = t3.pos, i3.parserBuf1 = e3.buf1, i3.parserBuf2 = e3.buf2, delete i3.firstEntryNum, delete i3.entryCount;
        }
        if (this.entries[0] && !this.entries[0].free) throw new FormatError("Invalid XRef table: unexpected first object");
        return a3;
      }
      processXRefStream(e3) {
        if (!("streamState" in this)) {
          const t3 = e3.dict, i3 = t3.get("W");
          let a3 = t3.get("Index");
          a3 || (a3 = [0, t3.get("Size")]), this.streamState = { entryRanges: a3, byteWidths: i3, entryNum: 0, streamPos: e3.pos };
        }
        return this.readXRefStream(e3), delete this.streamState, e3.dict;
      }
      readXRefStream(e3) {
        const t3 = this.streamState;
        e3.pos = t3.streamPos;
        const [i3, a3, s3] = t3.byteWidths, n3 = t3.entryRanges;
        for (; n3.length > 0; ) {
          const [r3, o3] = n3;
          if (!Number.isInteger(r3) || !Number.isInteger(o3)) throw new FormatError(`Invalid XRef range fields: ${r3}, ${o3}`);
          if (!Number.isInteger(i3) || !Number.isInteger(a3) || !Number.isInteger(s3)) throw new FormatError(`Invalid XRef entry fields length: ${r3}, ${o3}`);
          for (let n4 = t3.entryNum; n4 < o3; ++n4) {
            t3.entryNum = n4, t3.streamPos = e3.pos;
            let o4 = 0, g3 = 0, c3 = 0;
            for (let t4 = 0; t4 < i3; ++t4) {
              const t5 = e3.getByte();
              if (-1 === t5) throw new FormatError("Invalid XRef byteWidths 'type'.");
              o4 = o4 << 8 | t5;
            }
            0 === i3 && (o4 = 1);
            for (let t4 = 0; t4 < a3; ++t4) {
              const t5 = e3.getByte();
              if (-1 === t5) throw new FormatError("Invalid XRef byteWidths 'offset'.");
              g3 = g3 << 8 | t5;
            }
            for (let t4 = 0; t4 < s3; ++t4) {
              const t5 = e3.getByte();
              if (-1 === t5) throw new FormatError("Invalid XRef byteWidths 'generation'.");
              c3 = c3 << 8 | t5;
            }
            const h3 = {};
            switch (h3.offset = g3, h3.gen = c3, o4) {
              case 0:
                h3.free = true;
                break;
              case 1:
                h3.uncompressed = true;
                break;
              case 2:
                break;
              default:
                throw new FormatError(`Invalid XRef entry type: ${o4}`);
            }
            this.entries[r3 + n4] || (this.entries[r3 + n4] = h3);
          }
          t3.entryNum = 0, t3.streamPos = e3.pos, n3.splice(0, 2);
        }
      }
      indexObjects() {
        function readToken(e4, t4) {
          let i4 = "", a4 = e4[t4];
          for (; 10 !== a4 && 13 !== a4 && 60 !== a4 && !(++t4 >= e4.length); ) i4 += String.fromCharCode(a4), a4 = e4[t4];
          return i4;
        }
        function skipUntil(e4, t4, i4) {
          const a4 = i4.length, s4 = e4.length;
          let n4 = 0;
          for (; t4 < s4; ) {
            let s5 = 0;
            for (; s5 < a4 && e4[t4 + s5] === i4[s5]; ) ++s5;
            if (s5 >= a4) break;
            t4++, n4++;
          }
          return n4;
        }
        const e3 = /\b(endobj|\d+\s+\d+\s+obj|xref|trailer\s*<<)\b/g, t3 = /\b(startxref|\d+\s+\d+\s+obj)\b/g, i3 = /^(\d+)\s+(\d+)\s+obj\b/, a3 = new Uint8Array([116, 114, 97, 105, 108, 101, 114]), s3 = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), n3 = new Uint8Array([47, 88, 82, 101, 102]);
        this.entries.length = 0, this._cacheMap.clear();
        const r3 = this.stream;
        r3.pos = 0;
        const o3 = r3.getBytes(), g3 = bytesToString(o3), c3 = o3.length;
        let h3 = r3.start;
        const l3 = [], C3 = [];
        for (; h3 < c3; ) {
          let d4 = o3[h3];
          if (9 === d4 || 10 === d4 || 13 === d4 || 32 === d4) {
            ++h3;
            continue;
          }
          if (37 === d4) {
            do {
              if (++h3, h3 >= c3) break;
              d4 = o3[h3];
            } while (10 !== d4 && 13 !== d4);
            continue;
          }
          const u4 = readToken(o3, h3);
          let Q4;
          if (u4.startsWith("xref") && (4 === u4.length || /\s/.test(u4[4]))) h3 += skipUntil(o3, h3, a3), l3.push(h3), h3 += skipUntil(o3, h3, s3);
          else if (Q4 = i3.exec(u4)) {
            const t4 = 0 | Q4[1], i4 = 0 | Q4[2], a4 = h3 + u4.length;
            let s4, l4 = false;
            if (this.entries[t4]) {
              if (this.entries[t4].gen === i4) try {
                new Parser({ lexer: new Lexer(r3.makeSubStream(a4)) }).getObj(), l4 = true;
              } catch (e4) {
                e4 instanceof ParserEOFException ? warn(`indexObjects -- checking object (${u4}): "${e4}".`) : l4 = true;
              }
            } else l4 = true;
            l4 && (this.entries[t4] = { offset: h3 - r3.start, gen: i4, uncompressed: true }), e3.lastIndex = a4;
            const d5 = e3.exec(g3);
            if (d5) {
              s4 = e3.lastIndex + 1 - h3, "endobj" !== d5[1] && (warn(`indexObjects: Found "${d5[1]}" inside of another "obj", caused by missing "endobj" -- trying to recover.`), s4 -= d5[1].length + 1);
            } else s4 = c3 - h3;
            const f4 = o3.subarray(h3, h3 + s4), p3 = skipUntil(f4, 0, n3);
            p3 < s4 && f4[p3 + 5] < 64 && (C3.push(h3 - r3.start), this._xrefStms.add(h3 - r3.start)), h3 += s4;
          } else if (u4.startsWith("trailer") && (7 === u4.length || /\s/.test(u4[7]))) {
            l3.push(h3);
            const e4 = h3 + u4.length;
            let i4;
            t3.lastIndex = e4;
            const a4 = t3.exec(g3);
            if (a4) {
              i4 = t3.lastIndex + 1 - h3, "startxref" !== a4[1] && (warn(`indexObjects: Found "${a4[1]}" after "trailer", caused by missing "startxref" -- trying to recover.`), i4 -= a4[1].length + 1);
            } else i4 = c3 - h3;
            h3 += i4;
          } else h3 += u4.length + 1;
        }
        for (const e4 of C3) this.startXRefQueue.push(e4), this.readXRef(true);
        const d3 = [];
        let u3, Q3, f3 = false;
        for (const e4 of l3) {
          r3.pos = e4;
          const t4 = new Parser({ lexer: new Lexer(r3), xref: this, allowStreams: true, recoveryMode: true });
          if (!isCmd(t4.getObj(), "trailer")) continue;
          const i4 = t4.getObj();
          i4 instanceof Dict && (d3.push(i4), i4.has("Encrypt") && (f3 = true));
        }
        for (const e4 of [...d3, "genFallback", ...d3]) {
          if ("genFallback" === e4) {
            if (!Q3) break;
            this._generationFallback = true;
            continue;
          }
          let t4 = false;
          try {
            const i4 = e4.get("Root");
            if (!(i4 instanceof Dict)) continue;
            const a4 = i4.get("Pages");
            if (!(a4 instanceof Dict)) continue;
            const s4 = a4.get("Count");
            Number.isInteger(s4) && (t4 = true);
          } catch (e5) {
            Q3 = e5;
            continue;
          }
          if (t4 && (!f3 || e4.has("Encrypt")) && e4.has("ID")) return e4;
          u3 = e4;
        }
        if (u3) return u3;
        if (this.topDict) return this.topDict;
        throw new InvalidPDFException("Invalid PDF structure.");
      }
      readXRef(e3 = false) {
        const t3 = this.stream, i3 = /* @__PURE__ */ new Set();
        for (; this.startXRefQueue.length; ) {
          try {
            const e4 = this.startXRefQueue[0];
            if (i3.has(e4)) {
              warn("readXRef - skipping XRef table since it was already parsed."), this.startXRefQueue.shift();
              continue;
            }
            i3.add(e4), t3.pos = e4 + t3.start;
            const a3 = new Parser({ lexer: new Lexer(t3), xref: this, allowStreams: true });
            let s3, n3 = a3.getObj();
            if (isCmd(n3, "xref")) s3 = this.processXRefTable(a3), this.topDict || (this.topDict = s3), n3 = s3.get("XRefStm"), Number.isInteger(n3) && !this._xrefStms.has(n3) && (this._xrefStms.add(n3), this.startXRefQueue.push(n3), __privateGet(this, _Y) ?? __privateSet(this, _Y, n3));
            else {
              if (!Number.isInteger(n3)) throw new FormatError("Invalid XRef stream header");
              if (!(Number.isInteger(a3.getObj()) && isCmd(a3.getObj(), "obj") && (n3 = a3.getObj()) instanceof BaseStream)) throw new FormatError("Invalid XRef stream");
              if (s3 = this.processXRefStream(n3), this.topDict || (this.topDict = s3), !s3) throw new FormatError("Failed to read XRef stream");
            }
            n3 = s3.get("Prev"), Number.isInteger(n3) ? this.startXRefQueue.push(n3) : n3 instanceof Ref && this.startXRefQueue.push(n3.num);
          } catch (e4) {
            if (e4 instanceof MissingDataException) throw e4;
            info("(while reading XRef): " + e4);
          }
          this.startXRefQueue.shift();
        }
        if (this.topDict) return this.topDict;
        if (!e3) throw new XRefParseException();
      }
      get lastXRefStreamPos() {
        return __privateGet(this, _Y) ?? (this._xrefStms.size > 0 ? Math.max(...this._xrefStms) : null);
      }
      getEntry(e3) {
        const t3 = this.entries[e3];
        return t3 && !t3.free && t3.offset ? t3 : null;
      }
      fetchIfRef(e3, t3 = false) {
        return e3 instanceof Ref ? this.fetch(e3, t3) : e3;
      }
      fetch(e3, t3 = false) {
        if (!(e3 instanceof Ref)) throw new Error("ref object is not a reference");
        const i3 = e3.num, a3 = this._cacheMap.get(i3);
        if (void 0 !== a3) return a3 instanceof Dict && !a3.objId && (a3.objId = e3.toString()), a3;
        let s3 = this.getEntry(i3);
        if (null === s3) return this._cacheMap.set(i3, s3), s3;
        if (this._pendingRefs.has(e3)) return this._pendingRefs.remove(e3), warn(`Ignoring circular reference: ${e3}.`), js;
        this._pendingRefs.put(e3);
        try {
          s3 = s3.uncompressed ? this.fetchUncompressed(e3, s3, t3) : this.fetchCompressed(e3, s3, t3), this._pendingRefs.remove(e3);
        } catch (t4) {
          throw this._pendingRefs.remove(e3), t4;
        }
        return s3 instanceof Dict ? s3.objId = e3.toString() : s3 instanceof BaseStream && (s3.dict.objId = e3.toString()), s3;
      }
      fetchUncompressed(e3, t3, i3 = false) {
        const a3 = e3.gen;
        let s3 = e3.num;
        if (t3.gen !== a3) {
          const n4 = `Inconsistent generation in XRef: ${e3}`;
          if (this._generationFallback && t3.gen < a3) return warn(n4), this.fetchUncompressed(Ref.get(s3, t3.gen), t3, i3);
          throw new XRefEntryException(n4);
        }
        const n3 = this.stream.makeSubStream(t3.offset + this.stream.start), r3 = new Parser({ lexer: new Lexer(n3), xref: this, allowStreams: true }), o3 = r3.getObj(), g3 = r3.getObj(), c3 = r3.getObj();
        if (o3 !== s3 || g3 !== a3 || !(c3 instanceof Cmd)) throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${e3}`);
        if ("obj" !== c3.cmd) {
          if (c3.cmd.startsWith("obj") && (s3 = parseInt(c3.cmd.substring(3), 10), !Number.isNaN(s3))) return s3;
          throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${e3}`);
        }
        return (t3 = this.encrypt && !i3 ? r3.getObj(this.encrypt.createCipherTransform(s3, a3)) : r3.getObj()) instanceof BaseStream || this._cacheMap.set(s3, t3), t3;
      }
      fetchCompressed(e3, t3, i3 = false) {
        const a3 = t3.offset, s3 = this.fetch(Ref.get(a3, 0));
        if (!(s3 instanceof BaseStream)) throw new FormatError("bad ObjStm stream");
        const n3 = s3.dict.get("First"), r3 = s3.dict.get("N");
        if (!Number.isInteger(n3) || !Number.isInteger(r3)) throw new FormatError("invalid first and n parameters for ObjStm stream");
        let o3 = new Parser({ lexer: new Lexer(s3), xref: this, allowStreams: true });
        const g3 = new Array(r3), c3 = new Array(r3);
        for (let e4 = 0; e4 < r3; ++e4) {
          const t4 = o3.getObj();
          if (!Number.isInteger(t4)) throw new FormatError(`invalid object number in the ObjStm stream: ${t4}`);
          const i4 = o3.getObj();
          if (!Number.isInteger(i4)) throw new FormatError(`invalid object offset in the ObjStm stream: ${i4}`);
          g3[e4] = t4, c3[e4] = i4;
        }
        const h3 = (s3.start || 0) + n3, l3 = new Array(r3);
        for (let e4 = 0; e4 < r3; ++e4) {
          const t4 = e4 < r3 - 1 ? c3[e4 + 1] - c3[e4] : void 0;
          if (t4 < 0) throw new FormatError("Invalid offset in the ObjStm stream.");
          o3 = new Parser({ lexer: new Lexer(s3.makeSubStream(h3 + c3[e4], t4, s3.dict)), xref: this, allowStreams: true });
          const i4 = o3.getObj();
          if (l3[e4] = i4, i4 instanceof BaseStream) continue;
          const n4 = g3[e4], C3 = this.entries[n4];
          C3 && C3.offset === a3 && C3.gen === e4 && this._cacheMap.set(n4, i4);
        }
        if (void 0 === (t3 = l3[t3.gen])) throw new XRefEntryException(`Bad (compressed) XRef entry: ${e3}`);
        return t3;
      }
      async fetchIfRefAsync(e3, t3) {
        return e3 instanceof Ref ? this.fetchAsync(e3, t3) : e3;
      }
      async fetchAsync(e3, t3) {
        try {
          return this.fetch(e3, t3);
        } catch (i3) {
          if (!(i3 instanceof MissingDataException)) throw i3;
          return await this.pdfManager.requestRange(i3.begin, i3.end), this.fetchAsync(e3, t3);
        }
      }
      getCatalogObj() {
        return this.root;
      }
    };
    _Y = new WeakMap();
    Hh = [0, 0, 612, 792];
    Page = class {
      constructor({ pdfManager: e3, xref: t3, pageIndex: i3, pageDict: a3, ref: s3, globalIdFactory: n3, fontCache: r3, builtInCMapCache: o3, standardFontDataCache: g3, globalImageCache: c3, systemFontCache: h3, nonBlendModesSet: l3, xfaFactory: C3 }) {
        __privateAdd(this, _Page_instances);
        this.pdfManager = e3, this.pageIndex = i3, this.pageDict = a3, this.xref = t3, this.ref = s3, this.fontCache = r3, this.builtInCMapCache = o3, this.standardFontDataCache = g3, this.globalImageCache = c3, this.systemFontCache = h3, this.nonBlendModesSet = l3, this.evaluatorOptions = e3.evaluatorOptions, this.resourcesPromise = null, this.xfaFactory = C3;
        const d3 = { obj: 0 };
        this._localIdFactory = class extends n3 {
          static createObjId() {
            return `p${i3}_${++d3.obj}`;
          }
          static getPageObjId() {
            return `p${s3.toString()}`;
          }
        };
      }
      _getInheritableProperty(e3, t3 = false) {
        const i3 = getInheritableProperty({ dict: this.pageDict, key: e3, getArray: t3, stopWhenFound: false });
        return Array.isArray(i3) ? 1 !== i3.length && i3[0] instanceof Dict ? Dict.merge({ xref: this.xref, dictArray: i3 }) : i3[0] : i3;
      }
      get content() {
        return this.pageDict.getArray("Contents");
      }
      get resources() {
        const e3 = this._getInheritableProperty("Resources");
        return shadow(this, "resources", e3 instanceof Dict ? e3 : Dict.empty);
      }
      _getBoundingBox(e3) {
        if (this.xfaData) return this.xfaData.bbox;
        const t3 = lookupNormalRect(this._getInheritableProperty(e3, true), null);
        if (t3) {
          if (t3[2] - t3[0] > 0 && t3[3] - t3[1] > 0) return t3;
          warn(`Empty, or invalid, /${e3} entry.`);
        }
        return null;
      }
      get mediaBox() {
        return shadow(this, "mediaBox", this._getBoundingBox("MediaBox") || Hh);
      }
      get cropBox() {
        return shadow(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox);
      }
      get userUnit() {
        let e3 = this.pageDict.get("UserUnit");
        return ("number" != typeof e3 || e3 <= 0) && (e3 = 1), shadow(this, "userUnit", e3);
      }
      get view() {
        const { cropBox: e3, mediaBox: t3 } = this;
        if (e3 !== t3 && !isArrayEqual(e3, t3)) {
          const i3 = Util.intersect(e3, t3);
          if (i3 && i3[2] - i3[0] > 0 && i3[3] - i3[1] > 0) return shadow(this, "view", i3);
          warn("Empty /CropBox and /MediaBox intersection.");
        }
        return shadow(this, "view", t3);
      }
      get rotate() {
        let e3 = this._getInheritableProperty("Rotate") || 0;
        return e3 % 90 != 0 ? e3 = 0 : e3 >= 360 ? e3 %= 360 : e3 < 0 && (e3 = (e3 % 360 + 360) % 360), shadow(this, "rotate", e3);
      }
      _onSubStreamError(e3, t3) {
        if (!this.evaluatorOptions.ignoreErrors) throw e3;
        warn(`getContentStream - ignoring sub-stream (${t3}): "${e3}".`);
      }
      getContentStream() {
        return this.pdfManager.ensure(this, "content").then((e3) => e3 instanceof BaseStream ? e3 : Array.isArray(e3) ? new StreamsSequenceStream(e3, this._onSubStreamError.bind(this)) : new NullStream());
      }
      get xfaData() {
        return shadow(this, "xfaData", this.xfaFactory ? { bbox: this.xfaFactory.getBoundingBox(this.pageIndex) } : null);
      }
      async saveNewAnnotations(e3, t3, i3, a3) {
        if (this.xfaFactory) throw new Error("XFA: Cannot save new annotations.");
        const s3 = new PartialEvaluator({ xref: this.xref, handler: e3, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions }), n3 = new RefSetCache(), r3 = new RefSet();
        __privateMethod(this, _Page_instances, P_fn).call(this, i3, n3, r3);
        const o3 = this.pageDict, g3 = this.annotations.filter((e4) => !(e4 instanceof Ref && n3.has(e4))), c3 = await AnnotationFactory.saveNewAnnotations(s3, t3, i3, a3);
        for (const { ref: e4 } of c3.annotations) e4 instanceof Ref && !r3.has(e4) && g3.push(e4);
        const h3 = o3.get("Annots");
        o3.set("Annots", g3);
        const l3 = [];
        await writeObject(this.ref, o3, l3, this.xref), h3 && o3.set("Annots", h3);
        const C3 = c3.dependencies;
        C3.push({ ref: this.ref, data: l3.join("") }, ...c3.annotations);
        for (const e4 of n3) C3.push({ ref: e4, data: null });
        return C3;
      }
      save(e3, t3, i3) {
        const a3 = new PartialEvaluator({ xref: this.xref, handler: e3, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions });
        return this._parsedAnnotations.then(function(e4) {
          const s3 = [];
          for (const n3 of e4) n3.mustBePrinted(i3) && s3.push(n3.save(a3, t3, i3).catch(function(e5) {
            return warn(`save - ignoring annotation data during "${t3.name}" task: "${e5}".`), null;
          }));
          return Promise.all(s3).then(function(e5) {
            return e5.filter((e6) => !!e6);
          });
        });
      }
      loadResources(e3) {
        return this.resourcesPromise || (this.resourcesPromise = this.pdfManager.ensure(this, "resources")), this.resourcesPromise.then(() => new ObjectLoader(this.resources, e3, this.xref).load());
      }
      getOperatorList({ handler: e3, sink: t3, task: i3, intent: a3, cacheKey: s3, annotationStorage: n3 = null, modifiedIds: r3 = null }) {
        const o3 = this.getContentStream(), g3 = this.loadResources(["ColorSpace", "ExtGState", "Font", "Pattern", "Properties", "Shading", "XObject"]), c3 = new PartialEvaluator({ xref: this.xref, handler: e3, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions }), h3 = this.xfaFactory ? null : getNewAnnotationsMap(n3), l3 = h3?.get(this.pageIndex);
        let C3 = Promise.resolve(null), d3 = null;
        if (l3) {
          const e4 = this.pdfManager.ensureDoc("annotationGlobals");
          let t4;
          const a4 = /* @__PURE__ */ new Set();
          for (const { bitmapId: e5, bitmap: t5 } of l3) !e5 || t5 || a4.has(e5) || a4.add(e5);
          const { isOffscreenCanvasSupported: s4 } = this.evaluatorOptions;
          if (a4.size > 0) {
            const e5 = l3.slice();
            for (const [t5, i4] of n3) t5.startsWith(TA) && i4.bitmap && a4.has(i4.bitmapId) && e5.push(i4);
            t4 = AnnotationFactory.generateImages(e5, this.xref, s4);
          } else t4 = AnnotationFactory.generateImages(l3, this.xref, s4);
          d3 = new RefSet(), __privateMethod(this, _Page_instances, P_fn).call(this, l3, d3, null), C3 = e4.then((e5) => e5 ? AnnotationFactory.printNewAnnotations(e5, c3, i3, l3, t4) : null);
        }
        const u3 = Promise.all([o3, g3]).then(([n4]) => {
          const r4 = new OperatorList(a3, t3);
          return e3.send("StartRenderPage", { transparency: c3.hasBlendModes(this.resources, this.nonBlendModesSet), pageIndex: this.pageIndex, cacheKey: s3 }), c3.getOperatorList({ stream: n4, task: i3, resources: this.resources, operatorList: r4 }).then(function() {
            return r4;
          });
        });
        return Promise.all([u3, this._parsedAnnotations, C3]).then(function([e4, t4, s4]) {
          if (s4) {
            t4 = t4.filter((e5) => !(e5.ref && d3.has(e5.ref)));
            for (let e5 = 0, i4 = s4.length; e5 < i4; e5++) {
              const a4 = s4[e5];
              if (a4.refToReplace) {
                const n4 = t4.findIndex((e6) => e6.ref && isRefsEqual(e6.ref, a4.refToReplace));
                n4 >= 0 && (t4.splice(n4, 1, a4), s4.splice(e5--, 1), i4--);
              }
            }
            t4 = t4.concat(s4);
          }
          if (0 === t4.length || a3 & LA) return e4.flush(true), { length: e4.totalLength };
          const o4 = !!(a3 & vA), g4 = !!(a3 & UA), h4 = !!(a3 & xA), l4 = !!(a3 & NA), C4 = !!(a3 & MA), u4 = [];
          for (const e5 of t4) (h4 || l4 && e5.mustBeViewed(n3, o4) && e5.mustBeViewedWhenEditing(g4, r3) || C4 && e5.mustBePrinted(n3)) && u4.push(e5.getOperatorList(c3, i3, a3, n3).catch(function(e6) {
            return warn(`getOperatorList - ignoring annotation data during "${i3.name}" task: "${e6}".`), { opList: null, separateForm: false, separateCanvas: false };
          }));
          return Promise.all(u4).then(function(t5) {
            let i4 = false, a4 = false;
            for (const { opList: s5, separateForm: n4, separateCanvas: r4 } of t5) e4.addOpList(s5), i4 || (i4 = n4), a4 || (a4 = r4);
            return e4.flush(true, { form: i4, canvas: a4 }), { length: e4.totalLength };
          });
        });
      }
      async extractTextContent({ handler: e3, task: t3, includeMarkedContent: i3, disableNormalization: a3, sink: s3 }) {
        const n3 = this.getContentStream(), r3 = this.loadResources(["ExtGState", "Font", "Properties", "XObject"]), o3 = this.pdfManager.ensureCatalog("lang"), [g3, , c3] = await Promise.all([n3, r3, o3]);
        return new PartialEvaluator({ xref: this.xref, handler: e3, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions }).getTextContent({ stream: g3, task: t3, resources: this.resources, includeMarkedContent: i3, disableNormalization: a3, sink: s3, viewBox: this.view, lang: c3 });
      }
      async getStructTree() {
        const e3 = await this.pdfManager.ensureCatalog("structTreeRoot");
        if (!e3) return null;
        await this._parsedAnnotations;
        return (await this.pdfManager.ensure(this, "_parseStructTree", [e3])).serializable;
      }
      _parseStructTree(e3) {
        const t3 = new StructTreePage(e3, this.pageDict);
        return t3.parse(this.ref), t3;
      }
      async getAnnotationsData(e3, t3, i3) {
        const a3 = await this._parsedAnnotations;
        if (0 === a3.length) return a3;
        const s3 = [], n3 = [];
        let r3;
        const o3 = !!(i3 & xA), g3 = !!(i3 & NA), c3 = !!(i3 & MA);
        for (const i4 of a3) {
          const a4 = o3 || g3 && i4.viewable;
          (a4 || c3 && i4.printable) && s3.push(i4.data), i4.hasTextContent && a4 && (r3 || (r3 = new PartialEvaluator({ xref: this.xref, handler: e3, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions })), n3.push(i4.extractTextContent(r3, t3, [-1 / 0, -1 / 0, 1 / 0, 1 / 0]).catch(function(e4) {
            warn(`getAnnotationsData - ignoring textContent during "${t3.name}" task: "${e4}".`);
          })));
        }
        return await Promise.all(n3), s3;
      }
      get annotations() {
        const e3 = this._getInheritableProperty("Annots");
        return shadow(this, "annotations", Array.isArray(e3) ? e3 : []);
      }
      get _parsedAnnotations() {
        return shadow(this, "_parsedAnnotations", this.pdfManager.ensure(this, "annotations").then(async (e3) => {
          if (0 === e3.length) return e3;
          const t3 = await this.pdfManager.ensureDoc("annotationGlobals");
          if (!t3) return [];
          const i3 = [];
          for (const a4 of e3) i3.push(AnnotationFactory.create(this.xref, a4, t3, this._localIdFactory, false, this.ref).catch(function(e4) {
            return warn(`_parsedAnnotations: "${e4}".`), null;
          }));
          const a3 = [];
          let s3, n3;
          for (const e4 of await Promise.all(i3)) e4 && (e4 instanceof WidgetAnnotation ? (n3 || (n3 = [])).push(e4) : e4 instanceof PopupAnnotation ? (s3 || (s3 = [])).push(e4) : a3.push(e4));
          return n3 && a3.push(...n3), s3 && a3.push(...s3), a3;
        }));
      }
      get jsActions() {
        return shadow(this, "jsActions", collectActions(this.xref, this.pageDict, Oi));
      }
    };
    _Page_instances = new WeakSet();
    P_fn = function(e3, t3, i3) {
      for (const a3 of e3) if (a3.id) {
        const e4 = Ref.fromString(a3.id);
        if (!e4) {
          warn(`A non-linked annotation cannot be modified: ${a3.id}`);
          continue;
        }
        if (a3.deleted) {
          t3.put(e4, e4);
          continue;
        }
        i3?.put(e4), a3.ref = e4, delete a3.id;
      }
    };
    Th = new Uint8Array([37, 80, 68, 70, 45]);
    Jh = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
    Yh = new Uint8Array([101, 110, 100, 111, 98, 106]);
    PDFDocument = class {
      constructor(e3, t3) {
        __privateAdd(this, _PDFDocument_instances);
        if (t3.length <= 0) throw new InvalidPDFException("The PDF file is empty, i.e. its size is zero bytes.");
        this.pdfManager = e3, this.stream = t3, this.xref = new XRef(t3, e3), this._pagePromises = /* @__PURE__ */ new Map(), this._version = null;
        const i3 = { font: 0 };
        this._globalIdFactory = class {
          static getDocId() {
            return `g_${e3.docId}`;
          }
          static createFontId() {
            return "f" + ++i3.font;
          }
          static createObjId() {
            unreachable("Abstract method `createObjId` called.");
          }
          static getPageObjId() {
            unreachable("Abstract method `getPageObjId` called.");
          }
        };
      }
      parse(e3) {
        this.xref.parse(e3), this.catalog = new Catalog(this.pdfManager, this.xref);
      }
      get linearization() {
        let e3 = null;
        try {
          e3 = Linearization.create(this.stream);
        } catch (e4) {
          if (e4 instanceof MissingDataException) throw e4;
          info(e4);
        }
        return shadow(this, "linearization", e3);
      }
      get startXRef() {
        const e3 = this.stream;
        let t3 = 0;
        if (this.linearization) {
          if (e3.reset(), find(e3, Yh)) {
            e3.skip(6);
            let i3 = e3.peekByte();
            for (; isWhiteSpace(i3); ) e3.pos++, i3 = e3.peekByte();
            t3 = e3.pos - e3.start;
          }
        } else {
          const i3 = 1024, a3 = Jh.length;
          let s3 = false, n3 = e3.end;
          for (; !s3 && n3 > 0; ) n3 -= i3 - a3, n3 < 0 && (n3 = 0), e3.pos = n3, s3 = find(e3, Jh, i3, true);
          if (s3) {
            let i4;
            e3.skip(9);
            do {
              i4 = e3.getByte();
            } while (isWhiteSpace(i4));
            let a4 = "";
            for (; i4 >= 32 && i4 <= 57; ) a4 += String.fromCharCode(i4), i4 = e3.getByte();
            t3 = parseInt(a4, 10), isNaN(t3) && (t3 = 0);
          }
        }
        return shadow(this, "startXRef", t3);
      }
      checkHeader() {
        const e3 = this.stream;
        if (e3.reset(), !find(e3, Th)) return;
        e3.moveStart(), e3.skip(Th.length);
        let t3, i3 = "";
        for (; (t3 = e3.getByte()) > 32 && i3.length < 7; ) i3 += String.fromCharCode(t3);
        $s.test(i3) ? this._version = i3 : warn(`Invalid PDF header version: ${i3}`);
      }
      parseStartXRef() {
        this.xref.setStartXRef(this.startXRef);
      }
      get numPages() {
        let e3 = 0;
        return e3 = this.catalog.hasActualNumPages ? this.catalog.numPages : this.xfaFactory ? this.xfaFactory.getNumPages() : this.linearization ? this.linearization.numPages : this.catalog.numPages, shadow(this, "numPages", e3);
      }
      _hasOnlyDocumentSignatures(e3, t3 = 0) {
        return !!Array.isArray(e3) && e3.every((e4) => {
          if (!((e4 = this.xref.fetchIfRef(e4)) instanceof Dict)) return false;
          if (e4.has("Kids")) return ++t3 > 10 ? (warn("_hasOnlyDocumentSignatures: maximum recursion depth reached"), false) : this._hasOnlyDocumentSignatures(e4.get("Kids"), t3);
          const i3 = isName(e4.get("FT"), "Sig"), a3 = e4.get("Rect"), s3 = Array.isArray(a3) && a3.every((e5) => 0 === e5);
          return i3 && s3;
        });
      }
      get _xfaStreams() {
        const e3 = this.catalog.acroForm;
        if (!e3) return null;
        const t3 = e3.get("XFA"), i3 = { "xdp:xdp": "", template: "", datasets: "", config: "", connectionSet: "", localeSet: "", stylesheet: "", "/xdp:xdp": "" };
        if (t3 instanceof BaseStream && !t3.isEmpty) return i3["xdp:xdp"] = t3, i3;
        if (!Array.isArray(t3) || 0 === t3.length) return null;
        for (let e4 = 0, a3 = t3.length; e4 < a3; e4 += 2) {
          let s3;
          if (s3 = 0 === e4 ? "xdp:xdp" : e4 === a3 - 2 ? "/xdp:xdp" : t3[e4], !i3.hasOwnProperty(s3)) continue;
          const n3 = this.xref.fetchIfRef(t3[e4 + 1]);
          n3 instanceof BaseStream && !n3.isEmpty && (i3[s3] = n3);
        }
        return i3;
      }
      get xfaDatasets() {
        const e3 = this._xfaStreams;
        if (!e3) return shadow(this, "xfaDatasets", null);
        for (const t3 of ["datasets", "xdp:xdp"]) {
          const i3 = e3[t3];
          if (i3) try {
            const e4 = stringToUTF8String(i3.getString());
            return shadow(this, "xfaDatasets", new DatasetReader({ [t3]: e4 }));
          } catch {
            warn("XFA - Invalid utf-8 string.");
            break;
          }
        }
        return shadow(this, "xfaDatasets", null);
      }
      get xfaData() {
        const e3 = this._xfaStreams;
        if (!e3) return null;
        const t3 = /* @__PURE__ */ Object.create(null);
        for (const [i3, a3] of Object.entries(e3)) if (a3) try {
          t3[i3] = stringToUTF8String(a3.getString());
        } catch {
          return warn("XFA - Invalid utf-8 string."), null;
        }
        return t3;
      }
      get xfaFactory() {
        let e3;
        return this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm && (e3 = this.xfaData), shadow(this, "xfaFactory", e3 ? new XFAFactory(e3) : null);
      }
      get isPureXfa() {
        return !!this.xfaFactory && this.xfaFactory.isValid();
      }
      get htmlForXfa() {
        return this.xfaFactory ? this.xfaFactory.getPages() : null;
      }
      async loadXfaImages() {
        const e3 = await this.pdfManager.ensureCatalog("xfaImages");
        if (!e3) return;
        const t3 = e3.getKeys(), i3 = new ObjectLoader(e3, t3, this.xref);
        await i3.load();
        const a3 = /* @__PURE__ */ new Map();
        for (const i4 of t3) {
          const t4 = e3.get(i4);
          t4 instanceof BaseStream && a3.set(i4, t4.getBytes());
        }
        this.xfaFactory.setImages(a3);
      }
      async loadXfaFonts(e3, t3) {
        const i3 = await this.pdfManager.ensureCatalog("acroForm");
        if (!i3) return;
        const a3 = await i3.getAsync("DR");
        if (!(a3 instanceof Dict)) return;
        const s3 = new ObjectLoader(a3, ["Font"], this.xref);
        await s3.load();
        const n3 = a3.get("Font");
        if (!(n3 instanceof Dict)) return;
        const r3 = Object.assign(/* @__PURE__ */ Object.create(null), this.pdfManager.evaluatorOptions);
        r3.useSystemFonts = false;
        const o3 = new PartialEvaluator({ xref: this.xref, handler: e3, pageIndex: -1, idFactory: this._globalIdFactory, fontCache: this.catalog.fontCache, builtInCMapCache: this.catalog.builtInCMapCache, standardFontDataCache: this.catalog.standardFontDataCache, options: r3 }), g3 = new OperatorList(), c3 = [], h3 = { get font() {
          return c3.at(-1);
        }, set font(e4) {
          c3.push(e4);
        }, clone() {
          return this;
        } }, l3 = /* @__PURE__ */ new Map();
        n3.forEach((e4, t4) => {
          l3.set(e4, t4);
        });
        const C3 = [];
        for (const [e4, i4] of l3) {
          const s4 = i4.get("FontDescriptor");
          if (!(s4 instanceof Dict)) continue;
          let n4 = s4.get("FontFamily");
          n4 = n4.replaceAll(/[ ]+(\d)/g, "$1");
          const r4 = { fontFamily: n4, fontWeight: s4.get("FontWeight"), italicAngle: -s4.get("ItalicAngle") };
          validateCSSFont(r4) && C3.push(o3.handleSetFont(a3, [Name.get(e4), 1], null, g3, t3, h3, null, r4).catch(function(e5) {
            return warn(`loadXfaFonts: "${e5}".`), null;
          }));
        }
        await Promise.all(C3);
        const d3 = this.xfaFactory.setFonts(c3);
        if (!d3) return;
        r3.ignoreErrors = true, C3.length = 0, c3.length = 0;
        const u3 = /* @__PURE__ */ new Set();
        for (const e4 of d3) getXfaFontName(`${e4}-Regular`) || u3.add(e4);
        u3.size && d3.push("PdfJS-Fallback");
        for (const e4 of d3) if (!u3.has(e4)) for (const i4 of [{ name: "Regular", fontWeight: 400, italicAngle: 0 }, { name: "Bold", fontWeight: 700, italicAngle: 0 }, { name: "Italic", fontWeight: 400, italicAngle: 12 }, { name: "BoldItalic", fontWeight: 700, italicAngle: 12 }]) {
          const s4 = `${e4}-${i4.name}`, n4 = getXfaFontDict(s4);
          C3.push(o3.handleSetFont(a3, [Name.get(s4), 1], null, g3, t3, h3, n4, { fontFamily: e4, fontWeight: i4.fontWeight, italicAngle: i4.italicAngle }).catch(function(e5) {
            return warn(`loadXfaFonts: "${e5}".`), null;
          }));
        }
        await Promise.all(C3), this.xfaFactory.appendFonts(c3, u3);
      }
      async serializeXfaData(e3) {
        return this.xfaFactory ? this.xfaFactory.serializeData(e3) : null;
      }
      get version() {
        return this.catalog.version || this._version;
      }
      get formInfo() {
        const e3 = { hasFields: false, hasAcroForm: false, hasXfa: false, hasSignatures: false }, t3 = this.catalog.acroForm;
        if (!t3) return shadow(this, "formInfo", e3);
        try {
          const i3 = t3.get("Fields"), a3 = Array.isArray(i3) && i3.length > 0;
          e3.hasFields = a3;
          const s3 = t3.get("XFA");
          e3.hasXfa = Array.isArray(s3) && s3.length > 0 || s3 instanceof BaseStream && !s3.isEmpty;
          const n3 = !!(1 & t3.get("SigFlags")), r3 = n3 && this._hasOnlyDocumentSignatures(i3);
          e3.hasAcroForm = a3 && !r3, e3.hasSignatures = n3;
        } catch (e4) {
          if (e4 instanceof MissingDataException) throw e4;
          warn(`Cannot fetch form information: "${e4}".`);
        }
        return shadow(this, "formInfo", e3);
      }
      get documentInfo() {
        const e3 = { PDFFormatVersion: this.version, Language: this.catalog.lang, EncryptFilterName: this.xref.encrypt ? this.xref.encrypt.filterName : null, IsLinearized: !!this.linearization, IsAcroFormPresent: this.formInfo.hasAcroForm, IsXFAPresent: this.formInfo.hasXfa, IsCollectionPresent: !!this.catalog.collection, IsSignaturesPresent: this.formInfo.hasSignatures };
        let t3;
        try {
          t3 = this.xref.trailer.get("Info");
        } catch (e4) {
          if (e4 instanceof MissingDataException) throw e4;
          info("The document information dictionary is invalid.");
        }
        if (!(t3 instanceof Dict)) return shadow(this, "documentInfo", e3);
        for (const i3 of t3.getKeys()) {
          const a3 = t3.get(i3);
          switch (i3) {
            case "Title":
            case "Author":
            case "Subject":
            case "Keywords":
            case "Creator":
            case "Producer":
            case "CreationDate":
            case "ModDate":
              if ("string" == typeof a3) {
                e3[i3] = stringToPDFString(a3);
                continue;
              }
              break;
            case "Trapped":
              if (a3 instanceof Name) {
                e3[i3] = a3;
                continue;
              }
              break;
            default:
              let t4;
              switch (typeof a3) {
                case "string":
                  t4 = stringToPDFString(a3);
                  break;
                case "number":
                case "boolean":
                  t4 = a3;
                  break;
                default:
                  a3 instanceof Name && (t4 = a3);
              }
              if (void 0 === t4) {
                warn(`Bad value, for custom key "${i3}", in Info: ${a3}.`);
                continue;
              }
              e3.Custom || (e3.Custom = /* @__PURE__ */ Object.create(null)), e3.Custom[i3] = t4;
              continue;
          }
          warn(`Bad value, for key "${i3}", in Info: ${a3}.`);
        }
        return shadow(this, "documentInfo", e3);
      }
      get fingerprints() {
        function validate(e4) {
          return "string" == typeof e4 && e4.length > 0 && "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0" !== e4;
        }
        function hexString(e4) {
          const t4 = [];
          for (const i4 of e4) {
            const e5 = i4.toString(16);
            t4.push(e5.padStart(2, "0"));
          }
          return t4.join("");
        }
        const e3 = this.xref.trailer.get("ID");
        let t3, i3;
        return Array.isArray(e3) && validate(e3[0]) ? (t3 = stringToBytes(e3[0]), e3[1] !== e3[0] && validate(e3[1]) && (i3 = stringToBytes(e3[1]))) : t3 = hg(this.stream.getByteRange(0, 1024), 0, 1024), shadow(this, "fingerprints", [hexString(t3), i3 ? hexString(i3) : null]);
      }
      async _getLinearizationPage(e3) {
        const { catalog: t3, linearization: i3, xref: a3 } = this, s3 = Ref.get(i3.objectNumberFirst, 0);
        try {
          const e4 = await a3.fetchAsync(s3);
          if (e4 instanceof Dict) {
            let i4 = e4.getRaw("Type");
            if (i4 instanceof Ref && (i4 = await a3.fetchAsync(i4)), isName(i4, "Page") || !e4.has("Type") && !e4.has("Kids") && e4.has("Contents")) return t3.pageKidsCountCache.has(s3) || t3.pageKidsCountCache.put(s3, 1), t3.pageIndexCache.has(s3) || t3.pageIndexCache.put(s3, 0), [e4, s3];
          }
          throw new FormatError("The Linearization dictionary doesn't point to a valid Page dictionary.");
        } catch (i4) {
          return warn(`_getLinearizationPage: "${i4.message}".`), t3.getPageDict(e3);
        }
      }
      getPage(e3) {
        const t3 = this._pagePromises.get(e3);
        if (t3) return t3;
        const { catalog: i3, linearization: a3, xfaFactory: s3 } = this;
        let n3;
        return n3 = s3 ? Promise.resolve([Dict.empty, null]) : a3?.pageFirst === e3 ? this._getLinearizationPage(e3) : i3.getPageDict(e3), n3 = n3.then(([t4, a4]) => new Page({ pdfManager: this.pdfManager, xref: this.xref, pageIndex: e3, pageDict: t4, ref: a4, globalIdFactory: this._globalIdFactory, fontCache: i3.fontCache, builtInCMapCache: i3.builtInCMapCache, standardFontDataCache: i3.standardFontDataCache, globalImageCache: i3.globalImageCache, systemFontCache: i3.systemFontCache, nonBlendModesSet: i3.nonBlendModesSet, xfaFactory: s3 })), this._pagePromises.set(e3, n3), n3;
      }
      async checkFirstPage(e3 = false) {
        if (!e3) try {
          await this.getPage(0);
        } catch (e4) {
          if (e4 instanceof XRefEntryException) throw this._pagePromises.delete(0), await this.cleanup(), new XRefParseException();
        }
      }
      async checkLastPage(e3 = false) {
        const { catalog: t3, pdfManager: i3 } = this;
        let a3;
        t3.setActualNumPages();
        try {
          if (await Promise.all([i3.ensureDoc("xfaFactory"), i3.ensureDoc("linearization"), i3.ensureCatalog("numPages")]), this.xfaFactory) return;
          if (a3 = this.linearization ? this.linearization.numPages : t3.numPages, !Number.isInteger(a3)) throw new FormatError("Page count is not an integer.");
          if (a3 <= 1) return;
          await this.getPage(a3 - 1);
        } catch (s3) {
          if (this._pagePromises.delete(a3 - 1), await this.cleanup(), s3 instanceof XRefEntryException && !e3) throw new XRefParseException();
          let n3;
          warn(`checkLastPage - invalid /Pages tree /Count: ${a3}.`);
          try {
            n3 = await t3.getAllPageDicts(e3);
          } catch (i4) {
            if (i4 instanceof XRefEntryException && !e3) throw new XRefParseException();
            return void t3.setActualNumPages(1);
          }
          for (const [e4, [a4, s4]] of n3) {
            let n4;
            a4 instanceof Error ? (n4 = Promise.reject(a4), n4.catch(() => {
            })) : n4 = Promise.resolve(new Page({ pdfManager: i3, xref: this.xref, pageIndex: e4, pageDict: a4, ref: s4, globalIdFactory: this._globalIdFactory, fontCache: t3.fontCache, builtInCMapCache: t3.builtInCMapCache, standardFontDataCache: t3.standardFontDataCache, globalImageCache: t3.globalImageCache, systemFontCache: t3.systemFontCache, nonBlendModesSet: t3.nonBlendModesSet, xfaFactory: null })), this._pagePromises.set(e4, n4);
          }
          t3.setActualNumPages(n3.size);
        }
      }
      fontFallback(e3, t3) {
        return this.catalog.fontFallback(e3, t3);
      }
      async cleanup(e3 = false) {
        return this.catalog ? this.catalog.cleanup(e3) : clearGlobalCaches();
      }
      get fieldObjects() {
        if (!this.formInfo.hasFields) return shadow(this, "fieldObjects", Promise.resolve(null));
        const e3 = Promise.all([this.pdfManager.ensureDoc("annotationGlobals"), this.pdfManager.ensureCatalog("acroForm")]).then(async ([e4, t3]) => {
          if (!e4) return null;
          const i3 = new RefSet(), a3 = /* @__PURE__ */ Object.create(null), s3 = /* @__PURE__ */ new Map();
          for (const a4 of await t3.getAsync("Fields")) await __privateMethod(this, _PDFDocument_instances, O_fn).call(this, "", a4, s3, e4, i3);
          const n3 = [];
          for (const [e5, t4] of s3) n3.push(Promise.all(t4).then((t5) => {
            (t5 = t5.filter((e6) => !!e6)).length > 0 && (a3[e5] = t5);
          }));
          return await Promise.all(n3), a3;
        });
        return shadow(this, "fieldObjects", e3);
      }
      get hasJSActions() {
        return shadow(this, "hasJSActions", this.pdfManager.ensureDoc("_parseHasJSActions"));
      }
      async _parseHasJSActions() {
        const [e3, t3] = await Promise.all([this.pdfManager.ensureCatalog("jsActions"), this.pdfManager.ensureDoc("fieldObjects")]);
        return !!e3 || !!t3 && Object.values(t3).some((e4) => e4.some((e5) => null !== e5.actions));
      }
      get calculationOrderIds() {
        const e3 = this.catalog.acroForm;
        if (!e3?.has("CO")) return shadow(this, "calculationOrderIds", null);
        const t3 = e3.get("CO");
        if (!Array.isArray(t3) || 0 === t3.length) return shadow(this, "calculationOrderIds", null);
        const i3 = [];
        for (const e4 of t3) e4 instanceof Ref && i3.push(e4.toString());
        return 0 === i3.length ? shadow(this, "calculationOrderIds", null) : shadow(this, "calculationOrderIds", i3);
      }
      get annotationGlobals() {
        return shadow(this, "annotationGlobals", AnnotationFactory.createGlobals(this.pdfManager));
      }
    };
    _PDFDocument_instances = new WeakSet();
    O_fn = async function(e3, t3, i3, a3, s3) {
      const { xref: n3 } = this;
      if (!(t3 instanceof Ref) || s3.has(t3)) return;
      s3.put(t3);
      const r3 = await n3.fetchAsync(t3);
      if (!(r3 instanceof Dict)) return;
      if (r3.has("T")) {
        const t4 = stringToPDFString(await r3.getAsync("T"));
        e3 = "" === e3 ? t4 : `${e3}.${t4}`;
      } else {
        let t4 = r3;
        for (; ; ) {
          if (t4 = t4.getRaw("Parent"), t4 instanceof Ref) {
            if (s3.has(t4)) break;
            t4 = await n3.fetchAsync(t4);
          }
          if (!(t4 instanceof Dict)) break;
          if (t4.has("T")) {
            const i4 = stringToPDFString(await t4.getAsync("T"));
            e3 = "" === e3 ? i4 : `${e3}.${i4}`;
            break;
          }
        }
      }
      if (i3.has(e3) || i3.set(e3, []), i3.get(e3).push(AnnotationFactory.create(n3, t3, a3, null, true, null).then((e4) => e4?.getFieldObject()).catch(function(e4) {
        return warn(`#collectFieldObjects: "${e4}".`), null;
      })), !r3.has("Kids")) return;
      const o3 = await r3.getAsync("Kids");
      if (Array.isArray(o3)) for (const t4 of o3) await __privateMethod(this, _PDFDocument_instances, O_fn).call(this, e3, t4, i3, a3, s3);
    };
    BasePdfManager = class {
      constructor(e3) {
        var _a4;
        this._docBaseUrl = function(e4) {
          if (e4) {
            const t3 = createValidAbsoluteUrl(e4);
            if (t3) return t3.href;
            warn(`Invalid absolute docBaseUrl: "${e4}".`);
          }
          return null;
        }(e3.docBaseUrl), this._docId = e3.docId, this._password = e3.password, this.enableXfa = e3.enableXfa, (_a4 = e3.evaluatorOptions).isOffscreenCanvasSupported && (_a4.isOffscreenCanvasSupported = FeatureTest.isOffscreenCanvasSupported), this.evaluatorOptions = Object.freeze(e3.evaluatorOptions);
      }
      get docId() {
        return this._docId;
      }
      get password() {
        return this._password;
      }
      get docBaseUrl() {
        return this._docBaseUrl;
      }
      get catalog() {
        return this.pdfDocument.catalog;
      }
      ensureDoc(e3, t3) {
        return this.ensure(this.pdfDocument, e3, t3);
      }
      ensureXRef(e3, t3) {
        return this.ensure(this.pdfDocument.xref, e3, t3);
      }
      ensureCatalog(e3, t3) {
        return this.ensure(this.pdfDocument.catalog, e3, t3);
      }
      getPage(e3) {
        return this.pdfDocument.getPage(e3);
      }
      fontFallback(e3, t3) {
        return this.pdfDocument.fontFallback(e3, t3);
      }
      loadXfaFonts(e3, t3) {
        return this.pdfDocument.loadXfaFonts(e3, t3);
      }
      loadXfaImages() {
        return this.pdfDocument.loadXfaImages();
      }
      serializeXfaData(e3) {
        return this.pdfDocument.serializeXfaData(e3);
      }
      cleanup(e3 = false) {
        return this.pdfDocument.cleanup(e3);
      }
      async ensure(e3, t3, i3) {
        unreachable("Abstract method `ensure` called");
      }
      requestRange(e3, t3) {
        unreachable("Abstract method `requestRange` called");
      }
      requestLoadedStream(e3 = false) {
        unreachable("Abstract method `requestLoadedStream` called");
      }
      sendProgressiveData(e3) {
        unreachable("Abstract method `sendProgressiveData` called");
      }
      updatePassword(e3) {
        this._password = e3;
      }
      terminate(e3) {
        unreachable("Abstract method `terminate` called");
      }
    };
    LocalPdfManager = class extends BasePdfManager {
      constructor(e3) {
        super(e3);
        const t3 = new Stream(e3.source);
        this.pdfDocument = new PDFDocument(this, t3), this._loadedStreamPromise = Promise.resolve(t3);
      }
      async ensure(e3, t3, i3) {
        const a3 = e3[t3];
        return "function" == typeof a3 ? a3.apply(e3, i3) : a3;
      }
      requestRange(e3, t3) {
        return Promise.resolve();
      }
      requestLoadedStream(e3 = false) {
        return this._loadedStreamPromise;
      }
      terminate(e3) {
      }
    };
    NetworkPdfManager = class extends BasePdfManager {
      constructor(e3) {
        super(e3), this.streamManager = new ChunkedStreamManager(e3.source, { msgHandler: e3.handler, length: e3.length, disableAutoFetch: e3.disableAutoFetch, rangeChunkSize: e3.rangeChunkSize }), this.pdfDocument = new PDFDocument(this, this.streamManager.getStream());
      }
      async ensure(e3, t3, i3) {
        try {
          const a3 = e3[t3];
          return "function" == typeof a3 ? a3.apply(e3, i3) : a3;
        } catch (a3) {
          if (!(a3 instanceof MissingDataException)) throw a3;
          return await this.requestRange(a3.begin, a3.end), this.ensure(e3, t3, i3);
        }
      }
      requestRange(e3, t3) {
        return this.streamManager.requestRange(e3, t3);
      }
      requestLoadedStream(e3 = false) {
        return this.streamManager.requestAllChunks(e3);
      }
      sendProgressiveData(e3) {
        this.streamManager.onReceiveData({ chunk: e3 });
      }
      terminate(e3) {
        this.streamManager.abort(e3);
      }
    };
    Ph = 1;
    Oh = 2;
    Kh = 1;
    qh = 2;
    _h = 3;
    Wh = 4;
    jh = 5;
    Xh = 6;
    Vh = 7;
    Zh = 8;
    MessageHandler = class {
      constructor(e3, t3, i3) {
        __privateAdd(this, _MessageHandler_instances);
        this.sourceName = e3, this.targetName = t3, this.comObj = i3, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (e4) => {
          const t4 = e4.data;
          if (t4.targetName !== this.sourceName) return;
          if (t4.stream) return void __privateMethod(this, _MessageHandler_instances, K_fn).call(this, t4);
          if (t4.callback) {
            const e5 = t4.callbackId, i4 = this.callbackCapabilities[e5];
            if (!i4) throw new Error(`Cannot resolve callback ${e5}`);
            if (delete this.callbackCapabilities[e5], t4.callback === Ph) i4.resolve(t4.data);
            else {
              if (t4.callback !== Oh) throw new Error("Unexpected callback case");
              i4.reject(wrapReason(t4.reason));
            }
            return;
          }
          const a3 = this.actionHandler[t4.action];
          if (!a3) throw new Error(`Unknown action from worker: ${t4.action}`);
          if (t4.callbackId) {
            const e5 = this.sourceName, s3 = t4.sourceName;
            new Promise(function(e6) {
              e6(a3(t4.data));
            }).then(function(a4) {
              i3.postMessage({ sourceName: e5, targetName: s3, callback: Ph, callbackId: t4.callbackId, data: a4 });
            }, function(a4) {
              i3.postMessage({ sourceName: e5, targetName: s3, callback: Oh, callbackId: t4.callbackId, reason: wrapReason(a4) });
            });
          } else t4.streamId ? __privateMethod(this, _MessageHandler_instances, q_fn).call(this, t4) : a3(t4.data);
        }, i3.addEventListener("message", this._onComObjOnMessage);
      }
      on(e3, t3) {
        const i3 = this.actionHandler;
        if (i3[e3]) throw new Error(`There is already an actionName called "${e3}"`);
        i3[e3] = t3;
      }
      send(e3, t3, i3) {
        this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: e3, data: t3 }, i3);
      }
      sendWithPromise(e3, t3, i3) {
        const a3 = this.callbackId++, s3 = Promise.withResolvers();
        this.callbackCapabilities[a3] = s3;
        try {
          this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: e3, callbackId: a3, data: t3 }, i3);
        } catch (e4) {
          s3.reject(e4);
        }
        return s3.promise;
      }
      sendWithStream(e3, t3, i3, a3) {
        const s3 = this.streamId++, n3 = this.sourceName, r3 = this.targetName, o3 = this.comObj;
        return new ReadableStream({ start: (i4) => {
          const g3 = Promise.withResolvers();
          return this.streamControllers[s3] = { controller: i4, startCall: g3, pullCall: null, cancelCall: null, isClosed: false }, o3.postMessage({ sourceName: n3, targetName: r3, action: e3, streamId: s3, data: t3, desiredSize: i4.desiredSize }, a3), g3.promise;
        }, pull: (e4) => {
          const t4 = Promise.withResolvers();
          return this.streamControllers[s3].pullCall = t4, o3.postMessage({ sourceName: n3, targetName: r3, stream: Xh, streamId: s3, desiredSize: e4.desiredSize }), t4.promise;
        }, cancel: (e4) => {
          assert(e4 instanceof Error, "cancel must have a valid reason");
          const t4 = Promise.withResolvers();
          return this.streamControllers[s3].cancelCall = t4, this.streamControllers[s3].isClosed = true, o3.postMessage({ sourceName: n3, targetName: r3, stream: Kh, streamId: s3, reason: wrapReason(e4) }), t4.promise;
        } }, i3);
      }
      destroy() {
        this.comObj.removeEventListener("message", this._onComObjOnMessage);
      }
    };
    _MessageHandler_instances = new WeakSet();
    q_fn = function(e3) {
      const t3 = e3.streamId, i3 = this.sourceName, a3 = e3.sourceName, s3 = this.comObj, n3 = this, r3 = this.actionHandler[e3.action], o3 = { enqueue(e4, n4 = 1, r4) {
        if (this.isCancelled) return;
        const o4 = this.desiredSize;
        this.desiredSize -= n4, o4 > 0 && this.desiredSize <= 0 && (this.sinkCapability = Promise.withResolvers(), this.ready = this.sinkCapability.promise), s3.postMessage({ sourceName: i3, targetName: a3, stream: Wh, streamId: t3, chunk: e4 }, r4);
      }, close() {
        this.isCancelled || (this.isCancelled = true, s3.postMessage({ sourceName: i3, targetName: a3, stream: _h, streamId: t3 }), delete n3.streamSinks[t3]);
      }, error(e4) {
        assert(e4 instanceof Error, "error must have a valid reason"), this.isCancelled || (this.isCancelled = true, s3.postMessage({ sourceName: i3, targetName: a3, stream: jh, streamId: t3, reason: wrapReason(e4) }));
      }, sinkCapability: Promise.withResolvers(), onPull: null, onCancel: null, isCancelled: false, desiredSize: e3.desiredSize, ready: null };
      o3.sinkCapability.resolve(), o3.ready = o3.sinkCapability.promise, this.streamSinks[t3] = o3, new Promise(function(t4) {
        t4(r3(e3.data, o3));
      }).then(function() {
        s3.postMessage({ sourceName: i3, targetName: a3, stream: Zh, streamId: t3, success: true });
      }, function(e4) {
        s3.postMessage({ sourceName: i3, targetName: a3, stream: Zh, streamId: t3, reason: wrapReason(e4) });
      });
    };
    K_fn = function(e3) {
      const t3 = e3.streamId, i3 = this.sourceName, a3 = e3.sourceName, s3 = this.comObj, n3 = this.streamControllers[t3], r3 = this.streamSinks[t3];
      switch (e3.stream) {
        case Zh:
          e3.success ? n3.startCall.resolve() : n3.startCall.reject(wrapReason(e3.reason));
          break;
        case Vh:
          e3.success ? n3.pullCall.resolve() : n3.pullCall.reject(wrapReason(e3.reason));
          break;
        case Xh:
          if (!r3) {
            s3.postMessage({ sourceName: i3, targetName: a3, stream: Vh, streamId: t3, success: true });
            break;
          }
          r3.desiredSize <= 0 && e3.desiredSize > 0 && r3.sinkCapability.resolve(), r3.desiredSize = e3.desiredSize, new Promise(function(e4) {
            e4(r3.onPull?.());
          }).then(function() {
            s3.postMessage({ sourceName: i3, targetName: a3, stream: Vh, streamId: t3, success: true });
          }, function(e4) {
            s3.postMessage({ sourceName: i3, targetName: a3, stream: Vh, streamId: t3, reason: wrapReason(e4) });
          });
          break;
        case Wh:
          if (assert(n3, "enqueue should have stream controller"), n3.isClosed) break;
          n3.controller.enqueue(e3.chunk);
          break;
        case _h:
          if (assert(n3, "close should have stream controller"), n3.isClosed) break;
          n3.isClosed = true, n3.controller.close(), __privateMethod(this, _MessageHandler_instances, __fn).call(this, n3, t3);
          break;
        case jh:
          assert(n3, "error should have stream controller"), n3.controller.error(wrapReason(e3.reason)), __privateMethod(this, _MessageHandler_instances, __fn).call(this, n3, t3);
          break;
        case qh:
          e3.success ? n3.cancelCall.resolve() : n3.cancelCall.reject(wrapReason(e3.reason)), __privateMethod(this, _MessageHandler_instances, __fn).call(this, n3, t3);
          break;
        case Kh:
          if (!r3) break;
          new Promise(function(t4) {
            t4(r3.onCancel?.(wrapReason(e3.reason)));
          }).then(function() {
            s3.postMessage({ sourceName: i3, targetName: a3, stream: qh, streamId: t3, success: true });
          }, function(e4) {
            s3.postMessage({ sourceName: i3, targetName: a3, stream: qh, streamId: t3, reason: wrapReason(e4) });
          }), r3.sinkCapability.reject(wrapReason(e3.reason)), r3.isCancelled = true, delete this.streamSinks[t3];
          break;
        default:
          throw new Error("Unexpected stream case");
      }
    };
    __fn = async function(e3, t3) {
      await Promise.allSettled([e3.startCall?.promise, e3.pullCall?.promise, e3.cancelCall?.promise]), delete this.streamControllers[t3];
    };
    PDFWorkerStream = class {
      constructor(e3) {
        this._msgHandler = e3, this._contentLength = null, this._fullRequestReader = null, this._rangeRequestReaders = [];
      }
      getFullReader() {
        return assert(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once."), this._fullRequestReader = new PDFWorkerStreamReader(this._msgHandler), this._fullRequestReader;
      }
      getRangeReader(e3, t3) {
        const i3 = new PDFWorkerStreamRangeReader(e3, t3, this._msgHandler);
        return this._rangeRequestReaders.push(i3), i3;
      }
      cancelAllRequests(e3) {
        this._fullRequestReader?.cancel(e3);
        for (const t3 of this._rangeRequestReaders.slice(0)) t3.cancel(e3);
      }
    };
    PDFWorkerStreamReader = class {
      constructor(e3) {
        this._msgHandler = e3, this.onProgress = null, this._contentLength = null, this._isRangeSupported = false, this._isStreamingSupported = false;
        const t3 = this._msgHandler.sendWithStream("GetReader");
        this._reader = t3.getReader(), this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then((e4) => {
          this._isStreamingSupported = e4.isStreamingSupported, this._isRangeSupported = e4.isRangeSupported, this._contentLength = e4.contentLength;
        });
      }
      get headersReady() {
        return this._headersReady;
      }
      get contentLength() {
        return this._contentLength;
      }
      get isStreamingSupported() {
        return this._isStreamingSupported;
      }
      get isRangeSupported() {
        return this._isRangeSupported;
      }
      async read() {
        const { value: e3, done: t3 } = await this._reader.read();
        return t3 ? { value: void 0, done: true } : { value: e3.buffer, done: false };
      }
      cancel(e3) {
        this._reader.cancel(e3);
      }
    };
    PDFWorkerStreamRangeReader = class {
      constructor(e3, t3, i3) {
        this._msgHandler = i3, this.onProgress = null;
        const a3 = this._msgHandler.sendWithStream("GetRangeReader", { begin: e3, end: t3 });
        this._reader = a3.getReader();
      }
      get isStreamingSupported() {
        return false;
      }
      async read() {
        const { value: e3, done: t3 } = await this._reader.read();
        return t3 ? { value: void 0, done: true } : { value: e3.buffer, done: false };
      }
      cancel(e3) {
        this._reader.cancel(e3);
      }
    };
    WorkerTask = class {
      constructor(e3) {
        this.name = e3, this.terminated = false, this._capability = Promise.withResolvers();
      }
      get finished() {
        return this._capability.promise;
      }
      finish() {
        this._capability.resolve();
      }
      terminate() {
        this.terminated = true;
      }
      ensureNotTerminated() {
        if (this.terminated) throw new Error("Worker task was terminated");
      }
    };
    WorkerMessageHandler = class _WorkerMessageHandler {
      static setup(e3, t3) {
        let i3 = false;
        e3.on("test", function(t4) {
          i3 || (i3 = true, e3.send("test", t4 instanceof Uint8Array));
        }), e3.on("configure", function(e4) {
          var t4;
          t4 = e4.verbosity, Number.isInteger(t4) && (Ns = t4);
        }), e3.on("GetDocRequest", function(e4) {
          return _WorkerMessageHandler.createDocumentHandler(e4, t3);
        });
      }
      static createDocumentHandler(e3, t3) {
        let i3, a3 = false, s3 = null;
        const n3 = /* @__PURE__ */ new Set(), r3 = getVerbosityLevel(), { docId: o3, apiVersion: g3 } = e3, c3 = "4.6.82";
        if (g3 !== c3) throw new Error(`The API version "${g3}" does not match the Worker version "${c3}".`);
        const h3 = [];
        for (const e4 in []) h3.push(e4);
        if (h3.length) throw new Error("The `Array.prototype` contains unexpected enumerable properties: " + h3.join(", ") + "; thus breaking e.g. `for...in` iteration of `Array`s.");
        const l3 = o3 + "_worker";
        let C3 = new MessageHandler(l3, o3, t3);
        function ensureNotTerminated() {
          if (a3) throw new Error("Worker was terminated");
        }
        function startWorkerTask(e4) {
          n3.add(e4);
        }
        function finishWorkerTask(e4) {
          e4.finish(), n3.delete(e4);
        }
        async function loadDocument(e4) {
          await i3.ensureDoc("checkHeader"), await i3.ensureDoc("parseStartXRef"), await i3.ensureDoc("parse", [e4]), await i3.ensureDoc("checkFirstPage", [e4]), await i3.ensureDoc("checkLastPage", [e4]);
          const t4 = await i3.ensureDoc("isPureXfa");
          if (t4) {
            const e5 = new WorkerTask("loadXfaFonts");
            startWorkerTask(e5), await Promise.all([i3.loadXfaFonts(C3, e5).catch((e6) => {
            }).then(() => finishWorkerTask(e5)), i3.loadXfaImages()]);
          }
          const [a4, s4] = await Promise.all([i3.ensureDoc("numPages"), i3.ensureDoc("fingerprints")]);
          return { numPages: a4, fingerprints: s4, htmlForXfa: t4 ? await i3.ensureDoc("htmlForXfa") : null };
        }
        function getPdfManager({ data: e4, password: t4, disableAutoFetch: i4, rangeChunkSize: a4, length: n4, docBaseUrl: r4, enableXfa: g4, evaluatorOptions: c4 }) {
          const h4 = { source: null, disableAutoFetch: i4, docBaseUrl: r4, docId: o3, enableXfa: g4, evaluatorOptions: c4, handler: C3, length: n4, password: t4, rangeChunkSize: a4 }, l4 = Promise.withResolvers();
          let d3;
          if (e4) {
            try {
              h4.source = e4, d3 = new LocalPdfManager(h4), l4.resolve(d3);
            } catch (e5) {
              l4.reject(e5);
            }
            return l4.promise;
          }
          let u3, Q3 = [];
          try {
            u3 = new PDFWorkerStream(C3);
          } catch (e5) {
            return l4.reject(e5), l4.promise;
          }
          const f3 = u3.getFullReader();
          f3.headersReady.then(function() {
            if (f3.isRangeSupported) {
              h4.source = u3, h4.length = f3.contentLength, h4.disableAutoFetch || (h4.disableAutoFetch = f3.isStreamingSupported), d3 = new NetworkPdfManager(h4);
              for (const e5 of Q3) d3.sendProgressiveData(e5);
              Q3 = [], l4.resolve(d3), s3 = null;
            }
          }).catch(function(e5) {
            l4.reject(e5), s3 = null;
          });
          let p3 = 0;
          return new Promise(function(e5, t5) {
            const readChunk = function({ value: e6, done: i5 }) {
              try {
                if (ensureNotTerminated(), i5) return d3 || function() {
                  const e7 = arrayBuffersToBytes(Q3);
                  n4 && e7.length !== n4 && warn("reported HTTP length is different from actual");
                  try {
                    h4.source = e7, d3 = new LocalPdfManager(h4), l4.resolve(d3);
                  } catch (e8) {
                    l4.reject(e8);
                  }
                  Q3 = [];
                }(), void (s3 = null);
                p3 += e6.byteLength, f3.isStreamingSupported || C3.send("DocProgress", { loaded: p3, total: Math.max(p3, f3.contentLength || 0) }), d3 ? d3.sendProgressiveData(e6) : Q3.push(e6), f3.read().then(readChunk, t5);
              } catch (e7) {
                t5(e7);
              }
            };
            f3.read().then(readChunk, t5);
          }).catch(function(e5) {
            l4.reject(e5), s3 = null;
          }), s3 = function(e5) {
            u3.cancelAllRequests(e5);
          }, l4.promise;
        }
        return C3.on("GetPage", function(e4) {
          return i3.getPage(e4.pageIndex).then(function(e5) {
            return Promise.all([i3.ensure(e5, "rotate"), i3.ensure(e5, "ref"), i3.ensure(e5, "userUnit"), i3.ensure(e5, "view")]).then(function([e6, t4, i4, a4]) {
              return { rotate: e6, ref: t4, refStr: t4?.toString() ?? null, userUnit: i4, view: a4 };
            });
          });
        }), C3.on("GetPageIndex", function(e4) {
          const t4 = Ref.get(e4.num, e4.gen);
          return i3.ensureCatalog("getPageIndex", [t4]);
        }), C3.on("GetDestinations", function(e4) {
          return i3.ensureCatalog("destinations");
        }), C3.on("GetDestination", function(e4) {
          return i3.ensureCatalog("getDestination", [e4.id]);
        }), C3.on("GetPageLabels", function(e4) {
          return i3.ensureCatalog("pageLabels");
        }), C3.on("GetPageLayout", function(e4) {
          return i3.ensureCatalog("pageLayout");
        }), C3.on("GetPageMode", function(e4) {
          return i3.ensureCatalog("pageMode");
        }), C3.on("GetViewerPreferences", function(e4) {
          return i3.ensureCatalog("viewerPreferences");
        }), C3.on("GetOpenAction", function(e4) {
          return i3.ensureCatalog("openAction");
        }), C3.on("GetAttachments", function(e4) {
          return i3.ensureCatalog("attachments");
        }), C3.on("GetDocJSActions", function(e4) {
          return i3.ensureCatalog("jsActions");
        }), C3.on("GetPageJSActions", function({ pageIndex: e4 }) {
          return i3.getPage(e4).then(function(e5) {
            return i3.ensure(e5, "jsActions");
          });
        }), C3.on("GetOutline", function(e4) {
          return i3.ensureCatalog("documentOutline");
        }), C3.on("GetOptionalContentConfig", function(e4) {
          return i3.ensureCatalog("optionalContentConfig");
        }), C3.on("GetPermissions", function(e4) {
          return i3.ensureCatalog("permissions");
        }), C3.on("GetMetadata", function(e4) {
          return Promise.all([i3.ensureDoc("documentInfo"), i3.ensureCatalog("metadata")]);
        }), C3.on("GetMarkInfo", function(e4) {
          return i3.ensureCatalog("markInfo");
        }), C3.on("GetData", function(e4) {
          return i3.requestLoadedStream().then(function(e5) {
            return e5.bytes;
          });
        }), C3.on("GetAnnotations", function({ pageIndex: e4, intent: t4 }) {
          return i3.getPage(e4).then(function(i4) {
            const a4 = new WorkerTask(`GetAnnotations: page ${e4}`);
            return startWorkerTask(a4), i4.getAnnotationsData(C3, a4, t4).then((e5) => (finishWorkerTask(a4), e5), (e5) => {
              throw finishWorkerTask(a4), e5;
            });
          });
        }), C3.on("GetFieldObjects", function(e4) {
          return i3.ensureDoc("fieldObjects");
        }), C3.on("HasJSActions", function(e4) {
          return i3.ensureDoc("hasJSActions");
        }), C3.on("GetCalculationOrderIds", function(e4) {
          return i3.ensureDoc("calculationOrderIds");
        }), C3.on("SaveDocument", async function({ isPureXfa: e4, numPages: t4, annotationStorage: a4, filename: s4 }) {
          const n4 = [i3.requestLoadedStream(), i3.ensureCatalog("acroForm"), i3.ensureCatalog("acroFormRef"), i3.ensureDoc("startXRef"), i3.ensureDoc("xref"), i3.ensureDoc("linearization"), i3.ensureCatalog("structTreeRoot")], r4 = [], o4 = e4 ? null : getNewAnnotationsMap(a4), [g4, c4, h4, l4, d3, u3, Q3] = await Promise.all(n4), f3 = d3.trailer.getRaw("Root") || null;
          let p3;
          if (o4) {
            Q3 ? await Q3.canUpdateStructTree({ pdfManager: i3, xref: d3, newAnnotationsByPage: o4 }) && (p3 = Q3) : await StructTreeRoot.canCreateStructureTree({ catalogRef: f3, pdfManager: i3, newAnnotationsByPage: o4 }) && (p3 = null);
            const e5 = AnnotationFactory.generateImages(a4.values(), d3, i3.evaluatorOptions.isOffscreenCanvasSupported), t5 = void 0 === p3 ? r4 : [];
            for (const [a5, s5] of o4) t5.push(i3.getPage(a5).then((t6) => {
              const i4 = new WorkerTask(`Save (editor): page ${a5}`);
              return t6.saveNewAnnotations(C3, i4, s5, e5).finally(function() {
                finishWorkerTask(i4);
              });
            }));
            null === p3 ? r4.push(Promise.all(t5).then(async (e6) => (await StructTreeRoot.createStructureTree({ newAnnotationsByPage: o4, xref: d3, catalogRef: f3, pdfManager: i3, newRefs: e6 }), e6))) : p3 && r4.push(Promise.all(t5).then(async (e6) => (await p3.updateStructureTree({ newAnnotationsByPage: o4, pdfManager: i3, newRefs: e6 }), e6)));
          }
          if (e4) r4.push(i3.serializeXfaData(a4));
          else for (let e5 = 0; e5 < t4; e5++) r4.push(i3.getPage(e5).then(function(t5) {
            const i4 = new WorkerTask(`Save: page ${e5}`);
            return t5.save(C3, i4, a4).finally(function() {
              finishWorkerTask(i4);
            });
          }));
          const m3 = await Promise.all(r4);
          let y3 = [], w3 = null;
          if (e4) {
            if (w3 = m3[0], !w3) return g4.bytes;
          } else if (y3 = m3.flat(2), 0 === y3.length) return g4.bytes;
          const b3 = h4 && c4 instanceof Dict && y3.some((e5) => e5.needAppearances), D3 = c4 instanceof Dict && c4.get("XFA") || null;
          let S3 = null, F3 = false;
          if (Array.isArray(D3)) {
            for (let e5 = 0, t5 = D3.length; e5 < t5; e5 += 2) "datasets" === D3[e5] && (S3 = D3[e5 + 1], F3 = true);
            null === S3 && (S3 = d3.getNewTemporaryRef());
          } else D3 && warn("Unsupported XFA type.");
          let k3 = /* @__PURE__ */ Object.create(null);
          if (d3.trailer) {
            const e5 = /* @__PURE__ */ Object.create(null), t5 = d3.trailer.get("Info") || null;
            t5 instanceof Dict && t5.forEach((t6, i4) => {
              "string" == typeof i4 && (e5[t6] = stringToPDFString(i4));
            }), k3 = { rootRef: f3, encryptRef: d3.trailer.getRaw("Encrypt") || null, newRef: d3.getNewTemporaryRef(), infoRef: d3.trailer.getRaw("Info") || null, info: e5, fileIds: d3.trailer.get("ID") || null, startXRef: u3 ? l4 : d3.lastXRefStreamPos ?? l4, filename: s4 };
          }
          return incrementalUpdate({ originalData: g4.bytes, xrefInfo: k3, newRefs: y3, xref: d3, hasXfa: !!D3, xfaDatasetsRef: S3, hasXfaDatasetsEntry: F3, needAppearances: b3, acroFormRef: h4, acroForm: c4, xfaData: w3, useXrefStream: isDict(d3.topDict, "XRef") }).finally(() => {
            d3.resetNewTemporaryRef();
          });
        }), C3.on("GetOperatorList", function(e4, t4) {
          const a4 = e4.pageIndex;
          i3.getPage(a4).then(function(i4) {
            const s4 = new WorkerTask(`GetOperatorList: page ${a4}`);
            startWorkerTask(s4);
            const n4 = r3 >= qi ? Date.now() : 0;
            i4.getOperatorList({ handler: C3, sink: t4, task: s4, intent: e4.intent, cacheKey: e4.cacheKey, annotationStorage: e4.annotationStorage, modifiedIds: e4.modifiedIds }).then(function(e5) {
              finishWorkerTask(s4), n4 && info(`page=${a4 + 1} - getOperatorList: time=${Date.now() - n4}ms, len=${e5.length}`), t4.close();
            }, function(e5) {
              finishWorkerTask(s4), s4.terminated || t4.error(e5);
            });
          });
        }), C3.on("GetTextContent", function(e4, t4) {
          const { pageIndex: a4, includeMarkedContent: s4, disableNormalization: n4 } = e4;
          i3.getPage(a4).then(function(e5) {
            const i4 = new WorkerTask("GetTextContent: page " + a4);
            startWorkerTask(i4);
            const o4 = r3 >= qi ? Date.now() : 0;
            e5.extractTextContent({ handler: C3, task: i4, sink: t4, includeMarkedContent: s4, disableNormalization: n4 }).then(function() {
              finishWorkerTask(i4), o4 && info(`page=${a4 + 1} - getTextContent: time=` + (Date.now() - o4) + "ms"), t4.close();
            }, function(e6) {
              finishWorkerTask(i4), i4.terminated || t4.error(e6);
            });
          });
        }), C3.on("GetStructTree", function(e4) {
          return i3.getPage(e4.pageIndex).then(function(e5) {
            return i3.ensure(e5, "getStructTree");
          });
        }), C3.on("FontFallback", function(e4) {
          return i3.fontFallback(e4.id, C3);
        }), C3.on("Cleanup", function(e4) {
          return i3.cleanup(true);
        }), C3.on("Terminate", function(e4) {
          a3 = true;
          const t4 = [];
          if (i3) {
            i3.terminate(new AbortException("Worker was terminated."));
            const e5 = i3.cleanup();
            t4.push(e5), i3 = null;
          } else clearGlobalCaches();
          s3 && s3(new AbortException("Worker was terminated."));
          for (const e5 of n3) t4.push(e5.finished), e5.terminate();
          return Promise.all(t4).then(function() {
            C3.destroy(), C3 = null;
          });
        }), C3.on("Ready", function(t4) {
          !function(e4) {
            function onSuccess(e5) {
              ensureNotTerminated(), C3.send("GetDoc", { pdfInfo: e5 });
            }
            function onFailure(e5) {
              if (ensureNotTerminated(), e5 instanceof PasswordException) {
                const t5 = new WorkerTask(`PasswordException: response ${e5.code}`);
                startWorkerTask(t5), C3.sendWithPromise("PasswordRequest", e5).then(function({ password: e6 }) {
                  finishWorkerTask(t5), i3.updatePassword(e6), pdfManagerReady();
                }).catch(function() {
                  finishWorkerTask(t5), C3.send("DocException", e5);
                });
              } else e5 instanceof InvalidPDFException || e5 instanceof MissingPDFException || e5 instanceof UnexpectedResponseException || e5 instanceof UnknownErrorException ? C3.send("DocException", e5) : C3.send("DocException", new UnknownErrorException(e5.message, e5.toString()));
            }
            function pdfManagerReady() {
              ensureNotTerminated(), loadDocument(false).then(onSuccess, function(e5) {
                ensureNotTerminated(), e5 instanceof XRefParseException ? i3.requestLoadedStream().then(function() {
                  ensureNotTerminated(), loadDocument(true).then(onSuccess, onFailure);
                }) : onFailure(e5);
              });
            }
            ensureNotTerminated(), getPdfManager(e4).then(function(e5) {
              if (a3) throw e5.terminate(new AbortException("Worker was terminated.")), new Error("Worker was terminated");
              i3 = e5, i3.requestLoadedStream(true).then((e6) => {
                C3.send("DataLoaded", { length: e6.bytes.byteLength });
              });
            }).then(pdfManagerReady, onFailure);
          }(e3), e3 = null;
        }), l3;
      }
      static initializeFromPort(e3) {
        const t3 = new MessageHandler("worker", "main", e3);
        _WorkerMessageHandler.setup(t3, e3), t3.send("ready", null);
      }
    };
    !bA && "undefined" != typeof self && ("function" == typeof (zh = self).postMessage && "onmessage" in zh) && WorkerMessageHandler.initializeFromPort(self), Promise.withResolvers ?? (Promise.withResolvers = function() {
      let e3, t3;
      return { promise: new Promise((i3, a3) => {
        e3 = i3, t3 = a3;
      }), resolve: e3, reject: t3 };
    });
  }
});

// node_modules/unpdf/dist/index.mjs
async function getDocumentProxy(data, options = {}) {
  const { getDocument } = await getResolvedPDFJS();
  const pdf = await getDocument({
    data,
    isEvalSupported: false,
    // See: https://github.com/mozilla/pdf.js/issues/4244#issuecomment-1479534301
    useSystemFonts: true,
    ...options
  }).promise;
  return pdf;
}
async function getResolvedPDFJS() {
  if (!resolvedModule) {
    await resolvePDFJSImports();
  }
  return resolvedModule;
}
async function resolvePDFJSImports(pdfjsResolver, { force = false } = {}) {
  if (resolvedModule && !force) {
    return;
  }
  if (pdfjsResolver) {
    try {
      resolvedModule = await interopDefault(pdfjsResolver());
      if (resolvedModule && "resolvePDFJS" in resolvedModule) {
        resolvedModule = await resolvedModule.resolvePDFJS();
      }
      return;
    } catch (error) {
      console.error(error);
      throw new Error("Resolving failed. Please check the provided configuration.");
    }
  }
  try {
    const { resolvePDFJS: resolvePDFJS2 } = await Promise.resolve().then(() => (init_pdfjs(), pdfjs_exports));
    resolvedModule = await resolvePDFJS2();
  } catch (error) {
    console.error(error);
    throw new Error("PDF.js is not available. Please add the package as a dependency.");
  }
}
function isPDFDocumentProxy(data) {
  return typeof data === "object" && data !== null && "_pdfInfo" in data;
}
async function interopDefault(m3) {
  const resolved = await m3;
  return resolved.default || resolved;
}
async function getMeta$1(data) {
  const pdf = isPDFDocumentProxy(data) ? data : await getDocumentProxy(data);
  const meta = await pdf.getMetadata();
  return {
    info: meta?.info ?? {},
    metadata: meta?.metadata?.getAll() ?? {}
  };
}
async function extractText$1(data, options = {}) {
  const { mergePages = false } = { ...options };
  const pdf = isPDFDocumentProxy(data) ? data : await getDocumentProxy(data);
  const texts = await Promise.all(
    Array.from({ length: pdf.numPages }, (_3, i3) => getPageText(pdf, i3 + 1))
  );
  return {
    totalPages: pdf.numPages,
    text: mergePages ? texts.join("\n").replace(/\s+/g, " ") : texts
  };
}
async function getPageText(document2, pageNumber) {
  const page = await document2.getPage(pageNumber);
  const content = await page.getTextContent();
  return content.items.filter((item) => item.str != null).map((item) => item.str + (item.hasEOL ? "\n" : "")).join("");
}
var resolvedModule, isNode, getMeta, extractText;
var init_dist = __esm({
  "node_modules/unpdf/dist/index.mjs"() {
    isNode = globalThis.process?.release?.name === "node";
    getMeta = async (...args) => {
      await resolvePDFJSImports();
      return await getMeta$1(...args);
    };
    extractText = async (...args) => {
      await resolvePDFJSImports();
      return await extractText$1(...args);
    };
  }
});

// src/pdf.ts
var pdf_exports = {};
__export(pdf_exports, {
  arrayBufferToBase64: () => arrayBufferToBase64,
  detectContentType: () => detectContentType,
  extractPdfContent: () => extractPdfContent,
  fetchAndExtractPdf: () => fetchAndExtractPdf,
  fetchPdfAsArrayBuffer: () => fetchPdfAsArrayBuffer,
  isPdfContentType: () => isPdfContentType,
  isPdfUrl: () => isPdfUrl,
  isVisionModel: () => isVisionModel
});
function isPdfUrl(url) {
  try {
    const urlObj = new URL(url);
    const pathname = urlObj.pathname.toLowerCase();
    if (pathname.endsWith(".pdf")) return true;
    const format2 = urlObj.searchParams.get("format")?.toLowerCase();
    if (format2 === "pdf") return true;
    return false;
  } catch {
    return false;
  }
}
function isPdfContentType(contentType) {
  return contentType.toLowerCase().includes("application/pdf");
}
async function detectContentType(url) {
  if (isPdfUrl(url)) {
    return { isPdf: true, contentType: "application/pdf" };
  }
  try {
    const resp = await (0, import_obsidian2.requestUrl)({
      url,
      method: "HEAD",
      headers: { "User-Agent": USER_AGENT }
    });
    const contentType = resp.headers["content-type"] || "";
    return {
      isPdf: isPdfContentType(contentType),
      contentType
    };
  } catch {
    return { isPdf: false, contentType: "text/html" };
  }
}
async function fetchPdfAsArrayBuffer(url) {
  const resp = await (0, import_obsidian2.requestUrl)({
    url,
    headers: { "User-Agent": USER_AGENT }
  });
  if (resp.status >= 400) {
    throw new Error(`HTTP ${resp.status} when fetching PDF`);
  }
  const buffer = resp.arrayBuffer;
  const header = new Uint8Array(buffer, 0, 5);
  const headerStr = String.fromCharCode(...header);
  if (!headerStr.startsWith("%PDF-")) {
    const preview = String.fromCharCode(...new Uint8Array(buffer, 0, 100));
    throw new Error(`Invalid PDF file. Content does not start with %PDF-. Preview: "${preview.slice(0, 50)}..."`);
  }
  return buffer;
}
function guessSource(url) {
  try {
    const hostname = new URL(url).hostname.replace(/^www\./, "");
    return hostname;
  } catch {
    return "";
  }
}
function guessTitleFromUrl(url) {
  try {
    const urlObj = new URL(url);
    const pathname = urlObj.pathname;
    const filename = pathname.split("/").pop() || "";
    const decoded = decodeURIComponent(filename.replace(/\.pdf$/i, ""));
    return decoded.replace(/[_-]+/g, " ").trim();
  } catch {
    return "";
  }
}
function trimText(text, maxChars) {
  if (text.length <= maxChars) return text;
  return text.slice(0, maxChars) + "\n\n[truncated]";
}
async function extractPdfContent(buffer, url, maxChars, maxPages) {
  const uint8Array = new Uint8Array(buffer);
  const pdf = await getDocumentProxy(uint8Array);
  let meta = null;
  try {
    meta = await getMeta(pdf);
  } catch {
  }
  const totalPages = pdf.numPages;
  const pagesToExtract = maxPages ? Math.min(totalPages, maxPages) : totalPages;
  let fullText = "";
  try {
    const result = await extractText(pdf, { mergePages: true });
    fullText = result.text;
    if (maxPages && totalPages > maxPages) {
      fullText += `

[Note: Only first ${maxPages} of ${totalPages} pages extracted]`;
    }
  } catch (err) {
    console.warn("PDF text extraction failed:", err);
    fullText = "";
  }
  const authors = [];
  if (meta?.info?.Author) {
    const authorStr = String(meta.info.Author);
    authors.push(
      ...authorStr.split(/[,;&]|\s+and\s+/i).map((a3) => a3.trim()).filter(Boolean)
    );
  }
  let published = "";
  if (meta?.info?.CreationDate) {
    try {
      const dateStr = String(meta.info.CreationDate);
      const match = dateStr.match(/D:(\d{4})(\d{2})(\d{2})/);
      if (match) {
        published = `${match[1]}-${match[2]}-${match[3]}`;
      }
    } catch {
    }
  }
  const title = meta?.info?.Title ? String(meta.info.Title) : guessTitleFromUrl(url);
  return {
    title,
    authors,
    published,
    text: trimText(fullText, maxChars),
    sourceGuess: guessSource(url),
    links: [],
    // PDF link extraction is complex; skip for now
    images: [],
    // PDF image extraction requires additional processing
    contentType: "pdf",
    pageCount: totalPages,
    pdfBuffer: buffer
  };
}
async function fetchAndExtractPdf(url, maxChars, maxPages) {
  const buffer = await fetchPdfAsArrayBuffer(url);
  return extractPdfContent(buffer, url, maxChars, maxPages);
}
function arrayBufferToBase64(buffer) {
  const bytes = new Uint8Array(buffer);
  let binary = "";
  for (let i3 = 0; i3 < bytes.byteLength; i3++) {
    binary += String.fromCharCode(bytes[i3]);
  }
  return btoa(binary);
}
function isVisionModel(model) {
  const visionModels = [
    "gpt-4o",
    "gpt-4o-mini",
    "gpt-4-turbo",
    "gpt-4.1",
    "o3",
    "o3-mini",
    "o1",
    "o1-mini"
  ];
  const modelLower = model.toLowerCase();
  return visionModels.some((vm) => modelLower.includes(vm.toLowerCase()));
}
var import_obsidian2, USER_AGENT;
var init_pdf = __esm({
  "src/pdf.ts"() {
    "use strict";
    import_obsidian2 = require("obsidian");
    init_dist();
    USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36";
  }
});

// node_modules/node-fetch/node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS({
  "node_modules/node-fetch/node_modules/webidl-conversions/lib/index.js"(exports2, module2) {
    "use strict";
    var conversions = {};
    module2.exports = conversions;
    function sign(x3) {
      return x3 < 0 ? -1 : 1;
    }
    function evenRound(x3) {
      if (x3 % 1 === 0.5 && (x3 & 1) === 0) {
        return Math.floor(x3);
      } else {
        return Math.round(x3);
      }
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
      return function(V3, opts) {
        if (!opts) opts = {};
        let x3 = +V3;
        if (opts.enforceRange) {
          if (!Number.isFinite(x3)) {
            throw new TypeError("Argument is not a finite number");
          }
          x3 = sign(x3) * Math.floor(Math.abs(x3));
          if (x3 < lowerBound || x3 > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x3;
        }
        if (!isNaN(x3) && opts.clamp) {
          x3 = evenRound(x3);
          if (x3 < lowerBound) x3 = lowerBound;
          if (x3 > upperBound) x3 = upperBound;
          return x3;
        }
        if (!Number.isFinite(x3) || x3 === 0) {
          return 0;
        }
        x3 = sign(x3) * Math.floor(Math.abs(x3));
        x3 = x3 % moduloVal;
        if (!typeOpts.unsigned && x3 >= moduloBound) {
          return x3 - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x3 < 0) {
            x3 += moduloVal;
          } else if (x3 === -0) {
            return 0;
          }
        }
        return x3;
      };
    }
    conversions["void"] = function() {
      return void 0;
    };
    conversions["boolean"] = function(val) {
      return !!val;
    };
    conversions["byte"] = createNumberConversion(8, { unsigned: false });
    conversions["octet"] = createNumberConversion(8, { unsigned: true });
    conversions["short"] = createNumberConversion(16, { unsigned: false });
    conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
    conversions["long"] = createNumberConversion(32, { unsigned: false });
    conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
    conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
    conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
    conversions["double"] = function(V3) {
      const x3 = +V3;
      if (!Number.isFinite(x3)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x3;
    };
    conversions["unrestricted double"] = function(V3) {
      const x3 = +V3;
      if (isNaN(x3)) {
        throw new TypeError("Argument is NaN");
      }
      return x3;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V3, opts) {
      if (!opts) opts = {};
      if (opts.treatNullAsEmptyString && V3 === null) {
        return "";
      }
      return String(V3);
    };
    conversions["ByteString"] = function(V3, opts) {
      const x3 = String(V3);
      let c3 = void 0;
      for (let i3 = 0; (c3 = x3.codePointAt(i3)) !== void 0; ++i3) {
        if (c3 > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x3;
    };
    conversions["USVString"] = function(V3) {
      const S3 = String(V3);
      const n3 = S3.length;
      const U3 = [];
      for (let i3 = 0; i3 < n3; ++i3) {
        const c3 = S3.charCodeAt(i3);
        if (c3 < 55296 || c3 > 57343) {
          U3.push(String.fromCodePoint(c3));
        } else if (56320 <= c3 && c3 <= 57343) {
          U3.push(String.fromCodePoint(65533));
        } else {
          if (i3 === n3 - 1) {
            U3.push(String.fromCodePoint(65533));
          } else {
            const d3 = S3.charCodeAt(i3 + 1);
            if (56320 <= d3 && d3 <= 57343) {
              const a3 = c3 & 1023;
              const b3 = d3 & 1023;
              U3.push(String.fromCodePoint((2 << 15) + (2 << 9) * a3 + b3));
              ++i3;
            } else {
              U3.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U3.join("");
    };
    conversions["Date"] = function(V3, opts) {
      if (!(V3 instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V3)) {
        return void 0;
      }
      return V3;
    };
    conversions["RegExp"] = function(V3, opts) {
      if (!(V3 instanceof RegExp)) {
        V3 = new RegExp(V3);
      }
      return V3;
    };
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/utils.js
var require_utils = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/utils.js"(exports2, module2) {
    "use strict";
    module2.exports.mixin = function mixin(target, source) {
      const keys = Object.getOwnPropertyNames(source);
      for (let i3 = 0; i3 < keys.length; ++i3) {
        Object.defineProperty(target, keys[i3], Object.getOwnPropertyDescriptor(source, keys[i3]));
      }
    };
    module2.exports.wrapperSymbol = Symbol("wrapper");
    module2.exports.implSymbol = Symbol("impl");
    module2.exports.wrapperForImpl = function(impl) {
      return impl[module2.exports.wrapperSymbol];
    };
    module2.exports.implForWrapper = function(wrapper) {
      return wrapper[module2.exports.implSymbol];
    };
  }
});

// node_modules/node-fetch/node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "node_modules/node-fetch/node_modules/tr46/lib/mappingTable.json"(exports2, module2) {
    module2.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// node_modules/node-fetch/node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "node_modules/node-fetch/node_modules/tr46/index.js"(exports2, module2) {
    "use strict";
    var punycode = require("punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    };
    function normalize(str2) {
      return str2.split("\0").map(function(s3) {
        return s3.normalize("NFC");
      }).join("\0");
    }
    function findStatus(val) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          return target;
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string) {
      return string.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i3 = 0; i3 < len; ++i3) {
        var codePoint = domain_name.codePointAt(i3);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error = false;
      if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error = true;
      }
      var len = countSymbols(label);
      for (var i3 = 0; i3 < len; ++i3) {
        var status = findStatus(label.codePointAt(i3));
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
          error = true;
          break;
        }
      }
      return {
        label,
        error
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize(result.string);
      var labels = result.string.split(".");
      for (var i3 = 0; i3 < labels.length; ++i3) {
        try {
          var validation = validateLabel(labels[i3]);
          labels[i3] = validation.label;
          result.error = result.error || validation.error;
        } catch (e3) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      };
    }
    module2.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function(l3) {
        try {
          return punycode.toASCII(l3);
        } catch (e3) {
          result.error = true;
          return l3;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i3 = 0; i3 < labels.length; ++i3) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error) return null;
      return labels.join(".");
    };
    module2.exports.toUnicode = function(domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
      return {
        domain: result.string,
        error: result.error
      };
    };
    module2.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js"(exports2, module2) {
    "use strict";
    var punycode = require("punycode");
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str2) {
      return punycode.ucs2.decode(str2).length;
    }
    function at3(input, idx) {
      const c3 = input[idx];
      return isNaN(c3) ? void 0 : String.fromCodePoint(c3);
    }
    function isASCIIDigit(c3) {
      return c3 >= 48 && c3 <= 57;
    }
    function isASCIIAlpha(c3) {
      return c3 >= 65 && c3 <= 90 || c3 >= 97 && c3 <= 122;
    }
    function isASCIIAlphanumeric(c3) {
      return isASCIIAlpha(c3) || isASCIIDigit(c3);
    }
    function isASCIIHex(c3) {
      return isASCIIDigit(c3) || c3 >= 65 && c3 <= 70 || c3 >= 97 && c3 <= 102;
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
    }
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial2(url) {
      return isSpecialScheme(url.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function percentEncode(c3) {
      let hex = c3.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    function utf8PercentEncode(c3) {
      const buf = new Buffer(c3);
      let str2 = "";
      for (let i3 = 0; i3 < buf.length; ++i3) {
        str2 += percentEncode(buf[i3]);
      }
      return str2;
    }
    function utf8PercentDecode(str2) {
      const input = new Buffer(str2);
      const output = [];
      for (let i3 = 0; i3 < input.length; ++i3) {
        if (input[i3] !== 37) {
          output.push(input[i3]);
        } else if (input[i3] === 37 && isASCIIHex(input[i3 + 1]) && isASCIIHex(input[i3 + 2])) {
          output.push(parseInt(input.slice(i3 + 1, i3 + 3).toString(), 16));
          i3 += 2;
        } else {
          output.push(input[i3]);
        }
      }
      return new Buffer(output).toString();
    }
    function isC0ControlPercentEncode(c3) {
      return c3 <= 31 || c3 > 126;
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
    function isPathPercentEncode(c3) {
      return isC0ControlPercentEncode(c3) || extraPathPercentEncodeSet.has(c3);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
    function isUserinfoPercentEncode(c3) {
      return isPathPercentEncode(c3) || extraUserinfoPercentEncodeSet.has(c3);
    }
    function percentEncodeChar(c3, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c3);
      if (encodeSetPredicate(c3)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input) {
      let R3 = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R3 = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R3 = 8;
      }
      if (input === "") {
        return 0;
      }
      const regex = R3 === 10 ? /[^0-9]/ : R3 === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R3);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n3 = parseIPv4Number(part);
        if (n3 === failure) {
          return input;
        }
        numbers.push(n3);
      }
      for (let i3 = 0; i3 < numbers.length - 1; ++i3) {
        if (numbers[i3] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n3 of numbers) {
        ipv4 += n3 * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n3 = address;
      for (let i3 = 1; i3 <= 4; ++i3) {
        output = String(n3 % 256) + output;
        if (i3 !== 4) {
          output = "." + output;
        }
        n3 = Math.floor(n3 / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at3(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (isASCIIDigit(input[pointer])) {
              const number = parseInt(at3(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
      if (asciiDomain === null) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      let output = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i3 = 0; i3 < decoded.length; ++i3) {
        output += percentEncodeChar(decoded[i3], isC0ControlPercentEncode);
      }
      return output;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i3 = 0; i3 < arr.length; ++i3) {
        if (arr[i3] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i3;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function trimControlChars(url) {
      return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url) {
      const path2 = url.path;
      if (path2.length === 0) {
        return;
      }
      if (url.scheme === "file" && path2.length === 1 && isNormalizedWindowsDriveLetter(path2[0])) {
        return;
      }
      path2.pop();
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/.test(string);
    }
    function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c3 = this.input[this.pointer];
        const cStr = isNaN(c3) ? void 0 : String.fromCodePoint(c3);
        const ret = this["parse " + this.state](c3, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c3, cStr) {
      if (isASCIIAlpha(c3)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c3, cStr) {
      if (isASCIIAlphanumeric(c3) || c3 === 43 || c3 === 45 || c3 === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c3 === 58) {
        if (this.stateOverride) {
          if (isSpecial2(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial2(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial2(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial2(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c3) {
      if (this.base === null || this.base.cannotBeABaseURL && c3 !== 35) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c3 === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c3) {
      if (c3 === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c3) {
      if (c3 === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c3) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c3)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c3 === 47) {
        this.state = "relative slash";
      } else if (c3 === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c3 === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial2(this.url) && c3 === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c3) {
      if (isSpecial2(this.url) && (c3 === 47 || c3 === 92)) {
        if (c3 === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c3 === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c3) {
      if (c3 === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c3) {
      if (c3 !== 47 && c3 !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c3, cStr) {
      if (c3 === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c3) || c3 === 47 || c3 === 63 || c3 === 35 || isSpecial2(this.url) && c3 === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c3, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c3 === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isSpecial2(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c3) || c3 === 47 || c3 === 63 || c3 === 35 || isSpecial2(this.url) && c3 === 92) {
        --this.pointer;
        if (isSpecial2(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial2(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c3 === 91) {
          this.arrFlag = true;
        } else if (c3 === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c3, cStr) {
      if (isASCIIDigit(c3)) {
        this.buffer += cStr;
      } else if (isNaN(c3) || c3 === 47 || c3 === 63 || c3 === 35 || isSpecial2(this.url) && c3 === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = function parseFile(c3) {
      this.url.scheme = "file";
      if (c3 === 47 || c3 === 92) {
        if (c3 === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c3)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c3 === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c3 === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
          !isWindowsDriveLetterCodePoints(c3, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
          !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c3) {
      if (c3 === 47 || c3 === 92) {
        if (c3 === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c3, cStr) {
      if (isNaN(c3) || c3 === 47 || c3 === 92 || c3 === 63 || c3 === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial2(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c3) {
      if (isSpecial2(this.url)) {
        if (c3 === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c3 !== 47 && c3 !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c3 === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c3 === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c3 !== void 0) {
        this.state = "path";
        if (c3 !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c3) {
      if (isNaN(c3) || c3 === 47 || isSpecial2(this.url) && c3 === 92 || !this.stateOverride && (c3 === 63 || c3 === 35)) {
        if (isSpecial2(this.url) && c3 === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c3 !== 47 && !(isSpecial2(this.url) && c3 === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c3 !== 47 && !(isSpecial2(this.url) && c3 === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c3 === void 0 || c3 === 63 || c3 === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c3 === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c3 === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c3 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c3, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c3) {
      if (c3 === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c3 === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c3) && c3 !== 37) {
          this.parseError = true;
        }
        if (c3 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c3)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c3, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c3, cStr) {
      if (isNaN(c3) || !this.stateOverride && c3 === 35) {
        if (!isSpecial2(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer);
        for (let i3 = 0; i3 < buffer.length; ++i3) {
          if (buffer[i3] < 33 || buffer[i3] > 126 || buffer[i3] === 34 || buffer[i3] === 35 || buffer[i3] === 60 || buffer[i3] === 62) {
            this.url.query += percentEncode(buffer[i3]);
          } else {
            this.url.query += String.fromCodePoint(buffer[i3]);
          }
        }
        this.buffer = "";
        if (c3 === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c3 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c3) {
      if (isNaN(c3)) {
      } else if (c3 === 0) {
        this.parseError = true;
      } else {
        if (c3 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c3, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url, excludeFragment) {
      let output = url.scheme + ":";
      if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
          output += url.username;
          if (url.password !== "") {
            output += ":" + url.password;
          }
          output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
          output += ":" + url.port;
        }
      } else if (url.host === null && url.scheme === "file") {
        output += "//";
      }
      if (url.cannotBeABaseURL) {
        output += url.path[0];
      } else {
        for (const string of url.path) {
          output += "/" + string;
        }
      }
      if (url.query !== null) {
        output += "?" + url.query;
      }
      if (!excludeFragment && url.fragment !== null) {
        output += "#" + url.fragment;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://";
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += ":" + tuple.port;
      }
      return result;
    }
    module2.exports.serializeURL = serializeURL;
    module2.exports.serializeURLOrigin = function(url) {
      switch (url.scheme) {
        case "blob":
          try {
            return module2.exports.serializeURLOrigin(module2.exports.parseURL(url.path[0]));
          } catch (e3) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module2.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module2.exports.setTheUsername = function(url, username) {
      url.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i3 = 0; i3 < decoded.length; ++i3) {
        url.username += percentEncodeChar(decoded[i3], isUserinfoPercentEncode);
      }
    };
    module2.exports.setThePassword = function(url, password) {
      url.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i3 = 0; i3 < decoded.length; ++i3) {
        url.password += percentEncodeChar(decoded[i3], isUserinfoPercentEncode);
      }
    };
    module2.exports.serializeHost = serializeHost;
    module2.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module2.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module2.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module2.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/URL-impl.js"(exports2) {
    "use strict";
    var usm = require_url_state_machine();
    exports2.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== void 0) {
          parsedBase = usm.basicURLParse(base);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v3) {
        const parsedURL = usm.basicURLParse(v3);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v3) {
        usm.basicURLParse(v3 + ":", { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v3) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v3);
      }
      get password() {
        return this._url.password;
      }
      set password(v3) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v3);
      }
      get host() {
        const url = this._url;
        if (url.host === null) {
          return "";
        }
        if (url.port === null) {
          return usm.serializeHost(url.host);
        }
        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
      }
      set host(v3) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v3, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v3) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v3, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v3) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v3 === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v3, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v3) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v3, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v3) {
        const url = this._url;
        if (v3 === "") {
          url.query = null;
          return;
        }
        const input = v3[0] === "?" ? v3.substring(1) : v3;
        url.query = "";
        usm.basicURLParse(input, { url, stateOverride: "query" });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v3) {
        if (v3 === "") {
          this._url.fragment = null;
          return;
        }
        const input = v3[0] === "#" ? v3.substring(1) : v3;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/URL.js"(exports2, module2) {
    "use strict";
    var conversions = require_lib();
    var utils = require_utils();
    var Impl = require_URL_impl();
    var impl = utils.implSymbol;
    function URL2(url) {
      if (!this || this[impl] || !(this instanceof URL2)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
      }
      const args = [];
      for (let i3 = 0; i3 < arguments.length && i3 < 2; ++i3) {
        args[i3] = arguments[i3];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module2.exports.setup(this, args);
    }
    URL2.prototype.toJSON = function toJSON() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i3 = 0; i3 < arguments.length && i3 < 0; ++i3) {
        args[i3] = arguments[i3];
      }
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL2.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V3) {
        V3 = conversions["USVString"](V3);
        this[impl].href = V3;
      },
      enumerable: true,
      configurable: true
    });
    URL2.prototype.toString = function() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL2.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V3) {
        V3 = conversions["USVString"](V3);
        this[impl].protocol = V3;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V3) {
        V3 = conversions["USVString"](V3);
        this[impl].username = V3;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V3) {
        V3 = conversions["USVString"](V3);
        this[impl].password = V3;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V3) {
        V3 = conversions["USVString"](V3);
        this[impl].host = V3;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V3) {
        V3 = conversions["USVString"](V3);
        this[impl].hostname = V3;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V3) {
        V3 = conversions["USVString"](V3);
        this[impl].port = V3;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V3) {
        V3 = conversions["USVString"](V3);
        this[impl].pathname = V3;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V3) {
        V3 = conversions["USVString"](V3);
        this[impl].search = V3;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V3) {
        V3 = conversions["USVString"](V3);
        this[impl].hash = V3;
      },
      enumerable: true,
      configurable: true
    });
    module2.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL2.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData) privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils.wrapperSymbol] = obj;
      },
      interface: URL2,
      expose: {
        Window: { URL: URL2 },
        Worker: { URL: URL2 }
      }
    };
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/public-api.js"(exports2) {
    "use strict";
    exports2.URL = require_URL().interface;
    exports2.serializeURL = require_url_state_machine().serializeURL;
    exports2.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports2.basicURLParse = require_url_state_machine().basicURLParse;
    exports2.setTheUsername = require_url_state_machine().setTheUsername;
    exports2.setThePassword = require_url_state_machine().setThePassword;
    exports2.serializeHost = require_url_state_machine().serializeHost;
    exports2.serializeInteger = require_url_state_machine().serializeInteger;
    exports2.parseURL = require_url_state_machine().parseURL;
  }
});

// node_modules/node-fetch/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/node-fetch/lib/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Stream3 = _interopDefault(require("stream"));
    var http = _interopDefault(require("http"));
    var Url = _interopDefault(require("url"));
    var whatwgUrl = _interopDefault(require_public_api());
    var https = _interopDefault(require("https"));
    var zlib = _interopDefault(require("zlib"));
    var Readable2 = Stream3.Readable;
    var BUFFER = Symbol("buffer");
    var TYPE = Symbol("type");
    var Blob4 = class _Blob {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a3 = blobParts;
          const length = Number(a3.length);
          for (let i3 = 0; i3 < length; i3++) {
            const element = a3[i3];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof _Blob) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable2();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new _Blob([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob4.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob4.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function FetchError(message, type, systemError) {
      Error.call(this, message);
      this.message = message;
      this.type = type;
      if (systemError) {
        this.code = this.errno = systemError.code;
      }
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    var convert;
    try {
      convert = require("encoding").convert;
    } catch (e3) {
    }
    var INTERNALS = Symbol("Body internals");
    var PassThrough = Stream3.PassThrough;
    function Body2(body) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
      let size = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) {
        body = null;
      } else if (isURLSearchParams(body)) {
        body = Buffer.from(body.toString());
      } else if (isBlob2(body)) ;
      else if (Buffer.isBuffer(body)) ;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        body = Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      } else if (body instanceof Stream3) ;
      else {
        body = Buffer.from(String(body));
      }
      this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
      };
      this.size = size;
      this.timeout = timeout;
      if (body instanceof Stream3) {
        body.on("error", function(err) {
          const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
          _this[INTERNALS].error = error;
        });
      }
    }
    Body2.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      blob() {
        let ct3 = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf) {
          return Object.assign(
            // Prevent copying
            new Blob4([], {
              type: ct3.toLowerCase()
            }),
            {
              [BUFFER]: buf
            }
          );
        });
      },
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body2.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      text() {
        return consumeBody.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody.call(this);
      },
      /**
       * Decode response as text, while automatically detecting the encoding and
       * trying to decode to UTF-8 (non-spec api)
       *
       * @return  Promise
       */
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body2.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body2.mixIn = function(proto) {
      for (const name of Object.getOwnPropertyNames(Body2.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body2.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    };
    function consumeBody() {
      var _this4 = this;
      if (this[INTERNALS].disturbed) {
        return Body2.Promise.reject(new TypeError(`body used already for: ${this.url}`));
      }
      this[INTERNALS].disturbed = true;
      if (this[INTERNALS].error) {
        return Body2.Promise.reject(this[INTERNALS].error);
      }
      let body = this.body;
      if (body === null) {
        return Body2.Promise.resolve(Buffer.alloc(0));
      }
      if (isBlob2(body)) {
        body = body.stream();
      }
      if (Buffer.isBuffer(body)) {
        return Body2.Promise.resolve(body);
      }
      if (!(body instanceof Stream3)) {
        return Body2.Promise.resolve(Buffer.alloc(0));
      }
      let accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Body2.Promise(function(resolve2, reject) {
        let resTimeout;
        if (_this4.timeout) {
          resTimeout = setTimeout(function() {
            abort = true;
            reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
          }, _this4.timeout);
        }
        body.on("error", function(err) {
          if (err.name === "AbortError") {
            abort = true;
            reject(err);
          } else {
            reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
          }
        });
        body.on("data", function(chunk) {
          if (abort || chunk === null) {
            return;
          }
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort = true;
            reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
            return;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        });
        body.on("end", function() {
          if (abort) {
            return;
          }
          clearTimeout(resTimeout);
          try {
            resolve2(Buffer.concat(accum, accumBytes));
          } catch (err) {
            reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
          }
        });
      });
    }
    function convertBody(buffer, headers) {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function");
      }
      const ct3 = headers.get("content-type");
      let charset = "utf-8";
      let res, str2;
      if (ct3) {
        res = /charset=([^;]*)/i.exec(ct3);
      }
      str2 = buffer.slice(0, 1024).toString();
      if (!res && str2) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str2);
      }
      if (!res && str2) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str2);
        if (!res) {
          res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str2);
          if (res) {
            res.pop();
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str2) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str2);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(buffer, "UTF-8", charset).toString();
    }
    function isURLSearchParams(obj) {
      if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
        return false;
      }
      return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
    }
    function isBlob2(obj) {
      return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
    }
    function clone(instance) {
      let p1, p22;
      let body = instance.body;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream3 && typeof body.getBoundary !== "function") {
        p1 = new PassThrough();
        p22 = new PassThrough();
        body.pipe(p1);
        body.pipe(p22);
        instance[INTERNALS].body = p1;
        body = p22;
      }
      return body;
    }
    function extractContentType(body) {
      if (body === null) {
        return null;
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      } else if (isURLSearchParams(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isBlob2(body)) {
        return body.type || null;
      } else if (Buffer.isBuffer(body)) {
        return null;
      } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        return null;
      } else if (ArrayBuffer.isView(body)) {
        return null;
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      } else if (body instanceof Stream3) {
        return null;
      } else {
        return "text/plain;charset=UTF-8";
      }
    }
    function getTotalBytes(instance) {
      const body = instance.body;
      if (body === null) {
        return 0;
      } else if (isBlob2(body)) {
        return body.size;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (body && typeof body.getLengthSync === "function") {
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
        body.hasKnownLength && body.hasKnownLength()) {
          return body.getLengthSync();
        }
        return null;
      } else {
        return null;
      }
    }
    function writeToStream(dest, instance) {
      const body = instance.body;
      if (body === null) {
        dest.end();
      } else if (isBlob2(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    }
    Body2.Promise = global.Promise;
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name) {
      name = `${name}`;
      if (invalidTokenRegex.test(name) || name === "") {
        throw new TypeError(`${name} is not a legal HTTP header name`);
      }
    }
    function validateValue(value) {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
      }
    }
    function find2(map, name) {
      name = name.toLowerCase();
      for (const key in map) {
        if (key.toLowerCase() === name) {
          return key;
        }
      }
      return void 0;
    }
    var MAP = Symbol("map");
    var Headers4 = class _Headers {
      /**
       * Headers class
       *
       * @param   Object  headers  Response headers
       * @return  Void
       */
      constructor() {
        let init2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init2 instanceof _Headers) {
          const rawHeaders = init2.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init2 == null) ;
        else if (typeof init2 === "object") {
          const method = init2[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init2) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init2)) {
              const value = init2[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      /**
       * Return combined header value given name
       *
       * @param   String  name  Header name
       * @return  Mixed
       */
      get(name) {
        name = `${name}`;
        validateName(name);
        const key = find2(this[MAP], name);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      /**
       * Iterate over all headers
       *
       * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
       * @param   Boolean   thisArg   `this` context for callback function
       * @return  Void
       */
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i3 = 0;
        while (i3 < pairs.length) {
          var _pairs$i = pairs[i3];
          const name = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name, this);
          pairs = getHeaders(this);
          i3++;
        }
      }
      /**
       * Overwrite header values given name
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find2(this[MAP], name);
        this[MAP][key !== void 0 ? key : name] = [value];
      }
      /**
       * Append a value onto existing header
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find2(this[MAP], name);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      /**
       * Check for header name existence
       *
       * @param   String   name  Header name
       * @return  Boolean
       */
      has(name) {
        name = `${name}`;
        validateName(name);
        return find2(this[MAP], name) !== void 0;
      }
      /**
       * Delete all header values given name
       *
       * @param   String  name  Header name
       * @return  Void
       */
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find2(this[MAP], name);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      /**
       * Return raw headers (non-spec api)
       *
       * @return  Object
       */
      raw() {
        return this[MAP];
      }
      /**
       * Get an iterator on keys.
       *
       * @return  Iterator
       */
      keys() {
        return createHeadersIterator(this, "key");
      }
      /**
       * Get an iterator on values.
       *
       * @return  Iterator
       */
      values() {
        return createHeadersIterator(this, "value");
      }
      /**
       * Get an iterator on entries.
       *
       * This is the default iterator of the Headers object.
       *
       * @return  Iterator
       */
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers4.prototype.entries = Headers4.prototype[Symbol.iterator];
    Object.defineProperty(Headers4.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers4.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    function getHeaders(headers) {
      let kind2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
      const keys = Object.keys(headers[MAP]).sort();
      return keys.map(kind2 === "key" ? function(k3) {
        return k3.toLowerCase();
      } : kind2 === "value" ? function(k3) {
        return headers[MAP][k3].join(", ");
      } : function(k3) {
        return [k3.toLowerCase(), headers[MAP][k3].join(", ")];
      });
    }
    var INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind2) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind: kind2,
        index: 0
      };
      return iterator;
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind2 = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind2);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index + 1;
        return {
          value: values[index],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({ __proto__: null }, headers[MAP]);
      const hostHeaderKey = find2(headers[MAP], "Host");
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers = new Headers4();
      for (const name of Object.keys(obj)) {
        if (invalidTokenRegex.test(name)) {
          continue;
        }
        if (Array.isArray(obj[name])) {
          for (const val of obj[name]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers[MAP][name] === void 0) {
              headers[MAP][name] = [val];
            } else {
              headers[MAP][name].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
          headers[MAP][name] = [obj[name]];
        }
      }
      return headers;
    }
    var INTERNALS$1 = Symbol("Response internals");
    var STATUS_CODES = http.STATUS_CODES;
    var Response4 = class _Response {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body2.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers4(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new _Response(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body2.mixIn(Response4.prototype);
    Object.defineProperties(Response4.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response4.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    var INTERNALS$2 = Symbol("Request internals");
    var URL2 = Url.URL || whatwgUrl.URL;
    var parse_url = Url.parse;
    var format_url = Url.format;
    function parseURL(urlStr) {
      if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL2(urlStr).toString();
      }
      return parse_url(urlStr);
    }
    var streamDestructionSupported = "destroy" in Stream3.Readable.prototype;
    function isRequest(input) {
      return typeof input === "object" && typeof input[INTERNALS$2] === "object";
    }
    function isAbortSignal(signal) {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request3 = class _Request {
      constructor(input) {
        let init2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parseURL(input.href);
          } else {
            parsedURL = parseURL(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parseURL(input.url);
        }
        let method = init2.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init2.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init2.body != null ? init2.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body2.call(this, inputBody, {
          timeout: init2.timeout || input.timeout || 0,
          size: init2.size || input.size || 0
        });
        const headers = new Headers4(init2.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init2) signal = init2.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init2.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init2.follow !== void 0 ? init2.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init2.compress !== void 0 ? init2.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init2.counter || input.counter || 0;
        this.agent = init2.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new _Request(this);
      }
    };
    Body2.mixIn(Request3.prototype);
    Object.defineProperty(Request3.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request3.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    function getNodeRequestOptions(request) {
      const parsedURL = request[INTERNALS$2].parsedURL;
      const headers = new Headers4(request[INTERNALS$2].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (request.signal && request.body instanceof Stream3.Readable && !streamDestructionSupported) {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      }
      let contentLengthValue = null;
      if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body != null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate");
      }
      let agent = request.agent;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
      });
    }
    function AbortError(message) {
      Error.call(this, message);
      this.type = "aborted";
      this.message = message;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    var URL$1 = Url.URL || whatwgUrl.URL;
    var PassThrough$1 = Stream3.PassThrough;
    var isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
      const orig = new URL$1(original).hostname;
      const dest = new URL$1(destination).hostname;
      return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
    };
    var isSameProtocol = function isSameProtocol2(destination, original) {
      const orig = new URL$1(original).protocol;
      const dest = new URL$1(destination).protocol;
      return orig === dest;
    };
    function fetch3(url, opts) {
      if (!fetch3.Promise) {
        throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
      }
      Body2.Promise = fetch3.Promise;
      return new fetch3.Promise(function(resolve2, reject) {
        const request = new Request3(url, opts);
        const options = getNodeRequestOptions(request);
        const send = (options.protocol === "https:" ? https : http).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort2() {
          let error = new AbortError("The user aborted a request.");
          reject(error);
          if (request.body && request.body instanceof Stream3.Readable) {
            destroyStream(request.body, error);
          }
          if (!response || !response.body) return;
          response.body.emit("error", error);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort();
          finalize();
        };
        const req = send(options);
        let reqTimeout;
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        function finalize() {
          req.abort();
          if (signal) signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request.timeout) {
          req.once("socket", function(socket) {
            reqTimeout = setTimeout(function() {
              reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
              finalize();
            }, request.timeout);
          });
        }
        req.on("error", function(err) {
          reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
          if (response && response.body) {
            destroyStream(response.body, err);
          }
          finalize();
        });
        fixResponseChunkedTransferBadEnding(req, function(err) {
          if (signal && signal.aborted) {
            return;
          }
          if (response && response.body) {
            destroyStream(response.body, err);
          }
        });
        if (parseInt(process.version.substring(1)) < 14) {
          req.on("socket", function(s3) {
            s3.addListener("close", function(hadError) {
              const hasDataListener = s3.listenerCount("data") > 0;
              if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
                const err = new Error("Premature close");
                err.code = "ERR_STREAM_PREMATURE_CLOSE";
                response.body.emit("error", err);
              }
            });
          });
        }
        req.on("response", function(res) {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch3.isRedirect(res.statusCode)) {
            const location = headers.get("Location");
            let locationURL = null;
            try {
              locationURL = location === null ? null : new URL$1(location, request.url).toString();
            } catch (err) {
              if (request.redirect !== "manual") {
                reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
                finalize();
                return;
              }
            }
            switch (request.redirect) {
              case "error":
                reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err) {
                    reject(err);
                  }
                }
                break;
              case "follow":
                if (locationURL === null) {
                  break;
                }
                if (request.counter >= request.follow) {
                  reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers4(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal,
                  timeout: request.timeout,
                  size: request.size
                };
                if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                  for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                    requestOpts.headers.delete(name);
                  }
                }
                if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                  reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve2(fetch3(new Request3(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function() {
            if (signal) signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request.size,
            timeout: request.timeout,
            counter: request.counter
          };
          const codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response4(body, response_options);
            resolve2(response);
            return;
          }
          const zlibOptions = {
            flush: zlib.Z_SYNC_FLUSH,
            finishFlush: zlib.Z_SYNC_FLUSH
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(zlib.createGunzip(zlibOptions));
            response = new Response4(body, response_options);
            resolve2(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw = res.pipe(new PassThrough$1());
            raw.once("data", function(chunk) {
              if ((chunk[0] & 15) === 8) {
                body = body.pipe(zlib.createInflate());
              } else {
                body = body.pipe(zlib.createInflateRaw());
              }
              response = new Response4(body, response_options);
              resolve2(response);
            });
            raw.on("end", function() {
              if (!response) {
                response = new Response4(body, response_options);
                resolve2(response);
              }
            });
            return;
          }
          if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
            body = body.pipe(zlib.createBrotliDecompress());
            response = new Response4(body, response_options);
            resolve2(response);
            return;
          }
          response = new Response4(body, response_options);
          resolve2(response);
        });
        writeToStream(req, request);
      });
    }
    function fixResponseChunkedTransferBadEnding(request, errorCallback) {
      let socket;
      request.on("socket", function(s3) {
        socket = s3;
      });
      request.on("response", function(response) {
        const headers = response.headers;
        if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
          response.once("close", function(hadError) {
            const hasDataListener = socket && socket.listenerCount("data") > 0;
            if (hasDataListener && !hadError) {
              const err = new Error("Premature close");
              err.code = "ERR_STREAM_PREMATURE_CLOSE";
              errorCallback(err);
            }
          });
        }
      });
    }
    function destroyStream(stream, err) {
      if (stream.destroy) {
        stream.destroy(err);
      } else {
        stream.emit("error", err);
        stream.end();
      }
    }
    fetch3.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch3.Promise = global.Promise;
    module2.exports = exports2 = fetch3;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = exports2;
    exports2.Headers = Headers4;
    exports2.Request = Request3;
    exports2.Response = Response4;
    exports2.FetchError = FetchError;
    exports2.AbortError = AbortError;
  }
});

// node_modules/web-streams-polyfill/dist/ponyfill.mjs
function t2() {
}
function r2(e3) {
  return "object" == typeof e3 && null !== e3 || "function" == typeof e3;
}
function n2(e3, t3) {
  try {
    Object.defineProperty(e3, "name", { value: t3, configurable: true });
  } catch (e4) {
  }
}
function u2(e3) {
  return new a2(e3);
}
function c2(e3) {
  return l2(e3);
}
function d2(e3) {
  return s2(e3);
}
function f2(e3, t3, r3) {
  return i2.call(e3, t3, r3);
}
function b2(e3, t3, r3) {
  f2(f2(e3, t3, r3), void 0, o2);
}
function h2(e3, t3) {
  b2(e3, t3);
}
function _2(e3, t3) {
  b2(e3, void 0, t3);
}
function p2(e3, t3, r3) {
  return f2(e3, t3, r3);
}
function m2(e3) {
  f2(e3, void 0, o2);
}
function g2(e3, t3, r3) {
  if ("function" != typeof e3) throw new TypeError("Argument is not a function");
  return Function.prototype.apply.call(e3, t3, r3);
}
function w2(e3, t3, r3) {
  try {
    return c2(g2(e3, t3, r3));
  } catch (e4) {
    return d2(e4);
  }
}
function E2(e3, t3) {
  e3._ownerReadableStream = t3, t3._reader = e3, "readable" === t3._state ? O2(e3) : "closed" === t3._state ? function(e4) {
    O2(e4), j2(e4);
  }(e3) : B2(e3, t3._storedError);
}
function P2(e3, t3) {
  return Gt2(e3._ownerReadableStream, t3);
}
function W2(e3) {
  const t3 = e3._ownerReadableStream;
  "readable" === t3._state ? A2(e3, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : function(e4, t4) {
    B2(e4, t4);
  }(e3, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), t3._readableStreamController[C2](), t3._reader = void 0, e3._ownerReadableStream = void 0;
}
function k2(e3) {
  return new TypeError("Cannot " + e3 + " a stream using a released reader");
}
function O2(e3) {
  e3._closedPromise = u2((t3, r3) => {
    e3._closedPromise_resolve = t3, e3._closedPromise_reject = r3;
  });
}
function B2(e3, t3) {
  O2(e3), A2(e3, t3);
}
function A2(e3, t3) {
  void 0 !== e3._closedPromise_reject && (m2(e3._closedPromise), e3._closedPromise_reject(t3), e3._closedPromise_resolve = void 0, e3._closedPromise_reject = void 0);
}
function j2(e3) {
  void 0 !== e3._closedPromise_resolve && (e3._closedPromise_resolve(void 0), e3._closedPromise_resolve = void 0, e3._closedPromise_reject = void 0);
}
function F2(e3, t3) {
  if (void 0 !== e3 && ("object" != typeof (r3 = e3) && "function" != typeof r3)) throw new TypeError(`${t3} is not an object.`);
  var r3;
}
function I2(e3, t3) {
  if ("function" != typeof e3) throw new TypeError(`${t3} is not a function.`);
}
function D2(e3, t3) {
  if (!/* @__PURE__ */ function(e4) {
    return "object" == typeof e4 && null !== e4 || "function" == typeof e4;
  }(e3)) throw new TypeError(`${t3} is not an object.`);
}
function $2(e3, t3, r3) {
  if (void 0 === e3) throw new TypeError(`Parameter ${t3} is required in '${r3}'.`);
}
function M2(e3, t3, r3) {
  if (void 0 === e3) throw new TypeError(`${t3} is required in '${r3}'.`);
}
function Y2(e3) {
  return Number(e3);
}
function Q2(e3) {
  return 0 === e3 ? 0 : e3;
}
function N2(e3, t3) {
  const r3 = Number.MAX_SAFE_INTEGER;
  let o3 = Number(e3);
  if (o3 = Q2(o3), !z2(o3)) throw new TypeError(`${t3} is not a finite number`);
  if (o3 = function(e4) {
    return Q2(L2(e4));
  }(o3), o3 < 0 || o3 > r3) throw new TypeError(`${t3} is outside the accepted range of 0 to ${r3}, inclusive`);
  return z2(o3) && 0 !== o3 ? o3 : 0;
}
function H2(e3) {
  if (!r2(e3)) return false;
  if ("function" != typeof e3.getReader) return false;
  try {
    return "boolean" == typeof e3.locked;
  } catch (e4) {
    return false;
  }
}
function x2(e3) {
  if (!r2(e3)) return false;
  if ("function" != typeof e3.getWriter) return false;
  try {
    return "boolean" == typeof e3.locked;
  } catch (e4) {
    return false;
  }
}
function V2(e3, t3) {
  if (!Vt2(e3)) throw new TypeError(`${t3} is not a ReadableStream.`);
}
function U2(e3, t3) {
  e3._reader._readRequests.push(t3);
}
function G2(e3, t3, r3) {
  const o3 = e3._reader._readRequests.shift();
  r3 ? o3._closeSteps() : o3._chunkSteps(t3);
}
function X2(e3) {
  return e3._reader._readRequests.length;
}
function J2(e3) {
  const t3 = e3._reader;
  return void 0 !== t3 && !!K2(t3);
}
function K2(e3) {
  return !!r2(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_readRequests") && e3 instanceof ReadableStreamDefaultReader);
}
function Z2(e3, t3) {
  const r3 = e3._readRequests;
  e3._readRequests = new S2(), r3.forEach((e4) => {
    e4._errorSteps(t3);
  });
}
function ee2(e3) {
  return new TypeError(`ReadableStreamDefaultReader.prototype.${e3} can only be used on a ReadableStreamDefaultReader`);
}
function oe2(e3) {
  if (!r2(e3)) return false;
  if (!Object.prototype.hasOwnProperty.call(e3, "_asyncIteratorImpl")) return false;
  try {
    return e3._asyncIteratorImpl instanceof te2;
  } catch (e4) {
    return false;
  }
}
function ne2(e3) {
  return new TypeError(`ReadableStreamAsyncIterator.${e3} can only be used on a ReadableSteamAsyncIterator`);
}
function ie2(e3, t3, r3, o3, n3) {
  new Uint8Array(e3).set(new Uint8Array(r3, o3, n3), t3);
}
function le2(e3) {
  const t3 = function(e4, t4, r3) {
    if (e4.slice) return e4.slice(t4, r3);
    const o3 = r3 - t4, n3 = new ArrayBuffer(o3);
    return ie2(n3, 0, e4, t4, o3), n3;
  }(e3.buffer, e3.byteOffset, e3.byteOffset + e3.byteLength);
  return new Uint8Array(t3);
}
function se2(e3) {
  const t3 = e3._queue.shift();
  return e3._queueTotalSize -= t3.size, e3._queueTotalSize < 0 && (e3._queueTotalSize = 0), t3.value;
}
function ue2(e3, t3, r3) {
  if ("number" != typeof (o3 = r3) || ae2(o3) || o3 < 0 || r3 === 1 / 0) throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
  var o3;
  e3._queue.push({ value: t3, size: r3 }), e3._queueTotalSize += r3;
}
function ce2(e3) {
  e3._queue = new S2(), e3._queueTotalSize = 0;
}
function de2(e3) {
  return !!r2(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_controlledReadableByteStream") && e3 instanceof ReadableByteStreamController);
}
function fe2(e3) {
  return !!r2(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_associatedReadableByteStreamController") && e3 instanceof ReadableStreamBYOBRequest);
}
function be2(e3) {
  const t3 = function(e4) {
    const t4 = e4._controlledReadableByteStream;
    if ("readable" !== t4._state) return false;
    if (e4._closeRequested) return false;
    if (!e4._started) return false;
    if (J2(t4) && X2(t4) > 0) return true;
    if (Le2(t4) && ze2(t4) > 0) return true;
    if (ke2(e4) > 0) return true;
    return false;
  }(e3);
  if (!t3) return;
  if (e3._pulling) return void (e3._pullAgain = true);
  e3._pulling = true;
  b2(e3._pullAlgorithm(), () => (e3._pulling = false, e3._pullAgain && (e3._pullAgain = false, be2(e3)), null), (t4) => (Pe2(e3, t4), null));
}
function he2(e3) {
  Re2(e3), e3._pendingPullIntos = new S2();
}
function _e2(e3, t3) {
  let r3 = false;
  "closed" === e3._state && (r3 = true);
  const o3 = pe2(t3);
  "default" === t3.readerType ? G2(e3, o3, r3) : function(e4, t4, r4) {
    const o4 = e4._reader._readIntoRequests.shift();
    r4 ? o4._closeSteps(t4) : o4._chunkSteps(t4);
  }(e3, o3, r3);
}
function pe2(e3) {
  const t3 = e3.bytesFilled, r3 = e3.elementSize;
  return new e3.viewConstructor(e3.buffer, e3.byteOffset, t3 / r3);
}
function me2(e3, t3, r3, o3) {
  e3._queue.push({ buffer: t3, byteOffset: r3, byteLength: o3 }), e3._queueTotalSize += o3;
}
function ye2(e3, t3, r3, o3) {
  let n3;
  try {
    n3 = t3.slice(r3, r3 + o3);
  } catch (t4) {
    throw Pe2(e3, t4), t4;
  }
  me2(e3, n3, 0, o3);
}
function ge2(e3, t3) {
  t3.bytesFilled > 0 && ye2(e3, t3.buffer, t3.byteOffset, t3.bytesFilled), Ce2(e3);
}
function we2(e3, t3) {
  const r3 = t3.elementSize, o3 = t3.bytesFilled - t3.bytesFilled % r3, n3 = Math.min(e3._queueTotalSize, t3.byteLength - t3.bytesFilled), a3 = t3.bytesFilled + n3, i3 = a3 - a3 % r3;
  let l3 = n3, s3 = false;
  i3 > o3 && (l3 = i3 - t3.bytesFilled, s3 = true);
  const u3 = e3._queue;
  for (; l3 > 0; ) {
    const r4 = u3.peek(), o4 = Math.min(l3, r4.byteLength), n4 = t3.byteOffset + t3.bytesFilled;
    ie2(t3.buffer, n4, r4.buffer, r4.byteOffset, o4), r4.byteLength === o4 ? u3.shift() : (r4.byteOffset += o4, r4.byteLength -= o4), e3._queueTotalSize -= o4, Se2(e3, o4, t3), l3 -= o4;
  }
  return s3;
}
function Se2(e3, t3, r3) {
  r3.bytesFilled += t3;
}
function ve2(e3) {
  0 === e3._queueTotalSize && e3._closeRequested ? (Ee2(e3), Xt2(e3._controlledReadableByteStream)) : be2(e3);
}
function Re2(e3) {
  null !== e3._byobRequest && (e3._byobRequest._associatedReadableByteStreamController = void 0, e3._byobRequest._view = null, e3._byobRequest = null);
}
function Te2(e3) {
  for (; e3._pendingPullIntos.length > 0; ) {
    if (0 === e3._queueTotalSize) return;
    const t3 = e3._pendingPullIntos.peek();
    we2(e3, t3) && (Ce2(e3), _e2(e3._controlledReadableByteStream, t3));
  }
}
function qe2(e3, t3) {
  const r3 = e3._pendingPullIntos.peek();
  Re2(e3);
  "closed" === e3._controlledReadableByteStream._state ? function(e4, t4) {
    "none" === t4.readerType && Ce2(e4);
    const r4 = e4._controlledReadableByteStream;
    if (Le2(r4)) for (; ze2(r4) > 0; ) _e2(r4, Ce2(e4));
  }(e3, r3) : function(e4, t4, r4) {
    if (Se2(0, t4, r4), "none" === r4.readerType) return ge2(e4, r4), void Te2(e4);
    if (r4.bytesFilled < r4.elementSize) return;
    Ce2(e4);
    const o3 = r4.bytesFilled % r4.elementSize;
    if (o3 > 0) {
      const t5 = r4.byteOffset + r4.bytesFilled;
      ye2(e4, r4.buffer, t5 - o3, o3);
    }
    r4.bytesFilled -= o3, _e2(e4._controlledReadableByteStream, r4), Te2(e4);
  }(e3, t3, r3), be2(e3);
}
function Ce2(e3) {
  return e3._pendingPullIntos.shift();
}
function Ee2(e3) {
  e3._pullAlgorithm = void 0, e3._cancelAlgorithm = void 0;
}
function Pe2(e3, t3) {
  const r3 = e3._controlledReadableByteStream;
  "readable" === r3._state && (he2(e3), ce2(e3), Ee2(e3), Jt2(r3, t3));
}
function We2(e3, t3) {
  const r3 = e3._queue.shift();
  e3._queueTotalSize -= r3.byteLength, ve2(e3);
  const o3 = new Uint8Array(r3.buffer, r3.byteOffset, r3.byteLength);
  t3._chunkSteps(o3);
}
function ke2(e3) {
  const t3 = e3._controlledReadableByteStream._state;
  return "errored" === t3 ? null : "closed" === t3 ? 0 : e3._strategyHWM - e3._queueTotalSize;
}
function Oe2(e3, t3, r3) {
  const o3 = Object.create(ReadableByteStreamController.prototype);
  let n3, a3, i3;
  n3 = void 0 !== t3.start ? () => t3.start(o3) : () => {
  }, a3 = void 0 !== t3.pull ? () => t3.pull(o3) : () => c2(void 0), i3 = void 0 !== t3.cancel ? (e4) => t3.cancel(e4) : () => c2(void 0);
  const l3 = t3.autoAllocateChunkSize;
  if (0 === l3) throw new TypeError("autoAllocateChunkSize must be greater than 0");
  !function(e4, t4, r4, o4, n4, a4, i4) {
    t4._controlledReadableByteStream = e4, t4._pullAgain = false, t4._pulling = false, t4._byobRequest = null, t4._queue = t4._queueTotalSize = void 0, ce2(t4), t4._closeRequested = false, t4._started = false, t4._strategyHWM = a4, t4._pullAlgorithm = o4, t4._cancelAlgorithm = n4, t4._autoAllocateChunkSize = i4, t4._pendingPullIntos = new S2(), e4._readableStreamController = t4, b2(c2(r4()), () => (t4._started = true, be2(t4), null), (e5) => (Pe2(t4, e5), null));
  }(e3, o3, n3, a3, i3, r3, l3);
}
function Be2(e3) {
  return new TypeError(`ReadableStreamBYOBRequest.prototype.${e3} can only be used on a ReadableStreamBYOBRequest`);
}
function Ae2(e3) {
  return new TypeError(`ReadableByteStreamController.prototype.${e3} can only be used on a ReadableByteStreamController`);
}
function je2(e3, t3) {
  e3._reader._readIntoRequests.push(t3);
}
function ze2(e3) {
  return e3._reader._readIntoRequests.length;
}
function Le2(e3) {
  const t3 = e3._reader;
  return void 0 !== t3 && !!Fe2(t3);
}
function Fe2(e3) {
  return !!r2(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_readIntoRequests") && e3 instanceof ReadableStreamBYOBReader);
}
function Ie2(e3, t3) {
  const r3 = e3._readIntoRequests;
  e3._readIntoRequests = new S2(), r3.forEach((e4) => {
    e4._errorSteps(t3);
  });
}
function De2(e3) {
  return new TypeError(`ReadableStreamBYOBReader.prototype.${e3} can only be used on a ReadableStreamBYOBReader`);
}
function $e2(e3, t3) {
  const { highWaterMark: r3 } = e3;
  if (void 0 === r3) return t3;
  if (ae2(r3) || r3 < 0) throw new RangeError("Invalid highWaterMark");
  return r3;
}
function Me2(e3) {
  const { size: t3 } = e3;
  return t3 || (() => 1);
}
function Ye2(e3, t3) {
  F2(e3, t3);
  const r3 = null == e3 ? void 0 : e3.highWaterMark, o3 = null == e3 ? void 0 : e3.size;
  return { highWaterMark: void 0 === r3 ? void 0 : Y2(r3), size: void 0 === o3 ? void 0 : Qe2(o3, `${t3} has member 'size' that`) };
}
function Qe2(e3, t3) {
  return I2(e3, t3), (t4) => Y2(e3(t4));
}
function Ne2(e3, t3, r3) {
  return I2(e3, r3), (r4) => w2(e3, t3, [r4]);
}
function He2(e3, t3, r3) {
  return I2(e3, r3), () => w2(e3, t3, []);
}
function xe2(e3, t3, r3) {
  return I2(e3, r3), (r4) => g2(e3, t3, [r4]);
}
function Ve2(e3, t3, r3) {
  return I2(e3, r3), (r4, o3) => w2(e3, t3, [r4, o3]);
}
function Ge2(e3) {
  return !!r2(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_writableStreamController") && e3 instanceof WritableStream);
}
function Xe2(e3) {
  return void 0 !== e3._writer;
}
function Je2(e3, t3) {
  var r3;
  if ("closed" === e3._state || "errored" === e3._state) return c2(void 0);
  e3._writableStreamController._abortReason = t3, null === (r3 = e3._writableStreamController._abortController) || void 0 === r3 || r3.abort(t3);
  const o3 = e3._state;
  if ("closed" === o3 || "errored" === o3) return c2(void 0);
  if (void 0 !== e3._pendingAbortRequest) return e3._pendingAbortRequest._promise;
  let n3 = false;
  "erroring" === o3 && (n3 = true, t3 = void 0);
  const a3 = u2((r4, o4) => {
    e3._pendingAbortRequest = { _promise: void 0, _resolve: r4, _reject: o4, _reason: t3, _wasAlreadyErroring: n3 };
  });
  return e3._pendingAbortRequest._promise = a3, n3 || et2(e3, t3), a3;
}
function Ke2(e3) {
  const t3 = e3._state;
  if ("closed" === t3 || "errored" === t3) return d2(new TypeError(`The stream (in ${t3} state) is not in the writable state and cannot be closed`));
  const r3 = u2((t4, r4) => {
    const o4 = { _resolve: t4, _reject: r4 };
    e3._closeRequest = o4;
  }), o3 = e3._writer;
  var n3;
  return void 0 !== o3 && e3._backpressure && "writable" === t3 && Et2(o3), ue2(n3 = e3._writableStreamController, lt2, 0), dt2(n3), r3;
}
function Ze2(e3, t3) {
  "writable" !== e3._state ? tt2(e3) : et2(e3, t3);
}
function et2(e3, t3) {
  const r3 = e3._writableStreamController;
  e3._state = "erroring", e3._storedError = t3;
  const o3 = e3._writer;
  void 0 !== o3 && it2(o3, t3), !function(e4) {
    if (void 0 === e4._inFlightWriteRequest && void 0 === e4._inFlightCloseRequest) return false;
    return true;
  }(e3) && r3._started && tt2(e3);
}
function tt2(e3) {
  e3._state = "errored", e3._writableStreamController[R2]();
  const t3 = e3._storedError;
  if (e3._writeRequests.forEach((e4) => {
    e4._reject(t3);
  }), e3._writeRequests = new S2(), void 0 === e3._pendingAbortRequest) return void ot2(e3);
  const r3 = e3._pendingAbortRequest;
  if (e3._pendingAbortRequest = void 0, r3._wasAlreadyErroring) return r3._reject(t3), void ot2(e3);
  b2(e3._writableStreamController[v2](r3._reason), () => (r3._resolve(), ot2(e3), null), (t4) => (r3._reject(t4), ot2(e3), null));
}
function rt2(e3) {
  return void 0 !== e3._closeRequest || void 0 !== e3._inFlightCloseRequest;
}
function ot2(e3) {
  void 0 !== e3._closeRequest && (e3._closeRequest._reject(e3._storedError), e3._closeRequest = void 0);
  const t3 = e3._writer;
  void 0 !== t3 && St2(t3, e3._storedError);
}
function nt2(e3, t3) {
  const r3 = e3._writer;
  void 0 !== r3 && t3 !== e3._backpressure && (t3 ? function(e4) {
    Rt2(e4);
  }(r3) : Et2(r3)), e3._backpressure = t3;
}
function at2(e3) {
  return !!r2(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_ownerWritableStream") && e3 instanceof WritableStreamDefaultWriter);
}
function it2(e3, t3) {
  "pending" === e3._readyPromiseState ? Ct2(e3, t3) : function(e4, t4) {
    Tt2(e4, t4);
  }(e3, t3);
}
function st2(e3) {
  return !!r2(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_controlledWritableStream") && e3 instanceof WritableStreamDefaultController);
}
function ut2(e3) {
  e3._writeAlgorithm = void 0, e3._closeAlgorithm = void 0, e3._abortAlgorithm = void 0, e3._strategySizeAlgorithm = void 0;
}
function ct2(e3) {
  return e3._strategyHWM - e3._queueTotalSize;
}
function dt2(e3) {
  const t3 = e3._controlledWritableStream;
  if (!e3._started) return;
  if (void 0 !== t3._inFlightWriteRequest) return;
  if ("erroring" === t3._state) return void tt2(t3);
  if (0 === e3._queue.length) return;
  const r3 = e3._queue.peek().value;
  r3 === lt2 ? function(e4) {
    const t4 = e4._controlledWritableStream;
    (function(e5) {
      e5._inFlightCloseRequest = e5._closeRequest, e5._closeRequest = void 0;
    })(t4), se2(e4);
    const r4 = e4._closeAlgorithm();
    ut2(e4), b2(r4, () => (function(e5) {
      e5._inFlightCloseRequest._resolve(void 0), e5._inFlightCloseRequest = void 0, "erroring" === e5._state && (e5._storedError = void 0, void 0 !== e5._pendingAbortRequest && (e5._pendingAbortRequest._resolve(), e5._pendingAbortRequest = void 0)), e5._state = "closed";
      const t5 = e5._writer;
      void 0 !== t5 && vt2(t5);
    }(t4), null), (e5) => (function(e6, t5) {
      e6._inFlightCloseRequest._reject(t5), e6._inFlightCloseRequest = void 0, void 0 !== e6._pendingAbortRequest && (e6._pendingAbortRequest._reject(t5), e6._pendingAbortRequest = void 0), Ze2(e6, t5);
    }(t4, e5), null));
  }(e3) : function(e4, t4) {
    const r4 = e4._controlledWritableStream;
    !function(e5) {
      e5._inFlightWriteRequest = e5._writeRequests.shift();
    }(r4);
    b2(e4._writeAlgorithm(t4), () => {
      !function(e5) {
        e5._inFlightWriteRequest._resolve(void 0), e5._inFlightWriteRequest = void 0;
      }(r4);
      const t5 = r4._state;
      if (se2(e4), !rt2(r4) && "writable" === t5) {
        const t6 = bt2(e4);
        nt2(r4, t6);
      }
      return dt2(e4), null;
    }, (t5) => ("writable" === r4._state && ut2(e4), function(e5, t6) {
      e5._inFlightWriteRequest._reject(t6), e5._inFlightWriteRequest = void 0, Ze2(e5, t6);
    }(r4, t5), null));
  }(e3, r3);
}
function ft2(e3, t3) {
  "writable" === e3._controlledWritableStream._state && ht2(e3, t3);
}
function bt2(e3) {
  return ct2(e3) <= 0;
}
function ht2(e3, t3) {
  const r3 = e3._controlledWritableStream;
  ut2(e3), et2(r3, t3);
}
function _t2(e3) {
  return new TypeError(`WritableStream.prototype.${e3} can only be used on a WritableStream`);
}
function pt2(e3) {
  return new TypeError(`WritableStreamDefaultController.prototype.${e3} can only be used on a WritableStreamDefaultController`);
}
function mt2(e3) {
  return new TypeError(`WritableStreamDefaultWriter.prototype.${e3} can only be used on a WritableStreamDefaultWriter`);
}
function yt2(e3) {
  return new TypeError("Cannot " + e3 + " a stream using a released writer");
}
function gt2(e3) {
  e3._closedPromise = u2((t3, r3) => {
    e3._closedPromise_resolve = t3, e3._closedPromise_reject = r3, e3._closedPromiseState = "pending";
  });
}
function wt2(e3, t3) {
  gt2(e3), St2(e3, t3);
}
function St2(e3, t3) {
  void 0 !== e3._closedPromise_reject && (m2(e3._closedPromise), e3._closedPromise_reject(t3), e3._closedPromise_resolve = void 0, e3._closedPromise_reject = void 0, e3._closedPromiseState = "rejected");
}
function vt2(e3) {
  void 0 !== e3._closedPromise_resolve && (e3._closedPromise_resolve(void 0), e3._closedPromise_resolve = void 0, e3._closedPromise_reject = void 0, e3._closedPromiseState = "resolved");
}
function Rt2(e3) {
  e3._readyPromise = u2((t3, r3) => {
    e3._readyPromise_resolve = t3, e3._readyPromise_reject = r3;
  }), e3._readyPromiseState = "pending";
}
function Tt2(e3, t3) {
  Rt2(e3), Ct2(e3, t3);
}
function qt2(e3) {
  Rt2(e3), Et2(e3);
}
function Ct2(e3, t3) {
  void 0 !== e3._readyPromise_reject && (m2(e3._readyPromise), e3._readyPromise_reject(t3), e3._readyPromise_resolve = void 0, e3._readyPromise_reject = void 0, e3._readyPromiseState = "rejected");
}
function Et2(e3) {
  void 0 !== e3._readyPromise_resolve && (e3._readyPromise_resolve(void 0), e3._readyPromise_resolve = void 0, e3._readyPromise_reject = void 0, e3._readyPromiseState = "fulfilled");
}
function kt2(e3, t3, r3, o3, n3, a3) {
  const i3 = e3.getReader(), l3 = t3.getWriter();
  Vt2(e3) && (e3._disturbed = true);
  let s3, _3, g3, w3 = false, S3 = false, v3 = "readable", R3 = "writable", T3 = false, q3 = false;
  const C3 = u2((e4) => {
    g3 = e4;
  });
  let E3 = Promise.resolve(void 0);
  return u2((P3, W3) => {
    let k3;
    function O3() {
      if (w3) return;
      const e4 = u2((e5, t4) => {
        !function r4(o4) {
          o4 ? e5() : f2(function() {
            if (w3) return c2(true);
            return f2(l3.ready, () => f2(i3.read(), (e6) => !!e6.done || (E3 = l3.write(e6.value), m2(E3), false)));
          }(), r4, t4);
        }(false);
      });
      m2(e4);
    }
    function B3() {
      return v3 = "closed", r3 ? L3() : z3(() => (Ge2(t3) && (T3 = rt2(t3), R3 = t3._state), T3 || "closed" === R3 ? c2(void 0) : "erroring" === R3 || "errored" === R3 ? d2(_3) : (T3 = true, l3.close())), false, void 0), null;
    }
    function A3(e4) {
      return w3 || (v3 = "errored", s3 = e4, o3 ? L3(true, e4) : z3(() => l3.abort(e4), true, e4)), null;
    }
    function j3(e4) {
      return S3 || (R3 = "errored", _3 = e4, n3 ? L3(true, e4) : z3(() => i3.cancel(e4), true, e4)), null;
    }
    if (void 0 !== a3 && (k3 = () => {
      const e4 = void 0 !== a3.reason ? a3.reason : new Wt2("Aborted", "AbortError"), t4 = [];
      o3 || t4.push(() => "writable" === R3 ? l3.abort(e4) : c2(void 0)), n3 || t4.push(() => "readable" === v3 ? i3.cancel(e4) : c2(void 0)), z3(() => Promise.all(t4.map((e5) => e5())), true, e4);
    }, a3.aborted ? k3() : a3.addEventListener("abort", k3)), Vt2(e3) && (v3 = e3._state, s3 = e3._storedError), Ge2(t3) && (R3 = t3._state, _3 = t3._storedError, T3 = rt2(t3)), Vt2(e3) && Ge2(t3) && (q3 = true, g3()), "errored" === v3) A3(s3);
    else if ("erroring" === R3 || "errored" === R3) j3(_3);
    else if ("closed" === v3) B3();
    else if (T3 || "closed" === R3) {
      const e4 = new TypeError("the destination writable stream closed before all data could be piped to it");
      n3 ? L3(true, e4) : z3(() => i3.cancel(e4), true, e4);
    }
    function z3(e4, t4, r4) {
      function o4() {
        return "writable" !== R3 || T3 ? n4() : h2(function() {
          let e5;
          return c2(function t5() {
            if (e5 !== E3) return e5 = E3, p2(E3, t5, t5);
          }());
        }(), n4), null;
      }
      function n4() {
        return e4 ? b2(e4(), () => F3(t4, r4), (e5) => F3(true, e5)) : F3(t4, r4), null;
      }
      w3 || (w3 = true, q3 ? o4() : h2(C3, o4));
    }
    function L3(e4, t4) {
      z3(void 0, e4, t4);
    }
    function F3(e4, t4) {
      return S3 = true, l3.releaseLock(), i3.releaseLock(), void 0 !== a3 && a3.removeEventListener("abort", k3), e4 ? W3(t4) : P3(void 0), null;
    }
    w3 || (b2(i3.closed, B3, A3), b2(l3.closed, function() {
      return S3 || (R3 = "closed"), null;
    }, j3)), q3 ? O3() : y2(() => {
      q3 = true, g3(), O3();
    });
  });
}
function Ot2(e3, t3) {
  return function(e4) {
    try {
      return e4.getReader({ mode: "byob" }).releaseLock(), true;
    } catch (e5) {
      return false;
    }
  }(e3) ? function(e4) {
    let t4, r3, o3, n3, a3, i3 = e4.getReader(), l3 = false, s3 = false, d3 = false, f3 = false, h3 = false, p3 = false;
    const m3 = u2((e5) => {
      a3 = e5;
    });
    function y3(e5) {
      _2(e5.closed, (t5) => (e5 !== i3 || (o3.error(t5), n3.error(t5), h3 && p3 || a3(void 0)), null));
    }
    function g3() {
      l3 && (i3.releaseLock(), i3 = e4.getReader(), y3(i3), l3 = false), b2(i3.read(), (e5) => {
        var t5, r4;
        if (d3 = false, f3 = false, e5.done) return h3 || o3.close(), p3 || n3.close(), null === (t5 = o3.byobRequest) || void 0 === t5 || t5.respond(0), null === (r4 = n3.byobRequest) || void 0 === r4 || r4.respond(0), h3 && p3 || a3(void 0), null;
        const l4 = e5.value, u3 = l4;
        let c3 = l4;
        if (!h3 && !p3) try {
          c3 = le2(l4);
        } catch (e6) {
          return o3.error(e6), n3.error(e6), a3(i3.cancel(e6)), null;
        }
        return h3 || o3.enqueue(u3), p3 || n3.enqueue(c3), s3 = false, d3 ? S3() : f3 && v3(), null;
      }, () => (s3 = false, null));
    }
    function w3(t5, r4) {
      l3 || (i3.releaseLock(), i3 = e4.getReader({ mode: "byob" }), y3(i3), l3 = true);
      const u3 = r4 ? n3 : o3, c3 = r4 ? o3 : n3;
      b2(i3.read(t5), (e5) => {
        var t6;
        d3 = false, f3 = false;
        const o4 = r4 ? p3 : h3, n4 = r4 ? h3 : p3;
        if (e5.done) {
          o4 || u3.close(), n4 || c3.close();
          const r5 = e5.value;
          return void 0 !== r5 && (o4 || u3.byobRequest.respondWithNewView(r5), n4 || null === (t6 = c3.byobRequest) || void 0 === t6 || t6.respond(0)), o4 && n4 || a3(void 0), null;
        }
        const l4 = e5.value;
        if (n4) o4 || u3.byobRequest.respondWithNewView(l4);
        else {
          let e6;
          try {
            e6 = le2(l4);
          } catch (e7) {
            return u3.error(e7), c3.error(e7), a3(i3.cancel(e7)), null;
          }
          o4 || u3.byobRequest.respondWithNewView(l4), c3.enqueue(e6);
        }
        return s3 = false, d3 ? S3() : f3 && v3(), null;
      }, () => (s3 = false, null));
    }
    function S3() {
      if (s3) return d3 = true, c2(void 0);
      s3 = true;
      const e5 = o3.byobRequest;
      return null === e5 ? g3() : w3(e5.view, false), c2(void 0);
    }
    function v3() {
      if (s3) return f3 = true, c2(void 0);
      s3 = true;
      const e5 = n3.byobRequest;
      return null === e5 ? g3() : w3(e5.view, true), c2(void 0);
    }
    function R3(e5) {
      if (h3 = true, t4 = e5, p3) {
        const e6 = [t4, r3], o4 = i3.cancel(e6);
        a3(o4);
      }
      return m3;
    }
    function T3(e5) {
      if (p3 = true, r3 = e5, h3) {
        const e6 = [t4, r3], o4 = i3.cancel(e6);
        a3(o4);
      }
      return m3;
    }
    const q3 = new ReadableStream3({ type: "bytes", start(e5) {
      o3 = e5;
    }, pull: S3, cancel: R3 }), C3 = new ReadableStream3({ type: "bytes", start(e5) {
      n3 = e5;
    }, pull: v3, cancel: T3 });
    return y3(i3), [q3, C3];
  }(e3) : function(e4, t4) {
    const r3 = e4.getReader();
    let o3, n3, a3, i3, l3, s3 = false, d3 = false, f3 = false, h3 = false;
    const p3 = u2((e5) => {
      l3 = e5;
    });
    function m3() {
      return s3 ? (d3 = true, c2(void 0)) : (s3 = true, b2(r3.read(), (e5) => {
        if (d3 = false, e5.done) return f3 || a3.close(), h3 || i3.close(), f3 && h3 || l3(void 0), null;
        const t5 = e5.value, r4 = t5, o4 = t5;
        return f3 || a3.enqueue(r4), h3 || i3.enqueue(o4), s3 = false, d3 && m3(), null;
      }, () => (s3 = false, null)), c2(void 0));
    }
    function y3(e5) {
      if (f3 = true, o3 = e5, h3) {
        const e6 = [o3, n3], t5 = r3.cancel(e6);
        l3(t5);
      }
      return p3;
    }
    function g3(e5) {
      if (h3 = true, n3 = e5, f3) {
        const e6 = [o3, n3], t5 = r3.cancel(e6);
        l3(t5);
      }
      return p3;
    }
    const w3 = new ReadableStream3({ start(e5) {
      a3 = e5;
    }, pull: m3, cancel: y3 }), S3 = new ReadableStream3({ start(e5) {
      i3 = e5;
    }, pull: m3, cancel: g3 });
    return _2(r3.closed, (e5) => (a3.error(e5), i3.error(e5), f3 && h3 || l3(void 0), null)), [w3, S3];
  }(e3);
}
function Bt2(e3) {
  return !!r2(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_controlledReadableStream") && e3 instanceof ReadableStreamDefaultController);
}
function At2(e3) {
  const t3 = function(e4) {
    const t4 = e4._controlledReadableStream;
    if (!Ft2(e4)) return false;
    if (!e4._started) return false;
    if (Ut2(t4) && X2(t4) > 0) return true;
    if (Lt2(e4) > 0) return true;
    return false;
  }(e3);
  if (!t3) return;
  if (e3._pulling) return void (e3._pullAgain = true);
  e3._pulling = true;
  b2(e3._pullAlgorithm(), () => (e3._pulling = false, e3._pullAgain && (e3._pullAgain = false, At2(e3)), null), (t4) => (zt2(e3, t4), null));
}
function jt2(e3) {
  e3._pullAlgorithm = void 0, e3._cancelAlgorithm = void 0, e3._strategySizeAlgorithm = void 0;
}
function zt2(e3, t3) {
  const r3 = e3._controlledReadableStream;
  "readable" === r3._state && (ce2(e3), jt2(e3), Jt2(r3, t3));
}
function Lt2(e3) {
  const t3 = e3._controlledReadableStream._state;
  return "errored" === t3 ? null : "closed" === t3 ? 0 : e3._strategyHWM - e3._queueTotalSize;
}
function Ft2(e3) {
  return !e3._closeRequested && "readable" === e3._controlledReadableStream._state;
}
function It2(e3, t3, r3, o3) {
  const n3 = Object.create(ReadableStreamDefaultController.prototype);
  let a3, i3, l3;
  a3 = void 0 !== t3.start ? () => t3.start(n3) : () => {
  }, i3 = void 0 !== t3.pull ? () => t3.pull(n3) : () => c2(void 0), l3 = void 0 !== t3.cancel ? (e4) => t3.cancel(e4) : () => c2(void 0), function(e4, t4, r4, o4, n4, a4, i4) {
    t4._controlledReadableStream = e4, t4._queue = void 0, t4._queueTotalSize = void 0, ce2(t4), t4._started = false, t4._closeRequested = false, t4._pullAgain = false, t4._pulling = false, t4._strategySizeAlgorithm = i4, t4._strategyHWM = a4, t4._pullAlgorithm = o4, t4._cancelAlgorithm = n4, e4._readableStreamController = t4, b2(c2(r4()), () => (t4._started = true, At2(t4), null), (e5) => (zt2(t4, e5), null));
  }(e3, n3, a3, i3, l3, r3, o3);
}
function Dt2(e3) {
  return new TypeError(`ReadableStreamDefaultController.prototype.${e3} can only be used on a ReadableStreamDefaultController`);
}
function $t2(e3, t3, r3) {
  return I2(e3, r3), (r4) => w2(e3, t3, [r4]);
}
function Mt2(e3, t3, r3) {
  return I2(e3, r3), (r4) => w2(e3, t3, [r4]);
}
function Yt2(e3, t3, r3) {
  return I2(e3, r3), (r4) => g2(e3, t3, [r4]);
}
function Qt2(e3, t3) {
  if ("bytes" !== (e3 = `${e3}`)) throw new TypeError(`${t3} '${e3}' is not a valid enumeration value for ReadableStreamType`);
  return e3;
}
function Nt2(e3, t3) {
  if ("byob" !== (e3 = `${e3}`)) throw new TypeError(`${t3} '${e3}' is not a valid enumeration value for ReadableStreamReaderMode`);
  return e3;
}
function Ht2(e3, t3) {
  F2(e3, t3);
  const r3 = null == e3 ? void 0 : e3.preventAbort, o3 = null == e3 ? void 0 : e3.preventCancel, n3 = null == e3 ? void 0 : e3.preventClose, a3 = null == e3 ? void 0 : e3.signal;
  return void 0 !== a3 && function(e4, t4) {
    if (!function(e5) {
      if ("object" != typeof e5 || null === e5) return false;
      try {
        return "boolean" == typeof e5.aborted;
      } catch (e6) {
        return false;
      }
    }(e4)) throw new TypeError(`${t4} is not an AbortSignal.`);
  }(a3, `${t3} has member 'signal' that`), { preventAbort: Boolean(r3), preventCancel: Boolean(o3), preventClose: Boolean(n3), signal: a3 };
}
function xt2(e3, t3) {
  F2(e3, t3);
  const r3 = null == e3 ? void 0 : e3.readable;
  M2(r3, "readable", "ReadableWritablePair"), function(e4, t4) {
    if (!H2(e4)) throw new TypeError(`${t4} is not a ReadableStream.`);
  }(r3, `${t3} has member 'readable' that`);
  const o3 = null == e3 ? void 0 : e3.writable;
  return M2(o3, "writable", "ReadableWritablePair"), function(e4, t4) {
    if (!x2(e4)) throw new TypeError(`${t4} is not a WritableStream.`);
  }(o3, `${t3} has member 'writable' that`), { readable: r3, writable: o3 };
}
function Vt2(e3) {
  return !!r2(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_readableStreamController") && e3 instanceof ReadableStream3);
}
function Ut2(e3) {
  return void 0 !== e3._reader;
}
function Gt2(e3, r3) {
  if (e3._disturbed = true, "closed" === e3._state) return c2(void 0);
  if ("errored" === e3._state) return d2(e3._storedError);
  Xt2(e3);
  const o3 = e3._reader;
  if (void 0 !== o3 && Fe2(o3)) {
    const e4 = o3._readIntoRequests;
    o3._readIntoRequests = new S2(), e4.forEach((e5) => {
      e5._closeSteps(void 0);
    });
  }
  return p2(e3._readableStreamController[T2](r3), t2);
}
function Xt2(e3) {
  e3._state = "closed";
  const t3 = e3._reader;
  if (void 0 !== t3 && (j2(t3), K2(t3))) {
    const e4 = t3._readRequests;
    t3._readRequests = new S2(), e4.forEach((e5) => {
      e5._closeSteps();
    });
  }
}
function Jt2(e3, t3) {
  e3._state = "errored", e3._storedError = t3;
  const r3 = e3._reader;
  void 0 !== r3 && (A2(r3, t3), K2(r3) ? Z2(r3, t3) : Ie2(r3, t3));
}
function Kt2(e3) {
  return new TypeError(`ReadableStream.prototype.${e3} can only be used on a ReadableStream`);
}
function Zt2(e3, t3) {
  F2(e3, t3);
  const r3 = null == e3 ? void 0 : e3.highWaterMark;
  return M2(r3, "highWaterMark", "QueuingStrategyInit"), { highWaterMark: Y2(r3) };
}
function tr2(e3) {
  return new TypeError(`ByteLengthQueuingStrategy.prototype.${e3} can only be used on a ByteLengthQueuingStrategy`);
}
function rr2(e3) {
  return !!r2(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_byteLengthQueuingStrategyHighWaterMark") && e3 instanceof ByteLengthQueuingStrategy);
}
function nr2(e3) {
  return new TypeError(`CountQueuingStrategy.prototype.${e3} can only be used on a CountQueuingStrategy`);
}
function ar2(e3) {
  return !!r2(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_countQueuingStrategyHighWaterMark") && e3 instanceof CountQueuingStrategy);
}
function ir2(e3, t3, r3) {
  return I2(e3, r3), (r4) => w2(e3, t3, [r4]);
}
function lr2(e3, t3, r3) {
  return I2(e3, r3), (r4) => g2(e3, t3, [r4]);
}
function sr2(e3, t3, r3) {
  return I2(e3, r3), (r4, o3) => w2(e3, t3, [r4, o3]);
}
function ur2(e3) {
  return !!r2(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_transformStreamController") && e3 instanceof TransformStream);
}
function cr2(e3, t3) {
  Sr2(e3, t3), dr2(e3, t3);
}
function dr2(e3, t3) {
  hr2(e3._transformStreamController), function(e4, t4) {
    e4._writableController.error(t4);
    "writable" === e4._writableState && Tr2(e4, t4);
  }(e3, t3), e3._backpressure && fr2(e3, false);
}
function fr2(e3, t3) {
  void 0 !== e3._backpressureChangePromise && e3._backpressureChangePromise_resolve(), e3._backpressureChangePromise = u2((t4) => {
    e3._backpressureChangePromise_resolve = t4;
  }), e3._backpressure = t3;
}
function br2(e3) {
  return !!r2(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_controlledTransformStream") && e3 instanceof TransformStreamDefaultController);
}
function hr2(e3) {
  e3._transformAlgorithm = void 0, e3._flushAlgorithm = void 0;
}
function _r3(e3, t3) {
  const r3 = e3._controlledTransformStream;
  if (!gr2(r3)) throw new TypeError("Readable side is not in a state that permits enqueue");
  try {
    !function(e4, t4) {
      e4._readablePulling = false;
      try {
        e4._readableController.enqueue(t4);
      } catch (t5) {
        throw Sr2(e4, t5), t5;
      }
    }(r3, t3);
  } catch (e4) {
    throw dr2(r3, e4), r3._readableStoredError;
  }
  const o3 = function(e4) {
    return !function(e5) {
      if (!gr2(e5)) return false;
      if (e5._readablePulling) return true;
      if (vr2(e5) > 0) return true;
      return false;
    }(e4);
  }(r3);
  o3 !== r3._backpressure && fr2(r3, true);
}
function pr2(e3, t3) {
  return p2(e3._transformAlgorithm(t3), void 0, (t4) => {
    throw cr2(e3._controlledTransformStream, t4), t4;
  });
}
function mr2(e3) {
  return new TypeError(`TransformStreamDefaultController.prototype.${e3} can only be used on a TransformStreamDefaultController`);
}
function yr2(e3) {
  return new TypeError(`TransformStream.prototype.${e3} can only be used on a TransformStream`);
}
function gr2(e3) {
  return !e3._readableCloseRequested && "readable" === e3._readableState;
}
function wr2(e3) {
  e3._readableState = "closed", e3._readableCloseRequested = true, e3._readableController.close();
}
function Sr2(e3, t3) {
  "readable" === e3._readableState && (e3._readableState = "errored", e3._readableStoredError = t3), e3._readableController.error(t3);
}
function vr2(e3) {
  return e3._readableController.desiredSize;
}
function Rr2(e3, t3) {
  "writable" !== e3._writableState ? qr2(e3) : Tr2(e3, t3);
}
function Tr2(e3, t3) {
  e3._writableState = "erroring", e3._writableStoredError = t3, !function(e4) {
    return e4._writableHasInFlightOperation;
  }(e3) && e3._writableStarted && qr2(e3);
}
function qr2(e3) {
  e3._writableState = "errored";
}
function Cr2(e3) {
  "erroring" === e3._writableState && qr2(e3);
}
var e2, o2, a2, i2, l2, s2, y2, S2, v2, R2, T2, q2, C2, z2, L2, ReadableStreamDefaultReader, te2, re2, ae2, ReadableStreamBYOBRequest, ReadableByteStreamController, ReadableStreamBYOBReader, Ue2, WritableStream, WritableStreamDefaultWriter, lt2, WritableStreamDefaultController, Pt2, Wt2, ReadableStreamDefaultController, ReadableStream3, er2, ByteLengthQueuingStrategy, or2, CountQueuingStrategy, TransformStream, TransformStreamDefaultController;
var init_ponyfill = __esm({
  "node_modules/web-streams-polyfill/dist/ponyfill.mjs"() {
    e2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? Symbol : (e3) => `Symbol(${e3})`;
    o2 = t2;
    a2 = Promise;
    i2 = Promise.prototype.then;
    l2 = Promise.resolve.bind(a2);
    s2 = Promise.reject.bind(a2);
    y2 = (e3) => {
      if ("function" == typeof queueMicrotask) y2 = queueMicrotask;
      else {
        const e4 = c2(void 0);
        y2 = (t3) => f2(e4, t3);
      }
      return y2(e3);
    };
    S2 = class {
      constructor() {
        this._cursor = 0, this._size = 0, this._front = { _elements: [], _next: void 0 }, this._back = this._front, this._cursor = 0, this._size = 0;
      }
      get length() {
        return this._size;
      }
      push(e3) {
        const t3 = this._back;
        let r3 = t3;
        16383 === t3._elements.length && (r3 = { _elements: [], _next: void 0 }), t3._elements.push(e3), r3 !== t3 && (this._back = r3, t3._next = r3), ++this._size;
      }
      shift() {
        const e3 = this._front;
        let t3 = e3;
        const r3 = this._cursor;
        let o3 = r3 + 1;
        const n3 = e3._elements, a3 = n3[r3];
        return 16384 === o3 && (t3 = e3._next, o3 = 0), --this._size, this._cursor = o3, e3 !== t3 && (this._front = t3), n3[r3] = void 0, a3;
      }
      forEach(e3) {
        let t3 = this._cursor, r3 = this._front, o3 = r3._elements;
        for (; !(t3 === o3.length && void 0 === r3._next || t3 === o3.length && (r3 = r3._next, o3 = r3._elements, t3 = 0, 0 === o3.length)); ) e3(o3[t3]), ++t3;
      }
      peek() {
        const e3 = this._front, t3 = this._cursor;
        return e3._elements[t3];
      }
    };
    v2 = e2("[[AbortSteps]]");
    R2 = e2("[[ErrorSteps]]");
    T2 = e2("[[CancelSteps]]");
    q2 = e2("[[PullSteps]]");
    C2 = e2("[[ReleaseSteps]]");
    z2 = Number.isFinite || function(e3) {
      return "number" == typeof e3 && isFinite(e3);
    };
    L2 = Math.trunc || function(e3) {
      return e3 < 0 ? Math.ceil(e3) : Math.floor(e3);
    };
    ReadableStreamDefaultReader = class {
      constructor(e3) {
        if ($2(e3, 1, "ReadableStreamDefaultReader"), V2(e3, "First parameter"), Ut2(e3)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
        E2(this, e3), this._readRequests = new S2();
      }
      get closed() {
        return K2(this) ? this._closedPromise : d2(ee2("closed"));
      }
      cancel(e3) {
        return K2(this) ? void 0 === this._ownerReadableStream ? d2(k2("cancel")) : P2(this, e3) : d2(ee2("cancel"));
      }
      read() {
        if (!K2(this)) return d2(ee2("read"));
        if (void 0 === this._ownerReadableStream) return d2(k2("read from"));
        let e3, t3;
        const r3 = u2((r4, o3) => {
          e3 = r4, t3 = o3;
        });
        return function(e4, t4) {
          const r4 = e4._ownerReadableStream;
          r4._disturbed = true, "closed" === r4._state ? t4._closeSteps() : "errored" === r4._state ? t4._errorSteps(r4._storedError) : r4._readableStreamController[q2](t4);
        }(this, { _chunkSteps: (t4) => e3({ value: t4, done: false }), _closeSteps: () => e3({ value: void 0, done: true }), _errorSteps: (e4) => t3(e4) }), r3;
      }
      releaseLock() {
        if (!K2(this)) throw ee2("releaseLock");
        void 0 !== this._ownerReadableStream && function(e3) {
          W2(e3);
          const t3 = new TypeError("Reader was released");
          Z2(e3, t3);
        }(this);
      }
    };
    Object.defineProperties(ReadableStreamDefaultReader.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), n2(ReadableStreamDefaultReader.prototype.cancel, "cancel"), n2(ReadableStreamDefaultReader.prototype.read, "read"), n2(ReadableStreamDefaultReader.prototype.releaseLock, "releaseLock"), "symbol" == typeof e2.toStringTag && Object.defineProperty(ReadableStreamDefaultReader.prototype, e2.toStringTag, { value: "ReadableStreamDefaultReader", configurable: true });
    te2 = class {
      constructor(e3, t3) {
        this._ongoingPromise = void 0, this._isFinished = false, this._reader = e3, this._preventCancel = t3;
      }
      next() {
        const e3 = () => this._nextSteps();
        return this._ongoingPromise = this._ongoingPromise ? p2(this._ongoingPromise, e3, e3) : e3(), this._ongoingPromise;
      }
      return(e3) {
        const t3 = () => this._returnSteps(e3);
        return this._ongoingPromise ? p2(this._ongoingPromise, t3, t3) : t3();
      }
      _nextSteps() {
        if (this._isFinished) return Promise.resolve({ value: void 0, done: true });
        const e3 = this._reader;
        return void 0 === e3 ? d2(k2("iterate")) : f2(e3.read(), (e4) => {
          var t3;
          return this._ongoingPromise = void 0, e4.done && (this._isFinished = true, null === (t3 = this._reader) || void 0 === t3 || t3.releaseLock(), this._reader = void 0), e4;
        }, (e4) => {
          var t3;
          throw this._ongoingPromise = void 0, this._isFinished = true, null === (t3 = this._reader) || void 0 === t3 || t3.releaseLock(), this._reader = void 0, e4;
        });
      }
      _returnSteps(e3) {
        if (this._isFinished) return Promise.resolve({ value: e3, done: true });
        this._isFinished = true;
        const t3 = this._reader;
        if (void 0 === t3) return d2(k2("finish iterating"));
        if (this._reader = void 0, !this._preventCancel) {
          const r3 = t3.cancel(e3);
          return t3.releaseLock(), p2(r3, () => ({ value: e3, done: true }));
        }
        return t3.releaseLock(), c2({ value: e3, done: true });
      }
    };
    re2 = { next() {
      return oe2(this) ? this._asyncIteratorImpl.next() : d2(ne2("next"));
    }, return(e3) {
      return oe2(this) ? this._asyncIteratorImpl.return(e3) : d2(ne2("return"));
    } };
    "symbol" == typeof e2.asyncIterator && Object.defineProperty(re2, e2.asyncIterator, { value() {
      return this;
    }, writable: true, configurable: true });
    ae2 = Number.isNaN || function(e3) {
      return e3 != e3;
    };
    ReadableStreamBYOBRequest = class {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get view() {
        if (!fe2(this)) throw Be2("view");
        return this._view;
      }
      respond(e3) {
        if (!fe2(this)) throw Be2("respond");
        if ($2(e3, 1, "respond"), e3 = N2(e3, "First parameter"), void 0 === this._associatedReadableByteStreamController) throw new TypeError("This BYOB request has been invalidated");
        this._view.buffer, function(e4, t3) {
          const r3 = e4._pendingPullIntos.peek();
          if ("closed" === e4._controlledReadableByteStream._state) {
            if (0 !== t3) throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
          } else {
            if (0 === t3) throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
            if (r3.bytesFilled + t3 > r3.byteLength) throw new RangeError("bytesWritten out of range");
          }
          r3.buffer = r3.buffer, qe2(e4, t3);
        }(this._associatedReadableByteStreamController, e3);
      }
      respondWithNewView(e3) {
        if (!fe2(this)) throw Be2("respondWithNewView");
        if ($2(e3, 1, "respondWithNewView"), !ArrayBuffer.isView(e3)) throw new TypeError("You can only respond with array buffer views");
        if (void 0 === this._associatedReadableByteStreamController) throw new TypeError("This BYOB request has been invalidated");
        e3.buffer, function(e4, t3) {
          const r3 = e4._pendingPullIntos.peek();
          if ("closed" === e4._controlledReadableByteStream._state) {
            if (0 !== t3.byteLength) throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
          } else if (0 === t3.byteLength) throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
          if (r3.byteOffset + r3.bytesFilled !== t3.byteOffset) throw new RangeError("The region specified by view does not match byobRequest");
          if (r3.bufferByteLength !== t3.buffer.byteLength) throw new RangeError("The buffer of view has different capacity than byobRequest");
          if (r3.bytesFilled + t3.byteLength > r3.byteLength) throw new RangeError("The region specified by view is larger than byobRequest");
          const o3 = t3.byteLength;
          r3.buffer = t3.buffer, qe2(e4, o3);
        }(this._associatedReadableByteStreamController, e3);
      }
    };
    Object.defineProperties(ReadableStreamBYOBRequest.prototype, { respond: { enumerable: true }, respondWithNewView: { enumerable: true }, view: { enumerable: true } }), n2(ReadableStreamBYOBRequest.prototype.respond, "respond"), n2(ReadableStreamBYOBRequest.prototype.respondWithNewView, "respondWithNewView"), "symbol" == typeof e2.toStringTag && Object.defineProperty(ReadableStreamBYOBRequest.prototype, e2.toStringTag, { value: "ReadableStreamBYOBRequest", configurable: true });
    ReadableByteStreamController = class {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get byobRequest() {
        if (!de2(this)) throw Ae2("byobRequest");
        return function(e3) {
          if (null === e3._byobRequest && e3._pendingPullIntos.length > 0) {
            const t3 = e3._pendingPullIntos.peek(), r3 = new Uint8Array(t3.buffer, t3.byteOffset + t3.bytesFilled, t3.byteLength - t3.bytesFilled), o3 = Object.create(ReadableStreamBYOBRequest.prototype);
            !function(e4, t4, r4) {
              e4._associatedReadableByteStreamController = t4, e4._view = r4;
            }(o3, e3, r3), e3._byobRequest = o3;
          }
          return e3._byobRequest;
        }(this);
      }
      get desiredSize() {
        if (!de2(this)) throw Ae2("desiredSize");
        return ke2(this);
      }
      close() {
        if (!de2(this)) throw Ae2("close");
        if (this._closeRequested) throw new TypeError("The stream has already been closed; do not close it again!");
        const e3 = this._controlledReadableByteStream._state;
        if ("readable" !== e3) throw new TypeError(`The stream (in ${e3} state) is not in the readable state and cannot be closed`);
        !function(e4) {
          const t3 = e4._controlledReadableByteStream;
          if (e4._closeRequested || "readable" !== t3._state) return;
          if (e4._queueTotalSize > 0) return void (e4._closeRequested = true);
          if (e4._pendingPullIntos.length > 0) {
            if (e4._pendingPullIntos.peek().bytesFilled > 0) {
              const t4 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              throw Pe2(e4, t4), t4;
            }
          }
          Ee2(e4), Xt2(t3);
        }(this);
      }
      enqueue(e3) {
        if (!de2(this)) throw Ae2("enqueue");
        if ($2(e3, 1, "enqueue"), !ArrayBuffer.isView(e3)) throw new TypeError("chunk must be an array buffer view");
        if (0 === e3.byteLength) throw new TypeError("chunk must have non-zero byteLength");
        if (0 === e3.buffer.byteLength) throw new TypeError("chunk's buffer must have non-zero byteLength");
        if (this._closeRequested) throw new TypeError("stream is closed or draining");
        const t3 = this._controlledReadableByteStream._state;
        if ("readable" !== t3) throw new TypeError(`The stream (in ${t3} state) is not in the readable state and cannot be enqueued to`);
        !function(e4, t4) {
          const r3 = e4._controlledReadableByteStream;
          if (e4._closeRequested || "readable" !== r3._state) return;
          const o3 = t4.buffer, n3 = t4.byteOffset, a3 = t4.byteLength, i3 = o3;
          if (e4._pendingPullIntos.length > 0) {
            const t5 = e4._pendingPullIntos.peek();
            t5.buffer, 0, Re2(e4), t5.buffer = t5.buffer, "none" === t5.readerType && ge2(e4, t5);
          }
          if (J2(r3)) if (function(e5) {
            const t5 = e5._controlledReadableByteStream._reader;
            for (; t5._readRequests.length > 0; ) {
              if (0 === e5._queueTotalSize) return;
              We2(e5, t5._readRequests.shift());
            }
          }(e4), 0 === X2(r3)) me2(e4, i3, n3, a3);
          else {
            e4._pendingPullIntos.length > 0 && Ce2(e4);
            G2(r3, new Uint8Array(i3, n3, a3), false);
          }
          else Le2(r3) ? (me2(e4, i3, n3, a3), Te2(e4)) : me2(e4, i3, n3, a3);
          be2(e4);
        }(this, e3);
      }
      error(e3) {
        if (!de2(this)) throw Ae2("error");
        Pe2(this, e3);
      }
      [T2](e3) {
        he2(this), ce2(this);
        const t3 = this._cancelAlgorithm(e3);
        return Ee2(this), t3;
      }
      [q2](e3) {
        const t3 = this._controlledReadableByteStream;
        if (this._queueTotalSize > 0) return void We2(this, e3);
        const r3 = this._autoAllocateChunkSize;
        if (void 0 !== r3) {
          let t4;
          try {
            t4 = new ArrayBuffer(r3);
          } catch (t5) {
            return void e3._errorSteps(t5);
          }
          const o3 = { buffer: t4, bufferByteLength: r3, byteOffset: 0, byteLength: r3, bytesFilled: 0, elementSize: 1, viewConstructor: Uint8Array, readerType: "default" };
          this._pendingPullIntos.push(o3);
        }
        U2(t3, e3), be2(this);
      }
      [C2]() {
        if (this._pendingPullIntos.length > 0) {
          const e3 = this._pendingPullIntos.peek();
          e3.readerType = "none", this._pendingPullIntos = new S2(), this._pendingPullIntos.push(e3);
        }
      }
    };
    Object.defineProperties(ReadableByteStreamController.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, byobRequest: { enumerable: true }, desiredSize: { enumerable: true } }), n2(ReadableByteStreamController.prototype.close, "close"), n2(ReadableByteStreamController.prototype.enqueue, "enqueue"), n2(ReadableByteStreamController.prototype.error, "error"), "symbol" == typeof e2.toStringTag && Object.defineProperty(ReadableByteStreamController.prototype, e2.toStringTag, { value: "ReadableByteStreamController", configurable: true });
    ReadableStreamBYOBReader = class {
      constructor(e3) {
        if ($2(e3, 1, "ReadableStreamBYOBReader"), V2(e3, "First parameter"), Ut2(e3)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
        if (!de2(e3._readableStreamController)) throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
        E2(this, e3), this._readIntoRequests = new S2();
      }
      get closed() {
        return Fe2(this) ? this._closedPromise : d2(De2("closed"));
      }
      cancel(e3) {
        return Fe2(this) ? void 0 === this._ownerReadableStream ? d2(k2("cancel")) : P2(this, e3) : d2(De2("cancel"));
      }
      read(e3) {
        if (!Fe2(this)) return d2(De2("read"));
        if (!ArrayBuffer.isView(e3)) return d2(new TypeError("view must be an array buffer view"));
        if (0 === e3.byteLength) return d2(new TypeError("view must have non-zero byteLength"));
        if (0 === e3.buffer.byteLength) return d2(new TypeError("view's buffer must have non-zero byteLength"));
        if (e3.buffer, void 0 === this._ownerReadableStream) return d2(k2("read from"));
        let t3, r3;
        const o3 = u2((e4, o4) => {
          t3 = e4, r3 = o4;
        });
        return function(e4, t4, r4) {
          const o4 = e4._ownerReadableStream;
          o4._disturbed = true, "errored" === o4._state ? r4._errorSteps(o4._storedError) : function(e5, t5, r5) {
            const o5 = e5._controlledReadableByteStream;
            let n3 = 1;
            t5.constructor !== DataView && (n3 = t5.constructor.BYTES_PER_ELEMENT);
            const a3 = t5.constructor, i3 = t5.buffer, l3 = { buffer: i3, bufferByteLength: i3.byteLength, byteOffset: t5.byteOffset, byteLength: t5.byteLength, bytesFilled: 0, elementSize: n3, viewConstructor: a3, readerType: "byob" };
            if (e5._pendingPullIntos.length > 0) return e5._pendingPullIntos.push(l3), void je2(o5, r5);
            if ("closed" !== o5._state) {
              if (e5._queueTotalSize > 0) {
                if (we2(e5, l3)) {
                  const t6 = pe2(l3);
                  return ve2(e5), void r5._chunkSteps(t6);
                }
                if (e5._closeRequested) {
                  const t6 = new TypeError("Insufficient bytes to fill elements in the given buffer");
                  return Pe2(e5, t6), void r5._errorSteps(t6);
                }
              }
              e5._pendingPullIntos.push(l3), je2(o5, r5), be2(e5);
            } else {
              const e6 = new a3(l3.buffer, l3.byteOffset, 0);
              r5._closeSteps(e6);
            }
          }(o4._readableStreamController, t4, r4);
        }(this, e3, { _chunkSteps: (e4) => t3({ value: e4, done: false }), _closeSteps: (e4) => t3({ value: e4, done: true }), _errorSteps: (e4) => r3(e4) }), o3;
      }
      releaseLock() {
        if (!Fe2(this)) throw De2("releaseLock");
        void 0 !== this._ownerReadableStream && function(e3) {
          W2(e3);
          const t3 = new TypeError("Reader was released");
          Ie2(e3, t3);
        }(this);
      }
    };
    Object.defineProperties(ReadableStreamBYOBReader.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), n2(ReadableStreamBYOBReader.prototype.cancel, "cancel"), n2(ReadableStreamBYOBReader.prototype.read, "read"), n2(ReadableStreamBYOBReader.prototype.releaseLock, "releaseLock"), "symbol" == typeof e2.toStringTag && Object.defineProperty(ReadableStreamBYOBReader.prototype, e2.toStringTag, { value: "ReadableStreamBYOBReader", configurable: true });
    Ue2 = "function" == typeof AbortController;
    WritableStream = class {
      constructor(e3 = {}, t3 = {}) {
        void 0 === e3 ? e3 = null : D2(e3, "First parameter");
        const r3 = Ye2(t3, "Second parameter"), o3 = function(e4, t4) {
          F2(e4, t4);
          const r4 = null == e4 ? void 0 : e4.abort, o4 = null == e4 ? void 0 : e4.close, n4 = null == e4 ? void 0 : e4.start, a4 = null == e4 ? void 0 : e4.type, i3 = null == e4 ? void 0 : e4.write;
          return { abort: void 0 === r4 ? void 0 : Ne2(r4, e4, `${t4} has member 'abort' that`), close: void 0 === o4 ? void 0 : He2(o4, e4, `${t4} has member 'close' that`), start: void 0 === n4 ? void 0 : xe2(n4, e4, `${t4} has member 'start' that`), write: void 0 === i3 ? void 0 : Ve2(i3, e4, `${t4} has member 'write' that`), type: a4 };
        }(e3, "First parameter");
        var n3;
        (n3 = this)._state = "writable", n3._storedError = void 0, n3._writer = void 0, n3._writableStreamController = void 0, n3._writeRequests = new S2(), n3._inFlightWriteRequest = void 0, n3._closeRequest = void 0, n3._inFlightCloseRequest = void 0, n3._pendingAbortRequest = void 0, n3._backpressure = false;
        if (void 0 !== o3.type) throw new RangeError("Invalid type is specified");
        const a3 = Me2(r3);
        !function(e4, t4, r4, o4) {
          const n4 = Object.create(WritableStreamDefaultController.prototype);
          let a4, i3, l3, s3;
          a4 = void 0 !== t4.start ? () => t4.start(n4) : () => {
          };
          i3 = void 0 !== t4.write ? (e5) => t4.write(e5, n4) : () => c2(void 0);
          l3 = void 0 !== t4.close ? () => t4.close() : () => c2(void 0);
          s3 = void 0 !== t4.abort ? (e5) => t4.abort(e5) : () => c2(void 0);
          !function(e5, t5, r5, o5, n5, a5, i4, l4) {
            t5._controlledWritableStream = e5, e5._writableStreamController = t5, t5._queue = void 0, t5._queueTotalSize = void 0, ce2(t5), t5._abortReason = void 0, t5._abortController = function() {
              if (Ue2) return new AbortController();
            }(), t5._started = false, t5._strategySizeAlgorithm = l4, t5._strategyHWM = i4, t5._writeAlgorithm = o5, t5._closeAlgorithm = n5, t5._abortAlgorithm = a5;
            const s4 = bt2(t5);
            nt2(e5, s4);
            const u3 = r5();
            b2(c2(u3), () => (t5._started = true, dt2(t5), null), (r6) => (t5._started = true, Ze2(e5, r6), null));
          }(e4, n4, a4, i3, l3, s3, r4, o4);
        }(this, o3, $e2(r3, 1), a3);
      }
      get locked() {
        if (!Ge2(this)) throw _t2("locked");
        return Xe2(this);
      }
      abort(e3) {
        return Ge2(this) ? Xe2(this) ? d2(new TypeError("Cannot abort a stream that already has a writer")) : Je2(this, e3) : d2(_t2("abort"));
      }
      close() {
        return Ge2(this) ? Xe2(this) ? d2(new TypeError("Cannot close a stream that already has a writer")) : rt2(this) ? d2(new TypeError("Cannot close an already-closing stream")) : Ke2(this) : d2(_t2("close"));
      }
      getWriter() {
        if (!Ge2(this)) throw _t2("getWriter");
        return new WritableStreamDefaultWriter(this);
      }
    };
    Object.defineProperties(WritableStream.prototype, { abort: { enumerable: true }, close: { enumerable: true }, getWriter: { enumerable: true }, locked: { enumerable: true } }), n2(WritableStream.prototype.abort, "abort"), n2(WritableStream.prototype.close, "close"), n2(WritableStream.prototype.getWriter, "getWriter"), "symbol" == typeof e2.toStringTag && Object.defineProperty(WritableStream.prototype, e2.toStringTag, { value: "WritableStream", configurable: true });
    WritableStreamDefaultWriter = class {
      constructor(e3) {
        if ($2(e3, 1, "WritableStreamDefaultWriter"), function(e4, t4) {
          if (!Ge2(e4)) throw new TypeError(`${t4} is not a WritableStream.`);
        }(e3, "First parameter"), Xe2(e3)) throw new TypeError("This stream has already been locked for exclusive writing by another writer");
        this._ownerWritableStream = e3, e3._writer = this;
        const t3 = e3._state;
        if ("writable" === t3) !rt2(e3) && e3._backpressure ? Rt2(this) : qt2(this), gt2(this);
        else if ("erroring" === t3) Tt2(this, e3._storedError), gt2(this);
        else if ("closed" === t3) qt2(this), gt2(r3 = this), vt2(r3);
        else {
          const t4 = e3._storedError;
          Tt2(this, t4), wt2(this, t4);
        }
        var r3;
      }
      get closed() {
        return at2(this) ? this._closedPromise : d2(mt2("closed"));
      }
      get desiredSize() {
        if (!at2(this)) throw mt2("desiredSize");
        if (void 0 === this._ownerWritableStream) throw yt2("desiredSize");
        return function(e3) {
          const t3 = e3._ownerWritableStream, r3 = t3._state;
          if ("errored" === r3 || "erroring" === r3) return null;
          if ("closed" === r3) return 0;
          return ct2(t3._writableStreamController);
        }(this);
      }
      get ready() {
        return at2(this) ? this._readyPromise : d2(mt2("ready"));
      }
      abort(e3) {
        return at2(this) ? void 0 === this._ownerWritableStream ? d2(yt2("abort")) : function(e4, t3) {
          return Je2(e4._ownerWritableStream, t3);
        }(this, e3) : d2(mt2("abort"));
      }
      close() {
        if (!at2(this)) return d2(mt2("close"));
        const e3 = this._ownerWritableStream;
        return void 0 === e3 ? d2(yt2("close")) : rt2(e3) ? d2(new TypeError("Cannot close an already-closing stream")) : Ke2(this._ownerWritableStream);
      }
      releaseLock() {
        if (!at2(this)) throw mt2("releaseLock");
        void 0 !== this._ownerWritableStream && function(e3) {
          const t3 = e3._ownerWritableStream, r3 = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
          it2(e3, r3), function(e4, t4) {
            "pending" === e4._closedPromiseState ? St2(e4, t4) : function(e5, t5) {
              wt2(e5, t5);
            }(e4, t4);
          }(e3, r3), t3._writer = void 0, e3._ownerWritableStream = void 0;
        }(this);
      }
      write(e3) {
        return at2(this) ? void 0 === this._ownerWritableStream ? d2(yt2("write to")) : function(e4, t3) {
          const r3 = e4._ownerWritableStream, o3 = r3._writableStreamController, n3 = function(e5, t4) {
            try {
              return e5._strategySizeAlgorithm(t4);
            } catch (t5) {
              return ft2(e5, t5), 1;
            }
          }(o3, t3);
          if (r3 !== e4._ownerWritableStream) return d2(yt2("write to"));
          const a3 = r3._state;
          if ("errored" === a3) return d2(r3._storedError);
          if (rt2(r3) || "closed" === a3) return d2(new TypeError("The stream is closing or closed and cannot be written to"));
          if ("erroring" === a3) return d2(r3._storedError);
          const i3 = function(e5) {
            return u2((t4, r4) => {
              const o4 = { _resolve: t4, _reject: r4 };
              e5._writeRequests.push(o4);
            });
          }(r3);
          return function(e5, t4, r4) {
            try {
              ue2(e5, t4, r4);
            } catch (t5) {
              return void ft2(e5, t5);
            }
            const o4 = e5._controlledWritableStream;
            if (!rt2(o4) && "writable" === o4._state) {
              nt2(o4, bt2(e5));
            }
            dt2(e5);
          }(o3, t3, n3), i3;
        }(this, e3) : d2(mt2("write"));
      }
    };
    Object.defineProperties(WritableStreamDefaultWriter.prototype, { abort: { enumerable: true }, close: { enumerable: true }, releaseLock: { enumerable: true }, write: { enumerable: true }, closed: { enumerable: true }, desiredSize: { enumerable: true }, ready: { enumerable: true } }), n2(WritableStreamDefaultWriter.prototype.abort, "abort"), n2(WritableStreamDefaultWriter.prototype.close, "close"), n2(WritableStreamDefaultWriter.prototype.releaseLock, "releaseLock"), n2(WritableStreamDefaultWriter.prototype.write, "write"), "symbol" == typeof e2.toStringTag && Object.defineProperty(WritableStreamDefaultWriter.prototype, e2.toStringTag, { value: "WritableStreamDefaultWriter", configurable: true });
    lt2 = {};
    WritableStreamDefaultController = class {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get abortReason() {
        if (!st2(this)) throw pt2("abortReason");
        return this._abortReason;
      }
      get signal() {
        if (!st2(this)) throw pt2("signal");
        if (void 0 === this._abortController) throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
        return this._abortController.signal;
      }
      error(e3) {
        if (!st2(this)) throw pt2("error");
        "writable" === this._controlledWritableStream._state && ht2(this, e3);
      }
      [v2](e3) {
        const t3 = this._abortAlgorithm(e3);
        return ut2(this), t3;
      }
      [R2]() {
        ce2(this);
      }
    };
    Object.defineProperties(WritableStreamDefaultController.prototype, { abortReason: { enumerable: true }, signal: { enumerable: true }, error: { enumerable: true } }), "symbol" == typeof e2.toStringTag && Object.defineProperty(WritableStreamDefaultController.prototype, e2.toStringTag, { value: "WritableStreamDefaultController", configurable: true });
    Pt2 = "undefined" != typeof DOMException ? DOMException : void 0;
    Wt2 = function(e3) {
      if ("function" != typeof e3 && "object" != typeof e3) return false;
      try {
        return new e3(), true;
      } catch (e4) {
        return false;
      }
    }(Pt2) ? Pt2 : function() {
      const e3 = function(e4, t3) {
        this.message = e4 || "", this.name = t3 || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
      };
      return e3.prototype = Object.create(Error.prototype), Object.defineProperty(e3.prototype, "constructor", { value: e3, writable: true, configurable: true }), e3;
    }();
    ReadableStreamDefaultController = class {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get desiredSize() {
        if (!Bt2(this)) throw Dt2("desiredSize");
        return Lt2(this);
      }
      close() {
        if (!Bt2(this)) throw Dt2("close");
        if (!Ft2(this)) throw new TypeError("The stream is not in a state that permits close");
        !function(e3) {
          if (!Ft2(e3)) return;
          const t3 = e3._controlledReadableStream;
          e3._closeRequested = true, 0 === e3._queue.length && (jt2(e3), Xt2(t3));
        }(this);
      }
      enqueue(e3) {
        if (!Bt2(this)) throw Dt2("enqueue");
        if (!Ft2(this)) throw new TypeError("The stream is not in a state that permits enqueue");
        return function(e4, t3) {
          if (!Ft2(e4)) return;
          const r3 = e4._controlledReadableStream;
          if (Ut2(r3) && X2(r3) > 0) G2(r3, t3, false);
          else {
            let r4;
            try {
              r4 = e4._strategySizeAlgorithm(t3);
            } catch (t4) {
              throw zt2(e4, t4), t4;
            }
            try {
              ue2(e4, t3, r4);
            } catch (t4) {
              throw zt2(e4, t4), t4;
            }
          }
          At2(e4);
        }(this, e3);
      }
      error(e3) {
        if (!Bt2(this)) throw Dt2("error");
        zt2(this, e3);
      }
      [T2](e3) {
        ce2(this);
        const t3 = this._cancelAlgorithm(e3);
        return jt2(this), t3;
      }
      [q2](e3) {
        const t3 = this._controlledReadableStream;
        if (this._queue.length > 0) {
          const r3 = se2(this);
          this._closeRequested && 0 === this._queue.length ? (jt2(this), Xt2(t3)) : At2(this), e3._chunkSteps(r3);
        } else U2(t3, e3), At2(this);
      }
      [C2]() {
      }
    };
    Object.defineProperties(ReadableStreamDefaultController.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, desiredSize: { enumerable: true } }), n2(ReadableStreamDefaultController.prototype.close, "close"), n2(ReadableStreamDefaultController.prototype.enqueue, "enqueue"), n2(ReadableStreamDefaultController.prototype.error, "error"), "symbol" == typeof e2.toStringTag && Object.defineProperty(ReadableStreamDefaultController.prototype, e2.toStringTag, { value: "ReadableStreamDefaultController", configurable: true });
    ReadableStream3 = class {
      constructor(e3 = {}, t3 = {}) {
        void 0 === e3 ? e3 = null : D2(e3, "First parameter");
        const r3 = Ye2(t3, "Second parameter"), o3 = function(e4, t4) {
          F2(e4, t4);
          const r4 = e4, o4 = null == r4 ? void 0 : r4.autoAllocateChunkSize, n4 = null == r4 ? void 0 : r4.cancel, a3 = null == r4 ? void 0 : r4.pull, i3 = null == r4 ? void 0 : r4.start, l3 = null == r4 ? void 0 : r4.type;
          return { autoAllocateChunkSize: void 0 === o4 ? void 0 : N2(o4, `${t4} has member 'autoAllocateChunkSize' that`), cancel: void 0 === n4 ? void 0 : $t2(n4, r4, `${t4} has member 'cancel' that`), pull: void 0 === a3 ? void 0 : Mt2(a3, r4, `${t4} has member 'pull' that`), start: void 0 === i3 ? void 0 : Yt2(i3, r4, `${t4} has member 'start' that`), type: void 0 === l3 ? void 0 : Qt2(l3, `${t4} has member 'type' that`) };
        }(e3, "First parameter");
        var n3;
        if ((n3 = this)._state = "readable", n3._reader = void 0, n3._storedError = void 0, n3._disturbed = false, "bytes" === o3.type) {
          if (void 0 !== r3.size) throw new RangeError("The strategy for a byte stream cannot have a size function");
          Oe2(this, o3, $e2(r3, 0));
        } else {
          const e4 = Me2(r3);
          It2(this, o3, $e2(r3, 1), e4);
        }
      }
      get locked() {
        if (!Vt2(this)) throw Kt2("locked");
        return Ut2(this);
      }
      cancel(e3) {
        return Vt2(this) ? Ut2(this) ? d2(new TypeError("Cannot cancel a stream that already has a reader")) : Gt2(this, e3) : d2(Kt2("cancel"));
      }
      getReader(e3) {
        if (!Vt2(this)) throw Kt2("getReader");
        return void 0 === function(e4, t3) {
          F2(e4, t3);
          const r3 = null == e4 ? void 0 : e4.mode;
          return { mode: void 0 === r3 ? void 0 : Nt2(r3, `${t3} has member 'mode' that`) };
        }(e3, "First parameter").mode ? new ReadableStreamDefaultReader(this) : function(e4) {
          return new ReadableStreamBYOBReader(e4);
        }(this);
      }
      pipeThrough(e3, t3 = {}) {
        if (!H2(this)) throw Kt2("pipeThrough");
        $2(e3, 1, "pipeThrough");
        const r3 = xt2(e3, "First parameter"), o3 = Ht2(t3, "Second parameter");
        if (this.locked) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
        if (r3.writable.locked) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
        return m2(kt2(this, r3.writable, o3.preventClose, o3.preventAbort, o3.preventCancel, o3.signal)), r3.readable;
      }
      pipeTo(e3, t3 = {}) {
        if (!H2(this)) return d2(Kt2("pipeTo"));
        if (void 0 === e3) return d2("Parameter 1 is required in 'pipeTo'.");
        if (!x2(e3)) return d2(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
        let r3;
        try {
          r3 = Ht2(t3, "Second parameter");
        } catch (e4) {
          return d2(e4);
        }
        return this.locked ? d2(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : e3.locked ? d2(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : kt2(this, e3, r3.preventClose, r3.preventAbort, r3.preventCancel, r3.signal);
      }
      tee() {
        if (!H2(this)) throw Kt2("tee");
        if (this.locked) throw new TypeError("Cannot tee a stream that already has a reader");
        return Ot2(this);
      }
      values(e3) {
        if (!H2(this)) throw Kt2("values");
        return function(e4, t3) {
          const r3 = e4.getReader(), o3 = new te2(r3, t3), n3 = Object.create(re2);
          return n3._asyncIteratorImpl = o3, n3;
        }(this, function(e4, t3) {
          F2(e4, t3);
          const r3 = null == e4 ? void 0 : e4.preventCancel;
          return { preventCancel: Boolean(r3) };
        }(e3, "First parameter").preventCancel);
      }
    };
    Object.defineProperties(ReadableStream3.prototype, { cancel: { enumerable: true }, getReader: { enumerable: true }, pipeThrough: { enumerable: true }, pipeTo: { enumerable: true }, tee: { enumerable: true }, values: { enumerable: true }, locked: { enumerable: true } }), n2(ReadableStream3.prototype.cancel, "cancel"), n2(ReadableStream3.prototype.getReader, "getReader"), n2(ReadableStream3.prototype.pipeThrough, "pipeThrough"), n2(ReadableStream3.prototype.pipeTo, "pipeTo"), n2(ReadableStream3.prototype.tee, "tee"), n2(ReadableStream3.prototype.values, "values"), "symbol" == typeof e2.toStringTag && Object.defineProperty(ReadableStream3.prototype, e2.toStringTag, { value: "ReadableStream", configurable: true }), "symbol" == typeof e2.asyncIterator && Object.defineProperty(ReadableStream3.prototype, e2.asyncIterator, { value: ReadableStream3.prototype.values, writable: true, configurable: true });
    er2 = (e3) => e3.byteLength;
    n2(er2, "size");
    ByteLengthQueuingStrategy = class {
      constructor(e3) {
        $2(e3, 1, "ByteLengthQueuingStrategy"), e3 = Zt2(e3, "First parameter"), this._byteLengthQueuingStrategyHighWaterMark = e3.highWaterMark;
      }
      get highWaterMark() {
        if (!rr2(this)) throw tr2("highWaterMark");
        return this._byteLengthQueuingStrategyHighWaterMark;
      }
      get size() {
        if (!rr2(this)) throw tr2("size");
        return er2;
      }
    };
    Object.defineProperties(ByteLengthQueuingStrategy.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), "symbol" == typeof e2.toStringTag && Object.defineProperty(ByteLengthQueuingStrategy.prototype, e2.toStringTag, { value: "ByteLengthQueuingStrategy", configurable: true });
    or2 = () => 1;
    n2(or2, "size");
    CountQueuingStrategy = class {
      constructor(e3) {
        $2(e3, 1, "CountQueuingStrategy"), e3 = Zt2(e3, "First parameter"), this._countQueuingStrategyHighWaterMark = e3.highWaterMark;
      }
      get highWaterMark() {
        if (!ar2(this)) throw nr2("highWaterMark");
        return this._countQueuingStrategyHighWaterMark;
      }
      get size() {
        if (!ar2(this)) throw nr2("size");
        return or2;
      }
    };
    Object.defineProperties(CountQueuingStrategy.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), "symbol" == typeof e2.toStringTag && Object.defineProperty(CountQueuingStrategy.prototype, e2.toStringTag, { value: "CountQueuingStrategy", configurable: true });
    TransformStream = class {
      constructor(e3 = {}, t3 = {}, r3 = {}) {
        void 0 === e3 && (e3 = null);
        const o3 = Ye2(t3, "Second parameter"), n3 = Ye2(r3, "Third parameter"), a3 = function(e4, t4) {
          F2(e4, t4);
          const r4 = null == e4 ? void 0 : e4.flush, o4 = null == e4 ? void 0 : e4.readableType, n4 = null == e4 ? void 0 : e4.start, a4 = null == e4 ? void 0 : e4.transform, i4 = null == e4 ? void 0 : e4.writableType;
          return { flush: void 0 === r4 ? void 0 : ir2(r4, e4, `${t4} has member 'flush' that`), readableType: o4, start: void 0 === n4 ? void 0 : lr2(n4, e4, `${t4} has member 'start' that`), transform: void 0 === a4 ? void 0 : sr2(a4, e4, `${t4} has member 'transform' that`), writableType: i4 };
        }(e3, "First parameter");
        if (void 0 !== a3.readableType) throw new RangeError("Invalid readableType specified");
        if (void 0 !== a3.writableType) throw new RangeError("Invalid writableType specified");
        const i3 = $e2(n3, 0), l3 = Me2(n3), s3 = $e2(o3, 1), f3 = Me2(o3);
        let b3;
        !function(e4, t4, r4, o4, n4, a4) {
          function i4() {
            return t4;
          }
          function l4(t5) {
            return function(e5, t6) {
              const r5 = e5._transformStreamController;
              if (e5._backpressure) {
                return p2(e5._backpressureChangePromise, () => {
                  if ("erroring" === (Ge2(e5._writable) ? e5._writable._state : e5._writableState)) throw Ge2(e5._writable) ? e5._writable._storedError : e5._writableStoredError;
                  return pr2(r5, t6);
                });
              }
              return pr2(r5, t6);
            }(e4, t5);
          }
          function s4(t5) {
            return function(e5, t6) {
              return cr2(e5, t6), c2(void 0);
            }(e4, t5);
          }
          function u3() {
            return function(e5) {
              const t5 = e5._transformStreamController, r5 = t5._flushAlgorithm();
              return hr2(t5), p2(r5, () => {
                if ("errored" === e5._readableState) throw e5._readableStoredError;
                gr2(e5) && wr2(e5);
              }, (t6) => {
                throw cr2(e5, t6), e5._readableStoredError;
              });
            }(e4);
          }
          function d3() {
            return function(e5) {
              return fr2(e5, false), e5._backpressureChangePromise;
            }(e4);
          }
          function f4(t5) {
            return dr2(e4, t5), c2(void 0);
          }
          e4._writableState = "writable", e4._writableStoredError = void 0, e4._writableHasInFlightOperation = false, e4._writableStarted = false, e4._writable = function(e5, t5, r5, o5, n5, a5, i5) {
            return new WritableStream({ start(r6) {
              e5._writableController = r6;
              try {
                const t6 = r6.signal;
                void 0 !== t6 && t6.addEventListener("abort", () => {
                  "writable" === e5._writableState && (e5._writableState = "erroring", t6.reason && (e5._writableStoredError = t6.reason));
                });
              } catch (e6) {
              }
              return p2(t5(), () => (e5._writableStarted = true, Cr2(e5), null), (t6) => {
                throw e5._writableStarted = true, Rr2(e5, t6), t6;
              });
            }, write: (t6) => (function(e6) {
              e6._writableHasInFlightOperation = true;
            }(e5), p2(r5(t6), () => (function(e6) {
              e6._writableHasInFlightOperation = false;
            }(e5), Cr2(e5), null), (t7) => {
              throw function(e6, t8) {
                e6._writableHasInFlightOperation = false, Rr2(e6, t8);
              }(e5, t7), t7;
            })), close: () => (function(e6) {
              e6._writableHasInFlightOperation = true;
            }(e5), p2(o5(), () => (function(e6) {
              e6._writableHasInFlightOperation = false;
              "erroring" === e6._writableState && (e6._writableStoredError = void 0);
              e6._writableState = "closed";
            }(e5), null), (t6) => {
              throw function(e6, t7) {
                e6._writableHasInFlightOperation = false, e6._writableState, Rr2(e6, t7);
              }(e5, t6), t6;
            })), abort: (t6) => (e5._writableState = "errored", e5._writableStoredError = t6, n5(t6)) }, { highWaterMark: a5, size: i5 });
          }(e4, i4, l4, u3, s4, r4, o4), e4._readableState = "readable", e4._readableStoredError = void 0, e4._readableCloseRequested = false, e4._readablePulling = false, e4._readable = function(e5, t5, r5, o5, n5, a5) {
            return new ReadableStream3({ start: (r6) => (e5._readableController = r6, t5().catch((t6) => {
              Sr2(e5, t6);
            })), pull: () => (e5._readablePulling = true, r5().catch((t6) => {
              Sr2(e5, t6);
            })), cancel: (t6) => (e5._readableState = "closed", o5(t6)) }, { highWaterMark: n5, size: a5 });
          }(e4, i4, d3, f4, n4, a4), e4._backpressure = void 0, e4._backpressureChangePromise = void 0, e4._backpressureChangePromise_resolve = void 0, fr2(e4, true), e4._transformStreamController = void 0;
        }(this, u2((e4) => {
          b3 = e4;
        }), s3, f3, i3, l3), function(e4, t4) {
          const r4 = Object.create(TransformStreamDefaultController.prototype);
          let o4, n4;
          o4 = void 0 !== t4.transform ? (e5) => t4.transform(e5, r4) : (e5) => {
            try {
              return _r3(r4, e5), c2(void 0);
            } catch (e6) {
              return d2(e6);
            }
          };
          n4 = void 0 !== t4.flush ? () => t4.flush(r4) : () => c2(void 0);
          !function(e5, t5, r5, o5) {
            t5._controlledTransformStream = e5, e5._transformStreamController = t5, t5._transformAlgorithm = r5, t5._flushAlgorithm = o5;
          }(e4, r4, o4, n4);
        }(this, a3), void 0 !== a3.start ? b3(a3.start(this._transformStreamController)) : b3(void 0);
      }
      get readable() {
        if (!ur2(this)) throw yr2("readable");
        return this._readable;
      }
      get writable() {
        if (!ur2(this)) throw yr2("writable");
        return this._writable;
      }
    };
    Object.defineProperties(TransformStream.prototype, { readable: { enumerable: true }, writable: { enumerable: true } }), "symbol" == typeof e2.toStringTag && Object.defineProperty(TransformStream.prototype, e2.toStringTag, { value: "TransformStream", configurable: true });
    TransformStreamDefaultController = class {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get desiredSize() {
        if (!br2(this)) throw mr2("desiredSize");
        return vr2(this._controlledTransformStream);
      }
      enqueue(e3) {
        if (!br2(this)) throw mr2("enqueue");
        _r3(this, e3);
      }
      error(e3) {
        if (!br2(this)) throw mr2("error");
        var t3;
        t3 = e3, cr2(this._controlledTransformStream, t3);
      }
      terminate() {
        if (!br2(this)) throw mr2("terminate");
        !function(e3) {
          const t3 = e3._controlledTransformStream;
          gr2(t3) && wr2(t3);
          const r3 = new TypeError("TransformStream terminated");
          dr2(t3, r3);
        }(this);
      }
    };
    Object.defineProperties(TransformStreamDefaultController.prototype, { enqueue: { enumerable: true }, error: { enumerable: true }, terminate: { enumerable: true }, desiredSize: { enumerable: true } }), n2(TransformStreamDefaultController.prototype.enqueue, "enqueue"), n2(TransformStreamDefaultController.prototype.error, "error"), n2(TransformStreamDefaultController.prototype.terminate, "terminate"), "symbol" == typeof e2.toStringTag && Object.defineProperty(TransformStreamDefaultController.prototype, e2.toStringTag, { value: "TransformStreamDefaultController", configurable: true });
  }
});

// node_modules/formdata-node/lib/esm/isFunction.js
var isFunction;
var init_isFunction = __esm({
  "node_modules/formdata-node/lib/esm/isFunction.js"() {
    isFunction = (value) => typeof value === "function";
  }
});

// node_modules/formdata-node/lib/esm/blobHelpers.js
async function* clonePart(part) {
  const end = part.byteOffset + part.byteLength;
  let position = part.byteOffset;
  while (position !== end) {
    const size = Math.min(end - position, CHUNK_SIZE);
    const chunk = part.buffer.slice(position, position + size);
    position += chunk.byteLength;
    yield new Uint8Array(chunk);
  }
}
async function* consumeNodeBlob(blob) {
  let position = 0;
  while (position !== blob.size) {
    const chunk = blob.slice(position, Math.min(blob.size, position + CHUNK_SIZE));
    const buffer = await chunk.arrayBuffer();
    position += buffer.byteLength;
    yield new Uint8Array(buffer);
  }
}
async function* consumeBlobParts(parts, clone = false) {
  for (const part of parts) {
    if (ArrayBuffer.isView(part)) {
      if (clone) {
        yield* clonePart(part);
      } else {
        yield part;
      }
    } else if (isFunction(part.stream)) {
      yield* part.stream();
    } else {
      yield* consumeNodeBlob(part);
    }
  }
}
function* sliceBlob(blobParts, blobSize, start = 0, end) {
  end !== null && end !== void 0 ? end : end = blobSize;
  let relativeStart = start < 0 ? Math.max(blobSize + start, 0) : Math.min(start, blobSize);
  let relativeEnd = end < 0 ? Math.max(blobSize + end, 0) : Math.min(end, blobSize);
  const span = Math.max(relativeEnd - relativeStart, 0);
  let added = 0;
  for (const part of blobParts) {
    if (added >= span) {
      break;
    }
    const partSize = ArrayBuffer.isView(part) ? part.byteLength : part.size;
    if (relativeStart && partSize <= relativeStart) {
      relativeStart -= partSize;
      relativeEnd -= partSize;
    } else {
      let chunk;
      if (ArrayBuffer.isView(part)) {
        chunk = part.subarray(relativeStart, Math.min(partSize, relativeEnd));
        added += chunk.byteLength;
      } else {
        chunk = part.slice(relativeStart, Math.min(partSize, relativeEnd));
        added += chunk.size;
      }
      relativeEnd -= partSize;
      relativeStart = 0;
      yield chunk;
    }
  }
}
var CHUNK_SIZE;
var init_blobHelpers = __esm({
  "node_modules/formdata-node/lib/esm/blobHelpers.js"() {
    init_isFunction();
    CHUNK_SIZE = 65536;
  }
});

// node_modules/formdata-node/lib/esm/Blob.js
var __classPrivateFieldGet, __classPrivateFieldSet, _Blob_parts, _Blob_type, _Blob_size, Blob3;
var init_Blob = __esm({
  "node_modules/formdata-node/lib/esm/Blob.js"() {
    init_ponyfill();
    init_isFunction();
    init_blobHelpers();
    __classPrivateFieldGet = function(receiver, state, kind2, f3) {
      if (kind2 === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind2 === "m" ? f3 : kind2 === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind2, f3) {
      if (kind2 === "m") throw new TypeError("Private method is not writable");
      if (kind2 === "a" && !f3) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind2 === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state.set(receiver, value), value;
    };
    Blob3 = class _Blob {
      constructor(blobParts = [], options = {}) {
        _Blob_parts.set(this, []);
        _Blob_type.set(this, "");
        _Blob_size.set(this, 0);
        options !== null && options !== void 0 ? options : options = {};
        if (typeof blobParts !== "object" || blobParts === null) {
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        }
        if (!isFunction(blobParts[Symbol.iterator])) {
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        }
        if (typeof options !== "object" && !isFunction(options)) {
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        const encoder = new TextEncoder();
        for (const raw of blobParts) {
          let part;
          if (ArrayBuffer.isView(raw)) {
            part = new Uint8Array(raw.buffer.slice(raw.byteOffset, raw.byteOffset + raw.byteLength));
          } else if (raw instanceof ArrayBuffer) {
            part = new Uint8Array(raw.slice(0));
          } else if (raw instanceof _Blob) {
            part = raw;
          } else {
            part = encoder.encode(String(raw));
          }
          __classPrivateFieldSet(this, _Blob_size, __classPrivateFieldGet(this, _Blob_size, "f") + (ArrayBuffer.isView(part) ? part.byteLength : part.size), "f");
          __classPrivateFieldGet(this, _Blob_parts, "f").push(part);
        }
        const type = options.type === void 0 ? "" : String(options.type);
        __classPrivateFieldSet(this, _Blob_type, /^[\x20-\x7E]*$/.test(type) ? type : "", "f");
      }
      static [(_Blob_parts = /* @__PURE__ */ new WeakMap(), _Blob_type = /* @__PURE__ */ new WeakMap(), _Blob_size = /* @__PURE__ */ new WeakMap(), Symbol.hasInstance)](value) {
        return Boolean(value && typeof value === "object" && isFunction(value.constructor) && (isFunction(value.stream) || isFunction(value.arrayBuffer)) && /^(Blob|File)$/.test(value[Symbol.toStringTag]));
      }
      get type() {
        return __classPrivateFieldGet(this, _Blob_type, "f");
      }
      get size() {
        return __classPrivateFieldGet(this, _Blob_size, "f");
      }
      slice(start, end, contentType) {
        return new _Blob(sliceBlob(__classPrivateFieldGet(this, _Blob_parts, "f"), this.size, start, end), {
          type: contentType
        });
      }
      async text() {
        const decoder = new TextDecoder();
        let result = "";
        for await (const chunk of consumeBlobParts(__classPrivateFieldGet(this, _Blob_parts, "f"))) {
          result += decoder.decode(chunk, { stream: true });
        }
        result += decoder.decode();
        return result;
      }
      async arrayBuffer() {
        const view = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of consumeBlobParts(__classPrivateFieldGet(this, _Blob_parts, "f"))) {
          view.set(chunk, offset);
          offset += chunk.length;
        }
        return view.buffer;
      }
      stream() {
        const iterator = consumeBlobParts(__classPrivateFieldGet(this, _Blob_parts, "f"), true);
        return new ReadableStream3({
          async pull(controller) {
            const { value, done } = await iterator.next();
            if (done) {
              return queueMicrotask(() => controller.close());
            }
            controller.enqueue(value);
          },
          async cancel() {
            await iterator.return();
          }
        });
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
    };
    Object.defineProperties(Blob3.prototype, {
      type: { enumerable: true },
      size: { enumerable: true },
      slice: { enumerable: true },
      stream: { enumerable: true },
      text: { enumerable: true },
      arrayBuffer: { enumerable: true }
    });
  }
});

// node_modules/formdata-node/lib/esm/File.js
var __classPrivateFieldSet2, __classPrivateFieldGet2, _File_name, _File_lastModified, File3;
var init_File = __esm({
  "node_modules/formdata-node/lib/esm/File.js"() {
    init_Blob();
    __classPrivateFieldSet2 = function(receiver, state, value, kind2, f3) {
      if (kind2 === "m") throw new TypeError("Private method is not writable");
      if (kind2 === "a" && !f3) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind2 === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldGet2 = function(receiver, state, kind2, f3) {
      if (kind2 === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind2 === "m" ? f3 : kind2 === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
    };
    File3 = class extends Blob3 {
      constructor(fileBits, name, options = {}) {
        super(fileBits, options);
        _File_name.set(this, void 0);
        _File_lastModified.set(this, 0);
        if (arguments.length < 2) {
          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        }
        __classPrivateFieldSet2(this, _File_name, String(name), "f");
        const lastModified = options.lastModified === void 0 ? Date.now() : Number(options.lastModified);
        if (!Number.isNaN(lastModified)) {
          __classPrivateFieldSet2(this, _File_lastModified, lastModified, "f");
        }
      }
      static [(_File_name = /* @__PURE__ */ new WeakMap(), _File_lastModified = /* @__PURE__ */ new WeakMap(), Symbol.hasInstance)](value) {
        return value instanceof Blob3 && value[Symbol.toStringTag] === "File" && typeof value.name === "string";
      }
      get name() {
        return __classPrivateFieldGet2(this, _File_name, "f");
      }
      get lastModified() {
        return __classPrivateFieldGet2(this, _File_lastModified, "f");
      }
      get webkitRelativePath() {
        return "";
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    };
  }
});

// node_modules/formdata-node/lib/esm/isFile.js
var isFile;
var init_isFile = __esm({
  "node_modules/formdata-node/lib/esm/isFile.js"() {
    init_File();
    isFile = (value) => value instanceof File3;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s3 = 1e3;
    var m3 = s3 * 60;
    var h3 = m3 * 60;
    var d3 = h3 * 24;
    var w3 = d3 * 7;
    var y3 = d3 * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse3(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse3(str2) {
      str2 = String(str2);
      if (str2.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str2
      );
      if (!match) {
        return;
      }
      var n3 = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n3 * y3;
        case "weeks":
        case "week":
        case "w":
          return n3 * w3;
        case "days":
        case "day":
        case "d":
          return n3 * d3;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n3 * h3;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n3 * m3;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n3 * s3;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n3;
        default:
          return void 0;
      }
    }
    function fmtShort(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d3) {
        return Math.round(ms2 / d3) + "d";
      }
      if (msAbs >= h3) {
        return Math.round(ms2 / h3) + "h";
      }
      if (msAbs >= m3) {
        return Math.round(ms2 / m3) + "m";
      }
      if (msAbs >= s3) {
        return Math.round(ms2 / s3) + "s";
      }
      return ms2 + "ms";
    }
    function fmtLong(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d3) {
        return plural(ms2, msAbs, d3, "day");
      }
      if (msAbs >= h3) {
        return plural(ms2, msAbs, h3, "hour");
      }
      if (msAbs >= m3) {
        return plural(ms2, msAbs, m3, "minute");
      }
      if (msAbs >= s3) {
        return plural(ms2, msAbs, s3, "second");
      }
      return ms2 + " ms";
    }
    function plural(ms2, msAbs, n3, name) {
      var isPlural = msAbs >= n3 * 1.5;
      return Math.round(ms2 / n3) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/humanize-ms/index.js
var require_humanize_ms = __commonJS({
  "node_modules/humanize-ms/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var ms2 = require_ms();
    module2.exports = function(t3) {
      if (typeof t3 === "number") return t3;
      var r3 = ms2(t3);
      if (r3 === void 0) {
        var err = new Error(util.format("humanize-ms(%j) result undefined", t3));
        console.warn(err.stack);
      }
      return r3;
    };
  }
});

// node_modules/agentkeepalive/lib/constants.js
var require_constants = __commonJS({
  "node_modules/agentkeepalive/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      // agent
      CURRENT_ID: Symbol("agentkeepalive#currentId"),
      CREATE_ID: Symbol("agentkeepalive#createId"),
      INIT_SOCKET: Symbol("agentkeepalive#initSocket"),
      CREATE_HTTPS_CONNECTION: Symbol("agentkeepalive#createHttpsConnection"),
      // socket
      SOCKET_CREATED_TIME: Symbol("agentkeepalive#socketCreatedTime"),
      SOCKET_NAME: Symbol("agentkeepalive#socketName"),
      SOCKET_REQUEST_COUNT: Symbol("agentkeepalive#socketRequestCount"),
      SOCKET_REQUEST_FINISHED_COUNT: Symbol("agentkeepalive#socketRequestFinishedCount")
    };
  }
});

// node_modules/agentkeepalive/lib/agent.js
var require_agent = __commonJS({
  "node_modules/agentkeepalive/lib/agent.js"(exports2, module2) {
    "use strict";
    var OriginalAgent = require("http").Agent;
    var ms2 = require_humanize_ms();
    var debug2 = require("util").debuglog("agentkeepalive");
    var {
      INIT_SOCKET,
      CURRENT_ID,
      CREATE_ID,
      SOCKET_CREATED_TIME,
      SOCKET_NAME,
      SOCKET_REQUEST_COUNT,
      SOCKET_REQUEST_FINISHED_COUNT
    } = require_constants();
    var defaultTimeoutListenerCount = 1;
    var majorVersion = parseInt(process.version.split(".", 1)[0].substring(1));
    if (majorVersion >= 11 && majorVersion <= 12) {
      defaultTimeoutListenerCount = 2;
    } else if (majorVersion >= 13) {
      defaultTimeoutListenerCount = 3;
    }
    function deprecate2(message) {
      console.log("[agentkeepalive:deprecated] %s", message);
    }
    var Agent2 = class extends OriginalAgent {
      constructor(options) {
        options = options || {};
        options.keepAlive = options.keepAlive !== false;
        if (options.freeSocketTimeout === void 0) {
          options.freeSocketTimeout = 4e3;
        }
        if (options.keepAliveTimeout) {
          deprecate2("options.keepAliveTimeout is deprecated, please use options.freeSocketTimeout instead");
          options.freeSocketTimeout = options.keepAliveTimeout;
          delete options.keepAliveTimeout;
        }
        if (options.freeSocketKeepAliveTimeout) {
          deprecate2("options.freeSocketKeepAliveTimeout is deprecated, please use options.freeSocketTimeout instead");
          options.freeSocketTimeout = options.freeSocketKeepAliveTimeout;
          delete options.freeSocketKeepAliveTimeout;
        }
        if (options.timeout === void 0) {
          options.timeout = Math.max(options.freeSocketTimeout * 2, 8e3);
        }
        options.timeout = ms2(options.timeout);
        options.freeSocketTimeout = ms2(options.freeSocketTimeout);
        options.socketActiveTTL = options.socketActiveTTL ? ms2(options.socketActiveTTL) : 0;
        super(options);
        this[CURRENT_ID] = 0;
        this.createSocketCount = 0;
        this.createSocketCountLastCheck = 0;
        this.createSocketErrorCount = 0;
        this.createSocketErrorCountLastCheck = 0;
        this.closeSocketCount = 0;
        this.closeSocketCountLastCheck = 0;
        this.errorSocketCount = 0;
        this.errorSocketCountLastCheck = 0;
        this.requestCount = 0;
        this.requestCountLastCheck = 0;
        this.timeoutSocketCount = 0;
        this.timeoutSocketCountLastCheck = 0;
        this.on("free", (socket) => {
          const timeout = this.calcSocketTimeout(socket);
          if (timeout > 0 && socket.timeout !== timeout) {
            socket.setTimeout(timeout);
          }
        });
      }
      get freeSocketKeepAliveTimeout() {
        deprecate2("agent.freeSocketKeepAliveTimeout is deprecated, please use agent.options.freeSocketTimeout instead");
        return this.options.freeSocketTimeout;
      }
      get timeout() {
        deprecate2("agent.timeout is deprecated, please use agent.options.timeout instead");
        return this.options.timeout;
      }
      get socketActiveTTL() {
        deprecate2("agent.socketActiveTTL is deprecated, please use agent.options.socketActiveTTL instead");
        return this.options.socketActiveTTL;
      }
      calcSocketTimeout(socket) {
        let freeSocketTimeout = this.options.freeSocketTimeout;
        const socketActiveTTL = this.options.socketActiveTTL;
        if (socketActiveTTL) {
          const aliveTime = Date.now() - socket[SOCKET_CREATED_TIME];
          const diff = socketActiveTTL - aliveTime;
          if (diff <= 0) {
            return diff;
          }
          if (freeSocketTimeout && diff < freeSocketTimeout) {
            freeSocketTimeout = diff;
          }
        }
        if (freeSocketTimeout) {
          const customFreeSocketTimeout = socket.freeSocketTimeout || socket.freeSocketKeepAliveTimeout;
          return customFreeSocketTimeout || freeSocketTimeout;
        }
      }
      keepSocketAlive(socket) {
        const result = super.keepSocketAlive(socket);
        if (!result) return result;
        const customTimeout = this.calcSocketTimeout(socket);
        if (typeof customTimeout === "undefined") {
          return true;
        }
        if (customTimeout <= 0) {
          debug2(
            "%s(requests: %s, finished: %s) free but need to destroy by TTL, request count %s, diff is %s",
            socket[SOCKET_NAME],
            socket[SOCKET_REQUEST_COUNT],
            socket[SOCKET_REQUEST_FINISHED_COUNT],
            customTimeout
          );
          return false;
        }
        if (socket.timeout !== customTimeout) {
          socket.setTimeout(customTimeout);
        }
        return true;
      }
      // only call on addRequest
      reuseSocket(...args) {
        super.reuseSocket(...args);
        const socket = args[0];
        const req = args[1];
        req.reusedSocket = true;
        const agentTimeout = this.options.timeout;
        if (getSocketTimeout(socket) !== agentTimeout) {
          socket.setTimeout(agentTimeout);
          debug2("%s reset timeout to %sms", socket[SOCKET_NAME], agentTimeout);
        }
        socket[SOCKET_REQUEST_COUNT]++;
        debug2(
          "%s(requests: %s, finished: %s) reuse on addRequest, timeout %sms",
          socket[SOCKET_NAME],
          socket[SOCKET_REQUEST_COUNT],
          socket[SOCKET_REQUEST_FINISHED_COUNT],
          getSocketTimeout(socket)
        );
      }
      [CREATE_ID]() {
        const id = this[CURRENT_ID]++;
        if (this[CURRENT_ID] === Number.MAX_SAFE_INTEGER) this[CURRENT_ID] = 0;
        return id;
      }
      [INIT_SOCKET](socket, options) {
        if (options.timeout) {
          const timeout = getSocketTimeout(socket);
          if (!timeout) {
            socket.setTimeout(options.timeout);
          }
        }
        if (this.options.keepAlive) {
          socket.setNoDelay(true);
        }
        this.createSocketCount++;
        if (this.options.socketActiveTTL) {
          socket[SOCKET_CREATED_TIME] = Date.now();
        }
        socket[SOCKET_NAME] = `sock[${this[CREATE_ID]()}#${options._agentKey}]`.split("-----BEGIN", 1)[0];
        socket[SOCKET_REQUEST_COUNT] = 1;
        socket[SOCKET_REQUEST_FINISHED_COUNT] = 0;
        installListeners(this, socket, options);
      }
      createConnection(options, oncreate) {
        let called = false;
        const onNewCreate = (err, socket) => {
          if (called) return;
          called = true;
          if (err) {
            this.createSocketErrorCount++;
            return oncreate(err);
          }
          this[INIT_SOCKET](socket, options);
          oncreate(err, socket);
        };
        const newSocket = super.createConnection(options, onNewCreate);
        if (newSocket) onNewCreate(null, newSocket);
        return newSocket;
      }
      get statusChanged() {
        const changed = this.createSocketCount !== this.createSocketCountLastCheck || this.createSocketErrorCount !== this.createSocketErrorCountLastCheck || this.closeSocketCount !== this.closeSocketCountLastCheck || this.errorSocketCount !== this.errorSocketCountLastCheck || this.timeoutSocketCount !== this.timeoutSocketCountLastCheck || this.requestCount !== this.requestCountLastCheck;
        if (changed) {
          this.createSocketCountLastCheck = this.createSocketCount;
          this.createSocketErrorCountLastCheck = this.createSocketErrorCount;
          this.closeSocketCountLastCheck = this.closeSocketCount;
          this.errorSocketCountLastCheck = this.errorSocketCount;
          this.timeoutSocketCountLastCheck = this.timeoutSocketCount;
          this.requestCountLastCheck = this.requestCount;
        }
        return changed;
      }
      getCurrentStatus() {
        return {
          createSocketCount: this.createSocketCount,
          createSocketErrorCount: this.createSocketErrorCount,
          closeSocketCount: this.closeSocketCount,
          errorSocketCount: this.errorSocketCount,
          timeoutSocketCount: this.timeoutSocketCount,
          requestCount: this.requestCount,
          freeSockets: inspect2(this.freeSockets),
          sockets: inspect2(this.sockets),
          requests: inspect2(this.requests)
        };
      }
    };
    function getSocketTimeout(socket) {
      return socket.timeout || socket._idleTimeout;
    }
    function installListeners(agent, socket, options) {
      debug2("%s create, timeout %sms", socket[SOCKET_NAME], getSocketTimeout(socket));
      function onFree() {
        if (!socket._httpMessage && socket[SOCKET_REQUEST_COUNT] === 1) return;
        socket[SOCKET_REQUEST_FINISHED_COUNT]++;
        agent.requestCount++;
        debug2(
          "%s(requests: %s, finished: %s) free",
          socket[SOCKET_NAME],
          socket[SOCKET_REQUEST_COUNT],
          socket[SOCKET_REQUEST_FINISHED_COUNT]
        );
        const name = agent.getName(options);
        if (socket.writable && agent.requests[name] && agent.requests[name].length) {
          socket[SOCKET_REQUEST_COUNT]++;
          debug2(
            "%s(requests: %s, finished: %s) will be reuse on agent free event",
            socket[SOCKET_NAME],
            socket[SOCKET_REQUEST_COUNT],
            socket[SOCKET_REQUEST_FINISHED_COUNT]
          );
        }
      }
      socket.on("free", onFree);
      function onClose(isError) {
        debug2(
          "%s(requests: %s, finished: %s) close, isError: %s",
          socket[SOCKET_NAME],
          socket[SOCKET_REQUEST_COUNT],
          socket[SOCKET_REQUEST_FINISHED_COUNT],
          isError
        );
        agent.closeSocketCount++;
      }
      socket.on("close", onClose);
      function onTimeout() {
        const listenerCount = socket.listeners("timeout").length;
        const timeout = getSocketTimeout(socket);
        const req = socket._httpMessage;
        const reqTimeoutListenerCount = req && req.listeners("timeout").length || 0;
        debug2(
          "%s(requests: %s, finished: %s) timeout after %sms, listeners %s, defaultTimeoutListenerCount %s, hasHttpRequest %s, HttpRequest timeoutListenerCount %s",
          socket[SOCKET_NAME],
          socket[SOCKET_REQUEST_COUNT],
          socket[SOCKET_REQUEST_FINISHED_COUNT],
          timeout,
          listenerCount,
          defaultTimeoutListenerCount,
          !!req,
          reqTimeoutListenerCount
        );
        if (debug2.enabled) {
          debug2("timeout listeners: %s", socket.listeners("timeout").map((f3) => f3.name).join(", "));
        }
        agent.timeoutSocketCount++;
        const name = agent.getName(options);
        if (agent.freeSockets[name] && agent.freeSockets[name].indexOf(socket) !== -1) {
          socket.destroy();
          agent.removeSocket(socket, options);
          debug2("%s is free, destroy quietly", socket[SOCKET_NAME]);
        } else {
          if (reqTimeoutListenerCount === 0) {
            const error = new Error("Socket timeout");
            error.code = "ERR_SOCKET_TIMEOUT";
            error.timeout = timeout;
            socket.destroy(error);
            agent.removeSocket(socket, options);
            debug2("%s destroy with timeout error", socket[SOCKET_NAME]);
          }
        }
      }
      socket.on("timeout", onTimeout);
      function onError(err) {
        const listenerCount = socket.listeners("error").length;
        debug2(
          "%s(requests: %s, finished: %s) error: %s, listenerCount: %s",
          socket[SOCKET_NAME],
          socket[SOCKET_REQUEST_COUNT],
          socket[SOCKET_REQUEST_FINISHED_COUNT],
          err,
          listenerCount
        );
        agent.errorSocketCount++;
        if (listenerCount === 1) {
          debug2("%s emit uncaught error event", socket[SOCKET_NAME]);
          socket.removeListener("error", onError);
          socket.emit("error", err);
        }
      }
      socket.on("error", onError);
      function onRemove() {
        debug2(
          "%s(requests: %s, finished: %s) agentRemove",
          socket[SOCKET_NAME],
          socket[SOCKET_REQUEST_COUNT],
          socket[SOCKET_REQUEST_FINISHED_COUNT]
        );
        socket.removeListener("close", onClose);
        socket.removeListener("error", onError);
        socket.removeListener("free", onFree);
        socket.removeListener("timeout", onTimeout);
        socket.removeListener("agentRemove", onRemove);
      }
      socket.on("agentRemove", onRemove);
    }
    module2.exports = Agent2;
    function inspect2(obj) {
      const res = {};
      for (const key in obj) {
        res[key] = obj[key].length;
      }
      return res;
    }
  }
});

// node_modules/agentkeepalive/lib/https_agent.js
var require_https_agent = __commonJS({
  "node_modules/agentkeepalive/lib/https_agent.js"(exports2, module2) {
    "use strict";
    var OriginalHttpsAgent = require("https").Agent;
    var HttpAgent = require_agent();
    var {
      INIT_SOCKET,
      CREATE_HTTPS_CONNECTION
    } = require_constants();
    var HttpsAgent = class extends HttpAgent {
      constructor(options) {
        super(options);
        this.defaultPort = 443;
        this.protocol = "https:";
        this.maxCachedSessions = this.options.maxCachedSessions;
        if (this.maxCachedSessions === void 0) {
          this.maxCachedSessions = 100;
        }
        this._sessionCache = {
          map: {},
          list: []
        };
      }
      createConnection(options, oncreate) {
        const socket = this[CREATE_HTTPS_CONNECTION](options, oncreate);
        this[INIT_SOCKET](socket, options);
        return socket;
      }
    };
    HttpsAgent.prototype[CREATE_HTTPS_CONNECTION] = OriginalHttpsAgent.prototype.createConnection;
    [
      "getName",
      "_getSession",
      "_cacheSession",
      // https://github.com/nodejs/node/pull/4982
      "_evictSession"
    ].forEach(function(method) {
      if (typeof OriginalHttpsAgent.prototype[method] === "function") {
        HttpsAgent.prototype[method] = OriginalHttpsAgent.prototype[method];
      }
    });
    module2.exports = HttpsAgent;
  }
});

// node_modules/agentkeepalive/index.js
var require_agentkeepalive = __commonJS({
  "node_modules/agentkeepalive/index.js"(exports2, module2) {
    "use strict";
    var HttpAgent = require_agent();
    module2.exports = HttpAgent;
    module2.exports.HttpAgent = HttpAgent;
    module2.exports.HttpsAgent = require_https_agent();
    module2.exports.constants = require_constants();
  }
});

// node_modules/event-target-shim/dist/event-target-shim.js
var require_event_target_shim = __commonJS({
  "node_modules/event-target-shim/dist/event-target-shim.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var privateData = /* @__PURE__ */ new WeakMap();
    var wrappers = /* @__PURE__ */ new WeakMap();
    function pd(event) {
      const retv = privateData.get(event);
      console.assert(
        retv != null,
        "'this' is expected an Event object, but got",
        event
      );
      return retv;
    }
    function setCancelFlag(data) {
      if (data.passiveListener != null) {
        if (typeof console !== "undefined" && typeof console.error === "function") {
          console.error(
            "Unable to preventDefault inside passive event listener invocation.",
            data.passiveListener
          );
        }
        return;
      }
      if (!data.event.cancelable) {
        return;
      }
      data.canceled = true;
      if (typeof data.event.preventDefault === "function") {
        data.event.preventDefault();
      }
    }
    function Event2(eventTarget, event) {
      privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        immediateStopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now()
      });
      Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
      const keys = Object.keys(event);
      for (let i3 = 0; i3 < keys.length; ++i3) {
        const key = keys[i3];
        if (!(key in this)) {
          Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
      }
    }
    Event2.prototype = {
      /**
       * The type of this event.
       * @type {string}
       */
      get type() {
        return pd(this).event.type;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get target() {
        return pd(this).eventTarget;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get currentTarget() {
        return pd(this).currentTarget;
      },
      /**
       * @returns {EventTarget[]} The composed path of this event.
       */
      composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
          return [];
        }
        return [currentTarget];
      },
      /**
       * Constant of NONE.
       * @type {number}
       */
      get NONE() {
        return 0;
      },
      /**
       * Constant of CAPTURING_PHASE.
       * @type {number}
       */
      get CAPTURING_PHASE() {
        return 1;
      },
      /**
       * Constant of AT_TARGET.
       * @type {number}
       */
      get AT_TARGET() {
        return 2;
      },
      /**
       * Constant of BUBBLING_PHASE.
       * @type {number}
       */
      get BUBBLING_PHASE() {
        return 3;
      },
      /**
       * The target of this event.
       * @type {number}
       */
      get eventPhase() {
        return pd(this).eventPhase;
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopPropagation() {
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.stopPropagation === "function") {
          data.event.stopPropagation();
        }
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopImmediatePropagation() {
        const data = pd(this);
        data.stopped = true;
        data.immediateStopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
          data.event.stopImmediatePropagation();
        }
      },
      /**
       * The flag to be bubbling.
       * @type {boolean}
       */
      get bubbles() {
        return Boolean(pd(this).event.bubbles);
      },
      /**
       * The flag to be cancelable.
       * @type {boolean}
       */
      get cancelable() {
        return Boolean(pd(this).event.cancelable);
      },
      /**
       * Cancel this event.
       * @returns {void}
       */
      preventDefault() {
        setCancelFlag(pd(this));
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       */
      get defaultPrevented() {
        return pd(this).canceled;
      },
      /**
       * The flag to be composed.
       * @type {boolean}
       */
      get composed() {
        return Boolean(pd(this).event.composed);
      },
      /**
       * The unix time of this event.
       * @type {number}
       */
      get timeStamp() {
        return pd(this).timeStamp;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       * @deprecated
       */
      get srcElement() {
        return pd(this).eventTarget;
      },
      /**
       * The flag to stop event bubbling.
       * @type {boolean}
       * @deprecated
       */
      get cancelBubble() {
        return pd(this).stopped;
      },
      set cancelBubble(value) {
        if (!value) {
          return;
        }
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.cancelBubble === "boolean") {
          data.event.cancelBubble = true;
        }
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       * @deprecated
       */
      get returnValue() {
        return !pd(this).canceled;
      },
      set returnValue(value) {
        if (!value) {
          setCancelFlag(pd(this));
        }
      },
      /**
       * Initialize this event object. But do nothing under event dispatching.
       * @param {string} type The event type.
       * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
       * @param {boolean} [cancelable=false] The flag to be possible to cancel.
       * @deprecated
       */
      initEvent() {
      }
    };
    Object.defineProperty(Event2.prototype, "constructor", {
      value: Event2,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
      Object.setPrototypeOf(Event2.prototype, window.Event.prototype);
      wrappers.set(window.Event.prototype, Event2);
    }
    function defineRedirectDescriptor(key) {
      return {
        get() {
          return pd(this).event[key];
        },
        set(value) {
          pd(this).event[key] = value;
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineCallDescriptor(key) {
      return {
        value() {
          const event = pd(this).event;
          return event[key].apply(event, arguments);
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineWrapper(BaseEvent, proto) {
      const keys = Object.keys(proto);
      if (keys.length === 0) {
        return BaseEvent;
      }
      function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
      }
      CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true }
      });
      for (let i3 = 0; i3 < keys.length; ++i3) {
        const key = keys[i3];
        if (!(key in BaseEvent.prototype)) {
          const descriptor = Object.getOwnPropertyDescriptor(proto, key);
          const isFunc = typeof descriptor.value === "function";
          Object.defineProperty(
            CustomEvent.prototype,
            key,
            isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)
          );
        }
      }
      return CustomEvent;
    }
    function getWrapper(proto) {
      if (proto == null || proto === Object.prototype) {
        return Event2;
      }
      let wrapper = wrappers.get(proto);
      if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
      }
      return wrapper;
    }
    function wrapEvent(eventTarget, event) {
      const Wrapper = getWrapper(Object.getPrototypeOf(event));
      return new Wrapper(eventTarget, event);
    }
    function isStopped(event) {
      return pd(event).immediateStopped;
    }
    function setEventPhase(event, eventPhase) {
      pd(event).eventPhase = eventPhase;
    }
    function setCurrentTarget(event, currentTarget) {
      pd(event).currentTarget = currentTarget;
    }
    function setPassiveListener(event, passiveListener) {
      pd(event).passiveListener = passiveListener;
    }
    var listenersMap = /* @__PURE__ */ new WeakMap();
    var CAPTURE = 1;
    var BUBBLE = 2;
    var ATTRIBUTE = 3;
    function isObject(x3) {
      return x3 !== null && typeof x3 === "object";
    }
    function getListeners(eventTarget) {
      const listeners = listenersMap.get(eventTarget);
      if (listeners == null) {
        throw new TypeError(
          "'this' is expected an EventTarget object, but got another value."
        );
      }
      return listeners;
    }
    function defineEventAttributeDescriptor(eventName) {
      return {
        get() {
          const listeners = getListeners(this);
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              return node.listener;
            }
            node = node.next;
          }
          return null;
        },
        set(listener) {
          if (typeof listener !== "function" && !isObject(listener)) {
            listener = null;
          }
          const listeners = getListeners(this);
          let prev = null;
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              if (prev !== null) {
                prev.next = node.next;
              } else if (node.next !== null) {
                listeners.set(eventName, node.next);
              } else {
                listeners.delete(eventName);
              }
            } else {
              prev = node;
            }
            node = node.next;
          }
          if (listener !== null) {
            const newNode = {
              listener,
              listenerType: ATTRIBUTE,
              passive: false,
              once: false,
              next: null
            };
            if (prev === null) {
              listeners.set(eventName, newNode);
            } else {
              prev.next = newNode;
            }
          }
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineEventAttribute(eventTargetPrototype, eventName) {
      Object.defineProperty(
        eventTargetPrototype,
        `on${eventName}`,
        defineEventAttributeDescriptor(eventName)
      );
    }
    function defineCustomEventTarget(eventNames) {
      function CustomEventTarget() {
        EventTarget.call(this);
      }
      CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
          value: CustomEventTarget,
          configurable: true,
          writable: true
        }
      });
      for (let i3 = 0; i3 < eventNames.length; ++i3) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i3]);
      }
      return CustomEventTarget;
    }
    function EventTarget() {
      if (this instanceof EventTarget) {
        listenersMap.set(this, /* @__PURE__ */ new Map());
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0]);
      }
      if (arguments.length > 0) {
        const types = new Array(arguments.length);
        for (let i3 = 0; i3 < arguments.length; ++i3) {
          types[i3] = arguments[i3];
        }
        return defineCustomEventTarget(types);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    EventTarget.prototype = {
      /**
       * Add a given listener to this event target.
       * @param {string} eventName The event name to add.
       * @param {Function} listener The listener to add.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      addEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        if (typeof listener !== "function" && !isObject(listener)) {
          throw new TypeError("'listener' should be a function or an object.");
        }
        const listeners = getListeners(this);
        const optionsIsObj = isObject(options);
        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        const newNode = {
          listener,
          listenerType,
          passive: optionsIsObj && Boolean(options.passive),
          once: optionsIsObj && Boolean(options.once),
          next: null
        };
        let node = listeners.get(eventName);
        if (node === void 0) {
          listeners.set(eventName, newNode);
          return;
        }
        let prev = null;
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            return;
          }
          prev = node;
          node = node.next;
        }
        prev.next = newNode;
      },
      /**
       * Remove a given listener from this event target.
       * @param {string} eventName The event name to remove.
       * @param {Function} listener The listener to remove.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      removeEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        const listeners = getListeners(this);
        const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
            return;
          }
          prev = node;
          node = node.next;
        }
      },
      /**
       * Dispatch a given event.
       * @param {Event|{type:string}} event The event to dispatch.
       * @returns {boolean} `false` if canceled.
       */
      dispatchEvent(event) {
        if (event == null || typeof event.type !== "string") {
          throw new TypeError('"event.type" should be a string.');
        }
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
          return true;
        }
        const wrappedEvent = wrapEvent(this, event);
        let prev = null;
        while (node != null) {
          if (node.once) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
          } else {
            prev = node;
          }
          setPassiveListener(
            wrappedEvent,
            node.passive ? node.listener : null
          );
          if (typeof node.listener === "function") {
            try {
              node.listener.call(this, wrappedEvent);
            } catch (err) {
              if (typeof console !== "undefined" && typeof console.error === "function") {
                console.error(err);
              }
            }
          } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
            node.listener.handleEvent(wrappedEvent);
          }
          if (isStopped(wrappedEvent)) {
            break;
          }
          node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);
        return !wrappedEvent.defaultPrevented;
      }
    };
    Object.defineProperty(EventTarget.prototype, "constructor", {
      value: EventTarget,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
      Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
    }
    exports2.defineEventAttribute = defineEventAttribute;
    exports2.EventTarget = EventTarget;
    exports2.default = EventTarget;
    module2.exports = EventTarget;
    module2.exports.EventTarget = module2.exports["default"] = EventTarget;
    module2.exports.defineEventAttribute = defineEventAttribute;
  }
});

// node_modules/abort-controller/dist/abort-controller.js
var require_abort_controller = __commonJS({
  "node_modules/abort-controller/dist/abort-controller.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var eventTargetShim = require_event_target_shim();
    var AbortSignal2 = class extends eventTargetShim.EventTarget {
      /**
       * AbortSignal cannot be constructed directly.
       */
      constructor() {
        super();
        throw new TypeError("AbortSignal cannot be constructed directly");
      }
      /**
       * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
       */
      get aborted() {
        const aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean") {
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        }
        return aborted;
      }
    };
    eventTargetShim.defineEventAttribute(AbortSignal2.prototype, "abort");
    function createAbortSignal() {
      const signal = Object.create(AbortSignal2.prototype);
      eventTargetShim.EventTarget.call(signal);
      abortedFlags.set(signal, false);
      return signal;
    }
    function abortSignal(signal) {
      if (abortedFlags.get(signal) !== false) {
        return;
      }
      abortedFlags.set(signal, true);
      signal.dispatchEvent({ type: "abort" });
    }
    var abortedFlags = /* @__PURE__ */ new WeakMap();
    Object.defineProperties(AbortSignal2.prototype, {
      aborted: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortSignal2.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortSignal"
      });
    }
    var AbortController2 = class {
      /**
       * Initialize this controller.
       */
      constructor() {
        signals.set(this, createAbortSignal());
      }
      /**
       * Returns the `AbortSignal` object associated with this object.
       */
      get signal() {
        return getSignal(this);
      }
      /**
       * Abort and signal to any observers that the associated activity is to be aborted.
       */
      abort() {
        abortSignal(getSignal(this));
      }
    };
    var signals = /* @__PURE__ */ new WeakMap();
    function getSignal(controller) {
      const signal = signals.get(controller);
      if (signal == null) {
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
      }
      return signal;
    }
    Object.defineProperties(AbortController2.prototype, {
      signal: { enumerable: true },
      abort: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortController2.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortController"
      });
    }
    exports2.AbortController = AbortController2;
    exports2.AbortSignal = AbortSignal2;
    exports2.default = AbortController2;
    module2.exports = AbortController2;
    module2.exports.AbortController = module2.exports["default"] = AbortController2;
    module2.exports.AbortSignal = AbortSignal2;
  }
});

// node_modules/node-domexception/index.js
var require_node_domexception = __commonJS({
  "node_modules/node-domexception/index.js"(exports2, module2) {
    if (!globalThis.DOMException) {
      try {
        const { MessageChannel } = require("worker_threads"), port = new MessageChannel().port1, ab = new ArrayBuffer();
        port.postMessage(ab, [ab, ab]);
      } catch (err) {
        err.constructor.name === "DOMException" && (globalThis.DOMException = err.constructor);
      }
    }
    module2.exports = globalThis.DOMException;
  }
});

// node_modules/formdata-node/lib/esm/isPlainObject.js
function isPlainObject2(value) {
  if (getType2(value) !== "object") {
    return false;
  }
  const pp = Object.getPrototypeOf(value);
  if (pp === null || pp === void 0) {
    return true;
  }
  const Ctor = pp.constructor && pp.constructor.toString();
  return Ctor === Object.toString();
}
var getType2, isPlainObject_default2;
var init_isPlainObject = __esm({
  "node_modules/formdata-node/lib/esm/isPlainObject.js"() {
    getType2 = (value) => Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
    isPlainObject_default2 = isPlainObject2;
  }
});

// node_modules/formdata-node/lib/esm/fileFromPath.js
var fileFromPath_exports = {};
__export(fileFromPath_exports, {
  fileFromPath: () => fileFromPath2,
  fileFromPathSync: () => fileFromPathSync,
  isFile: () => isFile
});
function createFileFromPath(path2, { mtimeMs, size }, filenameOrOptions, options = {}) {
  let filename;
  if (isPlainObject_default2(filenameOrOptions)) {
    [options, filename] = [filenameOrOptions, void 0];
  } else {
    filename = filenameOrOptions;
  }
  const file = new FileFromPath({ path: path2, size, lastModified: mtimeMs });
  if (!filename) {
    filename = file.name;
  }
  return new File3([file], filename, {
    ...options,
    lastModified: file.lastModified
  });
}
function fileFromPathSync(path2, filenameOrOptions, options = {}) {
  const stats = (0, import_fs.statSync)(path2);
  return createFileFromPath(path2, stats, filenameOrOptions, options);
}
async function fileFromPath2(path2, filenameOrOptions, options) {
  const stats = await import_fs.promises.stat(path2);
  return createFileFromPath(path2, stats, filenameOrOptions, options);
}
var import_fs, import_path, import_node_domexception, __classPrivateFieldSet4, __classPrivateFieldGet5, _FileFromPath_path, _FileFromPath_start, MESSAGE, FileFromPath;
var init_fileFromPath = __esm({
  "node_modules/formdata-node/lib/esm/fileFromPath.js"() {
    import_fs = require("fs");
    import_path = require("path");
    import_node_domexception = __toESM(require_node_domexception(), 1);
    init_File();
    init_isPlainObject();
    init_isFile();
    __classPrivateFieldSet4 = function(receiver, state, value, kind2, f3) {
      if (kind2 === "m") throw new TypeError("Private method is not writable");
      if (kind2 === "a" && !f3) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind2 === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldGet5 = function(receiver, state, kind2, f3) {
      if (kind2 === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind2 === "m" ? f3 : kind2 === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
    };
    MESSAGE = "The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.";
    FileFromPath = class _FileFromPath {
      constructor(input) {
        _FileFromPath_path.set(this, void 0);
        _FileFromPath_start.set(this, void 0);
        __classPrivateFieldSet4(this, _FileFromPath_path, input.path, "f");
        __classPrivateFieldSet4(this, _FileFromPath_start, input.start || 0, "f");
        this.name = (0, import_path.basename)(__classPrivateFieldGet5(this, _FileFromPath_path, "f"));
        this.size = input.size;
        this.lastModified = input.lastModified;
      }
      slice(start, end) {
        return new _FileFromPath({
          path: __classPrivateFieldGet5(this, _FileFromPath_path, "f"),
          lastModified: this.lastModified,
          size: end - start,
          start
        });
      }
      async *stream() {
        const { mtimeMs } = await import_fs.promises.stat(__classPrivateFieldGet5(this, _FileFromPath_path, "f"));
        if (mtimeMs > this.lastModified) {
          throw new import_node_domexception.default(MESSAGE, "NotReadableError");
        }
        if (this.size) {
          yield* (0, import_fs.createReadStream)(__classPrivateFieldGet5(this, _FileFromPath_path, "f"), {
            start: __classPrivateFieldGet5(this, _FileFromPath_start, "f"),
            end: __classPrivateFieldGet5(this, _FileFromPath_start, "f") + this.size - 1
          });
        }
      }
      get [(_FileFromPath_path = /* @__PURE__ */ new WeakMap(), _FileFromPath_start = /* @__PURE__ */ new WeakMap(), Symbol.toStringTag)]() {
        return "File";
      }
    };
  }
});

// node_modules/papaparse/papaparse.js
var require_papaparse = __commonJS({
  "node_modules/papaparse/papaparse.js"(exports2, module2) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module2 === "object" && typeof exports2 !== "undefined") {
        module2.exports = factory();
      } else {
        root.Papa = factory();
      }
    })(exports2, function moduleFactory() {
      "use strict";
      var global2 = function() {
        if (typeof self !== "undefined") {
          return self;
        }
        if (typeof window !== "undefined") {
          return window;
        }
        if (typeof global2 !== "undefined") {
          return global2;
        }
        return {};
      }();
      function getWorkerBlob() {
        var URL2 = global2.URL || global2.webkitURL || null;
        var code = moduleFactory.toString();
        return Papa2.BLOB_URL || (Papa2.BLOB_URL = URL2.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ", "(", code, ")();"], { type: "text/javascript" })));
      }
      var IS_WORKER = !global2.document && !!global2.postMessage, IS_PAPA_WORKER = global2.IS_PAPA_WORKER || false;
      var workers = {}, workerIdCounter = 0;
      var Papa2 = {};
      Papa2.parse = CsvToJson;
      Papa2.unparse = JsonToCsv;
      Papa2.RECORD_SEP = String.fromCharCode(30);
      Papa2.UNIT_SEP = String.fromCharCode(31);
      Papa2.BYTE_ORDER_MARK = "\uFEFF";
      Papa2.BAD_DELIMITERS = ["\r", "\n", '"', Papa2.BYTE_ORDER_MARK];
      Papa2.WORKERS_SUPPORTED = !IS_WORKER && !!global2.Worker;
      Papa2.NODE_STREAM_INPUT = 1;
      Papa2.LocalChunkSize = 1024 * 1024 * 10;
      Papa2.RemoteChunkSize = 1024 * 1024 * 5;
      Papa2.DefaultDelimiter = ",";
      Papa2.Parser = Parser2;
      Papa2.ParserHandle = ParserHandle;
      Papa2.NetworkStreamer = NetworkStreamer;
      Papa2.FileStreamer = FileStreamer;
      Papa2.StringStreamer = StringStreamer;
      Papa2.ReadableStreamStreamer = ReadableStreamStreamer;
      if (typeof PAPA_BROWSER_CONTEXT === "undefined") {
        Papa2.DuplexStreamStreamer = DuplexStreamStreamer;
      }
      if (global2.jQuery) {
        var $3 = global2.jQuery;
        $3.fn.parse = function(options) {
          var config = options.config || {};
          var queue = [];
          this.each(function(idx) {
            var supported = $3(this).prop("tagName").toUpperCase() === "INPUT" && $3(this).attr("type").toLowerCase() === "file" && global2.FileReader;
            if (!supported || !this.files || this.files.length === 0)
              return true;
            for (var i3 = 0; i3 < this.files.length; i3++) {
              queue.push({
                file: this.files[i3],
                inputElem: this,
                instanceConfig: $3.extend({}, config)
              });
            }
          });
          parseNextFile();
          return this;
          function parseNextFile() {
            if (queue.length === 0) {
              if (isFunction3(options.complete))
                options.complete();
              return;
            }
            var f3 = queue[0];
            if (isFunction3(options.before)) {
              var returned = options.before(f3.file, f3.inputElem);
              if (typeof returned === "object") {
                if (returned.action === "abort") {
                  error("AbortError", f3.file, f3.inputElem, returned.reason);
                  return;
                } else if (returned.action === "skip") {
                  fileComplete();
                  return;
                } else if (typeof returned.config === "object")
                  f3.instanceConfig = $3.extend(f3.instanceConfig, returned.config);
              } else if (returned === "skip") {
                fileComplete();
                return;
              }
            }
            var userCompleteFunc = f3.instanceConfig.complete;
            f3.instanceConfig.complete = function(results) {
              if (isFunction3(userCompleteFunc))
                userCompleteFunc(results, f3.file, f3.inputElem);
              fileComplete();
            };
            Papa2.parse(f3.file, f3.instanceConfig);
          }
          function error(name, file, elem, reason) {
            if (isFunction3(options.error))
              options.error({ name }, file, elem, reason);
          }
          function fileComplete() {
            queue.splice(0, 1);
            parseNextFile();
          }
        };
      }
      if (IS_PAPA_WORKER) {
        global2.onmessage = workerThreadReceivedMessage;
      }
      function CsvToJson(_input, _config) {
        _config = _config || {};
        var dynamicTyping = _config.dynamicTyping || false;
        if (isFunction3(dynamicTyping)) {
          _config.dynamicTypingFunction = dynamicTyping;
          dynamicTyping = {};
        }
        _config.dynamicTyping = dynamicTyping;
        _config.transform = isFunction3(_config.transform) ? _config.transform : false;
        if (_config.worker && Papa2.WORKERS_SUPPORTED) {
          var w3 = newWorker();
          w3.userStep = _config.step;
          w3.userChunk = _config.chunk;
          w3.userComplete = _config.complete;
          w3.userError = _config.error;
          _config.step = isFunction3(_config.step);
          _config.chunk = isFunction3(_config.chunk);
          _config.complete = isFunction3(_config.complete);
          _config.error = isFunction3(_config.error);
          delete _config.worker;
          w3.postMessage({
            input: _input,
            config: _config,
            workerId: w3.id
          });
          return;
        }
        var streamer = null;
        if (_input === Papa2.NODE_STREAM_INPUT && typeof PAPA_BROWSER_CONTEXT === "undefined") {
          streamer = new DuplexStreamStreamer(_config);
          return streamer.getStream();
        } else if (typeof _input === "string") {
          _input = stripBom(_input);
          if (_config.download)
            streamer = new NetworkStreamer(_config);
          else
            streamer = new StringStreamer(_config);
        } else if (_input.readable === true && isFunction3(_input.read) && isFunction3(_input.on)) {
          streamer = new ReadableStreamStreamer(_config);
        } else if (global2.File && _input instanceof File || _input instanceof Object)
          streamer = new FileStreamer(_config);
        return streamer.stream(_input);
        function stripBom(string) {
          if (string.charCodeAt(0) === 65279) {
            return string.slice(1);
          }
          return string;
        }
      }
      function JsonToCsv(_input, _config) {
        var _quotes = false;
        var _writeHeader = true;
        var _delimiter = ",";
        var _newline = "\r\n";
        var _quoteChar = '"';
        var _escapedQuote = _quoteChar + _quoteChar;
        var _skipEmptyLines = false;
        var _columns = null;
        var _escapeFormulae = false;
        unpackConfig();
        var quoteCharRegex = new RegExp(escapeRegExp(_quoteChar), "g");
        if (typeof _input === "string")
          _input = JSON.parse(_input);
        if (Array.isArray(_input)) {
          if (!_input.length || Array.isArray(_input[0]))
            return serialize(null, _input, _skipEmptyLines);
          else if (typeof _input[0] === "object")
            return serialize(_columns || Object.keys(_input[0]), _input, _skipEmptyLines);
        } else if (typeof _input === "object") {
          if (typeof _input.data === "string")
            _input.data = JSON.parse(_input.data);
          if (Array.isArray(_input.data)) {
            if (!_input.fields)
              _input.fields = _input.meta && _input.meta.fields || _columns;
            if (!_input.fields)
              _input.fields = Array.isArray(_input.data[0]) ? _input.fields : typeof _input.data[0] === "object" ? Object.keys(_input.data[0]) : [];
            if (!Array.isArray(_input.data[0]) && typeof _input.data[0] !== "object")
              _input.data = [_input.data];
          }
          return serialize(_input.fields || [], _input.data || [], _skipEmptyLines);
        }
        throw new Error("Unable to serialize unrecognized input");
        function unpackConfig() {
          if (typeof _config !== "object")
            return;
          if (typeof _config.delimiter === "string" && !Papa2.BAD_DELIMITERS.filter(function(value) {
            return _config.delimiter.indexOf(value) !== -1;
          }).length) {
            _delimiter = _config.delimiter;
          }
          if (typeof _config.quotes === "boolean" || typeof _config.quotes === "function" || Array.isArray(_config.quotes))
            _quotes = _config.quotes;
          if (typeof _config.skipEmptyLines === "boolean" || typeof _config.skipEmptyLines === "string")
            _skipEmptyLines = _config.skipEmptyLines;
          if (typeof _config.newline === "string")
            _newline = _config.newline;
          if (typeof _config.quoteChar === "string")
            _quoteChar = _config.quoteChar;
          if (typeof _config.header === "boolean")
            _writeHeader = _config.header;
          if (Array.isArray(_config.columns)) {
            if (_config.columns.length === 0) throw new Error("Option columns is empty");
            _columns = _config.columns;
          }
          if (_config.escapeChar !== void 0) {
            _escapedQuote = _config.escapeChar + _quoteChar;
          }
          if (_config.escapeFormulae instanceof RegExp) {
            _escapeFormulae = _config.escapeFormulae;
          } else if (typeof _config.escapeFormulae === "boolean" && _config.escapeFormulae) {
            _escapeFormulae = /^[=+\-@\t\r].*$/;
          }
        }
        function serialize(fields, data, skipEmptyLines) {
          var csv = "";
          if (typeof fields === "string")
            fields = JSON.parse(fields);
          if (typeof data === "string")
            data = JSON.parse(data);
          var hasHeader = Array.isArray(fields) && fields.length > 0;
          var dataKeyedByField = !Array.isArray(data[0]);
          if (hasHeader && _writeHeader) {
            for (var i3 = 0; i3 < fields.length; i3++) {
              if (i3 > 0)
                csv += _delimiter;
              csv += safe(fields[i3], i3);
            }
            if (data.length > 0)
              csv += _newline;
          }
          for (var row = 0; row < data.length; row++) {
            var maxCol = hasHeader ? fields.length : data[row].length;
            var emptyLine = false;
            var nullLine = hasHeader ? Object.keys(data[row]).length === 0 : data[row].length === 0;
            if (skipEmptyLines && !hasHeader) {
              emptyLine = skipEmptyLines === "greedy" ? data[row].join("").trim() === "" : data[row].length === 1 && data[row][0].length === 0;
            }
            if (skipEmptyLines === "greedy" && hasHeader) {
              var line = [];
              for (var c3 = 0; c3 < maxCol; c3++) {
                var cx = dataKeyedByField ? fields[c3] : c3;
                line.push(data[row][cx]);
              }
              emptyLine = line.join("").trim() === "";
            }
            if (!emptyLine) {
              for (var col = 0; col < maxCol; col++) {
                if (col > 0 && !nullLine)
                  csv += _delimiter;
                var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;
                csv += safe(data[row][colIdx], col);
              }
              if (row < data.length - 1 && (!skipEmptyLines || maxCol > 0 && !nullLine)) {
                csv += _newline;
              }
            }
          }
          return csv;
        }
        function safe(str2, col) {
          if (typeof str2 === "undefined" || str2 === null)
            return "";
          if (str2.constructor === Date)
            return JSON.stringify(str2).slice(1, 25);
          var needsQuotes = false;
          if (_escapeFormulae && typeof str2 === "string" && _escapeFormulae.test(str2)) {
            str2 = "'" + str2;
            needsQuotes = true;
          }
          var escapedQuoteStr = str2.toString().replace(quoteCharRegex, _escapedQuote);
          needsQuotes = needsQuotes || _quotes === true || typeof _quotes === "function" && _quotes(str2, col) || Array.isArray(_quotes) && _quotes[col] || hasAny(escapedQuoteStr, Papa2.BAD_DELIMITERS) || escapedQuoteStr.indexOf(_delimiter) > -1 || escapedQuoteStr.charAt(0) === " " || escapedQuoteStr.charAt(escapedQuoteStr.length - 1) === " ";
          return needsQuotes ? _quoteChar + escapedQuoteStr + _quoteChar : escapedQuoteStr;
        }
        function hasAny(str2, substrings) {
          for (var i3 = 0; i3 < substrings.length; i3++)
            if (str2.indexOf(substrings[i3]) > -1)
              return true;
          return false;
        }
      }
      function ChunkStreamer(config) {
        this._handle = null;
        this._finished = false;
        this._completed = false;
        this._halted = false;
        this._input = null;
        this._baseIndex = 0;
        this._partialLine = "";
        this._rowCount = 0;
        this._start = 0;
        this._nextChunk = null;
        this.isFirstChunk = true;
        this._completeResults = {
          data: [],
          errors: [],
          meta: {}
        };
        replaceConfig.call(this, config);
        this.parseChunk = function(chunk, isFakeChunk) {
          const skipFirstNLines = parseInt(this._config.skipFirstNLines) || 0;
          if (this.isFirstChunk && skipFirstNLines > 0) {
            let _newline = this._config.newline;
            if (!_newline) {
              const quoteChar = this._config.quoteChar || '"';
              _newline = this._handle.guessLineEndings(chunk, quoteChar);
            }
            const splitChunk = chunk.split(_newline);
            chunk = [...splitChunk.slice(skipFirstNLines)].join(_newline);
          }
          if (this.isFirstChunk && isFunction3(this._config.beforeFirstChunk)) {
            var modifiedChunk = this._config.beforeFirstChunk(chunk);
            if (modifiedChunk !== void 0)
              chunk = modifiedChunk;
          }
          this.isFirstChunk = false;
          this._halted = false;
          var aggregate = this._partialLine + chunk;
          this._partialLine = "";
          var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);
          if (this._handle.paused() || this._handle.aborted()) {
            this._halted = true;
            return;
          }
          var lastIndex = results.meta.cursor;
          if (!this._finished) {
            this._partialLine = aggregate.substring(lastIndex - this._baseIndex);
            this._baseIndex = lastIndex;
          }
          if (results && results.data)
            this._rowCount += results.data.length;
          var finishedIncludingPreview = this._finished || this._config.preview && this._rowCount >= this._config.preview;
          if (IS_PAPA_WORKER) {
            global2.postMessage({
              results,
              workerId: Papa2.WORKER_ID,
              finished: finishedIncludingPreview
            });
          } else if (isFunction3(this._config.chunk) && !isFakeChunk) {
            this._config.chunk(results, this._handle);
            if (this._handle.paused() || this._handle.aborted()) {
              this._halted = true;
              return;
            }
            results = void 0;
            this._completeResults = void 0;
          }
          if (!this._config.step && !this._config.chunk) {
            this._completeResults.data = this._completeResults.data.concat(results.data);
            this._completeResults.errors = this._completeResults.errors.concat(results.errors);
            this._completeResults.meta = results.meta;
          }
          if (!this._completed && finishedIncludingPreview && isFunction3(this._config.complete) && (!results || !results.meta.aborted)) {
            this._config.complete(this._completeResults, this._input);
            this._completed = true;
          }
          if (!finishedIncludingPreview && (!results || !results.meta.paused))
            this._nextChunk();
          return results;
        };
        this._sendError = function(error) {
          if (isFunction3(this._config.error))
            this._config.error(error);
          else if (IS_PAPA_WORKER && this._config.error) {
            global2.postMessage({
              workerId: Papa2.WORKER_ID,
              error,
              finished: false
            });
          }
        };
        function replaceConfig(config2) {
          var configCopy = copy(config2);
          configCopy.chunkSize = parseInt(configCopy.chunkSize);
          if (!config2.step && !config2.chunk)
            configCopy.chunkSize = null;
          this._handle = new ParserHandle(configCopy);
          this._handle.streamer = this;
          this._config = configCopy;
        }
      }
      function NetworkStreamer(config) {
        config = config || {};
        if (!config.chunkSize)
          config.chunkSize = Papa2.RemoteChunkSize;
        ChunkStreamer.call(this, config);
        var xhr;
        if (IS_WORKER) {
          this._nextChunk = function() {
            this._readChunk();
            this._chunkLoaded();
          };
        } else {
          this._nextChunk = function() {
            this._readChunk();
          };
        }
        this.stream = function(url) {
          this._input = url;
          this._nextChunk();
        };
        this._readChunk = function() {
          if (this._finished) {
            this._chunkLoaded();
            return;
          }
          xhr = new XMLHttpRequest();
          if (this._config.withCredentials) {
            xhr.withCredentials = this._config.withCredentials;
          }
          if (!IS_WORKER) {
            xhr.onload = bindFunction(this._chunkLoaded, this);
            xhr.onerror = bindFunction(this._chunkError, this);
          }
          xhr.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !IS_WORKER);
          if (this._config.downloadRequestHeaders) {
            var headers = this._config.downloadRequestHeaders;
            for (var headerName in headers) {
              xhr.setRequestHeader(headerName, headers[headerName]);
            }
          }
          if (this._config.chunkSize) {
            var end = this._start + this._config.chunkSize - 1;
            xhr.setRequestHeader("Range", "bytes=" + this._start + "-" + end);
          }
          try {
            xhr.send(this._config.downloadRequestBody);
          } catch (err) {
            this._chunkError(err.message);
          }
          if (IS_WORKER && xhr.status === 0)
            this._chunkError();
        };
        this._chunkLoaded = function() {
          if (xhr.readyState !== 4)
            return;
          if (xhr.status < 200 || xhr.status >= 400) {
            this._chunkError();
            return;
          }
          this._start += this._config.chunkSize ? this._config.chunkSize : xhr.responseText.length;
          this._finished = !this._config.chunkSize || this._start >= getFileSize(xhr);
          this.parseChunk(xhr.responseText);
        };
        this._chunkError = function(errorMessage) {
          var errorText = xhr.statusText || errorMessage;
          this._sendError(new Error(errorText));
        };
        function getFileSize(xhr2) {
          var contentRange = xhr2.getResponseHeader("Content-Range");
          if (contentRange === null) {
            return -1;
          }
          return parseInt(contentRange.substring(contentRange.lastIndexOf("/") + 1));
        }
      }
      NetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);
      NetworkStreamer.prototype.constructor = NetworkStreamer;
      function FileStreamer(config) {
        config = config || {};
        if (!config.chunkSize)
          config.chunkSize = Papa2.LocalChunkSize;
        ChunkStreamer.call(this, config);
        var reader, slice;
        var usingAsyncReader = typeof FileReader !== "undefined";
        this.stream = function(file) {
          this._input = file;
          slice = file.slice || file.webkitSlice || file.mozSlice;
          if (usingAsyncReader) {
            reader = new FileReader();
            reader.onload = bindFunction(this._chunkLoaded, this);
            reader.onerror = bindFunction(this._chunkError, this);
          } else
            reader = new FileReaderSync();
          this._nextChunk();
        };
        this._nextChunk = function() {
          if (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))
            this._readChunk();
        };
        this._readChunk = function() {
          var input = this._input;
          if (this._config.chunkSize) {
            var end = Math.min(this._start + this._config.chunkSize, this._input.size);
            input = slice.call(input, this._start, end);
          }
          var txt = reader.readAsText(input, this._config.encoding);
          if (!usingAsyncReader)
            this._chunkLoaded({ target: { result: txt } });
        };
        this._chunkLoaded = function(event) {
          this._start += this._config.chunkSize;
          this._finished = !this._config.chunkSize || this._start >= this._input.size;
          this.parseChunk(event.target.result);
        };
        this._chunkError = function() {
          this._sendError(reader.error);
        };
      }
      FileStreamer.prototype = Object.create(ChunkStreamer.prototype);
      FileStreamer.prototype.constructor = FileStreamer;
      function StringStreamer(config) {
        config = config || {};
        ChunkStreamer.call(this, config);
        var remaining;
        this.stream = function(s3) {
          remaining = s3;
          return this._nextChunk();
        };
        this._nextChunk = function() {
          if (this._finished) return;
          var size = this._config.chunkSize;
          var chunk;
          if (size) {
            chunk = remaining.substring(0, size);
            remaining = remaining.substring(size);
          } else {
            chunk = remaining;
            remaining = "";
          }
          this._finished = !remaining;
          return this.parseChunk(chunk);
        };
      }
      StringStreamer.prototype = Object.create(StringStreamer.prototype);
      StringStreamer.prototype.constructor = StringStreamer;
      function ReadableStreamStreamer(config) {
        config = config || {};
        ChunkStreamer.call(this, config);
        var queue = [];
        var parseOnData = true;
        var streamHasEnded = false;
        this.pause = function() {
          ChunkStreamer.prototype.pause.apply(this, arguments);
          this._input.pause();
        };
        this.resume = function() {
          ChunkStreamer.prototype.resume.apply(this, arguments);
          this._input.resume();
        };
        this.stream = function(stream) {
          this._input = stream;
          this._input.on("data", this._streamData);
          this._input.on("end", this._streamEnd);
          this._input.on("error", this._streamError);
        };
        this._checkIsFinished = function() {
          if (streamHasEnded && queue.length === 1) {
            this._finished = true;
          }
        };
        this._nextChunk = function() {
          this._checkIsFinished();
          if (queue.length) {
            this.parseChunk(queue.shift());
          } else {
            parseOnData = true;
          }
        };
        this._streamData = bindFunction(function(chunk) {
          try {
            queue.push(typeof chunk === "string" ? chunk : chunk.toString(this._config.encoding));
            if (parseOnData) {
              parseOnData = false;
              this._checkIsFinished();
              this.parseChunk(queue.shift());
            }
          } catch (error) {
            this._streamError(error);
          }
        }, this);
        this._streamError = bindFunction(function(error) {
          this._streamCleanUp();
          this._sendError(error);
        }, this);
        this._streamEnd = bindFunction(function() {
          this._streamCleanUp();
          streamHasEnded = true;
          this._streamData("");
        }, this);
        this._streamCleanUp = bindFunction(function() {
          this._input.removeListener("data", this._streamData);
          this._input.removeListener("end", this._streamEnd);
          this._input.removeListener("error", this._streamError);
        }, this);
      }
      ReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);
      ReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;
      function DuplexStreamStreamer(_config) {
        var Duplex = require("stream").Duplex;
        var config = copy(_config);
        var parseOnWrite = true;
        var writeStreamHasFinished = false;
        var parseCallbackQueue = [];
        var stream = null;
        this._onCsvData = function(results) {
          var data = results.data;
          if (!stream.push(data) && !this._handle.paused()) {
            this._handle.pause();
          }
        };
        this._onCsvComplete = function() {
          stream.push(null);
        };
        config.step = bindFunction(this._onCsvData, this);
        config.complete = bindFunction(this._onCsvComplete, this);
        ChunkStreamer.call(this, config);
        this._nextChunk = function() {
          if (writeStreamHasFinished && parseCallbackQueue.length === 1) {
            this._finished = true;
          }
          if (parseCallbackQueue.length) {
            parseCallbackQueue.shift()();
          } else {
            parseOnWrite = true;
          }
        };
        this._addToParseQueue = function(chunk, callback) {
          parseCallbackQueue.push(bindFunction(function() {
            this.parseChunk(typeof chunk === "string" ? chunk : chunk.toString(config.encoding));
            if (isFunction3(callback)) {
              return callback();
            }
          }, this));
          if (parseOnWrite) {
            parseOnWrite = false;
            this._nextChunk();
          }
        };
        this._onRead = function() {
          if (this._handle.paused()) {
            this._handle.resume();
          }
        };
        this._onWrite = function(chunk, encoding, callback) {
          this._addToParseQueue(chunk, callback);
        };
        this._onWriteComplete = function() {
          writeStreamHasFinished = true;
          this._addToParseQueue("");
        };
        this.getStream = function() {
          return stream;
        };
        stream = new Duplex({
          readableObjectMode: true,
          decodeStrings: false,
          read: bindFunction(this._onRead, this),
          write: bindFunction(this._onWrite, this)
        });
        stream.once("finish", bindFunction(this._onWriteComplete, this));
      }
      if (typeof PAPA_BROWSER_CONTEXT === "undefined") {
        DuplexStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);
        DuplexStreamStreamer.prototype.constructor = DuplexStreamStreamer;
      }
      function ParserHandle(_config) {
        var MAX_FLOAT = Math.pow(2, 53);
        var MIN_FLOAT = -MAX_FLOAT;
        var FLOAT = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/;
        var ISO_DATE = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/;
        var self2 = this;
        var _stepCounter = 0;
        var _rowCounter = 0;
        var _input;
        var _parser;
        var _paused = false;
        var _aborted = false;
        var _delimiterError;
        var _fields = [];
        var _results = {
          // The last results returned from the parser
          data: [],
          errors: [],
          meta: {}
        };
        if (isFunction3(_config.step)) {
          var userStep = _config.step;
          _config.step = function(results) {
            _results = results;
            if (needsHeaderRow())
              processResults();
            else {
              processResults();
              if (_results.data.length === 0)
                return;
              _stepCounter += results.data.length;
              if (_config.preview && _stepCounter > _config.preview)
                _parser.abort();
              else {
                _results.data = _results.data[0];
                userStep(_results, self2);
              }
            }
          };
        }
        this.parse = function(input, baseIndex, ignoreLastRow) {
          var quoteChar = _config.quoteChar || '"';
          if (!_config.newline)
            _config.newline = this.guessLineEndings(input, quoteChar);
          _delimiterError = false;
          if (!_config.delimiter) {
            var delimGuess = guessDelimiter(input, _config.newline, _config.skipEmptyLines, _config.comments, _config.delimitersToGuess);
            if (delimGuess.successful)
              _config.delimiter = delimGuess.bestDelimiter;
            else {
              _delimiterError = true;
              _config.delimiter = Papa2.DefaultDelimiter;
            }
            _results.meta.delimiter = _config.delimiter;
          } else if (isFunction3(_config.delimiter)) {
            _config.delimiter = _config.delimiter(input);
            _results.meta.delimiter = _config.delimiter;
          }
          var parserConfig = copy(_config);
          if (_config.preview && _config.header)
            parserConfig.preview++;
          _input = input;
          _parser = new Parser2(parserConfig);
          _results = _parser.parse(_input, baseIndex, ignoreLastRow);
          processResults();
          return _paused ? { meta: { paused: true } } : _results || { meta: { paused: false } };
        };
        this.paused = function() {
          return _paused;
        };
        this.pause = function() {
          _paused = true;
          _parser.abort();
          _input = isFunction3(_config.chunk) ? "" : _input.substring(_parser.getCharIndex());
        };
        this.resume = function() {
          if (self2.streamer._halted) {
            _paused = false;
            self2.streamer.parseChunk(_input, true);
          } else {
            setTimeout(self2.resume, 3);
          }
        };
        this.aborted = function() {
          return _aborted;
        };
        this.abort = function() {
          _aborted = true;
          _parser.abort();
          _results.meta.aborted = true;
          if (isFunction3(_config.complete))
            _config.complete(_results);
          _input = "";
        };
        this.guessLineEndings = function(input, quoteChar) {
          input = input.substring(0, 1024 * 1024);
          var re3 = new RegExp(escapeRegExp(quoteChar) + "([^]*?)" + escapeRegExp(quoteChar), "gm");
          input = input.replace(re3, "");
          var r3 = input.split("\r");
          var n3 = input.split("\n");
          var nAppearsFirst = n3.length > 1 && n3[0].length < r3[0].length;
          if (r3.length === 1 || nAppearsFirst)
            return "\n";
          var numWithN = 0;
          for (var i3 = 0; i3 < r3.length; i3++) {
            if (r3[i3][0] === "\n")
              numWithN++;
          }
          return numWithN >= r3.length / 2 ? "\r\n" : "\r";
        };
        function testEmptyLine(s3) {
          return _config.skipEmptyLines === "greedy" ? s3.join("").trim() === "" : s3.length === 1 && s3[0].length === 0;
        }
        function testFloat(s3) {
          if (FLOAT.test(s3)) {
            var floatValue = parseFloat(s3);
            if (floatValue > MIN_FLOAT && floatValue < MAX_FLOAT) {
              return true;
            }
          }
          return false;
        }
        function processResults() {
          if (_results && _delimiterError) {
            addError("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + Papa2.DefaultDelimiter + "'");
            _delimiterError = false;
          }
          if (_config.skipEmptyLines) {
            _results.data = _results.data.filter(function(d3) {
              return !testEmptyLine(d3);
            });
          }
          if (needsHeaderRow())
            fillHeaderFields();
          return applyHeaderAndDynamicTypingAndTransformation();
        }
        function needsHeaderRow() {
          return _config.header && _fields.length === 0;
        }
        function fillHeaderFields() {
          if (!_results)
            return;
          function addHeader(header, i4) {
            if (isFunction3(_config.transformHeader))
              header = _config.transformHeader(header, i4);
            _fields.push(header);
          }
          if (Array.isArray(_results.data[0])) {
            for (var i3 = 0; needsHeaderRow() && i3 < _results.data.length; i3++)
              _results.data[i3].forEach(addHeader);
            _results.data.splice(0, 1);
          } else
            _results.data.forEach(addHeader);
        }
        function shouldApplyDynamicTyping(field) {
          if (_config.dynamicTypingFunction && _config.dynamicTyping[field] === void 0) {
            _config.dynamicTyping[field] = _config.dynamicTypingFunction(field);
          }
          return (_config.dynamicTyping[field] || _config.dynamicTyping) === true;
        }
        function parseDynamic(field, value) {
          if (shouldApplyDynamicTyping(field)) {
            if (value === "true" || value === "TRUE")
              return true;
            else if (value === "false" || value === "FALSE")
              return false;
            else if (testFloat(value))
              return parseFloat(value);
            else if (ISO_DATE.test(value))
              return new Date(value);
            else
              return value === "" ? null : value;
          }
          return value;
        }
        function applyHeaderAndDynamicTypingAndTransformation() {
          if (!_results || !_config.header && !_config.dynamicTyping && !_config.transform)
            return _results;
          function processRow(rowSource, i3) {
            var row = _config.header ? {} : [];
            var j3;
            for (j3 = 0; j3 < rowSource.length; j3++) {
              var field = j3;
              var value = rowSource[j3];
              if (_config.header)
                field = j3 >= _fields.length ? "__parsed_extra" : _fields[j3];
              if (_config.transform)
                value = _config.transform(value, field);
              value = parseDynamic(field, value);
              if (field === "__parsed_extra") {
                row[field] = row[field] || [];
                row[field].push(value);
              } else
                row[field] = value;
            }
            if (_config.header) {
              if (j3 > _fields.length)
                addError("FieldMismatch", "TooManyFields", "Too many fields: expected " + _fields.length + " fields but parsed " + j3, _rowCounter + i3);
              else if (j3 < _fields.length)
                addError("FieldMismatch", "TooFewFields", "Too few fields: expected " + _fields.length + " fields but parsed " + j3, _rowCounter + i3);
            }
            return row;
          }
          var incrementBy = 1;
          if (!_results.data.length || Array.isArray(_results.data[0])) {
            _results.data = _results.data.map(processRow);
            incrementBy = _results.data.length;
          } else
            _results.data = processRow(_results.data, 0);
          if (_config.header && _results.meta)
            _results.meta.fields = _fields;
          _rowCounter += incrementBy;
          return _results;
        }
        function guessDelimiter(input, newline, skipEmptyLines, comments, delimitersToGuess) {
          var bestDelim, bestDelta, fieldCountPrevRow, maxFieldCount;
          delimitersToGuess = delimitersToGuess || [",", "	", "|", ";", Papa2.RECORD_SEP, Papa2.UNIT_SEP];
          for (var i3 = 0; i3 < delimitersToGuess.length; i3++) {
            var delim = delimitersToGuess[i3];
            var delta = 0, avgFieldCount = 0, emptyLinesCount = 0;
            fieldCountPrevRow = void 0;
            var preview = new Parser2({
              comments,
              delimiter: delim,
              newline,
              preview: 10
            }).parse(input);
            for (var j3 = 0; j3 < preview.data.length; j3++) {
              if (skipEmptyLines && testEmptyLine(preview.data[j3])) {
                emptyLinesCount++;
                continue;
              }
              var fieldCount = preview.data[j3].length;
              avgFieldCount += fieldCount;
              if (typeof fieldCountPrevRow === "undefined") {
                fieldCountPrevRow = fieldCount;
                continue;
              } else if (fieldCount > 0) {
                delta += Math.abs(fieldCount - fieldCountPrevRow);
                fieldCountPrevRow = fieldCount;
              }
            }
            if (preview.data.length > 0)
              avgFieldCount /= preview.data.length - emptyLinesCount;
            if ((typeof bestDelta === "undefined" || delta <= bestDelta) && (typeof maxFieldCount === "undefined" || avgFieldCount > maxFieldCount) && avgFieldCount > 1.99) {
              bestDelta = delta;
              bestDelim = delim;
              maxFieldCount = avgFieldCount;
            }
          }
          _config.delimiter = bestDelim;
          return {
            successful: !!bestDelim,
            bestDelimiter: bestDelim
          };
        }
        function addError(type, code, msg, row) {
          var error = {
            type,
            code,
            message: msg
          };
          if (row !== void 0) {
            error.row = row;
          }
          _results.errors.push(error);
        }
      }
      function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function Parser2(config) {
        config = config || {};
        var delim = config.delimiter;
        var newline = config.newline;
        var comments = config.comments;
        var step = config.step;
        var preview = config.preview;
        var fastMode = config.fastMode;
        var quoteChar;
        var renamedHeaders = null;
        var headerParsed = false;
        if (config.quoteChar === void 0 || config.quoteChar === null) {
          quoteChar = '"';
        } else {
          quoteChar = config.quoteChar;
        }
        var escapeChar = quoteChar;
        if (config.escapeChar !== void 0) {
          escapeChar = config.escapeChar;
        }
        if (typeof delim !== "string" || Papa2.BAD_DELIMITERS.indexOf(delim) > -1)
          delim = ",";
        if (comments === delim)
          throw new Error("Comment character same as delimiter");
        else if (comments === true)
          comments = "#";
        else if (typeof comments !== "string" || Papa2.BAD_DELIMITERS.indexOf(comments) > -1)
          comments = false;
        if (newline !== "\n" && newline !== "\r" && newline !== "\r\n")
          newline = "\n";
        var cursor = 0;
        var aborted = false;
        this.parse = function(input, baseIndex, ignoreLastRow) {
          if (typeof input !== "string")
            throw new Error("Input must be a string");
          var inputLen = input.length, delimLen = delim.length, newlineLen = newline.length, commentsLen = comments.length;
          var stepIsFunction = isFunction3(step);
          cursor = 0;
          var data = [], errors = [], row = [], lastCursor = 0;
          if (!input)
            return returnable();
          if (fastMode || fastMode !== false && input.indexOf(quoteChar) === -1) {
            var rows = input.split(newline);
            for (var i3 = 0; i3 < rows.length; i3++) {
              row = rows[i3];
              cursor += row.length;
              if (i3 !== rows.length - 1)
                cursor += newline.length;
              else if (ignoreLastRow)
                return returnable();
              if (comments && row.substring(0, commentsLen) === comments)
                continue;
              if (stepIsFunction) {
                data = [];
                pushRow(row.split(delim));
                doStep();
                if (aborted)
                  return returnable();
              } else
                pushRow(row.split(delim));
              if (preview && i3 >= preview) {
                data = data.slice(0, preview);
                return returnable(true);
              }
            }
            return returnable();
          }
          var nextDelim = input.indexOf(delim, cursor);
          var nextNewline = input.indexOf(newline, cursor);
          var quoteCharRegex = new RegExp(escapeRegExp(escapeChar) + escapeRegExp(quoteChar), "g");
          var quoteSearch = input.indexOf(quoteChar, cursor);
          for (; ; ) {
            if (input[cursor] === quoteChar) {
              quoteSearch = cursor;
              cursor++;
              for (; ; ) {
                quoteSearch = input.indexOf(quoteChar, quoteSearch + 1);
                if (quoteSearch === -1) {
                  if (!ignoreLastRow) {
                    errors.push({
                      type: "Quotes",
                      code: "MissingQuotes",
                      message: "Quoted field unterminated",
                      row: data.length,
                      // row has yet to be inserted
                      index: cursor
                    });
                  }
                  return finish();
                }
                if (quoteSearch === inputLen - 1) {
                  var value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);
                  return finish(value);
                }
                if (quoteChar === escapeChar && input[quoteSearch + 1] === escapeChar) {
                  quoteSearch++;
                  continue;
                }
                if (quoteChar !== escapeChar && quoteSearch !== 0 && input[quoteSearch - 1] === escapeChar) {
                  continue;
                }
                if (nextDelim !== -1 && nextDelim < quoteSearch + 1) {
                  nextDelim = input.indexOf(delim, quoteSearch + 1);
                }
                if (nextNewline !== -1 && nextNewline < quoteSearch + 1) {
                  nextNewline = input.indexOf(newline, quoteSearch + 1);
                }
                var checkUpTo = nextNewline === -1 ? nextDelim : Math.min(nextDelim, nextNewline);
                var spacesBetweenQuoteAndDelimiter = extraSpaces(checkUpTo);
                if (input.substr(quoteSearch + 1 + spacesBetweenQuoteAndDelimiter, delimLen) === delim) {
                  row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
                  cursor = quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen;
                  if (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen] !== quoteChar) {
                    quoteSearch = input.indexOf(quoteChar, cursor);
                  }
                  nextDelim = input.indexOf(delim, cursor);
                  nextNewline = input.indexOf(newline, cursor);
                  break;
                }
                var spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline);
                if (input.substring(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen) === newline) {
                  row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
                  saveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen);
                  nextDelim = input.indexOf(delim, cursor);
                  quoteSearch = input.indexOf(quoteChar, cursor);
                  if (stepIsFunction) {
                    doStep();
                    if (aborted)
                      return returnable();
                  }
                  if (preview && data.length >= preview)
                    return returnable(true);
                  break;
                }
                errors.push({
                  type: "Quotes",
                  code: "InvalidQuotes",
                  message: "Trailing quote on quoted field is malformed",
                  row: data.length,
                  // row has yet to be inserted
                  index: cursor
                });
                quoteSearch++;
                continue;
              }
              continue;
            }
            if (comments && row.length === 0 && input.substring(cursor, cursor + commentsLen) === comments) {
              if (nextNewline === -1)
                return returnable();
              cursor = nextNewline + newlineLen;
              nextNewline = input.indexOf(newline, cursor);
              nextDelim = input.indexOf(delim, cursor);
              continue;
            }
            if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1)) {
              row.push(input.substring(cursor, nextDelim));
              cursor = nextDelim + delimLen;
              nextDelim = input.indexOf(delim, cursor);
              continue;
            }
            if (nextNewline !== -1) {
              row.push(input.substring(cursor, nextNewline));
              saveRow(nextNewline + newlineLen);
              if (stepIsFunction) {
                doStep();
                if (aborted)
                  return returnable();
              }
              if (preview && data.length >= preview)
                return returnable(true);
              continue;
            }
            break;
          }
          return finish();
          function pushRow(row2) {
            data.push(row2);
            lastCursor = cursor;
          }
          function extraSpaces(index) {
            var spaceLength = 0;
            if (index !== -1) {
              var textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, index);
              if (textBetweenClosingQuoteAndIndex && textBetweenClosingQuoteAndIndex.trim() === "") {
                spaceLength = textBetweenClosingQuoteAndIndex.length;
              }
            }
            return spaceLength;
          }
          function finish(value2) {
            if (ignoreLastRow)
              return returnable();
            if (typeof value2 === "undefined")
              value2 = input.substring(cursor);
            row.push(value2);
            cursor = inputLen;
            pushRow(row);
            if (stepIsFunction)
              doStep();
            return returnable();
          }
          function saveRow(newCursor) {
            cursor = newCursor;
            pushRow(row);
            row = [];
            nextNewline = input.indexOf(newline, cursor);
          }
          function returnable(stopped) {
            if (config.header && !baseIndex && data.length && !headerParsed) {
              const result = data[0];
              const headerCount = /* @__PURE__ */ Object.create(null);
              const usedHeaders = new Set(result);
              let duplicateHeaders = false;
              for (let i4 = 0; i4 < result.length; i4++) {
                let header = result[i4];
                if (isFunction3(config.transformHeader))
                  header = config.transformHeader(header, i4);
                if (!headerCount[header]) {
                  headerCount[header] = 1;
                  result[i4] = header;
                } else {
                  let newHeader;
                  let suffixCount = headerCount[header];
                  do {
                    newHeader = `${header}_${suffixCount}`;
                    suffixCount++;
                  } while (usedHeaders.has(newHeader));
                  usedHeaders.add(newHeader);
                  result[i4] = newHeader;
                  headerCount[header]++;
                  duplicateHeaders = true;
                  if (renamedHeaders === null) {
                    renamedHeaders = {};
                  }
                  renamedHeaders[newHeader] = header;
                }
                usedHeaders.add(header);
              }
              if (duplicateHeaders) {
                console.warn("Duplicate headers found and renamed.");
              }
              headerParsed = true;
            }
            return {
              data,
              errors,
              meta: {
                delimiter: delim,
                linebreak: newline,
                aborted,
                truncated: !!stopped,
                cursor: lastCursor + (baseIndex || 0),
                renamedHeaders
              }
            };
          }
          function doStep() {
            step(returnable());
            data = [];
            errors = [];
          }
        };
        this.abort = function() {
          aborted = true;
        };
        this.getCharIndex = function() {
          return cursor;
        };
      }
      function newWorker() {
        if (!Papa2.WORKERS_SUPPORTED)
          return false;
        var workerUrl = getWorkerBlob();
        var w3 = new global2.Worker(workerUrl);
        w3.onmessage = mainThreadReceivedMessage;
        w3.id = workerIdCounter++;
        workers[w3.id] = w3;
        return w3;
      }
      function mainThreadReceivedMessage(e3) {
        var msg = e3.data;
        var worker = workers[msg.workerId];
        var aborted = false;
        if (msg.error)
          worker.userError(msg.error, msg.file);
        else if (msg.results && msg.results.data) {
          var abort = function() {
            aborted = true;
            completeWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });
          };
          var handle = {
            abort,
            pause: notImplemented2,
            resume: notImplemented2
          };
          if (isFunction3(worker.userStep)) {
            for (var i3 = 0; i3 < msg.results.data.length; i3++) {
              worker.userStep({
                data: msg.results.data[i3],
                errors: msg.results.errors,
                meta: msg.results.meta
              }, handle);
              if (aborted)
                break;
            }
            delete msg.results;
          } else if (isFunction3(worker.userChunk)) {
            worker.userChunk(msg.results, handle, msg.file);
            delete msg.results;
          }
        }
        if (msg.finished && !aborted)
          completeWorker(msg.workerId, msg.results);
      }
      function completeWorker(workerId, results) {
        var worker = workers[workerId];
        if (isFunction3(worker.userComplete))
          worker.userComplete(results);
        worker.terminate();
        delete workers[workerId];
      }
      function notImplemented2() {
        throw new Error("Not implemented.");
      }
      function workerThreadReceivedMessage(e3) {
        var msg = e3.data;
        if (typeof Papa2.WORKER_ID === "undefined" && msg)
          Papa2.WORKER_ID = msg.workerId;
        if (typeof msg.input === "string") {
          global2.postMessage({
            workerId: Papa2.WORKER_ID,
            results: Papa2.parse(msg.input, msg.config),
            finished: true
          });
        } else if (global2.File && msg.input instanceof File || msg.input instanceof Object) {
          var results = Papa2.parse(msg.input, msg.config);
          if (results)
            global2.postMessage({
              workerId: Papa2.WORKER_ID,
              results,
              finished: true
            });
        }
      }
      function copy(obj) {
        if (typeof obj !== "object" || obj === null)
          return obj;
        var cpy = Array.isArray(obj) ? [] : {};
        for (var key in obj)
          cpy[key] = copy(obj[key]);
        return cpy;
      }
      function bindFunction(f3, self2) {
        return function() {
          f3.apply(self2, arguments);
        };
      }
      function isFunction3(func) {
        return typeof func === "function";
      }
      return Papa2;
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => UrlToVaultPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");

// src/prompt.ts
var PROMPT_TEMPLATE = `
You are an analyst assistant. Convert the provided article into a single Obsidian note written in Obsidian-flavoured Markdown.

STRICT OUTPUT RULES
- Return ONLY the final markdown note. No commentary, no code fences.
- The note MUST start with YAML frontmatter and end that block with a second line containing only '---'.
- After YAML, write the note body with the headings below.
- Wrap key named entities in [[double square brackets]] throughout the BODY only: people, organizations, countries, cities/places, weapon systems/munitions, events/operations, platforms/programs.
- Do NOT link generic nouns (e.g., police, court, store, judge) unless a specific named entity is given (e.g., [[Police Scotland]], [[High Court of Justiciary]]).

CRITICAL INPUT RULE
- You are given ARTICLE TEXT below. If ARTICLE TEXT is non-empty, you MUST use it to extract names, places, dates, and entities.
- If ARTICLE TEXT is present, you MUST NOT claim that \u201Cfull article content was not provided\u201D.
- Only say information is missing if it truly does not appear in ARTICLE TEXT or METADATA.

FRONTMATTER (STRICT YAML, OBSIDIAN PROPERTIES)
1) Valid YAML the parser can read:
   - snake_case keys only; spaces, not tabs; no duplicate keys.
   - omit unknown or uncertain fields (never output blanks or placeholders like "unknown").
2) Allowed keys and types:
   REQUIRED
   - title: quoted string (headline)
   - source: quoted string (may contain [[wikilink]] but keep inside quotes)
   - url: quoted string
   - published: ISO-8601 date or datetime (YYYY-MM-DD or YYYY-MM-DDTHH:MM:SS) with no surrounding quotes
   - type: "news_article"
   - tags: block list of lowercase slug tags (unquoted items)
   OPTIONAL (only when present)
   - author: quoted string (use ONLY when exactly one author)
   - authors: block list of quoted strings (use when multiple authors; never include both author and authors)
   - section: quoted string
   - language: quoted string (e.g. "en")
   - location: quoted string (may contain [[wikilink]])
   - article_id: integer (no quotes)
   - topics: block list of quoted strings (may contain [[wikilinks]]; keep consistent)
3) Quoting policy:
   - Quote ALL string values with double quotes, except items under tags which must be unquoted simple slugs.
   - Always quote values containing ':', '#', '@', '[', ']', '{{', '}}', ',', or leading/trailing spaces.
4) Lists:
   - Use block lists only (no inline lists). Each item on its own line, two spaces indent under the key.
5) Self-check before output:
   - YAML starts with '---' on its own line and ends with '---'.
   - Every key has exactly one value; lists are indented consistently; no blank/placeholder values; YAML would parse.

NOTE BODY STRUCTURE (REQUIRED HEADINGS)
## Summary
- 3-7 bullets capturing the key claims (with linked entities in the text).

## Key details
- Expand key facts: timeline, quantities, specs, locations, named suppliers/manufacturers, etc.

## Claims & attribution
- Separate what is claimed vs who claims it.
- Mark uncertainty clearly (unconfirmed / not independently verified in the provided text).

## Entities
Group key entities with Obsidian links:
- People
- Organisations
- Systems / equipment
- Locations
- (Optional) Platforms / sanctions / programs

## Analyst notes (optional but encouraged)
- 5-10 bullets: verification hooks, OSINT checks, notable gaps.

NOW CONVERT THIS ARTICLE

URL: {url}

METADATA (may be incomplete; ARTICLE TEXT overrides when present)
title: {title}
authors: {authors}
published: {published}
source: {source}

ARTICLE TEXT (use this for extraction; do not ignore)
{article_text}
`.trim();

// src/tags.ts
function normalizeTags(input) {
  if (!input) return [];
  const slugs = input.split(",").map((tag) => tag.trim()).filter(Boolean).map((tag) => {
    let slug = tag.replace(/^#/, "").toLowerCase();
    slug = slug.replace(/[\s_]+/g, "-");
    slug = slug.replace(/[^a-z0-9-]/g, "-");
    slug = slug.replace(/-+/g, "-");
    slug = slug.replace(/^-+|-+$/g, "");
    return slug;
  }).filter(Boolean);
  const seen = /* @__PURE__ */ new Set();
  const unique = [];
  for (const s3 of slugs) {
    if (!seen.has(s3)) {
      seen.add(s3);
      unique.push(s3);
    }
  }
  return unique;
}

// src/settings.ts
var ConfirmModal = class extends import_obsidian.Modal {
  constructor(app, titleText, bodyText, onConfirm) {
    super(app);
    this.titleText = titleText;
    this.bodyText = bodyText;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.titleEl.setText(this.titleText);
    contentEl.createEl("p", { text: this.bodyText });
    new import_obsidian.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Cancel").onClick(() => {
        this.close();
      })
    ).addButton(
      (btn) => btn.setButtonText("Confirm").setCta().onClick(() => {
        this.close();
        this.onConfirm();
      })
    );
  }
  onClose() {
    this.contentEl.empty();
  }
};
var UrlToVaultSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.saveSettingsDebounced = (0, import_obsidian.debounce)(() => {
      void this.plugin.saveSettings();
    }, 500, true);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    try {
      new import_obsidian.Setting(containerEl).setName("About this plugin").setHeading();
      const repoDesc = (() => {
        const frag = document.createDocumentFragment();
        const link = document.createElement("a");
        link.href = "https://github.com/thomasjjj/obsidian-osint-ner";
        link.textContent = "thomasjjj/obsidian-osint-ner (issues)";
        link.target = "_blank";
        link.rel = "noopener";
        frag.append("GitHub: ");
        frag.appendChild(link);
        return frag;
      })();
      new import_obsidian.Setting(containerEl).setName("Report a bug / view source").setDesc(repoDesc).addExtraButton(
        (btn) => btn.setIcon("bug").setTooltip("Open GitHub repository").onClick(() => window.open("https://github.com/thomasjjj/obsidian-osint-ner", "_blank"))
      );
      new import_obsidian.Setting(containerEl).setName("Provider").setDesc("Choose OpenAI or a local OpenAI-compatible server like LM Studio.").addDropdown(
        (dropdown) => dropdown.addOption("openai", "OpenAI").addOption("lmstudio", "Local (LM Studio)").setValue(this.plugin.settings.provider).onChange((value) => {
          this.plugin.settings.provider = value;
          this.saveSettingsDebounced();
          this.display();
        })
      );
      new import_obsidian.Setting(containerEl).setName("OpenAI-compatible base URL").setDesc("Used for LM Studio/local servers. Example: http://localhost:1234/v1").addText(
        (text) => text.setPlaceholder("http://localhost:1234/v1").setValue(this.plugin.settings.apiBaseUrl).onChange((value) => {
          this.plugin.settings.apiBaseUrl = value.trim();
          this.saveSettingsDebounced();
        })
      );
      new import_obsidian.Setting(containerEl).setName("API key").setDesc("Required for OpenAI. Optional for LM Studio; stored in SecretStorage when available.").addText((text) => {
        text.inputEl.type = "password";
        text.inputEl.placeholder = "sk-...";
        void this.plugin.getApiKey().then((key) => {
          if (key) text.setValue(key);
        });
        text.onChange((value) => {
          void this.plugin.setApiKey(value.trim());
        });
      });
      new import_obsidian.Setting(containerEl).setName("Test connection").setDesc("Checks the selected provider without sending article content.").addButton(
        (btn) => btn.setButtonText("Test").setTooltip("Send a lightweight request to confirm the connection works.").onClick(() => {
          btn.setDisabled(true).setButtonText("Testing connection...");
          void this.plugin.testApiKey().then(() => new import_obsidian.Notice("Connection looks good.")).catch((err) => {
            const msg = err instanceof Error ? err.message : "Connection test failed.";
            new import_obsidian.Notice(msg, 6e3);
          }).finally(() => {
            btn.setDisabled(false).setButtonText("Test");
          });
        })
      );
      new import_obsidian.Setting(containerEl).setName("Model").setDesc("OpenAI model or local model name used for formatting.").addText(
        (text) => text.setPlaceholder("gpt-5-mini").setValue(this.plugin.settings.model).onChange((value) => {
          this.plugin.settings.model = value.trim() || "gpt-5-mini";
          this.saveSettingsDebounced();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Output folder").setDesc("Relative to your vault. Will be created if it doesn't exist.").addText(
        (text) => text.setPlaceholder("articles").setValue(this.plugin.settings.outputFolder).onChange((value) => {
          this.plugin.settings.outputFolder = value.trim();
          this.saveSettingsDebounced();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Default tags").setDesc("Comma-separated tags to inject into the YAML tags list.").addText(
        (text) => text.setPlaceholder("news,reading").setValue(this.plugin.settings.defaultTags).onChange((value) => {
          const tags = normalizeTags(value);
          const sanitized = tags.join(", ");
          this.plugin.settings.defaultTags = sanitized;
          if (sanitized !== value.trim()) {
            text.setValue(sanitized);
          }
          this.saveSettingsDebounced();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Trim article text at").setDesc("Maximum number of characters sent to OpenAI (to avoid token blowups).").addText(
        (text) => text.setPlaceholder("12000").setValue(String(this.plugin.settings.maxChars)).onChange((value) => {
          const parsed = Number(value);
          const valid = !Number.isNaN(parsed) && parsed > 500 && parsed <= 5e4;
          text.inputEl.classList.toggle("osint-ner-invalid", !valid);
          text.inputEl.style.borderColor = valid ? "" : "var(--text-error, #d9534f)";
          if (valid) {
            this.plugin.settings.maxChars = parsed;
            this.saveSettingsDebounced();
          }
        })
      );
      const maxCharsInput = containerEl.querySelector("input[placeholder='12000']");
      if (maxCharsInput) {
        maxCharsInput.setAttribute("type", "number");
        maxCharsInput.setAttribute("min", "500");
        maxCharsInput.setAttribute("max", "50000");
        maxCharsInput.setAttribute("step", "500");
        maxCharsInput.classList.add("osint-ner-number");
      }
      new import_obsidian.Setting(containerEl).setName("Max request retries").setDesc("Retries on transient model errors (rate limits, 5xx).").addSlider(
        (slider) => slider.setLimits(0, 3, 1).setValue(this.plugin.settings.maxRetries).setDynamicTooltip().onChange((value) => {
          this.plugin.settings.maxRetries = value;
          this.saveSettingsDebounced();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Verbose logging").setDesc("Log extra details to the console for troubleshooting (no API keys).").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.verboseLogging).onChange((value) => {
          this.plugin.settings.verboseLogging = value;
          this.saveSettingsDebounced();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Open created note").setDesc("Open the note after creation.").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.openAfterCreate).onChange((value) => {
          this.plugin.settings.openAfterCreate = value;
          this.saveSettingsDebounced();
        })
      );
      new import_obsidian.Setting(containerEl).setName("PDF Processing").setHeading();
      new import_obsidian.Setting(containerEl).setName("PDF handling mode").setDesc("How to process PDF documents. Text extraction works with all models; native vision requires OpenAI GPT-4o/o3.").addDropdown(
        (dropdown) => dropdown.addOption("text-extraction", "Extract text (all models)").addOption("native-vision", "Native vision (OpenAI GPT-4o/o3 only)").setValue(this.plugin.settings.pdfHandling).onChange((value) => {
          this.plugin.settings.pdfHandling = value;
          this.saveSettingsDebounced();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Max PDF pages").setDesc("Maximum pages to extract text from (for text extraction mode).").addSlider(
        (slider) => slider.setLimits(1, 100, 1).setValue(this.plugin.settings.pdfMaxPages).setDynamicTooltip().onChange((value) => {
          this.plugin.settings.pdfMaxPages = value;
          this.saveSettingsDebounced();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Batch Processing").setHeading();
      new import_obsidian.Setting(containerEl).setName("Delay between items (seconds)").setDesc("Seconds to wait between processing each URL to avoid rate limits.").addSlider(
        (slider) => slider.setLimits(0.5, 10, 0.5).setValue(this.plugin.settings.batchDelayMs / 1e3).setDynamicTooltip().onChange((value) => {
          this.plugin.settings.batchDelayMs = value * 1e3;
          this.saveSettingsDebounced();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Continue on error").setDesc("When a URL fails, continue processing the rest of the batch.").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.batchContinueOnError).onChange((value) => {
          this.plugin.settings.batchContinueOnError = value;
          this.saveSettingsDebounced();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Create error report").setDesc("Generate a summary note listing any failed URLs after batch processing.").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.batchCreateReport).onChange((value) => {
          this.plugin.settings.batchCreateReport = value;
          this.saveSettingsDebounced();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Content options").setHeading();
      new import_obsidian.Setting(containerEl).setName("Append raw article").setDesc("Attach the extracted plaintext article below the AI-formatted note.").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.includeRaw).onChange((value) => {
          this.plugin.settings.includeRaw = value;
          this.saveSettingsDebounced();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Append hyperlinks").setDesc("Include a list of extracted links at the end of the note.").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.includeLinks).onChange((value) => {
          this.plugin.settings.includeLinks = value;
          this.saveSettingsDebounced();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Append images").setDesc("Include a list of image embeds (hotlinked) at the end of the note.").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.includeImages).onChange((value) => {
          this.plugin.settings.includeImages = value;
          this.saveSettingsDebounced();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Prompt (advanced)").setHeading();
      new import_obsidian.Setting(containerEl).setName("Use custom prompt").setDesc("When on, the prompt below overrides the built-in prompt.").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.useCustomPrompt).onChange((value) => {
          this.plugin.settings.useCustomPrompt = value;
          this.saveSettingsDebounced();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Custom prompt").setDesc(
        "Leave blank to keep using the built-in prompt. Insert the default to edit a copy, or clear to start fresh."
      ).addButton(
        (btn) => btn.setButtonText("Insert default prompt").setTooltip("Copy the shipped prompt into the box so you can edit it.").onClick(() => {
          this.plugin.settings.customPrompt = PROMPT_TEMPLATE;
          if (promptArea) promptArea.setValue(PROMPT_TEMPLATE);
          this.saveSettingsDebounced();
        })
      ).addButton(
        (btn) => btn.setButtonText("Clear").setTooltip("Empty the custom prompt box.").onClick(() => {
          this.plugin.settings.customPrompt = "";
          if (promptArea) promptArea.setValue("");
          this.saveSettingsDebounced();
        })
      ).addButton(
        (btn) => btn.setButtonText("Revert to default").setTooltip("Stop using a custom prompt and discard it.").onClick(() => {
          new ConfirmModal(
            this.app,
            "Revert to default prompt",
            "Discard the custom prompt and use the built-in prompt?",
            () => {
              this.plugin.settings.useCustomPrompt = false;
              this.plugin.settings.customPrompt = "";
              this.saveSettingsDebounced();
              this.display();
            }
          ).open();
        })
      );
      let promptArea = null;
      new import_obsidian.Setting(containerEl).setName("Prompt text").setDesc("Only used when 'Use custom prompt' is ON.").addTextArea((text) => {
        promptArea = text;
        text.setPlaceholder("Custom prompt (optional)").setValue(this.plugin.settings.customPrompt).onChange((value) => {
          this.plugin.settings.customPrompt = value;
          this.saveSettingsDebounced();
        });
      });
      if (promptArea) {
        promptArea.inputEl.rows = 14;
        promptArea.inputEl.addClass("osint-ner-prompt-area");
      }
    } catch (err) {
      console.error("Failed to render OSINT Entity Extractor settings", err);
      containerEl.createEl("p", {
        text: "Settings failed to load. See console for details."
      });
    }
  }
};

// src/types.ts
var DEFAULT_SETTINGS = {
  provider: "openai",
  model: "gpt-5-mini",
  apiBaseUrl: "http://localhost:1234/v1",
  outputFolder: "articles",
  defaultTags: "news",
  openAfterCreate: true,
  maxChars: 12e3,
  includeRaw: true,
  useCustomPrompt: false,
  customPrompt: "",
  includeLinks: false,
  includeImages: false,
  maxRetries: 2,
  verboseLogging: false,
  apiKey: "",
  // PDF settings
  pdfHandling: "text-extraction",
  pdfMaxPages: 50,
  // Batch processing settings
  batchDelayMs: 1e3,
  batchContinueOnError: true,
  batchCreateReport: true
};

// src/extract.ts
var import_obsidian3 = require("obsidian");
var import_readability = __toESM(require_readability());
init_pdf();
var USER_AGENT2 = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36";
function guessSource2(url) {
  try {
    const hostname = new URL(url).hostname.replace(/^www\./, "");
    return hostname;
  } catch {
    return "";
  }
}
function trimText2(text, maxChars) {
  if (text.length <= maxChars) return text;
  return text.slice(0, maxChars) + "\n\n[truncated]";
}
function extractPublished(doc) {
  const selectors = [
    "meta[property='article:published_time']",
    "meta[name='article:published_time']",
    "meta[name='pubdate']",
    "meta[property='og:pubdate']",
    "meta[name='date']",
    "meta[property='article:modified_time']"
  ];
  for (const sel of selectors) {
    const meta = doc.querySelector(sel);
    const content = meta?.getAttribute("content")?.trim();
    if (content) return content;
  }
  return "";
}
function extractAuthors(byline) {
  if (!byline) return [];
  return byline.split(/,\s*|\s+and\s+|\s*&\s*|;\s*/i).map((a3) => a3.trim()).filter(Boolean);
}
function extractLinksAndImages(articleHtml, baseUrl) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(articleHtml || "<div></div>", "text/html");
  const resolveUrl = (href) => {
    try {
      return new URL(href, baseUrl).href;
    } catch {
      return "";
    }
  };
  const links = Array.from(doc.querySelectorAll("a")).map((a3) => {
    const rawHref = a3.getAttribute("href");
    if (!rawHref) return null;
    const href = resolveUrl(rawHref);
    return {
      text: a3.textContent?.trim() ?? "",
      href
    };
  }).filter((l3) => !!l3 && !!l3.href);
  const images = Array.from(doc.querySelectorAll("img")).map((img) => {
    const rawSrc = img.getAttribute("src");
    if (!rawSrc) return null;
    const src = resolveUrl(rawSrc);
    return {
      alt: img.getAttribute("alt")?.trim() ?? "",
      src
    };
  }).filter((i3) => !!i3 && !!i3.src);
  return { links, images };
}
async function extractFromHtml(html, url, maxChars) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(html, "text/html");
  if (!doc.querySelector("base")) {
    const base = doc.createElement("base");
    base.href = url;
    doc.head.appendChild(base);
  }
  const reader = new import_readability.Readability(doc);
  const article = reader.parse();
  const text = article?.textContent?.trim() || doc.querySelector("article")?.textContent?.trim() || doc.body?.textContent?.trim() || "";
  const { links, images } = extractLinksAndImages(article?.content || "", url);
  const published = extractPublished(doc);
  const authors = extractAuthors(article?.byline);
  const sourceGuess = guessSource2(url);
  return {
    title: article?.title?.trim() || "",
    authors,
    published,
    text: trimText2(text, maxChars),
    sourceGuess,
    links,
    images,
    contentType: "html"
  };
}
async function fetchAndExtract(url, maxChars) {
  const resp = await (0, import_obsidian3.requestUrl)({
    url,
    headers: {
      "User-Agent": USER_AGENT2
    }
  });
  if (resp.status >= 400) {
    throw new Error(`HTTP ${resp.status} when fetching URL`);
  }
  return extractFromHtml(resp.text, url, maxChars);
}
async function fetchAndExtractContent(url, maxChars, pdfMaxPages) {
  const { isPdf } = await detectContentType(url);
  if (isPdf) {
    return fetchAndExtractPdf(url, maxChars, pdfMaxPages);
  }
  return fetchAndExtract(url, maxChars);
}

// node_modules/openai/internal/qs/formats.mjs
var default_format = "RFC3986";
var formatters = {
  RFC1738: (v3) => String(v3).replace(/%20/g, "+"),
  RFC3986: (v3) => String(v3)
};
var RFC1738 = "RFC1738";

// node_modules/openai/internal/qs/utils.mjs
var is_array = Array.isArray;
var hex_table = (() => {
  const array = [];
  for (let i3 = 0; i3 < 256; ++i3) {
    array.push("%" + ((i3 < 16 ? "0" : "") + i3.toString(16)).toUpperCase());
  }
  return array;
})();
var limit = 1024;
var encode = (str2, _defaultEncoder, charset, _kind, format2) => {
  if (str2.length === 0) {
    return str2;
  }
  let string = str2;
  if (typeof str2 === "symbol") {
    string = Symbol.prototype.toString.call(str2);
  } else if (typeof str2 !== "string") {
    string = String(str2);
  }
  if (charset === "iso-8859-1") {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  let out = "";
  for (let j3 = 0; j3 < string.length; j3 += limit) {
    const segment = string.length >= limit ? string.slice(j3, j3 + limit) : string;
    const arr = [];
    for (let i3 = 0; i3 < segment.length; ++i3) {
      let c3 = segment.charCodeAt(i3);
      if (c3 === 45 || // -
      c3 === 46 || // .
      c3 === 95 || // _
      c3 === 126 || // ~
      c3 >= 48 && c3 <= 57 || // 0-9
      c3 >= 65 && c3 <= 90 || // a-z
      c3 >= 97 && c3 <= 122 || // A-Z
      format2 === RFC1738 && (c3 === 40 || c3 === 41)) {
        arr[arr.length] = segment.charAt(i3);
        continue;
      }
      if (c3 < 128) {
        arr[arr.length] = hex_table[c3];
        continue;
      }
      if (c3 < 2048) {
        arr[arr.length] = hex_table[192 | c3 >> 6] + hex_table[128 | c3 & 63];
        continue;
      }
      if (c3 < 55296 || c3 >= 57344) {
        arr[arr.length] = hex_table[224 | c3 >> 12] + hex_table[128 | c3 >> 6 & 63] + hex_table[128 | c3 & 63];
        continue;
      }
      i3 += 1;
      c3 = 65536 + ((c3 & 1023) << 10 | segment.charCodeAt(i3) & 1023);
      arr[arr.length] = hex_table[240 | c3 >> 18] + hex_table[128 | c3 >> 12 & 63] + hex_table[128 | c3 >> 6 & 63] + hex_table[128 | c3 & 63];
    }
    out += arr.join("");
  }
  return out;
};
function is_buffer(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
}
function maybe_map(val, fn2) {
  if (is_array(val)) {
    const mapped = [];
    for (let i3 = 0; i3 < val.length; i3 += 1) {
      mapped.push(fn2(val[i3]));
    }
    return mapped;
  }
  return fn2(val);
}

// node_modules/openai/internal/qs/stringify.mjs
var has = Object.prototype.hasOwnProperty;
var array_prefix_generators = {
  brackets(prefix) {
    return String(prefix) + "[]";
  },
  comma: "comma",
  indices(prefix, key) {
    return String(prefix) + "[" + key + "]";
  },
  repeat(prefix) {
    return String(prefix);
  }
};
var is_array2 = Array.isArray;
var push = Array.prototype.push;
var push_to_array = function(arr, value_or_array) {
  push.apply(arr, is_array2(value_or_array) ? value_or_array : [value_or_array]);
};
var to_ISO = Date.prototype.toISOString;
var defaults = {
  addQueryPrefix: false,
  allowDots: false,
  allowEmptyArrays: false,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encodeDotInKeys: false,
  encoder: encode,
  encodeValuesOnly: false,
  format: default_format,
  formatter: formatters[default_format],
  /** @deprecated */
  indices: false,
  serializeDate(date) {
    return to_ISO.call(date);
  },
  skipNulls: false,
  strictNullHandling: false
};
function is_non_nullish_primitive(v3) {
  return typeof v3 === "string" || typeof v3 === "number" || typeof v3 === "boolean" || typeof v3 === "symbol" || typeof v3 === "bigint";
}
var sentinel = {};
function inner_stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset, sideChannel) {
  let obj = object;
  let tmp_sc = sideChannel;
  let step = 0;
  let find_flag = false;
  while ((tmp_sc = tmp_sc.get(sentinel)) !== void 0 && !find_flag) {
    const pos = tmp_sc.get(object);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        find_flag = true;
      }
    }
    if (typeof tmp_sc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter === "function") {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate?.(obj);
  } else if (generateArrayPrefix === "comma" && is_array2(obj)) {
    obj = maybe_map(obj, function(value) {
      if (value instanceof Date) {
        return serializeDate?.(value);
      }
      return value;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? (
        // @ts-expect-error
        encoder(prefix, defaults.encoder, charset, "key", format2)
      ) : prefix;
    }
    obj = "";
  }
  if (is_non_nullish_primitive(obj) || is_buffer(obj)) {
    if (encoder) {
      const key_value = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format2);
      return [
        formatter?.(key_value) + "=" + // @ts-expect-error
        formatter?.(encoder(obj, defaults.encoder, charset, "value", format2))
      ];
    }
    return [formatter?.(prefix) + "=" + formatter?.(String(obj))];
  }
  const values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  let obj_keys;
  if (generateArrayPrefix === "comma" && is_array2(obj)) {
    if (encodeValuesOnly && encoder) {
      obj = maybe_map(obj, encoder);
    }
    obj_keys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (is_array2(filter)) {
    obj_keys = filter;
  } else {
    const keys = Object.keys(obj);
    obj_keys = sort ? keys.sort(sort) : keys;
  }
  const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
  const adjusted_prefix = commaRoundTrip && is_array2(obj) && obj.length === 1 ? encoded_prefix + "[]" : encoded_prefix;
  if (allowEmptyArrays && is_array2(obj) && obj.length === 0) {
    return adjusted_prefix + "[]";
  }
  for (let j3 = 0; j3 < obj_keys.length; ++j3) {
    const key = obj_keys[j3];
    const value = (
      // @ts-ignore
      typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key]
    );
    if (skipNulls && value === null) {
      continue;
    }
    const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
    const key_prefix = is_array2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjusted_prefix, encoded_key) : adjusted_prefix : adjusted_prefix + (allowDots ? "." + encoded_key : "[" + encoded_key + "]");
    sideChannel.set(object, step);
    const valueSideChannel = /* @__PURE__ */ new WeakMap();
    valueSideChannel.set(sentinel, sideChannel);
    push_to_array(values, inner_stringify(
      value,
      key_prefix,
      generateArrayPrefix,
      commaRoundTrip,
      allowEmptyArrays,
      strictNullHandling,
      skipNulls,
      encodeDotInKeys,
      // @ts-ignore
      generateArrayPrefix === "comma" && encodeValuesOnly && is_array2(obj) ? null : encoder,
      filter,
      sort,
      allowDots,
      serializeDate,
      format2,
      formatter,
      encodeValuesOnly,
      charset,
      valueSideChannel
    ));
  }
  return values;
}
function normalize_stringify_options(opts = defaults) {
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  const charset = opts.charset || defaults.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  let format2 = default_format;
  if (typeof opts.format !== "undefined") {
    if (!has.call(formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format2 = opts.format;
  }
  const formatter = formatters[format2];
  let filter = defaults.filter;
  if (typeof opts.filter === "function" || is_array2(opts.filter)) {
    filter = opts.filter;
  }
  let arrayFormat;
  if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {
    arrayFormat = opts.arrayFormat;
  } else if ("indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = defaults.arrayFormat;
  }
  if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  const allowDots = typeof opts.allowDots === "undefined" ? !!opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
    // @ts-ignore
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
    arrayFormat,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    commaRoundTrip: !!opts.commaRoundTrip,
    delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
    encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
    filter,
    format: format2,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
    // @ts-ignore
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
}
function stringify(object, opts = {}) {
  let obj = object;
  const options = normalize_stringify_options(opts);
  let obj_keys;
  let filter;
  if (typeof options.filter === "function") {
    filter = options.filter;
    obj = filter("", obj);
  } else if (is_array2(options.filter)) {
    filter = options.filter;
    obj_keys = filter;
  }
  const keys = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  const generateArrayPrefix = array_prefix_generators[options.arrayFormat];
  const commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
  if (!obj_keys) {
    obj_keys = Object.keys(obj);
  }
  if (options.sort) {
    obj_keys.sort(options.sort);
  }
  const sideChannel = /* @__PURE__ */ new WeakMap();
  for (let i3 = 0; i3 < obj_keys.length; ++i3) {
    const key = obj_keys[i3];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    push_to_array(keys, inner_stringify(
      obj[key],
      key,
      // @ts-expect-error
      generateArrayPrefix,
      commaRoundTrip,
      options.allowEmptyArrays,
      options.strictNullHandling,
      options.skipNulls,
      options.encodeDotInKeys,
      options.encode ? options.encoder : null,
      options.filter,
      options.sort,
      options.allowDots,
      options.serializeDate,
      options.format,
      options.formatter,
      options.encodeValuesOnly,
      options.charset,
      sideChannel
    ));
  }
  const joined = keys.join(options.delimiter);
  let prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
}

// node_modules/openai/version.mjs
var VERSION = "4.104.0";

// node_modules/openai/_shims/registry.mjs
var auto = false;
var kind = void 0;
var fetch2 = void 0;
var Request = void 0;
var Response2 = void 0;
var Headers2 = void 0;
var FormData = void 0;
var Blob2 = void 0;
var File2 = void 0;
var ReadableStream2 = void 0;
var getMultipartRequestOptions = void 0;
var getDefaultAgent = void 0;
var fileFromPath = void 0;
var isFsReadStream = void 0;
function setShims(shims, options = { auto: false }) {
  if (auto) {
    throw new Error(`you must \`import 'openai/shims/${shims.kind}'\` before importing anything else from openai`);
  }
  if (kind) {
    throw new Error(`can't \`import 'openai/shims/${shims.kind}'\` after \`import 'openai/shims/${kind}'\``);
  }
  auto = options.auto;
  kind = shims.kind;
  fetch2 = shims.fetch;
  Request = shims.Request;
  Response2 = shims.Response;
  Headers2 = shims.Headers;
  FormData = shims.FormData;
  Blob2 = shims.Blob;
  File2 = shims.File;
  ReadableStream2 = shims.ReadableStream;
  getMultipartRequestOptions = shims.getMultipartRequestOptions;
  getDefaultAgent = shims.getDefaultAgent;
  fileFromPath = shims.fileFromPath;
  isFsReadStream = shims.isFsReadStream;
}

// node_modules/openai/_shims/node-runtime.mjs
var nf = __toESM(require_lib2(), 1);

// node_modules/formdata-node/lib/esm/FormData.js
var import_util2 = require("util");
init_File();
init_isFile();

// node_modules/formdata-node/lib/esm/isBlob.js
init_Blob();
var isBlob = (value) => value instanceof Blob3;

// node_modules/formdata-node/lib/esm/FormData.js
init_isFunction();

// node_modules/formdata-node/lib/esm/deprecateConstructorEntries.js
var import_util = require("util");
var deprecateConstructorEntries = (0, import_util.deprecate)(() => {
}, 'Constructor "entries" argument is not spec-compliant and will be removed in next major release.');

// node_modules/formdata-node/lib/esm/FormData.js
var __classPrivateFieldGet3 = function(receiver, state, kind2, f3) {
  if (kind2 === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f3 : kind2 === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
};
var _FormData_instances;
var _FormData_entries;
var _FormData_setEntry;
var FormData2 = class {
  constructor(entries) {
    _FormData_instances.add(this);
    _FormData_entries.set(this, /* @__PURE__ */ new Map());
    if (entries) {
      deprecateConstructorEntries();
      entries.forEach(({ name, value, fileName }) => this.append(name, value, fileName));
    }
  }
  static [(_FormData_entries = /* @__PURE__ */ new WeakMap(), _FormData_instances = /* @__PURE__ */ new WeakSet(), Symbol.hasInstance)](value) {
    return Boolean(value && isFunction(value.constructor) && value[Symbol.toStringTag] === "FormData" && isFunction(value.append) && isFunction(value.set) && isFunction(value.get) && isFunction(value.getAll) && isFunction(value.has) && isFunction(value.delete) && isFunction(value.entries) && isFunction(value.values) && isFunction(value.keys) && isFunction(value[Symbol.iterator]) && isFunction(value.forEach));
  }
  append(name, value, fileName) {
    __classPrivateFieldGet3(this, _FormData_instances, "m", _FormData_setEntry).call(this, {
      name,
      fileName,
      append: true,
      rawValue: value,
      argsLength: arguments.length
    });
  }
  set(name, value, fileName) {
    __classPrivateFieldGet3(this, _FormData_instances, "m", _FormData_setEntry).call(this, {
      name,
      fileName,
      append: false,
      rawValue: value,
      argsLength: arguments.length
    });
  }
  get(name) {
    const field = __classPrivateFieldGet3(this, _FormData_entries, "f").get(String(name));
    if (!field) {
      return null;
    }
    return field[0];
  }
  getAll(name) {
    const field = __classPrivateFieldGet3(this, _FormData_entries, "f").get(String(name));
    if (!field) {
      return [];
    }
    return field.slice();
  }
  has(name) {
    return __classPrivateFieldGet3(this, _FormData_entries, "f").has(String(name));
  }
  delete(name) {
    __classPrivateFieldGet3(this, _FormData_entries, "f").delete(String(name));
  }
  *keys() {
    for (const key of __classPrivateFieldGet3(this, _FormData_entries, "f").keys()) {
      yield key;
    }
  }
  *entries() {
    for (const name of this.keys()) {
      const values = this.getAll(name);
      for (const value of values) {
        yield [name, value];
      }
    }
  }
  *values() {
    for (const [, value] of this) {
      yield value;
    }
  }
  [(_FormData_setEntry = function _FormData_setEntry2({ name, rawValue, append, fileName, argsLength }) {
    const methodName = append ? "append" : "set";
    if (argsLength < 2) {
      throw new TypeError(`Failed to execute '${methodName}' on 'FormData': 2 arguments required, but only ${argsLength} present.`);
    }
    name = String(name);
    let value;
    if (isFile(rawValue)) {
      value = fileName === void 0 ? rawValue : new File3([rawValue], fileName, {
        type: rawValue.type,
        lastModified: rawValue.lastModified
      });
    } else if (isBlob(rawValue)) {
      value = new File3([rawValue], fileName === void 0 ? "blob" : fileName, {
        type: rawValue.type
      });
    } else if (fileName) {
      throw new TypeError(`Failed to execute '${methodName}' on 'FormData': parameter 2 is not of type 'Blob'.`);
    } else {
      value = String(rawValue);
    }
    const values = __classPrivateFieldGet3(this, _FormData_entries, "f").get(name);
    if (!values) {
      return void __classPrivateFieldGet3(this, _FormData_entries, "f").set(name, [value]);
    }
    if (!append) {
      return void __classPrivateFieldGet3(this, _FormData_entries, "f").set(name, [value]);
    }
    values.push(value);
  }, Symbol.iterator)]() {
    return this.entries();
  }
  forEach(callback, thisArg) {
    for (const [name, value] of this) {
      callback.call(thisArg, value, name, this);
    }
  }
  get [Symbol.toStringTag]() {
    return "FormData";
  }
  [import_util2.inspect.custom]() {
    return this[Symbol.toStringTag];
  }
};

// node_modules/formdata-node/lib/esm/index.js
init_Blob();
init_File();

// node_modules/openai/_shims/node-runtime.mjs
var import_agentkeepalive = __toESM(require_agentkeepalive(), 1);
var import_abort_controller = __toESM(require_abort_controller(), 1);
var import_node_fs = require("node:fs");

// node_modules/form-data-encoder/lib/esm/util/createBoundary.js
var alphabet = "abcdefghijklmnopqrstuvwxyz0123456789";
function createBoundary() {
  let size = 16;
  let res = "";
  while (size--) {
    res += alphabet[Math.random() * alphabet.length << 0];
  }
  return res;
}
var createBoundary_default = createBoundary;

// node_modules/form-data-encoder/lib/esm/util/isPlainObject.js
var getType = (value) => Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
function isPlainObject(value) {
  if (getType(value) !== "object") {
    return false;
  }
  const pp = Object.getPrototypeOf(value);
  if (pp === null || pp === void 0) {
    return true;
  }
  const Ctor = pp.constructor && pp.constructor.toString();
  return Ctor === Object.toString();
}
var isPlainObject_default = isPlainObject;

// node_modules/form-data-encoder/lib/esm/util/normalizeValue.js
var normalizeValue = (value) => String(value).replace(/\r|\n/g, (match, i3, str2) => {
  if (match === "\r" && str2[i3 + 1] !== "\n" || match === "\n" && str2[i3 - 1] !== "\r") {
    return "\r\n";
  }
  return match;
});
var normalizeValue_default = normalizeValue;

// node_modules/form-data-encoder/lib/esm/util/escapeName.js
var escapeName = (name) => String(name).replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/"/g, "%22");
var escapeName_default = escapeName;

// node_modules/form-data-encoder/lib/esm/util/isFunction.js
var isFunction2 = (value) => typeof value === "function";
var isFunction_default = isFunction2;

// node_modules/form-data-encoder/lib/esm/util/isFileLike.js
var isFileLike = (value) => Boolean(value && typeof value === "object" && isFunction_default(value.constructor) && value[Symbol.toStringTag] === "File" && isFunction_default(value.stream) && value.name != null && value.size != null && value.lastModified != null);

// node_modules/form-data-encoder/lib/esm/util/isFormData.js
var isFormData = (value) => Boolean(value && isFunction_default(value.constructor) && value[Symbol.toStringTag] === "FormData" && isFunction_default(value.append) && isFunction_default(value.getAll) && isFunction_default(value.entries) && isFunction_default(value[Symbol.iterator]));

// node_modules/form-data-encoder/lib/esm/FormDataEncoder.js
var __classPrivateFieldSet3 = function(receiver, state, value, kind2, f3) {
  if (kind2 === "m") throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f3) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet4 = function(receiver, state, kind2, f3) {
  if (kind2 === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f3 : kind2 === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
};
var _FormDataEncoder_instances;
var _FormDataEncoder_CRLF;
var _FormDataEncoder_CRLF_BYTES;
var _FormDataEncoder_CRLF_BYTES_LENGTH;
var _FormDataEncoder_DASHES;
var _FormDataEncoder_encoder;
var _FormDataEncoder_footer;
var _FormDataEncoder_form;
var _FormDataEncoder_options;
var _FormDataEncoder_getFieldHeader;
var defaultOptions = {
  enableAdditionalHeaders: false
};
var FormDataEncoder = class {
  constructor(form, boundaryOrOptions, options) {
    _FormDataEncoder_instances.add(this);
    _FormDataEncoder_CRLF.set(this, "\r\n");
    _FormDataEncoder_CRLF_BYTES.set(this, void 0);
    _FormDataEncoder_CRLF_BYTES_LENGTH.set(this, void 0);
    _FormDataEncoder_DASHES.set(this, "-".repeat(2));
    _FormDataEncoder_encoder.set(this, new TextEncoder());
    _FormDataEncoder_footer.set(this, void 0);
    _FormDataEncoder_form.set(this, void 0);
    _FormDataEncoder_options.set(this, void 0);
    if (!isFormData(form)) {
      throw new TypeError("Expected first argument to be a FormData instance.");
    }
    let boundary;
    if (isPlainObject_default(boundaryOrOptions)) {
      options = boundaryOrOptions;
    } else {
      boundary = boundaryOrOptions;
    }
    if (!boundary) {
      boundary = createBoundary_default();
    }
    if (typeof boundary !== "string") {
      throw new TypeError("Expected boundary argument to be a string.");
    }
    if (options && !isPlainObject_default(options)) {
      throw new TypeError("Expected options argument to be an object.");
    }
    __classPrivateFieldSet3(this, _FormDataEncoder_form, form, "f");
    __classPrivateFieldSet3(this, _FormDataEncoder_options, { ...defaultOptions, ...options }, "f");
    __classPrivateFieldSet3(this, _FormDataEncoder_CRLF_BYTES, __classPrivateFieldGet4(this, _FormDataEncoder_encoder, "f").encode(__classPrivateFieldGet4(this, _FormDataEncoder_CRLF, "f")), "f");
    __classPrivateFieldSet3(this, _FormDataEncoder_CRLF_BYTES_LENGTH, __classPrivateFieldGet4(this, _FormDataEncoder_CRLF_BYTES, "f").byteLength, "f");
    this.boundary = `form-data-boundary-${boundary}`;
    this.contentType = `multipart/form-data; boundary=${this.boundary}`;
    __classPrivateFieldSet3(this, _FormDataEncoder_footer, __classPrivateFieldGet4(this, _FormDataEncoder_encoder, "f").encode(`${__classPrivateFieldGet4(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet4(this, _FormDataEncoder_DASHES, "f")}${__classPrivateFieldGet4(this, _FormDataEncoder_CRLF, "f").repeat(2)}`), "f");
    this.contentLength = String(this.getContentLength());
    this.headers = Object.freeze({
      "Content-Type": this.contentType,
      "Content-Length": this.contentLength
    });
    Object.defineProperties(this, {
      boundary: { writable: false, configurable: false },
      contentType: { writable: false, configurable: false },
      contentLength: { writable: false, configurable: false },
      headers: { writable: false, configurable: false }
    });
  }
  getContentLength() {
    let length = 0;
    for (const [name, raw] of __classPrivateFieldGet4(this, _FormDataEncoder_form, "f")) {
      const value = isFileLike(raw) ? raw : __classPrivateFieldGet4(this, _FormDataEncoder_encoder, "f").encode(normalizeValue_default(raw));
      length += __classPrivateFieldGet4(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value).byteLength;
      length += isFileLike(value) ? value.size : value.byteLength;
      length += __classPrivateFieldGet4(this, _FormDataEncoder_CRLF_BYTES_LENGTH, "f");
    }
    return length + __classPrivateFieldGet4(this, _FormDataEncoder_footer, "f").byteLength;
  }
  *values() {
    for (const [name, raw] of __classPrivateFieldGet4(this, _FormDataEncoder_form, "f").entries()) {
      const value = isFileLike(raw) ? raw : __classPrivateFieldGet4(this, _FormDataEncoder_encoder, "f").encode(normalizeValue_default(raw));
      yield __classPrivateFieldGet4(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value);
      yield value;
      yield __classPrivateFieldGet4(this, _FormDataEncoder_CRLF_BYTES, "f");
    }
    yield __classPrivateFieldGet4(this, _FormDataEncoder_footer, "f");
  }
  async *encode() {
    for (const part of this.values()) {
      if (isFileLike(part)) {
        yield* part.stream();
      } else {
        yield part;
      }
    }
  }
  [(_FormDataEncoder_CRLF = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_CRLF_BYTES = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_CRLF_BYTES_LENGTH = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_DASHES = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_encoder = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_footer = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_form = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_options = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_instances = /* @__PURE__ */ new WeakSet(), _FormDataEncoder_getFieldHeader = function _FormDataEncoder_getFieldHeader2(name, value) {
    let header = "";
    header += `${__classPrivateFieldGet4(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet4(this, _FormDataEncoder_CRLF, "f")}`;
    header += `Content-Disposition: form-data; name="${escapeName_default(name)}"`;
    if (isFileLike(value)) {
      header += `; filename="${escapeName_default(value.name)}"${__classPrivateFieldGet4(this, _FormDataEncoder_CRLF, "f")}`;
      header += `Content-Type: ${value.type || "application/octet-stream"}`;
    }
    if (__classPrivateFieldGet4(this, _FormDataEncoder_options, "f").enableAdditionalHeaders === true) {
      header += `${__classPrivateFieldGet4(this, _FormDataEncoder_CRLF, "f")}Content-Length: ${isFileLike(value) ? value.size : value.byteLength}`;
    }
    return __classPrivateFieldGet4(this, _FormDataEncoder_encoder, "f").encode(`${header}${__classPrivateFieldGet4(this, _FormDataEncoder_CRLF, "f").repeat(2)}`);
  }, Symbol.iterator)]() {
    return this.values();
  }
  [Symbol.asyncIterator]() {
    return this.encode();
  }
};

// node_modules/openai/_shims/node-runtime.mjs
var import_node_stream = require("node:stream");

// node_modules/openai/_shims/MultipartBody.mjs
var MultipartBody = class {
  constructor(body) {
    this.body = body;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};

// node_modules/openai/_shims/node-runtime.mjs
var import_web = require("node:stream/web");
var fileFromPathWarned = false;
async function fileFromPath3(path2, ...args) {
  const { fileFromPath: _fileFromPath } = await Promise.resolve().then(() => (init_fileFromPath(), fileFromPath_exports));
  if (!fileFromPathWarned) {
    console.warn(`fileFromPath is deprecated; use fs.createReadStream(${JSON.stringify(path2)}) instead`);
    fileFromPathWarned = true;
  }
  return await _fileFromPath(path2, ...args);
}
var defaultHttpAgent = new import_agentkeepalive.default({ keepAlive: true, timeout: 5 * 60 * 1e3 });
var defaultHttpsAgent = new import_agentkeepalive.default.HttpsAgent({ keepAlive: true, timeout: 5 * 60 * 1e3 });
async function getMultipartRequestOptions2(form, opts) {
  const encoder = new FormDataEncoder(form);
  const readable = import_node_stream.Readable.from(encoder);
  const body = new MultipartBody(readable);
  const headers = {
    ...opts.headers,
    ...encoder.headers,
    "Content-Length": encoder.contentLength
  };
  return { ...opts, body, headers };
}
function getRuntime() {
  if (typeof AbortController === "undefined") {
    globalThis.AbortController = import_abort_controller.AbortController;
  }
  return {
    kind: "node",
    fetch: nf.default,
    Request: nf.Request,
    Response: nf.Response,
    Headers: nf.Headers,
    FormData: FormData2,
    Blob: Blob3,
    File: File3,
    ReadableStream: import_web.ReadableStream,
    getMultipartRequestOptions: getMultipartRequestOptions2,
    getDefaultAgent: (url) => url.startsWith("https") ? defaultHttpsAgent : defaultHttpAgent,
    fileFromPath: fileFromPath3,
    isFsReadStream: (value) => value instanceof import_node_fs.ReadStream
  };
}

// node_modules/openai/_shims/index.mjs
var init = () => {
  if (!kind) setShims(getRuntime(), { auto: true });
};
init();

// node_modules/openai/error.mjs
var OpenAIError = class extends Error {
};
var APIError = class _APIError extends OpenAIError {
  constructor(status, error, message, headers) {
    super(`${_APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    this.request_id = headers?.["x-request-id"];
    this.error = error;
    const data = error;
    this.code = data?.["code"];
    this.param = data?.["param"];
    this.type = data?.["type"];
  }
  static makeMessage(status, error, message) {
    const msg = error?.message ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status || !headers) {
      return new APIConnectionError({ message, cause: castToError(errorResponse) });
    }
    const error = errorResponse?.["error"];
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new _APIError(status, error, message, headers);
  }
};
var APIUserAbortError = class extends APIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
  }
};
var APIConnectionError = class extends APIError {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError = class extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message ?? "Request timed out." });
  }
};
var BadRequestError = class extends APIError {
};
var AuthenticationError = class extends APIError {
};
var PermissionDeniedError = class extends APIError {
};
var NotFoundError = class extends APIError {
};
var ConflictError = class extends APIError {
};
var UnprocessableEntityError = class extends APIError {
};
var RateLimitError = class extends APIError {
};
var InternalServerError = class extends APIError {
};
var LengthFinishReasonError = class extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the length limit was reached`);
  }
};
var ContentFilterFinishReasonError = class extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the request was rejected by the content filter`);
  }
};

// node_modules/openai/internal/decoders/line.mjs
var __classPrivateFieldSet5 = function(receiver, state, value, kind2, f3) {
  if (kind2 === "m") throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f3) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet6 = function(receiver, state, kind2, f3) {
  if (kind2 === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f3 : kind2 === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
};
var _LineDecoder_carriageReturnIndex;
var LineDecoder = class {
  constructor() {
    _LineDecoder_carriageReturnIndex.set(this, void 0);
    this.buffer = new Uint8Array();
    __classPrivateFieldSet5(this, _LineDecoder_carriageReturnIndex, null, "f");
  }
  decode(chunk) {
    if (chunk == null) {
      return [];
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
    let newData = new Uint8Array(this.buffer.length + binaryChunk.length);
    newData.set(this.buffer);
    newData.set(binaryChunk, this.buffer.length);
    this.buffer = newData;
    const lines = [];
    let patternIndex;
    while ((patternIndex = findNewlineIndex(this.buffer, __classPrivateFieldGet6(this, _LineDecoder_carriageReturnIndex, "f"))) != null) {
      if (patternIndex.carriage && __classPrivateFieldGet6(this, _LineDecoder_carriageReturnIndex, "f") == null) {
        __classPrivateFieldSet5(this, _LineDecoder_carriageReturnIndex, patternIndex.index, "f");
        continue;
      }
      if (__classPrivateFieldGet6(this, _LineDecoder_carriageReturnIndex, "f") != null && (patternIndex.index !== __classPrivateFieldGet6(this, _LineDecoder_carriageReturnIndex, "f") + 1 || patternIndex.carriage)) {
        lines.push(this.decodeText(this.buffer.slice(0, __classPrivateFieldGet6(this, _LineDecoder_carriageReturnIndex, "f") - 1)));
        this.buffer = this.buffer.slice(__classPrivateFieldGet6(this, _LineDecoder_carriageReturnIndex, "f"));
        __classPrivateFieldSet5(this, _LineDecoder_carriageReturnIndex, null, "f");
        continue;
      }
      const endIndex = __classPrivateFieldGet6(this, _LineDecoder_carriageReturnIndex, "f") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;
      const line = this.decodeText(this.buffer.slice(0, endIndex));
      lines.push(line);
      this.buffer = this.buffer.slice(patternIndex.index);
      __classPrivateFieldSet5(this, _LineDecoder_carriageReturnIndex, null, "f");
    }
    return lines;
  }
  decodeText(bytes) {
    if (bytes == null)
      return "";
    if (typeof bytes === "string")
      return bytes;
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder !== "undefined") {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8"));
        return this.textDecoder.decode(bytes);
      }
      throw new OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
  }
  flush() {
    if (!this.buffer.length) {
      return [];
    }
    return this.decode("\n");
  }
};
_LineDecoder_carriageReturnIndex = /* @__PURE__ */ new WeakMap();
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function findNewlineIndex(buffer, startIndex) {
  const newline = 10;
  const carriage = 13;
  for (let i3 = startIndex ?? 0; i3 < buffer.length; i3++) {
    if (buffer[i3] === newline) {
      return { preceding: i3, index: i3 + 1, carriage: false };
    }
    if (buffer[i3] === carriage) {
      return { preceding: i3, index: i3 + 1, carriage: true };
    }
  }
  return null;
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i3 = 0; i3 < buffer.length - 1; i3++) {
    if (buffer[i3] === newline && buffer[i3 + 1] === newline) {
      return i3 + 2;
    }
    if (buffer[i3] === carriage && buffer[i3 + 1] === carriage) {
      return i3 + 2;
    }
    if (buffer[i3] === carriage && buffer[i3 + 1] === newline && i3 + 3 < buffer.length && buffer[i3 + 2] === carriage && buffer[i3 + 3] === newline) {
      return i3 + 4;
    }
  }
  return -1;
}

// node_modules/openai/internal/stream-utils.mjs
function ReadableStreamToAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result?.done)
          reader.releaseLock();
        return result;
      } catch (e3) {
        reader.releaseLock();
        throw e3;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// node_modules/openai/streaming.mjs
var Stream2 = class _Stream {
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller;
  }
  static fromSSEResponse(response, controller) {
    let consumed = false;
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of _iterSSEMessages(response, controller)) {
          if (done)
            continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null || sse.event.startsWith("response.") || sse.event.startsWith("transcript.")) {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e3) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e3;
            }
            if (data && data.error) {
              throw new APIError(void 0, data.error, void 0, createResponseHeaders(response.headers));
            }
            yield data;
          } else {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e3) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e3;
            }
            if (sse.event == "error") {
              throw new APIError(void 0, data.error, data.message, void 0);
            }
            yield { event: sse.event, data };
          }
        }
        done = true;
      } catch (e3) {
        if (e3 instanceof Error && e3.name === "AbortError")
          return;
        throw e3;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new _Stream(iterator, controller);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder();
      const iter = ReadableStreamToAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e3) {
        if (e3 instanceof Error && e3.name === "AbortError")
          return;
        throw e3;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new _Stream(iterator, controller);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new _Stream(() => teeIterator(left), this.controller),
      new _Stream(() => teeIterator(right), this.controller)
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self2 = this;
    let iter;
    const encoder = new TextEncoder();
    return new ReadableStream2({
      async start() {
        iter = self2[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encoder.encode(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        await iter.return?.();
      }
    });
  }
};
async function* _iterSSEMessages(response, controller) {
  if (!response.body) {
    controller.abort();
    throw new OpenAIError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder();
  const lineDecoder = new LineDecoder();
  const iter = ReadableStreamToAsyncIterable(response.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks(iterator) {
  let data = new Uint8Array();
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
var SSEDecoder = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _3, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
function partition(str2, delimiter) {
  const index = str2.indexOf(delimiter);
  if (index !== -1) {
    return [str2.substring(0, index), delimiter, str2.substring(index + delimiter.length)];
  }
  return [str2, "", ""];
}

// node_modules/openai/uploads.mjs
var isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
var isFileLike2 = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isUploadable = (value) => {
  return isFileLike2(value) || isResponseLike(value) || isFsReadStream(value);
};
async function toFile(value, name, options) {
  value = await value;
  if (isFileLike2(value)) {
    return value;
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
    const data = isBlobLike(blob) ? [await blob.arrayBuffer()] : [blob];
    return new File2(data, name, options);
  }
  const bits = await getBytes(value);
  name || (name = getName(value) ?? "unknown_file");
  if (!options?.type) {
    const type = bits[0]?.type;
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return new File2(bits, name, options);
}
async function getBytes(value) {
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${value?.constructor?.name}; props: ${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p3) => `"${p3}"`).join(", ")}]`;
}
function getName(value) {
  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
  getStringFromMaybeBuffer(value.path)?.split(/[\\/]/).pop();
}
var getStringFromMaybeBuffer = (x3) => {
  if (typeof x3 === "string")
    return x3;
  if (typeof Buffer !== "undefined" && x3 instanceof Buffer)
    return String(x3);
  return void 0;
};
var isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
var multipartFormRequestOptions = async (opts) => {
  const form = await createForm(opts.body);
  return getMultipartRequestOptions(form, opts);
};
var createForm = async (body) => {
  const form = new FormData();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
var addFormValue = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (isUploadable(value)) {
    const file = await toFile(value);
    form.append(key, file);
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};

// node_modules/openai/core.mjs
var __classPrivateFieldSet6 = function(receiver, state, value, kind2, f3) {
  if (kind2 === "m") throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f3) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet7 = function(receiver, state, kind2, f3) {
  if (kind2 === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f3 : kind2 === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
};
var _AbstractPage_client;
init();
async function defaultParseResponse(props) {
  const { response } = props;
  if (props.options.stream) {
    debug("response", response.status, response.url, response.headers, response.body);
    if (props.options.__streamClass) {
      return props.options.__streamClass.fromSSEResponse(response, props.controller);
    }
    return Stream2.fromSSEResponse(response, props.controller);
  }
  if (response.status === 204) {
    return null;
  }
  if (props.options.__binaryResponse) {
    return response;
  }
  const contentType = response.headers.get("content-type");
  const mediaType = contentType?.split(";")[0]?.trim();
  const isJSON = mediaType?.includes("application/json") || mediaType?.endsWith("+json");
  if (isJSON) {
    const json = await response.json();
    debug("response", response.status, response.url, response.headers, json);
    return _addRequestID(json, response);
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}
function _addRequestID(value, response) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response.headers.get("x-request-id"),
    enumerable: false
  });
}
var APIPromise = class _APIPromise extends Promise {
  constructor(responsePromise, parseResponse2 = defaultParseResponse) {
    super((resolve2) => {
      resolve2(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse2;
  }
  _thenUnwrap(transform) {
    return new _APIPromise(this.responsePromise, async (props) => _addRequestID(transform(await this.parseResponse(props), props), props.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import … from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((p3) => p3.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the X-Request-ID header which is useful for debugging requests and reporting
   * issues to OpenAI.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import … from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response, request_id: response.headers.get("x-request-id") };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
var APIClient = class {
  constructor({
    baseURL,
    maxRetries = 2,
    timeout = 6e5,
    // 10 minutes
    httpAgent,
    fetch: overriddenFetch
  }) {
    this.baseURL = baseURL;
    this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
    this.timeout = validatePositiveInteger("timeout", timeout);
    this.httpAgent = httpAgent;
    this.fetch = overriddenFetch ?? fetch2;
  }
  authHeaders(opts) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(opts) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...getPlatformHeaders(),
      ...this.authHeaders(opts)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(headers, customHeaders) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  get(path2, opts) {
    return this.methodRequest("get", path2, opts);
  }
  post(path2, opts) {
    return this.methodRequest("post", path2, opts);
  }
  patch(path2, opts) {
    return this.methodRequest("patch", path2, opts);
  }
  put(path2, opts) {
    return this.methodRequest("put", path2, opts);
  }
  delete(path2, opts) {
    return this.methodRequest("delete", path2, opts);
  }
  methodRequest(method, path2, opts) {
    return this.request(Promise.resolve(opts).then(async (opts2) => {
      const body = opts2 && isBlobLike(opts2?.body) ? new DataView(await opts2.body.arrayBuffer()) : opts2?.body instanceof DataView ? opts2.body : opts2?.body instanceof ArrayBuffer ? new DataView(opts2.body) : opts2 && ArrayBuffer.isView(opts2?.body) ? new DataView(opts2.body.buffer) : opts2?.body;
      return { method, path: path2, ...opts2, body };
    }));
  }
  getAPIList(path2, Page3, opts) {
    return this.requestAPIList(Page3, { method: "get", path: path2, ...opts });
  }
  calculateContentLength(body) {
    if (typeof body === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.byteLength(body, "utf8").toString();
      }
      if (typeof TextEncoder !== "undefined") {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(body);
        return encoded.length.toString();
      }
    } else if (ArrayBuffer.isView(body)) {
      return body.byteLength.toString();
    }
    return null;
  }
  buildRequest(inputOptions, { retryCount = 0 } = {}) {
    const options = { ...inputOptions };
    const { method, path: path2, query, headers = {} } = options;
    const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === "string" ? options.body : isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
    const contentLength = this.calculateContentLength(body);
    const url = this.buildURL(path2, query);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    options.timeout = options.timeout ?? this.timeout;
    const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);
    const minAgentTimeout = options.timeout + 1e3;
    if (typeof httpAgent?.options?.timeout === "number" && minAgentTimeout > (httpAgent.options.timeout ?? 0)) {
      httpAgent.options.timeout = minAgentTimeout;
    }
    if (this.idempotencyHeader && method !== "get") {
      if (!inputOptions.idempotencyKey)
        inputOptions.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = inputOptions.idempotencyKey;
    }
    const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });
    const req = {
      method,
      ...body && { body },
      headers: reqHeaders,
      ...httpAgent && { agent: httpAgent },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: options.signal ?? null
    };
    return { req, url, timeout: options.timeout };
  }
  buildHeaders({ options, headers, contentLength, retryCount }) {
    const reqHeaders = {};
    if (contentLength) {
      reqHeaders["content-length"] = contentLength;
    }
    const defaultHeaders = this.defaultHeaders(options);
    applyHeadersMut(reqHeaders, defaultHeaders);
    applyHeadersMut(reqHeaders, headers);
    if (isMultipartBody(options.body) && kind !== "node") {
      delete reqHeaders["content-type"];
    }
    if (getHeader(defaultHeaders, "x-stainless-retry-count") === void 0 && getHeader(headers, "x-stainless-retry-count") === void 0) {
      reqHeaders["x-stainless-retry-count"] = String(retryCount);
    }
    if (getHeader(defaultHeaders, "x-stainless-timeout") === void 0 && getHeader(headers, "x-stainless-timeout") === void 0 && options.timeout) {
      reqHeaders["x-stainless-timeout"] = String(Math.trunc(options.timeout / 1e3));
    }
    this.validateHeaders(reqHeaders, headers);
    return reqHeaders;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(options) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options }) {
  }
  parseHeaders(headers) {
    return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
  }
  makeStatusError(status, error, message, headers) {
    return APIError.generate(status, error, message, headers);
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this.makeRequest(options, remainingRetries));
  }
  async makeRequest(optionsInput, retriesRemaining) {
    const options = await optionsInput;
    const maxRetries = options.maxRetries ?? this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });
    await this.prepareRequest(req, { url, options });
    debug("request", url, options, req.headers);
    if (options.signal?.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    if (response instanceof Error) {
      if (options.signal?.aborted) {
        throw new APIUserAbortError();
      }
      if (retriesRemaining) {
        return this.retryRequest(options, retriesRemaining);
      }
      if (response.name === "AbortError") {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }
    const responseHeaders = createResponseHeaders(response.headers);
    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        debug(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
        return this.retryRequest(options, retriesRemaining, responseHeaders);
      }
      const errText = await response.text().catch((e3) => castToError(e3).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
      debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
      throw err;
    }
    return { response, options, controller };
  }
  requestAPIList(Page3, options) {
    const request = this.makeRequest(options, null);
    return new PagePromise(this, request, Page3);
  }
  buildURL(path2, query) {
    const url = isAbsoluteURL(path2) ? new URL(path2) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path2.startsWith("/") ? path2.slice(1) : path2));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  stringifyQuery(query) {
    return Object.entries(query).filter(([_3, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(url, init2, ms2, controller) {
    const { signal, ...options } = init2 || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms2);
    const fetchOptions = {
      signal: controller.signal,
      ...options
    };
    if (fetchOptions.method) {
      fetchOptions.method = fetchOptions.method.toUpperCase();
    }
    return (
      // use undefined this binding; fetch errors if bound to something else in browser/cloudflare
      this.fetch.call(void 0, url, fetchOptions).finally(() => {
        clearTimeout(timeout);
      })
    );
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, responseHeaders) {
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders?.["retry-after-ms"];
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders?.["retry-after"];
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries = options.maxRetries ?? this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
};
var AbstractPage = class {
  constructor(client, response, body, options) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet6(this, _AbstractPage_client, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageInfo() != null;
  }
  async getNextPage() {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    const nextOptions = { ...this.options };
    if ("params" in nextInfo && typeof nextOptions.query === "object") {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ("url" in nextInfo) {
      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
      for (const [key, value] of params) {
        nextInfo.url.searchParams.set(key, value);
      }
      nextOptions.query = void 0;
      nextOptions.path = nextInfo.url.toString();
    }
    return await __classPrivateFieldGet7(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise = class extends APIPromise {
  constructor(client, request, Page3) {
    super(request, async (props) => new Page3(client, props.response, await defaultParseResponse(props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var createResponseHeaders = (headers) => {
  return new Proxy(Object.fromEntries(
    // @ts-ignore
    headers.entries()
  ), {
    get(target, name) {
      const key = name.toString();
      return target[key.toLowerCase()] || target[key];
    }
  });
};
var requestOptionsKeys = {
  method: true,
  path: true,
  query: true,
  body: true,
  headers: true,
  maxRetries: true,
  stream: true,
  timeout: true,
  httpAgent: true,
  signal: true,
  idempotencyKey: true,
  __metadata: true,
  __binaryRequest: true,
  __binaryResponse: true,
  __streamClass: true
};
var isRequestOptions = (obj) => {
  return typeof obj === "object" && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k3) => hasOwn(requestOptionsKeys, k3));
};
var getPlatformProperties = () => {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(process.platform),
      "X-Stainless-Arch": normalizeArch(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
};
var safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
var startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
var isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
};
var sleep = (ms2) => new Promise((resolve2) => setTimeout(resolve2, ms2));
var validatePositiveInteger = (name, n3) => {
  if (typeof n3 !== "number" || !Number.isInteger(n3)) {
    throw new OpenAIError(`${name} must be an integer`);
  }
  if (n3 < 0) {
    throw new OpenAIError(`${name} must be a positive integer`);
  }
  return n3;
};
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      return new Error(JSON.stringify(err));
    } catch {
    }
  }
  return new Error(err);
};
var readEnv = (env) => {
  if (typeof process !== "undefined") {
    return process.env?.[env]?.trim() ?? void 0;
  }
  if (typeof Deno !== "undefined") {
    return Deno.env?.get?.(env)?.trim();
  }
  return void 0;
};
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k2 in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function applyHeadersMut(targetHeaders, newHeaders) {
  for (const k3 in newHeaders) {
    if (!hasOwn(newHeaders, k3))
      continue;
    const lowerKey = k3.toLowerCase();
    if (!lowerKey)
      continue;
    const val = newHeaders[k3];
    if (val === null) {
      delete targetHeaders[lowerKey];
    } else if (val !== void 0) {
      targetHeaders[lowerKey] = val;
    }
  }
}
var SENSITIVE_HEADERS = /* @__PURE__ */ new Set(["authorization", "api-key"]);
function debug(action, ...args) {
  if (typeof process !== "undefined" && process?.env?.["DEBUG"] === "true") {
    const modifiedArgs = args.map((arg) => {
      if (!arg) {
        return arg;
      }
      if (arg["headers"]) {
        const modifiedArg2 = { ...arg, headers: { ...arg["headers"] } };
        for (const header in arg["headers"]) {
          if (SENSITIVE_HEADERS.has(header.toLowerCase())) {
            modifiedArg2["headers"][header] = "REDACTED";
          }
        }
        return modifiedArg2;
      }
      let modifiedArg = null;
      for (const header in arg) {
        if (SENSITIVE_HEADERS.has(header.toLowerCase())) {
          modifiedArg ?? (modifiedArg = { ...arg });
          modifiedArg[header] = "REDACTED";
        }
      }
      return modifiedArg ?? arg;
    });
    console.log(`OpenAI:DEBUG:${action}`, ...modifiedArgs);
  }
}
var uuid4 = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c3) => {
    const r3 = Math.random() * 16 | 0;
    const v3 = c3 === "x" ? r3 : r3 & 3 | 8;
    return v3.toString(16);
  });
};
var isRunningInBrowser = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};
var isHeadersProtocol = (headers) => {
  return typeof headers?.get === "function";
};
var getHeader = (headers, header) => {
  const lowerCasedHeader = header.toLowerCase();
  if (isHeadersProtocol(headers)) {
    const intercapsHeader = header[0]?.toUpperCase() + header.substring(1).replace(/([^\w])(\w)/g, (_m, g1, g22) => g1 + g22.toUpperCase());
    for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {
      const value = headers.get(key);
      if (value) {
        return value;
      }
    }
  }
  for (const [key, value] of Object.entries(headers)) {
    if (key.toLowerCase() === lowerCasedHeader) {
      if (Array.isArray(value)) {
        if (value.length <= 1)
          return value[0];
        console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);
        return value[0];
      }
      return value;
    }
  }
  return void 0;
};
var toFloat32Array = (base64Str) => {
  if (typeof Buffer !== "undefined") {
    const buf = Buffer.from(base64Str, "base64");
    return Array.from(new Float32Array(buf.buffer, buf.byteOffset, buf.length / Float32Array.BYTES_PER_ELEMENT));
  } else {
    const binaryStr = atob(base64Str);
    const len = binaryStr.length;
    const bytes = new Uint8Array(len);
    for (let i3 = 0; i3 < len; i3++) {
      bytes[i3] = binaryStr.charCodeAt(i3);
    }
    return Array.from(new Float32Array(bytes.buffer));
  }
};
function isObj(obj) {
  return obj != null && typeof obj === "object" && !Array.isArray(obj);
}

// node_modules/openai/pagination.mjs
var Page2 = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.object = body.object;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  // @deprecated Please use `nextPageInfo()` instead
  /**
   * This page represents a response that isn't actually paginated at the API level
   * so there will never be any next page params.
   */
  nextPageParams() {
    return null;
  }
  nextPageInfo() {
    return null;
  }
};
var CursorPage = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  // @deprecated Please use `nextPageInfo()` instead
  nextPageParams() {
    const info2 = this.nextPageInfo();
    if (!info2)
      return null;
    if ("params" in info2)
      return info2.params;
    const params = Object.fromEntries(info2.url.searchParams);
    if (!Object.keys(params).length)
      return null;
    return params;
  }
  nextPageInfo() {
    const data = this.getPaginatedItems();
    if (!data.length) {
      return null;
    }
    const id = data[data.length - 1]?.id;
    if (!id) {
      return null;
    }
    return { params: { after: id } };
  }
};

// node_modules/openai/resource.mjs
var APIResource = class {
  constructor(client) {
    this._client = client;
  }
};

// node_modules/openai/resources/chat/completions/messages.mjs
var Messages = class extends APIResource {
  list(completionId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(completionId, {}, query);
    }
    return this._client.getAPIList(`/chat/completions/${completionId}/messages`, ChatCompletionStoreMessagesPage, { query, ...options });
  }
};

// node_modules/openai/resources/chat/completions/completions.mjs
var Completions = class extends APIResource {
  constructor() {
    super(...arguments);
    this.messages = new Messages(this._client);
  }
  create(body, options) {
    return this._client.post("/chat/completions", { body, ...options, stream: body.stream ?? false });
  }
  /**
   * Get a stored chat completion. Only Chat Completions that have been created with
   * the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * const chatCompletion =
   *   await client.chat.completions.retrieve('completion_id');
   * ```
   */
  retrieve(completionId, options) {
    return this._client.get(`/chat/completions/${completionId}`, options);
  }
  /**
   * Modify a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be modified. Currently, the only
   * supported modification is to update the `metadata` field.
   *
   * @example
   * ```ts
   * const chatCompletion = await client.chat.completions.update(
   *   'completion_id',
   *   { metadata: { foo: 'string' } },
   * );
   * ```
   */
  update(completionId, body, options) {
    return this._client.post(`/chat/completions/${completionId}`, { body, ...options });
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/chat/completions", ChatCompletionsPage, { query, ...options });
  }
  /**
   * Delete a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be deleted.
   *
   * @example
   * ```ts
   * const chatCompletionDeleted =
   *   await client.chat.completions.del('completion_id');
   * ```
   */
  del(completionId, options) {
    return this._client.delete(`/chat/completions/${completionId}`, options);
  }
};
var ChatCompletionsPage = class extends CursorPage {
};
var ChatCompletionStoreMessagesPage = class extends CursorPage {
};
Completions.ChatCompletionsPage = ChatCompletionsPage;
Completions.Messages = Messages;

// node_modules/openai/resources/chat/chat.mjs
var Chat = class extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions(this._client);
  }
};
Chat.Completions = Completions;
Chat.ChatCompletionsPage = ChatCompletionsPage;

// node_modules/openai/resources/audio/speech.mjs
var Speech = class extends APIResource {
  /**
   * Generates audio from the input text.
   *
   * @example
   * ```ts
   * const speech = await client.audio.speech.create({
   *   input: 'input',
   *   model: 'string',
   *   voice: 'ash',
   * });
   *
   * const content = await speech.blob();
   * console.log(content);
   * ```
   */
  create(body, options) {
    return this._client.post("/audio/speech", {
      body,
      ...options,
      headers: { Accept: "application/octet-stream", ...options?.headers },
      __binaryResponse: true
    });
  }
};

// node_modules/openai/resources/audio/transcriptions.mjs
var Transcriptions = class extends APIResource {
  create(body, options) {
    return this._client.post("/audio/transcriptions", multipartFormRequestOptions({
      body,
      ...options,
      stream: body.stream ?? false,
      __metadata: { model: body.model }
    }));
  }
};

// node_modules/openai/resources/audio/translations.mjs
var Translations = class extends APIResource {
  create(body, options) {
    return this._client.post("/audio/translations", multipartFormRequestOptions({ body, ...options, __metadata: { model: body.model } }));
  }
};

// node_modules/openai/resources/audio/audio.mjs
var Audio = class extends APIResource {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this._client);
    this.translations = new Translations(this._client);
    this.speech = new Speech(this._client);
  }
};
Audio.Transcriptions = Transcriptions;
Audio.Translations = Translations;
Audio.Speech = Speech;

// node_modules/openai/resources/batches.mjs
var Batches = class extends APIResource {
  /**
   * Creates and executes a batch from an uploaded file of requests
   */
  create(body, options) {
    return this._client.post("/batches", { body, ...options });
  }
  /**
   * Retrieves a batch.
   */
  retrieve(batchId, options) {
    return this._client.get(`/batches/${batchId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/batches", BatchesPage, { query, ...options });
  }
  /**
   * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
   * 10 minutes, before changing to `cancelled`, where it will have partial results
   * (if any) available in the output file.
   */
  cancel(batchId, options) {
    return this._client.post(`/batches/${batchId}/cancel`, options);
  }
};
var BatchesPage = class extends CursorPage {
};
Batches.BatchesPage = BatchesPage;

// node_modules/openai/lib/EventStream.mjs
var __classPrivateFieldSet7 = function(receiver, state, value, kind2, f3) {
  if (kind2 === "m") throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f3) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet8 = function(receiver, state, kind2, f3) {
  if (kind2 === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f3 : kind2 === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
};
var _EventStream_instances;
var _EventStream_connectedPromise;
var _EventStream_resolveConnectedPromise;
var _EventStream_rejectConnectedPromise;
var _EventStream_endPromise;
var _EventStream_resolveEndPromise;
var _EventStream_rejectEndPromise;
var _EventStream_listeners;
var _EventStream_ended;
var _EventStream_errored;
var _EventStream_aborted;
var _EventStream_catchingPromiseCreated;
var _EventStream_handleError;
var EventStream = class {
  constructor() {
    _EventStream_instances.add(this);
    this.controller = new AbortController();
    _EventStream_connectedPromise.set(this, void 0);
    _EventStream_resolveConnectedPromise.set(this, () => {
    });
    _EventStream_rejectConnectedPromise.set(this, () => {
    });
    _EventStream_endPromise.set(this, void 0);
    _EventStream_resolveEndPromise.set(this, () => {
    });
    _EventStream_rejectEndPromise.set(this, () => {
    });
    _EventStream_listeners.set(this, {});
    _EventStream_ended.set(this, false);
    _EventStream_errored.set(this, false);
    _EventStream_aborted.set(this, false);
    _EventStream_catchingPromiseCreated.set(this, false);
    __classPrivateFieldSet7(this, _EventStream_connectedPromise, new Promise((resolve2, reject) => {
      __classPrivateFieldSet7(this, _EventStream_resolveConnectedPromise, resolve2, "f");
      __classPrivateFieldSet7(this, _EventStream_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet7(this, _EventStream_endPromise, new Promise((resolve2, reject) => {
      __classPrivateFieldSet7(this, _EventStream_resolveEndPromise, resolve2, "f");
      __classPrivateFieldSet7(this, _EventStream_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet8(this, _EventStream_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet8(this, _EventStream_endPromise, "f").catch(() => {
    });
  }
  _run(executor) {
    setTimeout(() => {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet8(this, _EventStream_instances, "m", _EventStream_handleError).bind(this));
    }, 0);
  }
  _connected() {
    if (this.ended)
      return;
    __classPrivateFieldGet8(this, _EventStream_resolveConnectedPromise, "f").call(this);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet8(this, _EventStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet8(this, _EventStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet8(this, _EventStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners = __classPrivateFieldGet8(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet8(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners = __classPrivateFieldGet8(this, _EventStream_listeners, "f")[event];
    if (!listeners)
      return this;
    const index = listeners.findIndex((l3) => l3.listener === listener);
    if (index >= 0)
      listeners.splice(index, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners = __classPrivateFieldGet8(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet8(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve2, reject) => {
      __classPrivateFieldSet7(this, _EventStream_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve2);
    });
  }
  async done() {
    __classPrivateFieldSet7(this, _EventStream_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet8(this, _EventStream_endPromise, "f");
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet8(this, _EventStream_ended, "f")) {
      return;
    }
    if (event === "end") {
      __classPrivateFieldSet7(this, _EventStream_ended, true, "f");
      __classPrivateFieldGet8(this, _EventStream_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet8(this, _EventStream_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet8(this, _EventStream_listeners, "f")[event] = listeners.filter((l3) => !l3.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error = args[0];
      if (!__classPrivateFieldGet8(this, _EventStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error);
      }
      __classPrivateFieldGet8(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet8(this, _EventStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error = args[0];
      if (!__classPrivateFieldGet8(this, _EventStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error);
      }
      __classPrivateFieldGet8(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet8(this, _EventStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
    }
  }
  _emitFinal() {
  }
};
_EventStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_endPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_listeners = /* @__PURE__ */ new WeakMap(), _EventStream_ended = /* @__PURE__ */ new WeakMap(), _EventStream_errored = /* @__PURE__ */ new WeakMap(), _EventStream_aborted = /* @__PURE__ */ new WeakMap(), _EventStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _EventStream_instances = /* @__PURE__ */ new WeakSet(), _EventStream_handleError = function _EventStream_handleError2(error) {
  __classPrivateFieldSet7(this, _EventStream_errored, true, "f");
  if (error instanceof Error && error.name === "AbortError") {
    error = new APIUserAbortError();
  }
  if (error instanceof APIUserAbortError) {
    __classPrivateFieldSet7(this, _EventStream_aborted, true, "f");
    return this._emit("abort", error);
  }
  if (error instanceof OpenAIError) {
    return this._emit("error", error);
  }
  if (error instanceof Error) {
    const openAIError = new OpenAIError(error.message);
    openAIError.cause = error;
    return this._emit("error", openAIError);
  }
  return this._emit("error", new OpenAIError(String(error)));
};

// node_modules/openai/lib/AssistantStream.mjs
var __classPrivateFieldGet9 = function(receiver, state, kind2, f3) {
  if (kind2 === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f3 : kind2 === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
};
var __classPrivateFieldSet8 = function(receiver, state, value, kind2, f3) {
  if (kind2 === "m") throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f3) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state.set(receiver, value), value;
};
var _AssistantStream_instances;
var _AssistantStream_events;
var _AssistantStream_runStepSnapshots;
var _AssistantStream_messageSnapshots;
var _AssistantStream_messageSnapshot;
var _AssistantStream_finalRun;
var _AssistantStream_currentContentIndex;
var _AssistantStream_currentContent;
var _AssistantStream_currentToolCallIndex;
var _AssistantStream_currentToolCall;
var _AssistantStream_currentEvent;
var _AssistantStream_currentRunSnapshot;
var _AssistantStream_currentRunStepSnapshot;
var _AssistantStream_addEvent;
var _AssistantStream_endRequest;
var _AssistantStream_handleMessage;
var _AssistantStream_handleRunStep;
var _AssistantStream_handleEvent;
var _AssistantStream_accumulateRunStep;
var _AssistantStream_accumulateMessage;
var _AssistantStream_accumulateContent;
var _AssistantStream_handleRun;
var AssistantStream = class _AssistantStream extends EventStream {
  constructor() {
    super(...arguments);
    _AssistantStream_instances.add(this);
    _AssistantStream_events.set(this, []);
    _AssistantStream_runStepSnapshots.set(this, {});
    _AssistantStream_messageSnapshots.set(this, {});
    _AssistantStream_messageSnapshot.set(this, void 0);
    _AssistantStream_finalRun.set(this, void 0);
    _AssistantStream_currentContentIndex.set(this, void 0);
    _AssistantStream_currentContent.set(this, void 0);
    _AssistantStream_currentToolCallIndex.set(this, void 0);
    _AssistantStream_currentToolCall.set(this, void 0);
    _AssistantStream_currentEvent.set(this, void 0);
    _AssistantStream_currentRunSnapshot.set(this, void 0);
    _AssistantStream_currentRunStepSnapshot.set(this, void 0);
  }
  [(_AssistantStream_events = /* @__PURE__ */ new WeakMap(), _AssistantStream_runStepSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_finalRun = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContentIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCallIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCall = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentEvent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunStepSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_instances = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve2, reject) => readQueue.push({ resolve: resolve2, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  static fromReadableStream(stream) {
    const runner = new _AssistantStream();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  async _fromReadableStream(readableStream, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    this._connected();
    const stream = Stream2.fromReadableStream(readableStream, this.controller);
    for await (const event of stream) {
      __classPrivateFieldGet9(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet9(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  toReadableStream() {
    const stream = new Stream2(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
  static createToolAssistantStream(threadId, runId, runs, params, options) {
    const runner = new _AssistantStream();
    runner._run(() => runner._runToolAssistantStream(threadId, runId, runs, params, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createToolAssistantStream(run, threadId, runId, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run.submitToolOutputs(threadId, runId, body, {
      ...options,
      signal: this.controller.signal
    });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet9(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet9(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static createThreadAssistantStream(params, thread, options) {
    const runner = new _AssistantStream();
    runner._run(() => runner._threadAssistantStream(params, thread, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  static createAssistantStream(threadId, runs, params, options) {
    const runner = new _AssistantStream();
    runner._run(() => runner._runAssistantStream(threadId, runs, params, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  currentEvent() {
    return __classPrivateFieldGet9(this, _AssistantStream_currentEvent, "f");
  }
  currentRun() {
    return __classPrivateFieldGet9(this, _AssistantStream_currentRunSnapshot, "f");
  }
  currentMessageSnapshot() {
    return __classPrivateFieldGet9(this, _AssistantStream_messageSnapshot, "f");
  }
  currentRunStepSnapshot() {
    return __classPrivateFieldGet9(this, _AssistantStream_currentRunStepSnapshot, "f");
  }
  async finalRunSteps() {
    await this.done();
    return Object.values(__classPrivateFieldGet9(this, _AssistantStream_runStepSnapshots, "f"));
  }
  async finalMessages() {
    await this.done();
    return Object.values(__classPrivateFieldGet9(this, _AssistantStream_messageSnapshots, "f"));
  }
  async finalRun() {
    await this.done();
    if (!__classPrivateFieldGet9(this, _AssistantStream_finalRun, "f"))
      throw Error("Final run was not received.");
    return __classPrivateFieldGet9(this, _AssistantStream_finalRun, "f");
  }
  async _createThreadAssistantStream(thread, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet9(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet9(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  async _createAssistantStream(run, threadId, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run.create(threadId, body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet9(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet9(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static accumulateDelta(acc, delta) {
    for (const [key, deltaValue] of Object.entries(delta)) {
      if (!acc.hasOwnProperty(key)) {
        acc[key] = deltaValue;
        continue;
      }
      let accValue = acc[key];
      if (accValue === null || accValue === void 0) {
        acc[key] = deltaValue;
        continue;
      }
      if (key === "index" || key === "type") {
        acc[key] = deltaValue;
        continue;
      }
      if (typeof accValue === "string" && typeof deltaValue === "string") {
        accValue += deltaValue;
      } else if (typeof accValue === "number" && typeof deltaValue === "number") {
        accValue += deltaValue;
      } else if (isObj(accValue) && isObj(deltaValue)) {
        accValue = this.accumulateDelta(accValue, deltaValue);
      } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
        if (accValue.every((x3) => typeof x3 === "string" || typeof x3 === "number")) {
          accValue.push(...deltaValue);
          continue;
        }
        for (const deltaEntry of deltaValue) {
          if (!isObj(deltaEntry)) {
            throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);
          }
          const index = deltaEntry["index"];
          if (index == null) {
            console.error(deltaEntry);
            throw new Error("Expected array delta entry to have an `index` property");
          }
          if (typeof index !== "number") {
            throw new Error(`Expected array delta entry \`index\` property to be a number but got ${index}`);
          }
          const accEntry = accValue[index];
          if (accEntry == null) {
            accValue.push(deltaEntry);
          } else {
            accValue[index] = this.accumulateDelta(accEntry, deltaEntry);
          }
        }
        continue;
      } else {
        throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);
      }
      acc[key] = accValue;
    }
    return acc;
  }
  _addRun(run) {
    return run;
  }
  async _threadAssistantStream(params, thread, options) {
    return await this._createThreadAssistantStream(thread, params, options);
  }
  async _runAssistantStream(threadId, runs, params, options) {
    return await this._createAssistantStream(runs, threadId, params, options);
  }
  async _runToolAssistantStream(threadId, runId, runs, params, options) {
    return await this._createToolAssistantStream(runs, threadId, runId, params, options);
  }
};
_AssistantStream_addEvent = function _AssistantStream_addEvent2(event) {
  if (this.ended)
    return;
  __classPrivateFieldSet8(this, _AssistantStream_currentEvent, event, "f");
  __classPrivateFieldGet9(this, _AssistantStream_instances, "m", _AssistantStream_handleEvent).call(this, event);
  switch (event.event) {
    case "thread.created":
      break;
    case "thread.run.created":
    case "thread.run.queued":
    case "thread.run.in_progress":
    case "thread.run.requires_action":
    case "thread.run.completed":
    case "thread.run.incomplete":
    case "thread.run.failed":
    case "thread.run.cancelling":
    case "thread.run.cancelled":
    case "thread.run.expired":
      __classPrivateFieldGet9(this, _AssistantStream_instances, "m", _AssistantStream_handleRun).call(this, event);
      break;
    case "thread.run.step.created":
    case "thread.run.step.in_progress":
    case "thread.run.step.delta":
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldGet9(this, _AssistantStream_instances, "m", _AssistantStream_handleRunStep).call(this, event);
      break;
    case "thread.message.created":
    case "thread.message.in_progress":
    case "thread.message.delta":
    case "thread.message.completed":
    case "thread.message.incomplete":
      __classPrivateFieldGet9(this, _AssistantStream_instances, "m", _AssistantStream_handleMessage).call(this, event);
      break;
    case "error":
      throw new Error("Encountered an error event in event processing - errors should be processed earlier");
    default:
      assertNever(event);
  }
}, _AssistantStream_endRequest = function _AssistantStream_endRequest2() {
  if (this.ended) {
    throw new OpenAIError(`stream has ended, this shouldn't happen`);
  }
  if (!__classPrivateFieldGet9(this, _AssistantStream_finalRun, "f"))
    throw Error("Final run has not been received");
  return __classPrivateFieldGet9(this, _AssistantStream_finalRun, "f");
}, _AssistantStream_handleMessage = function _AssistantStream_handleMessage2(event) {
  const [accumulatedMessage, newContent] = __classPrivateFieldGet9(this, _AssistantStream_instances, "m", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet9(this, _AssistantStream_messageSnapshot, "f"));
  __classPrivateFieldSet8(this, _AssistantStream_messageSnapshot, accumulatedMessage, "f");
  __classPrivateFieldGet9(this, _AssistantStream_messageSnapshots, "f")[accumulatedMessage.id] = accumulatedMessage;
  for (const content of newContent) {
    const snapshotContent = accumulatedMessage.content[content.index];
    if (snapshotContent?.type == "text") {
      this._emit("textCreated", snapshotContent.text);
    }
  }
  switch (event.event) {
    case "thread.message.created":
      this._emit("messageCreated", event.data);
      break;
    case "thread.message.in_progress":
      break;
    case "thread.message.delta":
      this._emit("messageDelta", event.data.delta, accumulatedMessage);
      if (event.data.delta.content) {
        for (const content of event.data.delta.content) {
          if (content.type == "text" && content.text) {
            let textDelta = content.text;
            let snapshot = accumulatedMessage.content[content.index];
            if (snapshot && snapshot.type == "text") {
              this._emit("textDelta", textDelta, snapshot.text);
            } else {
              throw Error("The snapshot associated with this text delta is not text or missing");
            }
          }
          if (content.index != __classPrivateFieldGet9(this, _AssistantStream_currentContentIndex, "f")) {
            if (__classPrivateFieldGet9(this, _AssistantStream_currentContent, "f")) {
              switch (__classPrivateFieldGet9(this, _AssistantStream_currentContent, "f").type) {
                case "text":
                  this._emit("textDone", __classPrivateFieldGet9(this, _AssistantStream_currentContent, "f").text, __classPrivateFieldGet9(this, _AssistantStream_messageSnapshot, "f"));
                  break;
                case "image_file":
                  this._emit("imageFileDone", __classPrivateFieldGet9(this, _AssistantStream_currentContent, "f").image_file, __classPrivateFieldGet9(this, _AssistantStream_messageSnapshot, "f"));
                  break;
              }
            }
            __classPrivateFieldSet8(this, _AssistantStream_currentContentIndex, content.index, "f");
          }
          __classPrivateFieldSet8(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], "f");
        }
      }
      break;
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (__classPrivateFieldGet9(this, _AssistantStream_currentContentIndex, "f") !== void 0) {
        const currentContent = event.data.content[__classPrivateFieldGet9(this, _AssistantStream_currentContentIndex, "f")];
        if (currentContent) {
          switch (currentContent.type) {
            case "image_file":
              this._emit("imageFileDone", currentContent.image_file, __classPrivateFieldGet9(this, _AssistantStream_messageSnapshot, "f"));
              break;
            case "text":
              this._emit("textDone", currentContent.text, __classPrivateFieldGet9(this, _AssistantStream_messageSnapshot, "f"));
              break;
          }
        }
      }
      if (__classPrivateFieldGet9(this, _AssistantStream_messageSnapshot, "f")) {
        this._emit("messageDone", event.data);
      }
      __classPrivateFieldSet8(this, _AssistantStream_messageSnapshot, void 0, "f");
  }
}, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep2(event) {
  const accumulatedRunStep = __classPrivateFieldGet9(this, _AssistantStream_instances, "m", _AssistantStream_accumulateRunStep).call(this, event);
  __classPrivateFieldSet8(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, "f");
  switch (event.event) {
    case "thread.run.step.created":
      this._emit("runStepCreated", event.data);
      break;
    case "thread.run.step.delta":
      const delta = event.data.delta;
      if (delta.step_details && delta.step_details.type == "tool_calls" && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == "tool_calls") {
        for (const toolCall of delta.step_details.tool_calls) {
          if (toolCall.index == __classPrivateFieldGet9(this, _AssistantStream_currentToolCallIndex, "f")) {
            this._emit("toolCallDelta", toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
          } else {
            if (__classPrivateFieldGet9(this, _AssistantStream_currentToolCall, "f")) {
              this._emit("toolCallDone", __classPrivateFieldGet9(this, _AssistantStream_currentToolCall, "f"));
            }
            __classPrivateFieldSet8(this, _AssistantStream_currentToolCallIndex, toolCall.index, "f");
            __classPrivateFieldSet8(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], "f");
            if (__classPrivateFieldGet9(this, _AssistantStream_currentToolCall, "f"))
              this._emit("toolCallCreated", __classPrivateFieldGet9(this, _AssistantStream_currentToolCall, "f"));
          }
        }
      }
      this._emit("runStepDelta", event.data.delta, accumulatedRunStep);
      break;
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldSet8(this, _AssistantStream_currentRunStepSnapshot, void 0, "f");
      const details = event.data.step_details;
      if (details.type == "tool_calls") {
        if (__classPrivateFieldGet9(this, _AssistantStream_currentToolCall, "f")) {
          this._emit("toolCallDone", __classPrivateFieldGet9(this, _AssistantStream_currentToolCall, "f"));
          __classPrivateFieldSet8(this, _AssistantStream_currentToolCall, void 0, "f");
        }
      }
      this._emit("runStepDone", event.data, accumulatedRunStep);
      break;
    case "thread.run.step.in_progress":
      break;
  }
}, _AssistantStream_handleEvent = function _AssistantStream_handleEvent2(event) {
  __classPrivateFieldGet9(this, _AssistantStream_events, "f").push(event);
  this._emit("event", event);
}, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep2(event) {
  switch (event.event) {
    case "thread.run.step.created":
      __classPrivateFieldGet9(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      return event.data;
    case "thread.run.step.delta":
      let snapshot = __classPrivateFieldGet9(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
      if (!snapshot) {
        throw Error("Received a RunStepDelta before creation of a snapshot");
      }
      let data = event.data;
      if (data.delta) {
        const accumulated = AssistantStream.accumulateDelta(snapshot, data.delta);
        __classPrivateFieldGet9(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = accumulated;
      }
      return __classPrivateFieldGet9(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
    case "thread.run.step.in_progress":
      __classPrivateFieldGet9(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      break;
  }
  if (__classPrivateFieldGet9(this, _AssistantStream_runStepSnapshots, "f")[event.data.id])
    return __classPrivateFieldGet9(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
  throw new Error("No snapshot available");
}, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage2(event, snapshot) {
  let newContent = [];
  switch (event.event) {
    case "thread.message.created":
      return [event.data, newContent];
    case "thread.message.delta":
      if (!snapshot) {
        throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
      }
      let data = event.data;
      if (data.delta.content) {
        for (const contentElement of data.delta.content) {
          if (contentElement.index in snapshot.content) {
            let currentContent = snapshot.content[contentElement.index];
            snapshot.content[contentElement.index] = __classPrivateFieldGet9(this, _AssistantStream_instances, "m", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);
          } else {
            snapshot.content[contentElement.index] = contentElement;
            newContent.push(contentElement);
          }
        }
      }
      return [snapshot, newContent];
    case "thread.message.in_progress":
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (snapshot) {
        return [snapshot, newContent];
      } else {
        throw Error("Received thread message event with no existing snapshot");
      }
  }
  throw Error("Tried to accumulate a non-message event");
}, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent2(contentElement, currentContent) {
  return AssistantStream.accumulateDelta(currentContent, contentElement);
}, _AssistantStream_handleRun = function _AssistantStream_handleRun2(event) {
  __classPrivateFieldSet8(this, _AssistantStream_currentRunSnapshot, event.data, "f");
  switch (event.event) {
    case "thread.run.created":
      break;
    case "thread.run.queued":
      break;
    case "thread.run.in_progress":
      break;
    case "thread.run.requires_action":
    case "thread.run.cancelled":
    case "thread.run.failed":
    case "thread.run.completed":
    case "thread.run.expired":
      __classPrivateFieldSet8(this, _AssistantStream_finalRun, event.data, "f");
      if (__classPrivateFieldGet9(this, _AssistantStream_currentToolCall, "f")) {
        this._emit("toolCallDone", __classPrivateFieldGet9(this, _AssistantStream_currentToolCall, "f"));
        __classPrivateFieldSet8(this, _AssistantStream_currentToolCall, void 0, "f");
      }
      break;
    case "thread.run.cancelling":
      break;
  }
};
function assertNever(_x) {
}

// node_modules/openai/resources/beta/assistants.mjs
var Assistants = class extends APIResource {
  /**
   * Create an assistant with a model and instructions.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.create({
   *   model: 'gpt-4o',
   * });
   * ```
   */
  create(body, options) {
    return this._client.post("/assistants", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Retrieves an assistant.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.retrieve(
   *   'assistant_id',
   * );
   * ```
   */
  retrieve(assistantId, options) {
    return this._client.get(`/assistants/${assistantId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Modifies an assistant.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.update(
   *   'assistant_id',
   * );
   * ```
   */
  update(assistantId, body, options) {
    return this._client.post(`/assistants/${assistantId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/assistants", AssistantsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Delete an assistant.
   *
   * @example
   * ```ts
   * const assistantDeleted = await client.beta.assistants.del(
   *   'assistant_id',
   * );
   * ```
   */
  del(assistantId, options) {
    return this._client.delete(`/assistants/${assistantId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
};
var AssistantsPage = class extends CursorPage {
};
Assistants.AssistantsPage = AssistantsPage;

// node_modules/openai/lib/RunnableFunction.mjs
function isRunnableFunctionWithParse(fn2) {
  return typeof fn2.parse === "function";
}

// node_modules/openai/lib/chatCompletionUtils.mjs
var isAssistantMessage = (message) => {
  return message?.role === "assistant";
};
var isFunctionMessage = (message) => {
  return message?.role === "function";
};
var isToolMessage = (message) => {
  return message?.role === "tool";
};

// node_modules/openai/lib/parser.mjs
function isAutoParsableResponseFormat(response_format) {
  return response_format?.["$brand"] === "auto-parseable-response-format";
}
function isAutoParsableTool(tool) {
  return tool?.["$brand"] === "auto-parseable-tool";
}
function maybeParseChatCompletion(completion, params) {
  if (!params || !hasAutoParseableInput(params)) {
    return {
      ...completion,
      choices: completion.choices.map((choice) => ({
        ...choice,
        message: {
          ...choice.message,
          parsed: null,
          ...choice.message.tool_calls ? {
            tool_calls: choice.message.tool_calls
          } : void 0
        }
      }))
    };
  }
  return parseChatCompletion(completion, params);
}
function parseChatCompletion(completion, params) {
  const choices = completion.choices.map((choice) => {
    if (choice.finish_reason === "length") {
      throw new LengthFinishReasonError();
    }
    if (choice.finish_reason === "content_filter") {
      throw new ContentFilterFinishReasonError();
    }
    return {
      ...choice,
      message: {
        ...choice.message,
        ...choice.message.tool_calls ? {
          tool_calls: choice.message.tool_calls?.map((toolCall) => parseToolCall(params, toolCall)) ?? void 0
        } : void 0,
        parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null
      }
    };
  });
  return { ...completion, choices };
}
function parseResponseFormat(params, content) {
  if (params.response_format?.type !== "json_schema") {
    return null;
  }
  if (params.response_format?.type === "json_schema") {
    if ("$parseRaw" in params.response_format) {
      const response_format = params.response_format;
      return response_format.$parseRaw(content);
    }
    return JSON.parse(content);
  }
  return null;
}
function parseToolCall(params, toolCall) {
  const inputTool = params.tools?.find((inputTool2) => inputTool2.function?.name === toolCall.function.name);
  return {
    ...toolCall,
    function: {
      ...toolCall.function,
      parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCall.function.arguments) : null
    }
  };
}
function shouldParseToolCall(params, toolCall) {
  if (!params) {
    return false;
  }
  const inputTool = params.tools?.find((inputTool2) => inputTool2.function?.name === toolCall.function.name);
  return isAutoParsableTool(inputTool) || inputTool?.function.strict || false;
}
function hasAutoParseableInput(params) {
  if (isAutoParsableResponseFormat(params.response_format)) {
    return true;
  }
  return params.tools?.some((t3) => isAutoParsableTool(t3) || t3.type === "function" && t3.function.strict === true) ?? false;
}
function validateInputTools(tools) {
  for (const tool of tools ?? []) {
    if (tool.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``);
    }
    if (tool.function.strict !== true) {
      throw new OpenAIError(`The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
    }
  }
}

// node_modules/openai/lib/AbstractChatCompletionRunner.mjs
var __classPrivateFieldGet10 = function(receiver, state, kind2, f3) {
  if (kind2 === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f3 : kind2 === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
};
var _AbstractChatCompletionRunner_instances;
var _AbstractChatCompletionRunner_getFinalContent;
var _AbstractChatCompletionRunner_getFinalMessage;
var _AbstractChatCompletionRunner_getFinalFunctionCall;
var _AbstractChatCompletionRunner_getFinalFunctionCallResult;
var _AbstractChatCompletionRunner_calculateTotalUsage;
var _AbstractChatCompletionRunner_validateParams;
var _AbstractChatCompletionRunner_stringifyFunctionCallResult;
var DEFAULT_MAX_CHAT_COMPLETIONS = 10;
var AbstractChatCompletionRunner = class extends EventStream {
  constructor() {
    super(...arguments);
    _AbstractChatCompletionRunner_instances.add(this);
    this._chatCompletions = [];
    this.messages = [];
  }
  _addChatCompletion(chatCompletion) {
    this._chatCompletions.push(chatCompletion);
    this._emit("chatCompletion", chatCompletion);
    const message = chatCompletion.choices[0]?.message;
    if (message)
      this._addMessage(message);
    return chatCompletion;
  }
  _addMessage(message, emit = true) {
    if (!("content" in message))
      message.content = null;
    this.messages.push(message);
    if (emit) {
      this._emit("message", message);
      if ((isFunctionMessage(message) || isToolMessage(message)) && message.content) {
        this._emit("functionCallResult", message.content);
      } else if (isAssistantMessage(message) && message.function_call) {
        this._emit("functionCall", message.function_call);
      } else if (isAssistantMessage(message) && message.tool_calls) {
        for (const tool_call of message.tool_calls) {
          if (tool_call.type === "function") {
            this._emit("functionCall", tool_call.function);
          }
        }
      }
    }
  }
  /**
   * @returns a promise that resolves with the final ChatCompletion, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
   */
  async finalChatCompletion() {
    await this.done();
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (!completion)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return completion;
  }
  /**
   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalContent() {
    await this.done();
    return __classPrivateFieldGet10(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet10(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the content of the final FunctionCall, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalFunctionCall() {
    await this.done();
    return __classPrivateFieldGet10(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
  }
  async finalFunctionCallResult() {
    await this.done();
    return __classPrivateFieldGet10(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
  }
  async totalUsage() {
    await this.done();
    return __classPrivateFieldGet10(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emitFinal() {
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (completion)
      this._emit("finalChatCompletion", completion);
    const finalMessage = __classPrivateFieldGet10(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
    if (finalMessage)
      this._emit("finalMessage", finalMessage);
    const finalContent = __classPrivateFieldGet10(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
    if (finalContent)
      this._emit("finalContent", finalContent);
    const finalFunctionCall = __classPrivateFieldGet10(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
    if (finalFunctionCall)
      this._emit("finalFunctionCall", finalFunctionCall);
    const finalFunctionCallResult = __classPrivateFieldGet10(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
    if (finalFunctionCallResult != null)
      this._emit("finalFunctionCallResult", finalFunctionCallResult);
    if (this._chatCompletions.some((c3) => c3.usage)) {
      this._emit("totalUsage", __classPrivateFieldGet10(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
    }
  }
  async _createChatCompletion(client, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet10(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
    const chatCompletion = await client.chat.completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });
    this._connected();
    return this._addChatCompletion(parseChatCompletion(chatCompletion, params));
  }
  async _runChatCompletion(client, params, options) {
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    return await this._createChatCompletion(client, params, options);
  }
  async _runFunctions(client, params, options) {
    const role = "function";
    const { function_call = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof function_call !== "string" && function_call?.name;
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const functionsByName = {};
    for (const f3 of params.functions) {
      functionsByName[f3.name || f3.function.name] = f3;
    }
    const functions = params.functions.map((f3) => ({
      name: f3.name || f3.function.name,
      parameters: f3.parameters,
      description: f3.description
    }));
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i3 = 0; i3 < maxChatCompletions; ++i3) {
      const chatCompletion = await this._createChatCompletion(client, {
        ...restParams,
        function_call,
        functions,
        messages: [...this.messages]
      }, options);
      const message = chatCompletion.choices[0]?.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!message.function_call)
        return;
      const { name, arguments: args } = message.function_call;
      const fn2 = functionsByName[name];
      if (!fn2) {
        const content2 = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions.map((f3) => JSON.stringify(f3.name)).join(", ")}. Please try again`;
        this._addMessage({ role, name, content: content2 });
        continue;
      } else if (singleFunctionToCall && singleFunctionToCall !== name) {
        const content2 = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
        this._addMessage({ role, name, content: content2 });
        continue;
      }
      let parsed;
      try {
        parsed = isRunnableFunctionWithParse(fn2) ? await fn2.parse(args) : args;
      } catch (error) {
        this._addMessage({
          role,
          name,
          content: error instanceof Error ? error.message : String(error)
        });
        continue;
      }
      const rawContent = await fn2.function(parsed, this);
      const content = __classPrivateFieldGet10(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
      this._addMessage({ role, name, content });
      if (singleFunctionToCall)
        return;
    }
  }
  async _runTools(client, params, options) {
    const role = "tool";
    const { tool_choice = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof tool_choice !== "string" && tool_choice?.function?.name;
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const inputTools = params.tools.map((tool) => {
      if (isAutoParsableTool(tool)) {
        if (!tool.$callback) {
          throw new OpenAIError("Tool given to `.runTools()` that does not have an associated function");
        }
        return {
          type: "function",
          function: {
            function: tool.$callback,
            name: tool.function.name,
            description: tool.function.description || "",
            parameters: tool.function.parameters,
            parse: tool.$parseRaw,
            strict: true
          }
        };
      }
      return tool;
    });
    const functionsByName = {};
    for (const f3 of inputTools) {
      if (f3.type === "function") {
        functionsByName[f3.function.name || f3.function.function.name] = f3.function;
      }
    }
    const tools = "tools" in params ? inputTools.map((t3) => t3.type === "function" ? {
      type: "function",
      function: {
        name: t3.function.name || t3.function.function.name,
        parameters: t3.function.parameters,
        description: t3.function.description,
        strict: t3.function.strict
      }
    } : t3) : void 0;
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i3 = 0; i3 < maxChatCompletions; ++i3) {
      const chatCompletion = await this._createChatCompletion(client, {
        ...restParams,
        tool_choice,
        tools,
        messages: [...this.messages]
      }, options);
      const message = chatCompletion.choices[0]?.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!message.tool_calls?.length) {
        return;
      }
      for (const tool_call of message.tool_calls) {
        if (tool_call.type !== "function")
          continue;
        const tool_call_id = tool_call.id;
        const { name, arguments: args } = tool_call.function;
        const fn2 = functionsByName[name];
        if (!fn2) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map((name2) => JSON.stringify(name2)).join(", ")}. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        } else if (singleFunctionToCall && singleFunctionToCall !== name) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        let parsed;
        try {
          parsed = isRunnableFunctionWithParse(fn2) ? await fn2.parse(args) : args;
        } catch (error) {
          const content2 = error instanceof Error ? error.message : String(error);
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        const rawContent = await fn2.function(parsed, this);
        const content = __classPrivateFieldGet10(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
        this._addMessage({ role, tool_call_id, content });
        if (singleFunctionToCall) {
          return;
        }
      }
    }
    return;
  }
};
_AbstractChatCompletionRunner_instances = /* @__PURE__ */ new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent2() {
  return __classPrivateFieldGet10(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;
}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage2() {
  let i3 = this.messages.length;
  while (i3-- > 0) {
    const message = this.messages[i3];
    if (isAssistantMessage(message)) {
      const { function_call, ...rest } = message;
      const ret = {
        ...rest,
        content: message.content ?? null,
        refusal: message.refusal ?? null
      };
      if (function_call) {
        ret.function_call = function_call;
      }
      return ret;
    }
  }
  throw new OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant");
}, _AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall2() {
  for (let i3 = this.messages.length - 1; i3 >= 0; i3--) {
    const message = this.messages[i3];
    if (isAssistantMessage(message) && message?.function_call) {
      return message.function_call;
    }
    if (isAssistantMessage(message) && message?.tool_calls?.length) {
      return message.tool_calls.at(-1)?.function;
    }
  }
  return;
}, _AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult2() {
  for (let i3 = this.messages.length - 1; i3 >= 0; i3--) {
    const message = this.messages[i3];
    if (isFunctionMessage(message) && message.content != null) {
      return message.content;
    }
    if (isToolMessage(message) && message.content != null && typeof message.content === "string" && this.messages.some((x3) => x3.role === "assistant" && x3.tool_calls?.some((y3) => y3.type === "function" && y3.id === message.tool_call_id))) {
      return message.content;
    }
  }
  return;
}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage2() {
  const total = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage } of this._chatCompletions) {
    if (usage) {
      total.completion_tokens += usage.completion_tokens;
      total.prompt_tokens += usage.prompt_tokens;
      total.total_tokens += usage.total_tokens;
    }
  }
  return total;
}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams2(params) {
  if (params.n != null && params.n > 1) {
    throw new OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
  }
}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
  return typeof rawContent === "string" ? rawContent : rawContent === void 0 ? "undefined" : JSON.stringify(rawContent);
};

// node_modules/openai/lib/ChatCompletionRunner.mjs
var ChatCompletionRunner = class _ChatCompletionRunner extends AbstractChatCompletionRunner {
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(client, params, options) {
    const runner = new _ChatCompletionRunner();
    const opts = {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    runner._run(() => runner._runFunctions(client, params, opts));
    return runner;
  }
  static runTools(client, params, options) {
    const runner = new _ChatCompletionRunner();
    const opts = {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client, params, opts));
    return runner;
  }
  _addMessage(message, emit = true) {
    super._addMessage(message, emit);
    if (isAssistantMessage(message) && message.content) {
      this._emit("content", message.content);
    }
  }
};

// node_modules/openai/_vendor/partial-json-parser/parser.mjs
var STR = 1;
var NUM = 2;
var ARR = 4;
var OBJ = 8;
var NULL = 16;
var BOOL = 32;
var NAN = 64;
var INFINITY = 128;
var MINUS_INFINITY = 256;
var INF = INFINITY | MINUS_INFINITY;
var SPECIAL = NULL | BOOL | INF | NAN;
var ATOM = STR | NUM | SPECIAL;
var COLLECTION = ARR | OBJ;
var ALL = ATOM | COLLECTION;
var Allow = {
  STR,
  NUM,
  ARR,
  OBJ,
  NULL,
  BOOL,
  NAN,
  INFINITY,
  MINUS_INFINITY,
  INF,
  SPECIAL,
  ATOM,
  COLLECTION,
  ALL
};
var PartialJSON = class extends Error {
};
var MalformedJSON = class extends Error {
};
function parseJSON(jsonString, allowPartial = Allow.ALL) {
  if (typeof jsonString !== "string") {
    throw new TypeError(`expecting str, got ${typeof jsonString}`);
  }
  if (!jsonString.trim()) {
    throw new Error(`${jsonString} is empty`);
  }
  return _parseJSON(jsonString.trim(), allowPartial);
}
var _parseJSON = (jsonString, allow) => {
  const length = jsonString.length;
  let index = 0;
  const markPartialJSON = (msg) => {
    throw new PartialJSON(`${msg} at position ${index}`);
  };
  const throwMalformedError = (msg) => {
    throw new MalformedJSON(`${msg} at position ${index}`);
  };
  const parseAny = () => {
    skipBlank();
    if (index >= length)
      markPartialJSON("Unexpected end of input");
    if (jsonString[index] === '"')
      return parseStr();
    if (jsonString[index] === "{")
      return parseObj();
    if (jsonString[index] === "[")
      return parseArr();
    if (jsonString.substring(index, index + 4) === "null" || Allow.NULL & allow && length - index < 4 && "null".startsWith(jsonString.substring(index))) {
      index += 4;
      return null;
    }
    if (jsonString.substring(index, index + 4) === "true" || Allow.BOOL & allow && length - index < 4 && "true".startsWith(jsonString.substring(index))) {
      index += 4;
      return true;
    }
    if (jsonString.substring(index, index + 5) === "false" || Allow.BOOL & allow && length - index < 5 && "false".startsWith(jsonString.substring(index))) {
      index += 5;
      return false;
    }
    if (jsonString.substring(index, index + 8) === "Infinity" || Allow.INFINITY & allow && length - index < 8 && "Infinity".startsWith(jsonString.substring(index))) {
      index += 8;
      return Infinity;
    }
    if (jsonString.substring(index, index + 9) === "-Infinity" || Allow.MINUS_INFINITY & allow && 1 < length - index && length - index < 9 && "-Infinity".startsWith(jsonString.substring(index))) {
      index += 9;
      return -Infinity;
    }
    if (jsonString.substring(index, index + 3) === "NaN" || Allow.NAN & allow && length - index < 3 && "NaN".startsWith(jsonString.substring(index))) {
      index += 3;
      return NaN;
    }
    return parseNum();
  };
  const parseStr = () => {
    const start = index;
    let escape2 = false;
    index++;
    while (index < length && (jsonString[index] !== '"' || escape2 && jsonString[index - 1] === "\\")) {
      escape2 = jsonString[index] === "\\" ? !escape2 : false;
      index++;
    }
    if (jsonString.charAt(index) == '"') {
      try {
        return JSON.parse(jsonString.substring(start, ++index - Number(escape2)));
      } catch (e3) {
        throwMalformedError(String(e3));
      }
    } else if (Allow.STR & allow) {
      try {
        return JSON.parse(jsonString.substring(start, index - Number(escape2)) + '"');
      } catch (e3) {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("\\")) + '"');
      }
    }
    markPartialJSON("Unterminated string literal");
  };
  const parseObj = () => {
    index++;
    skipBlank();
    const obj = {};
    try {
      while (jsonString[index] !== "}") {
        skipBlank();
        if (index >= length && Allow.OBJ & allow)
          return obj;
        const key = parseStr();
        skipBlank();
        index++;
        try {
          const value = parseAny();
          Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });
        } catch (e3) {
          if (Allow.OBJ & allow)
            return obj;
          else
            throw e3;
        }
        skipBlank();
        if (jsonString[index] === ",")
          index++;
      }
    } catch (e3) {
      if (Allow.OBJ & allow)
        return obj;
      else
        markPartialJSON("Expected '}' at end of object");
    }
    index++;
    return obj;
  };
  const parseArr = () => {
    index++;
    const arr = [];
    try {
      while (jsonString[index] !== "]") {
        arr.push(parseAny());
        skipBlank();
        if (jsonString[index] === ",") {
          index++;
        }
      }
    } catch (e3) {
      if (Allow.ARR & allow) {
        return arr;
      }
      markPartialJSON("Expected ']' at end of array");
    }
    index++;
    return arr;
  };
  const parseNum = () => {
    if (index === 0) {
      if (jsonString === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString);
      } catch (e3) {
        if (Allow.NUM & allow) {
          try {
            if ("." === jsonString[jsonString.length - 1])
              return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf(".")));
            return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf("e")));
          } catch (e4) {
          }
        }
        throwMalformedError(String(e3));
      }
    }
    const start = index;
    if (jsonString[index] === "-")
      index++;
    while (jsonString[index] && !",]}".includes(jsonString[index]))
      index++;
    if (index == length && !(Allow.NUM & allow))
      markPartialJSON("Unterminated number literal");
    try {
      return JSON.parse(jsonString.substring(start, index));
    } catch (e3) {
      if (jsonString.substring(start, index) === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("e")));
      } catch (e4) {
        throwMalformedError(String(e4));
      }
    }
  };
  const skipBlank = () => {
    while (index < length && " \n\r	".includes(jsonString[index])) {
      index++;
    }
  };
  return parseAny();
};
var partialParse = (input) => parseJSON(input, Allow.ALL ^ Allow.NUM);

// node_modules/openai/lib/ChatCompletionStream.mjs
var __classPrivateFieldSet9 = function(receiver, state, value, kind2, f3) {
  if (kind2 === "m") throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f3) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet11 = function(receiver, state, kind2, f3) {
  if (kind2 === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f3 : kind2 === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
};
var _ChatCompletionStream_instances;
var _ChatCompletionStream_params;
var _ChatCompletionStream_choiceEventStates;
var _ChatCompletionStream_currentChatCompletionSnapshot;
var _ChatCompletionStream_beginRequest;
var _ChatCompletionStream_getChoiceEventState;
var _ChatCompletionStream_addChunk;
var _ChatCompletionStream_emitToolCallDoneEvent;
var _ChatCompletionStream_emitContentDoneEvents;
var _ChatCompletionStream_endRequest;
var _ChatCompletionStream_getAutoParseableResponseFormat;
var _ChatCompletionStream_accumulateChatCompletion;
var ChatCompletionStream = class _ChatCompletionStream extends AbstractChatCompletionRunner {
  constructor(params) {
    super();
    _ChatCompletionStream_instances.add(this);
    _ChatCompletionStream_params.set(this, void 0);
    _ChatCompletionStream_choiceEventStates.set(this, void 0);
    _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
    __classPrivateFieldSet9(this, _ChatCompletionStream_params, params, "f");
    __classPrivateFieldSet9(this, _ChatCompletionStream_choiceEventStates, [], "f");
  }
  get currentChatCompletionSnapshot() {
    return __classPrivateFieldGet11(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream) {
    const runner = new _ChatCompletionStream(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createChatCompletion(client, params, options) {
    const runner = new _ChatCompletionStream(params);
    runner._run(() => runner._runChatCompletion(client, { ...params, stream: true }, { ...options, headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  async _createChatCompletion(client, params, options) {
    super._createChatCompletion;
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet11(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    const stream = await client.chat.completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const chunk of stream) {
      __classPrivateFieldGet11(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet11(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  async _fromReadableStream(readableStream, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet11(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    this._connected();
    const stream = Stream2.fromReadableStream(readableStream, this.controller);
    let chatId;
    for await (const chunk of stream) {
      if (chatId && chatId !== chunk.id) {
        this._addChatCompletion(__classPrivateFieldGet11(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
      }
      __classPrivateFieldGet11(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
      chatId = chunk.id;
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet11(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  [(_ChatCompletionStream_params = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_choiceEventStates = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_instances = /* @__PURE__ */ new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet9(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
  }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState2(choice) {
    let state = __classPrivateFieldGet11(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index];
    if (state) {
      return state;
    }
    state = {
      content_done: false,
      refusal_done: false,
      logprobs_content_done: false,
      logprobs_refusal_done: false,
      done_tool_calls: /* @__PURE__ */ new Set(),
      current_tool_call_index: null
    };
    __classPrivateFieldGet11(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index] = state;
    return state;
  }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk2(chunk) {
    if (this.ended)
      return;
    const completion = __classPrivateFieldGet11(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
    this._emit("chunk", chunk, completion);
    for (const choice of chunk.choices) {
      const choiceSnapshot = completion.choices[choice.index];
      if (choice.delta.content != null && choiceSnapshot.message?.role === "assistant" && choiceSnapshot.message?.content) {
        this._emit("content", choice.delta.content, choiceSnapshot.message.content);
        this._emit("content.delta", {
          delta: choice.delta.content,
          snapshot: choiceSnapshot.message.content,
          parsed: choiceSnapshot.message.parsed
        });
      }
      if (choice.delta.refusal != null && choiceSnapshot.message?.role === "assistant" && choiceSnapshot.message?.refusal) {
        this._emit("refusal.delta", {
          delta: choice.delta.refusal,
          snapshot: choiceSnapshot.message.refusal
        });
      }
      if (choice.logprobs?.content != null && choiceSnapshot.message?.role === "assistant") {
        this._emit("logprobs.content.delta", {
          content: choice.logprobs?.content,
          snapshot: choiceSnapshot.logprobs?.content ?? []
        });
      }
      if (choice.logprobs?.refusal != null && choiceSnapshot.message?.role === "assistant") {
        this._emit("logprobs.refusal.delta", {
          refusal: choice.logprobs?.refusal,
          snapshot: choiceSnapshot.logprobs?.refusal ?? []
        });
      }
      const state = __classPrivateFieldGet11(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
      if (choiceSnapshot.finish_reason) {
        __classPrivateFieldGet11(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
        if (state.current_tool_call_index != null) {
          __classPrivateFieldGet11(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
        }
      }
      for (const toolCall of choice.delta.tool_calls ?? []) {
        if (state.current_tool_call_index !== toolCall.index) {
          __classPrivateFieldGet11(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
          if (state.current_tool_call_index != null) {
            __classPrivateFieldGet11(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
          }
        }
        state.current_tool_call_index = toolCall.index;
      }
      for (const toolCallDelta of choice.delta.tool_calls ?? []) {
        const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallDelta.index];
        if (!toolCallSnapshot?.type) {
          continue;
        }
        if (toolCallSnapshot?.type === "function") {
          this._emit("tool_calls.function.arguments.delta", {
            name: toolCallSnapshot.function?.name,
            index: toolCallDelta.index,
            arguments: toolCallSnapshot.function.arguments,
            parsed_arguments: toolCallSnapshot.function.parsed_arguments,
            arguments_delta: toolCallDelta.function?.arguments ?? ""
          });
        } else {
          assertNever2(toolCallSnapshot?.type);
        }
      }
    }
  }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent2(choiceSnapshot, toolCallIndex) {
    const state = __classPrivateFieldGet11(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (state.done_tool_calls.has(toolCallIndex)) {
      return;
    }
    const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallIndex];
    if (!toolCallSnapshot) {
      throw new Error("no tool call snapshot");
    }
    if (!toolCallSnapshot.type) {
      throw new Error("tool call snapshot missing `type`");
    }
    if (toolCallSnapshot.type === "function") {
      const inputTool = __classPrivateFieldGet11(this, _ChatCompletionStream_params, "f")?.tools?.find((tool) => tool.type === "function" && tool.function.name === toolCallSnapshot.function.name);
      this._emit("tool_calls.function.arguments.done", {
        name: toolCallSnapshot.function.name,
        index: toolCallIndex,
        arguments: toolCallSnapshot.function.arguments,
        parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCallSnapshot.function.arguments) : null
      });
    } else {
      assertNever2(toolCallSnapshot.type);
    }
  }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents2(choiceSnapshot) {
    const state = __classPrivateFieldGet11(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (choiceSnapshot.message.content && !state.content_done) {
      state.content_done = true;
      const responseFormat = __classPrivateFieldGet11(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);
      this._emit("content.done", {
        content: choiceSnapshot.message.content,
        parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null
      });
    }
    if (choiceSnapshot.message.refusal && !state.refusal_done) {
      state.refusal_done = true;
      this._emit("refusal.done", { refusal: choiceSnapshot.message.refusal });
    }
    if (choiceSnapshot.logprobs?.content && !state.logprobs_content_done) {
      state.logprobs_content_done = true;
      this._emit("logprobs.content.done", { content: choiceSnapshot.logprobs.content });
    }
    if (choiceSnapshot.logprobs?.refusal && !state.logprobs_refusal_done) {
      state.logprobs_refusal_done = true;
      this._emit("logprobs.refusal.done", { refusal: choiceSnapshot.logprobs.refusal });
    }
  }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet11(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet9(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
    __classPrivateFieldSet9(this, _ChatCompletionStream_choiceEventStates, [], "f");
    return finalizeChatCompletion(snapshot, __classPrivateFieldGet11(this, _ChatCompletionStream_params, "f"));
  }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat2() {
    const responseFormat = __classPrivateFieldGet11(this, _ChatCompletionStream_params, "f")?.response_format;
    if (isAutoParsableResponseFormat(responseFormat)) {
      return responseFormat;
    }
    return null;
  }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion2(chunk) {
    var _a4, _b2, _c3, _d;
    let snapshot = __classPrivateFieldGet11(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    const { choices, ...rest } = chunk;
    if (!snapshot) {
      snapshot = __classPrivateFieldSet9(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
        ...rest,
        choices: []
      }, "f");
    } else {
      Object.assign(snapshot, rest);
    }
    for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {
      let choice = snapshot.choices[index];
      if (!choice) {
        choice = snapshot.choices[index] = { finish_reason, index, message: {}, logprobs, ...other };
      }
      if (logprobs) {
        if (!choice.logprobs) {
          choice.logprobs = Object.assign({}, logprobs);
        } else {
          const { content: content2, refusal: refusal2, ...rest3 } = logprobs;
          assertIsEmpty(rest3);
          Object.assign(choice.logprobs, rest3);
          if (content2) {
            (_a4 = choice.logprobs).content ?? (_a4.content = []);
            choice.logprobs.content.push(...content2);
          }
          if (refusal2) {
            (_b2 = choice.logprobs).refusal ?? (_b2.refusal = []);
            choice.logprobs.refusal.push(...refusal2);
          }
        }
      }
      if (finish_reason) {
        choice.finish_reason = finish_reason;
        if (__classPrivateFieldGet11(this, _ChatCompletionStream_params, "f") && hasAutoParseableInput(__classPrivateFieldGet11(this, _ChatCompletionStream_params, "f"))) {
          if (finish_reason === "length") {
            throw new LengthFinishReasonError();
          }
          if (finish_reason === "content_filter") {
            throw new ContentFilterFinishReasonError();
          }
        }
      }
      Object.assign(choice, other);
      if (!delta)
        continue;
      const { content, refusal, function_call, role, tool_calls, ...rest2 } = delta;
      assertIsEmpty(rest2);
      Object.assign(choice.message, rest2);
      if (refusal) {
        choice.message.refusal = (choice.message.refusal || "") + refusal;
      }
      if (role)
        choice.message.role = role;
      if (function_call) {
        if (!choice.message.function_call) {
          choice.message.function_call = function_call;
        } else {
          if (function_call.name)
            choice.message.function_call.name = function_call.name;
          if (function_call.arguments) {
            (_c3 = choice.message.function_call).arguments ?? (_c3.arguments = "");
            choice.message.function_call.arguments += function_call.arguments;
          }
        }
      }
      if (content) {
        choice.message.content = (choice.message.content || "") + content;
        if (!choice.message.refusal && __classPrivateFieldGet11(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {
          choice.message.parsed = partialParse(choice.message.content);
        }
      }
      if (tool_calls) {
        if (!choice.message.tool_calls)
          choice.message.tool_calls = [];
        for (const { index: index2, id, type, function: fn2, ...rest3 } of tool_calls) {
          const tool_call = (_d = choice.message.tool_calls)[index2] ?? (_d[index2] = {});
          Object.assign(tool_call, rest3);
          if (id)
            tool_call.id = id;
          if (type)
            tool_call.type = type;
          if (fn2)
            tool_call.function ?? (tool_call.function = { name: fn2.name ?? "", arguments: "" });
          if (fn2?.name)
            tool_call.function.name = fn2.name;
          if (fn2?.arguments) {
            tool_call.function.arguments += fn2.arguments;
            if (shouldParseToolCall(__classPrivateFieldGet11(this, _ChatCompletionStream_params, "f"), tool_call)) {
              tool_call.function.parsed_arguments = partialParse(tool_call.function.arguments);
            }
          }
        }
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("chunk", (chunk) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(chunk);
      } else {
        pushQueue.push(chunk);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve2, reject) => readQueue.push({ resolve: resolve2, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream2(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
};
function finalizeChatCompletion(snapshot, params) {
  const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;
  const completion = {
    ...rest,
    id,
    choices: choices.map(({ message, finish_reason, index, logprobs, ...choiceRest }) => {
      if (!finish_reason) {
        throw new OpenAIError(`missing finish_reason for choice ${index}`);
      }
      const { content = null, function_call, tool_calls, ...messageRest } = message;
      const role = message.role;
      if (!role) {
        throw new OpenAIError(`missing role for choice ${index}`);
      }
      if (function_call) {
        const { arguments: args, name } = function_call;
        if (args == null) {
          throw new OpenAIError(`missing function_call.arguments for choice ${index}`);
        }
        if (!name) {
          throw new OpenAIError(`missing function_call.name for choice ${index}`);
        }
        return {
          ...choiceRest,
          message: {
            content,
            function_call: { arguments: args, name },
            role,
            refusal: message.refusal ?? null
          },
          finish_reason,
          index,
          logprobs
        };
      }
      if (tool_calls) {
        return {
          ...choiceRest,
          index,
          finish_reason,
          logprobs,
          message: {
            ...messageRest,
            role,
            content,
            refusal: message.refusal ?? null,
            tool_calls: tool_calls.map((tool_call, i3) => {
              const { function: fn2, type, id: id2, ...toolRest } = tool_call;
              const { arguments: args, name, ...fnRest } = fn2 || {};
              if (id2 == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i3}].id
${str(snapshot)}`);
              }
              if (type == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i3}].type
${str(snapshot)}`);
              }
              if (name == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i3}].function.name
${str(snapshot)}`);
              }
              if (args == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i3}].function.arguments
${str(snapshot)}`);
              }
              return { ...toolRest, id: id2, type, function: { ...fnRest, name, arguments: args } };
            })
          }
        };
      }
      return {
        ...choiceRest,
        message: { ...messageRest, content, role, refusal: message.refusal ?? null },
        finish_reason,
        index,
        logprobs
      };
    }),
    created,
    model,
    object: "chat.completion",
    ...system_fingerprint ? { system_fingerprint } : {}
  };
  return maybeParseChatCompletion(completion, params);
}
function str(x3) {
  return JSON.stringify(x3);
}
function assertIsEmpty(obj) {
  return;
}
function assertNever2(_x) {
}

// node_modules/openai/lib/ChatCompletionStreamingRunner.mjs
var ChatCompletionStreamingRunner = class _ChatCompletionStreamingRunner extends ChatCompletionStream {
  static fromReadableStream(stream) {
    const runner = new _ChatCompletionStreamingRunner(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(client, params, options) {
    const runner = new _ChatCompletionStreamingRunner(null);
    const opts = {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    runner._run(() => runner._runFunctions(client, params, opts));
    return runner;
  }
  static runTools(client, params, options) {
    const runner = new _ChatCompletionStreamingRunner(
      // @ts-expect-error TODO these types are incompatible
      params
    );
    const opts = {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client, params, opts));
    return runner;
  }
};

// node_modules/openai/resources/beta/chat/completions.mjs
var Completions2 = class extends APIResource {
  parse(body, options) {
    validateInputTools(body.tools);
    return this._client.chat.completions.create(body, {
      ...options,
      headers: {
        ...options?.headers,
        "X-Stainless-Helper-Method": "beta.chat.completions.parse"
      }
    })._thenUnwrap((completion) => parseChatCompletion(completion, body));
  }
  runFunctions(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runFunctions(this._client, body, options);
    }
    return ChatCompletionRunner.runFunctions(this._client, body, options);
  }
  runTools(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runTools(this._client, body, options);
    }
    return ChatCompletionRunner.runTools(this._client, body, options);
  }
  /**
   * Creates a chat completion stream
   */
  stream(body, options) {
    return ChatCompletionStream.createChatCompletion(this._client, body, options);
  }
};

// node_modules/openai/resources/beta/chat/chat.mjs
var Chat2 = class extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions2(this._client);
  }
};
(function(Chat3) {
  Chat3.Completions = Completions2;
})(Chat2 || (Chat2 = {}));

// node_modules/openai/resources/beta/realtime/sessions.mjs
var Sessions = class extends APIResource {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API. Can be configured with the same session parameters as the
   * `session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const session =
   *   await client.beta.realtime.sessions.create();
   * ```
   */
  create(body, options) {
    return this._client.post("/realtime/sessions", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
};

// node_modules/openai/resources/beta/realtime/transcription-sessions.mjs
var TranscriptionSessions = class extends APIResource {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API specifically for realtime transcriptions. Can be configured with
   * the same session parameters as the `transcription_session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const transcriptionSession =
   *   await client.beta.realtime.transcriptionSessions.create();
   * ```
   */
  create(body, options) {
    return this._client.post("/realtime/transcription_sessions", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
};

// node_modules/openai/resources/beta/realtime/realtime.mjs
var Realtime = class extends APIResource {
  constructor() {
    super(...arguments);
    this.sessions = new Sessions(this._client);
    this.transcriptionSessions = new TranscriptionSessions(this._client);
  }
};
Realtime.Sessions = Sessions;
Realtime.TranscriptionSessions = TranscriptionSessions;

// node_modules/openai/resources/beta/threads/messages.mjs
var Messages2 = class extends APIResource {
  /**
   * Create a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  create(threadId, body, options) {
    return this._client.post(`/threads/${threadId}/messages`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Retrieve a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(threadId, messageId, options) {
    return this._client.get(`/threads/${threadId}/messages/${messageId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Modifies a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(threadId, messageId, body, options) {
    return this._client.post(`/threads/${threadId}/messages/${messageId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  list(threadId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/messages`, MessagesPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Deletes a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  del(threadId, messageId, options) {
    return this._client.delete(`/threads/${threadId}/messages/${messageId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
};
var MessagesPage = class extends CursorPage {
};
Messages2.MessagesPage = MessagesPage;

// node_modules/openai/resources/beta/threads/runs/steps.mjs
var Steps = class extends APIResource {
  retrieve(threadId, runId, stepId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.retrieve(threadId, runId, stepId, {}, query);
    }
    return this._client.get(`/threads/${threadId}/runs/${runId}/steps/${stepId}`, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  list(threadId, runId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, runId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/runs/${runId}/steps`, RunStepsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
};
var RunStepsPage = class extends CursorPage {
};
Steps.RunStepsPage = RunStepsPage;

// node_modules/openai/resources/beta/threads/runs/runs.mjs
var Runs = class extends APIResource {
  constructor() {
    super(...arguments);
    this.steps = new Steps(this._client);
  }
  create(threadId, params, options) {
    const { include, ...body } = params;
    return this._client.post(`/threads/${threadId}/runs`, {
      query: { include },
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers },
      stream: params.stream ?? false
    });
  }
  /**
   * Retrieves a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(threadId, runId, options) {
    return this._client.get(`/threads/${threadId}/runs/${runId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Modifies a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(threadId, runId, body, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  list(threadId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/runs`, RunsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Cancels a run that is `in_progress`.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  cancel(threadId, runId, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * A helper to create a run an poll for a terminal state. More information on Run
   * lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndPoll(threadId, body, options) {
    const run = await this.create(threadId, body, options);
    return await this.poll(threadId, run.id, options);
  }
  /**
   * Create a Run stream
   *
   * @deprecated use `stream` instead
   */
  createAndStream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  /**
   * A helper to poll a run status until it reaches a terminal state. More
   * information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async poll(threadId, runId, options) {
    const headers = { ...options?.headers, "X-Stainless-Poll-Helper": "true" };
    if (options?.pollIntervalMs) {
      headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
    }
    while (true) {
      const { data: run, response } = await this.retrieve(threadId, runId, {
        ...options,
        headers: { ...options?.headers, ...headers }
      }).withResponse();
      switch (run.status) {
        //If we are in any sort of intermediate state we poll
        case "queued":
        case "in_progress":
        case "cancelling":
          let sleepInterval = 5e3;
          if (options?.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep(sleepInterval);
          break;
        //We return the run in any terminal state.
        case "requires_action":
        case "incomplete":
        case "cancelled":
        case "completed":
        case "failed":
        case "expired":
          return run;
      }
    }
  }
  /**
   * Create a Run stream
   */
  stream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  submitToolOutputs(threadId, runId, body, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}/submit_tool_outputs`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers },
      stream: body.stream ?? false
    });
  }
  /**
   * A helper to submit a tool output to a run and poll for a terminal run state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async submitToolOutputsAndPoll(threadId, runId, body, options) {
    const run = await this.submitToolOutputs(threadId, runId, body, options);
    return await this.poll(threadId, run.id, options);
  }
  /**
   * Submit the tool outputs from a previous run and stream the run to a terminal
   * state. More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  submitToolOutputsStream(threadId, runId, body, options) {
    return AssistantStream.createToolAssistantStream(threadId, runId, this._client.beta.threads.runs, body, options);
  }
};
var RunsPage = class extends CursorPage {
};
Runs.RunsPage = RunsPage;
Runs.Steps = Steps;
Runs.RunStepsPage = RunStepsPage;

// node_modules/openai/resources/beta/threads/threads.mjs
var Threads = class extends APIResource {
  constructor() {
    super(...arguments);
    this.runs = new Runs(this._client);
    this.messages = new Messages2(this._client);
  }
  create(body = {}, options) {
    if (isRequestOptions(body)) {
      return this.create({}, body);
    }
    return this._client.post("/threads", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Retrieves a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(threadId, options) {
    return this._client.get(`/threads/${threadId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Modifies a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(threadId, body, options) {
    return this._client.post(`/threads/${threadId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Delete a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  del(threadId, options) {
    return this._client.delete(`/threads/${threadId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  createAndRun(body, options) {
    return this._client.post("/threads/runs", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers },
      stream: body.stream ?? false
    });
  }
  /**
   * A helper to create a thread, start a run and then poll for a terminal state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndRunPoll(body, options) {
    const run = await this.createAndRun(body, options);
    return await this.runs.poll(run.thread_id, run.id, options);
  }
  /**
   * Create a thread and stream the run back
   */
  createAndRunStream(body, options) {
    return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);
  }
};
Threads.Runs = Runs;
Threads.RunsPage = RunsPage;
Threads.Messages = Messages2;
Threads.MessagesPage = MessagesPage;

// node_modules/openai/resources/beta/beta.mjs
var Beta = class extends APIResource {
  constructor() {
    super(...arguments);
    this.realtime = new Realtime(this._client);
    this.chat = new Chat2(this._client);
    this.assistants = new Assistants(this._client);
    this.threads = new Threads(this._client);
  }
};
Beta.Realtime = Realtime;
Beta.Assistants = Assistants;
Beta.AssistantsPage = AssistantsPage;
Beta.Threads = Threads;

// node_modules/openai/resources/completions.mjs
var Completions3 = class extends APIResource {
  create(body, options) {
    return this._client.post("/completions", { body, ...options, stream: body.stream ?? false });
  }
};

// node_modules/openai/resources/containers/files/content.mjs
var Content = class extends APIResource {
  /**
   * Retrieve Container File Content
   */
  retrieve(containerId, fileId, options) {
    return this._client.get(`/containers/${containerId}/files/${fileId}/content`, {
      ...options,
      headers: { Accept: "application/binary", ...options?.headers },
      __binaryResponse: true
    });
  }
};

// node_modules/openai/resources/containers/files/files.mjs
var Files = class extends APIResource {
  constructor() {
    super(...arguments);
    this.content = new Content(this._client);
  }
  /**
   * Create a Container File
   *
   * You can send either a multipart/form-data request with the raw file content, or
   * a JSON request with a file ID.
   */
  create(containerId, body, options) {
    return this._client.post(`/containers/${containerId}/files`, multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Retrieve Container File
   */
  retrieve(containerId, fileId, options) {
    return this._client.get(`/containers/${containerId}/files/${fileId}`, options);
  }
  list(containerId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(containerId, {}, query);
    }
    return this._client.getAPIList(`/containers/${containerId}/files`, FileListResponsesPage, {
      query,
      ...options
    });
  }
  /**
   * Delete Container File
   */
  del(containerId, fileId, options) {
    return this._client.delete(`/containers/${containerId}/files/${fileId}`, {
      ...options,
      headers: { Accept: "*/*", ...options?.headers }
    });
  }
};
var FileListResponsesPage = class extends CursorPage {
};
Files.FileListResponsesPage = FileListResponsesPage;
Files.Content = Content;

// node_modules/openai/resources/containers/containers.mjs
var Containers = class extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files(this._client);
  }
  /**
   * Create Container
   */
  create(body, options) {
    return this._client.post("/containers", { body, ...options });
  }
  /**
   * Retrieve Container
   */
  retrieve(containerId, options) {
    return this._client.get(`/containers/${containerId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/containers", ContainerListResponsesPage, { query, ...options });
  }
  /**
   * Delete Container
   */
  del(containerId, options) {
    return this._client.delete(`/containers/${containerId}`, {
      ...options,
      headers: { Accept: "*/*", ...options?.headers }
    });
  }
};
var ContainerListResponsesPage = class extends CursorPage {
};
Containers.ContainerListResponsesPage = ContainerListResponsesPage;
Containers.Files = Files;
Containers.FileListResponsesPage = FileListResponsesPage;

// node_modules/openai/resources/embeddings.mjs
var Embeddings = class extends APIResource {
  /**
   * Creates an embedding vector representing the input text.
   *
   * @example
   * ```ts
   * const createEmbeddingResponse =
   *   await client.embeddings.create({
   *     input: 'The quick brown fox jumped over the lazy dog',
   *     model: 'text-embedding-3-small',
   *   });
   * ```
   */
  create(body, options) {
    const hasUserProvidedEncodingFormat = !!body.encoding_format;
    let encoding_format = hasUserProvidedEncodingFormat ? body.encoding_format : "base64";
    if (hasUserProvidedEncodingFormat) {
      debug("Request", "User defined encoding_format:", body.encoding_format);
    }
    const response = this._client.post("/embeddings", {
      body: {
        ...body,
        encoding_format
      },
      ...options
    });
    if (hasUserProvidedEncodingFormat) {
      return response;
    }
    debug("response", "Decoding base64 embeddings to float32 array");
    return response._thenUnwrap((response2) => {
      if (response2 && response2.data) {
        response2.data.forEach((embeddingBase64Obj) => {
          const embeddingBase64Str = embeddingBase64Obj.embedding;
          embeddingBase64Obj.embedding = toFloat32Array(embeddingBase64Str);
        });
      }
      return response2;
    });
  }
};

// node_modules/openai/resources/evals/runs/output-items.mjs
var OutputItems = class extends APIResource {
  /**
   * Get an evaluation run output item by ID.
   */
  retrieve(evalId, runId, outputItemId, options) {
    return this._client.get(`/evals/${evalId}/runs/${runId}/output_items/${outputItemId}`, options);
  }
  list(evalId, runId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(evalId, runId, {}, query);
    }
    return this._client.getAPIList(`/evals/${evalId}/runs/${runId}/output_items`, OutputItemListResponsesPage, { query, ...options });
  }
};
var OutputItemListResponsesPage = class extends CursorPage {
};
OutputItems.OutputItemListResponsesPage = OutputItemListResponsesPage;

// node_modules/openai/resources/evals/runs/runs.mjs
var Runs2 = class extends APIResource {
  constructor() {
    super(...arguments);
    this.outputItems = new OutputItems(this._client);
  }
  /**
   * Kicks off a new run for a given evaluation, specifying the data source, and what
   * model configuration to use to test. The datasource will be validated against the
   * schema specified in the config of the evaluation.
   */
  create(evalId, body, options) {
    return this._client.post(`/evals/${evalId}/runs`, { body, ...options });
  }
  /**
   * Get an evaluation run by ID.
   */
  retrieve(evalId, runId, options) {
    return this._client.get(`/evals/${evalId}/runs/${runId}`, options);
  }
  list(evalId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(evalId, {}, query);
    }
    return this._client.getAPIList(`/evals/${evalId}/runs`, RunListResponsesPage, { query, ...options });
  }
  /**
   * Delete an eval run.
   */
  del(evalId, runId, options) {
    return this._client.delete(`/evals/${evalId}/runs/${runId}`, options);
  }
  /**
   * Cancel an ongoing evaluation run.
   */
  cancel(evalId, runId, options) {
    return this._client.post(`/evals/${evalId}/runs/${runId}`, options);
  }
};
var RunListResponsesPage = class extends CursorPage {
};
Runs2.RunListResponsesPage = RunListResponsesPage;
Runs2.OutputItems = OutputItems;
Runs2.OutputItemListResponsesPage = OutputItemListResponsesPage;

// node_modules/openai/resources/evals/evals.mjs
var Evals = class extends APIResource {
  constructor() {
    super(...arguments);
    this.runs = new Runs2(this._client);
  }
  /**
   * Create the structure of an evaluation that can be used to test a model's
   * performance. An evaluation is a set of testing criteria and the config for a
   * data source, which dictates the schema of the data used in the evaluation. After
   * creating an evaluation, you can run it on different models and model parameters.
   * We support several types of graders and datasources. For more information, see
   * the [Evals guide](https://platform.openai.com/docs/guides/evals).
   */
  create(body, options) {
    return this._client.post("/evals", { body, ...options });
  }
  /**
   * Get an evaluation by ID.
   */
  retrieve(evalId, options) {
    return this._client.get(`/evals/${evalId}`, options);
  }
  /**
   * Update certain properties of an evaluation.
   */
  update(evalId, body, options) {
    return this._client.post(`/evals/${evalId}`, { body, ...options });
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/evals", EvalListResponsesPage, { query, ...options });
  }
  /**
   * Delete an evaluation.
   */
  del(evalId, options) {
    return this._client.delete(`/evals/${evalId}`, options);
  }
};
var EvalListResponsesPage = class extends CursorPage {
};
Evals.EvalListResponsesPage = EvalListResponsesPage;
Evals.Runs = Runs2;
Evals.RunListResponsesPage = RunListResponsesPage;

// node_modules/openai/resources/files.mjs
var Files2 = class extends APIResource {
  /**
   * Upload a file that can be used across various endpoints. Individual files can be
   * up to 512 MB, and the size of all files uploaded by one organization can be up
   * to 100 GB.
   *
   * The Assistants API supports files up to 2 million tokens and of specific file
   * types. See the
   * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for
   * details.
   *
   * The Fine-tuning API only supports `.jsonl` files. The input also has certain
   * required formats for fine-tuning
   * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or
   * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
   * models.
   *
   * The Batch API only supports `.jsonl` files up to 200 MB in size. The input also
   * has a specific required
   * [format](https://platform.openai.com/docs/api-reference/batch/request-input).
   *
   * Please [contact us](https://help.openai.com/) if you need to increase these
   * storage limits.
   */
  create(body, options) {
    return this._client.post("/files", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(fileId, options) {
    return this._client.get(`/files/${fileId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/files", FileObjectsPage, { query, ...options });
  }
  /**
   * Delete a file.
   */
  del(fileId, options) {
    return this._client.delete(`/files/${fileId}`, options);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(fileId, options) {
    return this._client.get(`/files/${fileId}/content`, {
      ...options,
      headers: { Accept: "application/binary", ...options?.headers },
      __binaryResponse: true
    });
  }
  /**
   * Returns the contents of the specified file.
   *
   * @deprecated The `.content()` method should be used instead
   */
  retrieveContent(fileId, options) {
    return this._client.get(`/files/${fileId}/content`, options);
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
    const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
    const start = Date.now();
    let file = await this.retrieve(id);
    while (!file.status || !TERMINAL_STATES.has(file.status)) {
      await sleep(pollInterval);
      file = await this.retrieve(id);
      if (Date.now() - start > maxWait) {
        throw new APIConnectionTimeoutError({
          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
        });
      }
    }
    return file;
  }
};
var FileObjectsPage = class extends CursorPage {
};
Files2.FileObjectsPage = FileObjectsPage;

// node_modules/openai/resources/fine-tuning/methods.mjs
var Methods = class extends APIResource {
};

// node_modules/openai/resources/fine-tuning/alpha/graders.mjs
var Graders = class extends APIResource {
  /**
   * Run a grader.
   *
   * @example
   * ```ts
   * const response = await client.fineTuning.alpha.graders.run({
   *   grader: {
   *     input: 'input',
   *     name: 'name',
   *     operation: 'eq',
   *     reference: 'reference',
   *     type: 'string_check',
   *   },
   *   model_sample: 'model_sample',
   *   reference_answer: 'string',
   * });
   * ```
   */
  run(body, options) {
    return this._client.post("/fine_tuning/alpha/graders/run", { body, ...options });
  }
  /**
   * Validate a grader.
   *
   * @example
   * ```ts
   * const response =
   *   await client.fineTuning.alpha.graders.validate({
   *     grader: {
   *       input: 'input',
   *       name: 'name',
   *       operation: 'eq',
   *       reference: 'reference',
   *       type: 'string_check',
   *     },
   *   });
   * ```
   */
  validate(body, options) {
    return this._client.post("/fine_tuning/alpha/graders/validate", { body, ...options });
  }
};

// node_modules/openai/resources/fine-tuning/alpha/alpha.mjs
var Alpha = class extends APIResource {
  constructor() {
    super(...arguments);
    this.graders = new Graders(this._client);
  }
};
Alpha.Graders = Graders;

// node_modules/openai/resources/fine-tuning/checkpoints/permissions.mjs
var Permissions2 = class extends APIResource {
  /**
   * **NOTE:** Calling this endpoint requires an [admin API key](../admin-api-keys).
   *
   * This enables organization owners to share fine-tuned models with other projects
   * in their organization.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const permissionCreateResponse of client.fineTuning.checkpoints.permissions.create(
   *   'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *   { project_ids: ['string'] },
   * )) {
   *   // ...
   * }
   * ```
   */
  create(fineTunedModelCheckpoint, body, options) {
    return this._client.getAPIList(`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, PermissionCreateResponsesPage, { body, method: "post", ...options });
  }
  retrieve(fineTunedModelCheckpoint, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.retrieve(fineTunedModelCheckpoint, {}, query);
    }
    return this._client.get(`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, {
      query,
      ...options
    });
  }
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to delete a permission for a
   * fine-tuned model checkpoint.
   *
   * @example
   * ```ts
   * const permission =
   *   await client.fineTuning.checkpoints.permissions.del(
   *     'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *     'cp_zc4Q7MP6XxulcVzj4MZdwsAB',
   *   );
   * ```
   */
  del(fineTunedModelCheckpoint, permissionId, options) {
    return this._client.delete(`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions/${permissionId}`, options);
  }
};
var PermissionCreateResponsesPage = class extends Page2 {
};
Permissions2.PermissionCreateResponsesPage = PermissionCreateResponsesPage;

// node_modules/openai/resources/fine-tuning/checkpoints/checkpoints.mjs
var Checkpoints = class extends APIResource {
  constructor() {
    super(...arguments);
    this.permissions = new Permissions2(this._client);
  }
};
Checkpoints.Permissions = Permissions2;
Checkpoints.PermissionCreateResponsesPage = PermissionCreateResponsesPage;

// node_modules/openai/resources/fine-tuning/jobs/checkpoints.mjs
var Checkpoints2 = class extends APIResource {
  list(fineTuningJobId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(fineTuningJobId, {}, query);
    }
    return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/checkpoints`, FineTuningJobCheckpointsPage, { query, ...options });
  }
};
var FineTuningJobCheckpointsPage = class extends CursorPage {
};
Checkpoints2.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;

// node_modules/openai/resources/fine-tuning/jobs/jobs.mjs
var Jobs = class extends APIResource {
  constructor() {
    super(...arguments);
    this.checkpoints = new Checkpoints2(this._client);
  }
  /**
   * Creates a fine-tuning job which begins the process of creating a new model from
   * a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.create({
   *   model: 'gpt-4o-mini',
   *   training_file: 'file-abc123',
   * });
   * ```
   */
  create(body, options) {
    return this._client.post("/fine_tuning/jobs", { body, ...options });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.retrieve(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  retrieve(fineTuningJobId, options) {
    return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/fine_tuning/jobs", FineTuningJobsPage, { query, ...options });
  }
  /**
   * Immediately cancel a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.cancel(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  cancel(fineTuningJobId, options) {
    return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);
  }
  listEvents(fineTuningJobId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.listEvents(fineTuningJobId, {}, query);
    }
    return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {
      query,
      ...options
    });
  }
  /**
   * Pause a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.pause(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  pause(fineTuningJobId, options) {
    return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/pause`, options);
  }
  /**
   * Resume a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.resume(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  resume(fineTuningJobId, options) {
    return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/resume`, options);
  }
};
var FineTuningJobsPage = class extends CursorPage {
};
var FineTuningJobEventsPage = class extends CursorPage {
};
Jobs.FineTuningJobsPage = FineTuningJobsPage;
Jobs.FineTuningJobEventsPage = FineTuningJobEventsPage;
Jobs.Checkpoints = Checkpoints2;
Jobs.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;

// node_modules/openai/resources/fine-tuning/fine-tuning.mjs
var FineTuning = class extends APIResource {
  constructor() {
    super(...arguments);
    this.methods = new Methods(this._client);
    this.jobs = new Jobs(this._client);
    this.checkpoints = new Checkpoints(this._client);
    this.alpha = new Alpha(this._client);
  }
};
FineTuning.Methods = Methods;
FineTuning.Jobs = Jobs;
FineTuning.FineTuningJobsPage = FineTuningJobsPage;
FineTuning.FineTuningJobEventsPage = FineTuningJobEventsPage;
FineTuning.Checkpoints = Checkpoints;
FineTuning.Alpha = Alpha;

// node_modules/openai/resources/graders/grader-models.mjs
var GraderModels = class extends APIResource {
};

// node_modules/openai/resources/graders/graders.mjs
var Graders2 = class extends APIResource {
  constructor() {
    super(...arguments);
    this.graderModels = new GraderModels(this._client);
  }
};
Graders2.GraderModels = GraderModels;

// node_modules/openai/resources/images.mjs
var Images = class extends APIResource {
  /**
   * Creates a variation of a given image. This endpoint only supports `dall-e-2`.
   *
   * @example
   * ```ts
   * const imagesResponse = await client.images.createVariation({
   *   image: fs.createReadStream('otter.png'),
   * });
   * ```
   */
  createVariation(body, options) {
    return this._client.post("/images/variations", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an edited or extended image given one or more source images and a
   * prompt. This endpoint only supports `gpt-image-1` and `dall-e-2`.
   *
   * @example
   * ```ts
   * const imagesResponse = await client.images.edit({
   *   image: fs.createReadStream('path/to/file'),
   *   prompt: 'A cute baby sea otter wearing a beret',
   * });
   * ```
   */
  edit(body, options) {
    return this._client.post("/images/edits", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an image given a prompt.
   * [Learn more](https://platform.openai.com/docs/guides/images).
   *
   * @example
   * ```ts
   * const imagesResponse = await client.images.generate({
   *   prompt: 'A cute baby sea otter',
   * });
   * ```
   */
  generate(body, options) {
    return this._client.post("/images/generations", { body, ...options });
  }
};

// node_modules/openai/resources/models.mjs
var Models = class extends APIResource {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(model, options) {
    return this._client.get(`/models/${model}`, options);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(options) {
    return this._client.getAPIList("/models", ModelsPage, options);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  del(model, options) {
    return this._client.delete(`/models/${model}`, options);
  }
};
var ModelsPage = class extends Page2 {
};
Models.ModelsPage = ModelsPage;

// node_modules/openai/resources/moderations.mjs
var Moderations = class extends APIResource {
  /**
   * Classifies if text and/or image inputs are potentially harmful. Learn more in
   * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
   */
  create(body, options) {
    return this._client.post("/moderations", { body, ...options });
  }
};

// node_modules/openai/lib/ResponsesParser.mjs
function maybeParseResponse(response, params) {
  if (!params || !hasAutoParseableInput2(params)) {
    return {
      ...response,
      output_parsed: null,
      output: response.output.map((item) => {
        if (item.type === "function_call") {
          return {
            ...item,
            parsed_arguments: null
          };
        }
        if (item.type === "message") {
          return {
            ...item,
            content: item.content.map((content) => ({
              ...content,
              parsed: null
            }))
          };
        } else {
          return item;
        }
      })
    };
  }
  return parseResponse(response, params);
}
function parseResponse(response, params) {
  const output = response.output.map((item) => {
    if (item.type === "function_call") {
      return {
        ...item,
        parsed_arguments: parseToolCall2(params, item)
      };
    }
    if (item.type === "message") {
      const content = item.content.map((content2) => {
        if (content2.type === "output_text") {
          return {
            ...content2,
            parsed: parseTextFormat(params, content2.text)
          };
        }
        return content2;
      });
      return {
        ...item,
        content
      };
    }
    return item;
  });
  const parsed = Object.assign({}, response, { output });
  if (!Object.getOwnPropertyDescriptor(response, "output_text")) {
    addOutputText(parsed);
  }
  Object.defineProperty(parsed, "output_parsed", {
    enumerable: true,
    get() {
      for (const output2 of parsed.output) {
        if (output2.type !== "message") {
          continue;
        }
        for (const content of output2.content) {
          if (content.type === "output_text" && content.parsed !== null) {
            return content.parsed;
          }
        }
      }
      return null;
    }
  });
  return parsed;
}
function parseTextFormat(params, content) {
  if (params.text?.format?.type !== "json_schema") {
    return null;
  }
  if ("$parseRaw" in params.text?.format) {
    const text_format = params.text?.format;
    return text_format.$parseRaw(content);
  }
  return JSON.parse(content);
}
function hasAutoParseableInput2(params) {
  if (isAutoParsableResponseFormat(params.text?.format)) {
    return true;
  }
  return false;
}
function isAutoParsableTool2(tool) {
  return tool?.["$brand"] === "auto-parseable-tool";
}
function getInputToolByName(input_tools, name) {
  return input_tools.find((tool) => tool.type === "function" && tool.name === name);
}
function parseToolCall2(params, toolCall) {
  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);
  return {
    ...toolCall,
    ...toolCall,
    parsed_arguments: isAutoParsableTool2(inputTool) ? inputTool.$parseRaw(toolCall.arguments) : inputTool?.strict ? JSON.parse(toolCall.arguments) : null
  };
}
function addOutputText(rsp) {
  const texts = [];
  for (const output of rsp.output) {
    if (output.type !== "message") {
      continue;
    }
    for (const content of output.content) {
      if (content.type === "output_text") {
        texts.push(content.text);
      }
    }
  }
  rsp.output_text = texts.join("");
}

// node_modules/openai/resources/responses/input-items.mjs
var InputItems = class extends APIResource {
  list(responseId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(responseId, {}, query);
    }
    return this._client.getAPIList(`/responses/${responseId}/input_items`, ResponseItemsPage, {
      query,
      ...options
    });
  }
};

// node_modules/openai/lib/responses/ResponseStream.mjs
var __classPrivateFieldSet10 = function(receiver, state, value, kind2, f3) {
  if (kind2 === "m") throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f3) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet12 = function(receiver, state, kind2, f3) {
  if (kind2 === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f3 : kind2 === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
};
var _ResponseStream_instances;
var _ResponseStream_params;
var _ResponseStream_currentResponseSnapshot;
var _ResponseStream_finalResponse;
var _ResponseStream_beginRequest;
var _ResponseStream_addEvent;
var _ResponseStream_endRequest;
var _ResponseStream_accumulateResponse;
var ResponseStream = class _ResponseStream extends EventStream {
  constructor(params) {
    super();
    _ResponseStream_instances.add(this);
    _ResponseStream_params.set(this, void 0);
    _ResponseStream_currentResponseSnapshot.set(this, void 0);
    _ResponseStream_finalResponse.set(this, void 0);
    __classPrivateFieldSet10(this, _ResponseStream_params, params, "f");
  }
  static createResponse(client, params, options) {
    const runner = new _ResponseStream(params);
    runner._run(() => runner._createOrRetrieveResponse(client, params, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createOrRetrieveResponse(client, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet12(this, _ResponseStream_instances, "m", _ResponseStream_beginRequest).call(this);
    let stream;
    let starting_after = null;
    if ("response_id" in params) {
      stream = await client.responses.retrieve(params.response_id, { stream: true }, { ...options, signal: this.controller.signal, stream: true });
      starting_after = params.starting_after ?? null;
    } else {
      stream = await client.responses.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    }
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet12(this, _ResponseStream_instances, "m", _ResponseStream_addEvent).call(this, event, starting_after);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return __classPrivateFieldGet12(this, _ResponseStream_instances, "m", _ResponseStream_endRequest).call(this);
  }
  [(_ResponseStream_params = /* @__PURE__ */ new WeakMap(), _ResponseStream_currentResponseSnapshot = /* @__PURE__ */ new WeakMap(), _ResponseStream_finalResponse = /* @__PURE__ */ new WeakMap(), _ResponseStream_instances = /* @__PURE__ */ new WeakSet(), _ResponseStream_beginRequest = function _ResponseStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet10(this, _ResponseStream_currentResponseSnapshot, void 0, "f");
  }, _ResponseStream_addEvent = function _ResponseStream_addEvent2(event, starting_after) {
    if (this.ended)
      return;
    const maybeEmit = (name, event2) => {
      if (starting_after == null || event2.sequence_number > starting_after) {
        this._emit(name, event2);
      }
    };
    const response = __classPrivateFieldGet12(this, _ResponseStream_instances, "m", _ResponseStream_accumulateResponse).call(this, event);
    maybeEmit("event", event);
    switch (event.type) {
      case "response.output_text.delta": {
        const output = response.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          const content = output.content[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "output_text") {
            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
          }
          maybeEmit("response.output_text.delta", {
            ...event,
            snapshot: content.text
          });
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const output = response.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "function_call") {
          maybeEmit("response.function_call_arguments.delta", {
            ...event,
            snapshot: output.arguments
          });
        }
        break;
      }
      default:
        maybeEmit(event.type, event);
        break;
    }
  }, _ResponseStream_endRequest = function _ResponseStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet12(this, _ResponseStream_currentResponseSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any events`);
    }
    __classPrivateFieldSet10(this, _ResponseStream_currentResponseSnapshot, void 0, "f");
    const parsedResponse = finalizeResponse(snapshot, __classPrivateFieldGet12(this, _ResponseStream_params, "f"));
    __classPrivateFieldSet10(this, _ResponseStream_finalResponse, parsedResponse, "f");
    return parsedResponse;
  }, _ResponseStream_accumulateResponse = function _ResponseStream_accumulateResponse2(event) {
    let snapshot = __classPrivateFieldGet12(this, _ResponseStream_currentResponseSnapshot, "f");
    if (!snapshot) {
      if (event.type !== "response.created") {
        throw new OpenAIError(`When snapshot hasn't been set yet, expected 'response.created' event, got ${event.type}`);
      }
      snapshot = __classPrivateFieldSet10(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
      return snapshot;
    }
    switch (event.type) {
      case "response.output_item.added": {
        snapshot.output.push(event.item);
        break;
      }
      case "response.content_part.added": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          output.content.push(event.part);
        }
        break;
      }
      case "response.output_text.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          const content = output.content[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "output_text") {
            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
          }
          content.text += event.delta;
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "function_call") {
          output.arguments += event.delta;
        }
        break;
      }
      case "response.completed": {
        __classPrivateFieldSet10(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
        break;
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve2, reject) => readQueue.push({ resolve: resolve2, reject })).then((event2) => event2 ? { value: event2, done: false } : { value: void 0, done: true });
        }
        const event = pushQueue.shift();
        return { value: event, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  /**
   * @returns a promise that resolves with the final Response, or rejects
   * if an error occurred or the stream ended prematurely without producing a REsponse.
   */
  async finalResponse() {
    await this.done();
    const response = __classPrivateFieldGet12(this, _ResponseStream_finalResponse, "f");
    if (!response)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return response;
  }
};
function finalizeResponse(snapshot, params) {
  return maybeParseResponse(snapshot, params);
}

// node_modules/openai/resources/responses/responses.mjs
var Responses = class extends APIResource {
  constructor() {
    super(...arguments);
    this.inputItems = new InputItems(this._client);
  }
  create(body, options) {
    return this._client.post("/responses", { body, ...options, stream: body.stream ?? false })._thenUnwrap((rsp) => {
      if ("object" in rsp && rsp.object === "response") {
        addOutputText(rsp);
      }
      return rsp;
    });
  }
  retrieve(responseId, query = {}, options) {
    return this._client.get(`/responses/${responseId}`, {
      query,
      ...options,
      stream: query?.stream ?? false
    });
  }
  /**
   * Deletes a model response with the given ID.
   *
   * @example
   * ```ts
   * await client.responses.del(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  del(responseId, options) {
    return this._client.delete(`/responses/${responseId}`, {
      ...options,
      headers: { Accept: "*/*", ...options?.headers }
    });
  }
  parse(body, options) {
    return this._client.responses.create(body, options)._thenUnwrap((response) => parseResponse(response, body));
  }
  /**
   * Creates a model response stream
   */
  stream(body, options) {
    return ResponseStream.createResponse(this._client, body, options);
  }
  /**
   * Cancels a model response with the given ID. Only responses created with the
   * `background` parameter set to `true` can be cancelled.
   * [Learn more](https://platform.openai.com/docs/guides/background).
   *
   * @example
   * ```ts
   * await client.responses.cancel(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  cancel(responseId, options) {
    return this._client.post(`/responses/${responseId}/cancel`, {
      ...options,
      headers: { Accept: "*/*", ...options?.headers }
    });
  }
};
var ResponseItemsPage = class extends CursorPage {
};
Responses.InputItems = InputItems;

// node_modules/openai/resources/uploads/parts.mjs
var Parts = class extends APIResource {
  /**
   * Adds a
   * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
   * A Part represents a chunk of bytes from the file you are trying to upload.
   *
   * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
   * maximum of 8 GB.
   *
   * It is possible to add multiple Parts in parallel. You can decide the intended
   * order of the Parts when you
   * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
   */
  create(uploadId, body, options) {
    return this._client.post(`/uploads/${uploadId}/parts`, multipartFormRequestOptions({ body, ...options }));
  }
};

// node_modules/openai/resources/uploads/uploads.mjs
var Uploads = class extends APIResource {
  constructor() {
    super(...arguments);
    this.parts = new Parts(this._client);
  }
  /**
   * Creates an intermediate
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
   * that you can add
   * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
   * Currently, an Upload can accept at most 8 GB in total and expires after an hour
   * after you create it.
   *
   * Once you complete the Upload, we will create a
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * contains all the parts you uploaded. This File is usable in the rest of our
   * platform as a regular File object.
   *
   * For certain `purpose` values, the correct `mime_type` must be specified. Please
   * refer to documentation for the
   * [supported MIME types for your use case](https://platform.openai.com/docs/assistants/tools/file-search#supported-files).
   *
   * For guidance on the proper filename extensions for each purpose, please follow
   * the documentation on
   * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
   */
  create(body, options) {
    return this._client.post("/uploads", { body, ...options });
  }
  /**
   * Cancels the Upload. No Parts may be added after an Upload is cancelled.
   */
  cancel(uploadId, options) {
    return this._client.post(`/uploads/${uploadId}/cancel`, options);
  }
  /**
   * Completes the
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
   *
   * Within the returned Upload object, there is a nested
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * is ready to use in the rest of the platform.
   *
   * You can specify the order of the Parts by passing in an ordered list of the Part
   * IDs.
   *
   * The number of bytes uploaded upon completion must match the number of bytes
   * initially specified when creating the Upload object. No Parts may be added after
   * an Upload is completed.
   */
  complete(uploadId, body, options) {
    return this._client.post(`/uploads/${uploadId}/complete`, { body, ...options });
  }
};
Uploads.Parts = Parts;

// node_modules/openai/lib/Util.mjs
var allSettledWithThrow = async (promises) => {
  const results = await Promise.allSettled(promises);
  const rejected = results.filter((result) => result.status === "rejected");
  if (rejected.length) {
    for (const result of rejected) {
      console.error(result.reason);
    }
    throw new Error(`${rejected.length} promise(s) failed - see the above errors`);
  }
  const values = [];
  for (const result of results) {
    if (result.status === "fulfilled") {
      values.push(result.value);
    }
  }
  return values;
};

// node_modules/openai/resources/vector-stores/files.mjs
var Files3 = class extends APIResource {
  /**
   * Create a vector store file by attaching a
   * [File](https://platform.openai.com/docs/api-reference/files) to a
   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
   */
  create(vectorStoreId, body, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}/files`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Retrieves a vector store file.
   */
  retrieve(vectorStoreId, fileId, options) {
    return this._client.get(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Update attributes on a vector store file.
   */
  update(vectorStoreId, fileId, body, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  list(vectorStoreId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(vectorStoreId, {}, query);
    }
    return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files`, VectorStoreFilesPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Delete a vector store file. This will remove the file from the vector store but
   * the file itself will not be deleted. To delete the file, use the
   * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
   * endpoint.
   */
  del(vectorStoreId, fileId, options) {
    return this._client.delete(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Attach a file to the given vector store and wait for it to be processed.
   */
  async createAndPoll(vectorStoreId, body, options) {
    const file = await this.create(vectorStoreId, body, options);
    return await this.poll(vectorStoreId, file.id, options);
  }
  /**
   * Wait for the vector store file to finish processing.
   *
   * Note: this will return even if the file failed to process, you need to check
   * file.last_error and file.status to handle these cases
   */
  async poll(vectorStoreId, fileId, options) {
    const headers = { ...options?.headers, "X-Stainless-Poll-Helper": "true" };
    if (options?.pollIntervalMs) {
      headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
    }
    while (true) {
      const fileResponse = await this.retrieve(vectorStoreId, fileId, {
        ...options,
        headers
      }).withResponse();
      const file = fileResponse.data;
      switch (file.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options?.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = fileResponse.response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep(sleepInterval);
          break;
        case "failed":
        case "completed":
          return file;
      }
    }
  }
  /**
   * Upload a file to the `files` API and then attach it to the given vector store.
   *
   * Note the file will be asynchronously processed (you can use the alternative
   * polling helper method to wait for processing to complete).
   */
  async upload(vectorStoreId, file, options) {
    const fileInfo = await this._client.files.create({ file, purpose: "assistants" }, options);
    return this.create(vectorStoreId, { file_id: fileInfo.id }, options);
  }
  /**
   * Add a file to a vector store and poll until processing is complete.
   */
  async uploadAndPoll(vectorStoreId, file, options) {
    const fileInfo = await this.upload(vectorStoreId, file, options);
    return await this.poll(vectorStoreId, fileInfo.id, options);
  }
  /**
   * Retrieve the parsed contents of a vector store file.
   */
  content(vectorStoreId, fileId, options) {
    return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files/${fileId}/content`, FileContentResponsesPage, { ...options, headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers } });
  }
};
var VectorStoreFilesPage = class extends CursorPage {
};
var FileContentResponsesPage = class extends Page2 {
};
Files3.VectorStoreFilesPage = VectorStoreFilesPage;
Files3.FileContentResponsesPage = FileContentResponsesPage;

// node_modules/openai/resources/vector-stores/file-batches.mjs
var FileBatches = class extends APIResource {
  /**
   * Create a vector store file batch.
   */
  create(vectorStoreId, body, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}/file_batches`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Retrieves a vector store file batch.
   */
  retrieve(vectorStoreId, batchId, options) {
    return this._client.get(`/vector_stores/${vectorStoreId}/file_batches/${batchId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Cancel a vector store file batch. This attempts to cancel the processing of
   * files in this batch as soon as possible.
   */
  cancel(vectorStoreId, batchId, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/cancel`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Create a vector store batch and poll until all files have been processed.
   */
  async createAndPoll(vectorStoreId, body, options) {
    const batch = await this.create(vectorStoreId, body);
    return await this.poll(vectorStoreId, batch.id, options);
  }
  listFiles(vectorStoreId, batchId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.listFiles(vectorStoreId, batchId, {}, query);
    }
    return this._client.getAPIList(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/files`, VectorStoreFilesPage, { query, ...options, headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers } });
  }
  /**
   * Wait for the given file batch to be processed.
   *
   * Note: this will return even if one of the files failed to process, you need to
   * check batch.file_counts.failed_count to handle this case.
   */
  async poll(vectorStoreId, batchId, options) {
    const headers = { ...options?.headers, "X-Stainless-Poll-Helper": "true" };
    if (options?.pollIntervalMs) {
      headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
    }
    while (true) {
      const { data: batch, response } = await this.retrieve(vectorStoreId, batchId, {
        ...options,
        headers
      }).withResponse();
      switch (batch.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options?.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep(sleepInterval);
          break;
        case "failed":
        case "cancelled":
        case "completed":
          return batch;
      }
    }
  }
  /**
   * Uploads the given files concurrently and then creates a vector store file batch.
   *
   * The concurrency limit is configurable using the `maxConcurrency` parameter.
   */
  async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {
    if (files == null || files.length == 0) {
      throw new Error(`No \`files\` provided to process. If you've already uploaded files you should use \`.createAndPoll()\` instead`);
    }
    const configuredConcurrency = options?.maxConcurrency ?? 5;
    const concurrencyLimit = Math.min(configuredConcurrency, files.length);
    const client = this._client;
    const fileIterator = files.values();
    const allFileIds = [...fileIds];
    async function processFiles(iterator) {
      for (let item of iterator) {
        const fileObj = await client.files.create({ file: item, purpose: "assistants" }, options);
        allFileIds.push(fileObj.id);
      }
    }
    const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);
    await allSettledWithThrow(workers);
    return await this.createAndPoll(vectorStoreId, {
      file_ids: allFileIds
    });
  }
};

// node_modules/openai/resources/vector-stores/vector-stores.mjs
var VectorStores = class extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files3(this._client);
    this.fileBatches = new FileBatches(this._client);
  }
  /**
   * Create a vector store.
   */
  create(body, options) {
    return this._client.post("/vector_stores", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Retrieves a vector store.
   */
  retrieve(vectorStoreId, options) {
    return this._client.get(`/vector_stores/${vectorStoreId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Modifies a vector store.
   */
  update(vectorStoreId, body, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/vector_stores", VectorStoresPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Delete a vector store.
   */
  del(vectorStoreId, options) {
    return this._client.delete(`/vector_stores/${vectorStoreId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Search a vector store for relevant chunks based on a query and file attributes
   * filter.
   */
  search(vectorStoreId, body, options) {
    return this._client.getAPIList(`/vector_stores/${vectorStoreId}/search`, VectorStoreSearchResponsesPage, {
      body,
      method: "post",
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
};
var VectorStoresPage = class extends CursorPage {
};
var VectorStoreSearchResponsesPage = class extends Page2 {
};
VectorStores.VectorStoresPage = VectorStoresPage;
VectorStores.VectorStoreSearchResponsesPage = VectorStoreSearchResponsesPage;
VectorStores.Files = Files3;
VectorStores.VectorStoreFilesPage = VectorStoreFilesPage;
VectorStores.FileContentResponsesPage = FileContentResponsesPage;
VectorStores.FileBatches = FileBatches;

// node_modules/openai/index.mjs
var _a3;
var OpenAI = class extends APIClient {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
   * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
   * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL = readEnv("OPENAI_BASE_URL"), apiKey = readEnv("OPENAI_API_KEY"), organization = readEnv("OPENAI_ORG_ID") ?? null, project = readEnv("OPENAI_PROJECT_ID") ?? null, ...opts } = {}) {
    if (apiKey === void 0) {
      throw new OpenAIError("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).");
    }
    const options = {
      apiKey,
      organization,
      project,
      ...opts,
      baseURL: baseURL || `https://api.openai.com/v1`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
    }
    super({
      baseURL: options.baseURL,
      timeout: options.timeout ?? 6e5,
      httpAgent: options.httpAgent,
      maxRetries: options.maxRetries,
      fetch: options.fetch
    });
    this.completions = new Completions3(this);
    this.chat = new Chat(this);
    this.embeddings = new Embeddings(this);
    this.files = new Files2(this);
    this.images = new Images(this);
    this.audio = new Audio(this);
    this.moderations = new Moderations(this);
    this.models = new Models(this);
    this.fineTuning = new FineTuning(this);
    this.graders = new Graders2(this);
    this.vectorStores = new VectorStores(this);
    this.beta = new Beta(this);
    this.batches = new Batches(this);
    this.uploads = new Uploads(this);
    this.responses = new Responses(this);
    this.evals = new Evals(this);
    this.containers = new Containers(this);
    this._options = options;
    this.apiKey = apiKey;
    this.organization = organization;
    this.project = project;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(opts) {
    return {
      ...super.defaultHeaders(opts),
      "OpenAI-Organization": this.organization,
      "OpenAI-Project": this.project,
      ...this._options.defaultHeaders
    };
  }
  authHeaders(opts) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
  stringifyQuery(query) {
    return stringify(query, { arrayFormat: "brackets" });
  }
};
_a3 = OpenAI;
OpenAI.OpenAI = _a3;
OpenAI.DEFAULT_TIMEOUT = 6e5;
OpenAI.OpenAIError = OpenAIError;
OpenAI.APIError = APIError;
OpenAI.APIConnectionError = APIConnectionError;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
OpenAI.APIUserAbortError = APIUserAbortError;
OpenAI.NotFoundError = NotFoundError;
OpenAI.ConflictError = ConflictError;
OpenAI.RateLimitError = RateLimitError;
OpenAI.BadRequestError = BadRequestError;
OpenAI.AuthenticationError = AuthenticationError;
OpenAI.InternalServerError = InternalServerError;
OpenAI.PermissionDeniedError = PermissionDeniedError;
OpenAI.UnprocessableEntityError = UnprocessableEntityError;
OpenAI.toFile = toFile;
OpenAI.fileFromPath = fileFromPath;
OpenAI.Completions = Completions3;
OpenAI.Chat = Chat;
OpenAI.ChatCompletionsPage = ChatCompletionsPage;
OpenAI.Embeddings = Embeddings;
OpenAI.Files = Files2;
OpenAI.FileObjectsPage = FileObjectsPage;
OpenAI.Images = Images;
OpenAI.Audio = Audio;
OpenAI.Moderations = Moderations;
OpenAI.Models = Models;
OpenAI.ModelsPage = ModelsPage;
OpenAI.FineTuning = FineTuning;
OpenAI.Graders = Graders2;
OpenAI.VectorStores = VectorStores;
OpenAI.VectorStoresPage = VectorStoresPage;
OpenAI.VectorStoreSearchResponsesPage = VectorStoreSearchResponsesPage;
OpenAI.Beta = Beta;
OpenAI.Batches = Batches;
OpenAI.BatchesPage = BatchesPage;
OpenAI.Uploads = Uploads;
OpenAI.Responses = Responses;
OpenAI.Evals = Evals;
OpenAI.EvalListResponsesPage = EvalListResponsesPage;
OpenAI.Containers = Containers;
OpenAI.ContainerListResponsesPage = ContainerListResponsesPage;
var openai_default = OpenAI;

// src/openai.ts
init_pdf();
function buildPrompt(url, meta, defaultTags, promptTemplate = PROMPT_TEMPLATE) {
  const articleText = meta.text.trim() || "_NO ARTICLE TEXT EXTRACTED_";
  const base = promptTemplate.replace("{url}", url).replace("{title}", meta.title || "").replace("{authors}", meta.authors.join(", ")).replace("{published}", meta.published || "").replace("{source}", meta.sourceGuess || "").replace("{article_text}", articleText);
  const tagsArray = Array.isArray(defaultTags) ? defaultTags : defaultTags ? defaultTags.split(",").map((t3) => t3.trim()).filter(Boolean) : [];
  if (tagsArray.length) {
    const tagsBlock = tagsArray.map((t3) => `- ${t3}`).join("\n");
    return `${base}

DEFAULT TAGS TO INCLUDE IN YAML (if appropriate):
${tagsBlock}`;
  }
  return base;
}
async function formatWithModel(apiKey, model, url, meta, defaultTags, promptTemplate, provider = "openai", apiBaseUrl) {
  const client = getOpenAIClient(apiKey, apiBaseUrl);
  const prompt = buildPrompt(url, meta, defaultTags, promptTemplate || PROMPT_TEMPLATE);
  if (provider === "lmstudio") {
    const resp2 = await client.chat.completions.create({
      model,
      messages: [{ role: "user", content: prompt }]
    });
    const output2 = resp2.choices?.[0]?.message?.content ?? "";
    return output2.trim();
  }
  const resp = await client.responses.create({
    model,
    input: prompt
  });
  const output = resp.output_text ?? "";
  return output.trim();
}
async function formatPdfWithVision(apiKey, model, url, meta, defaultTags, promptTemplate) {
  if (!isVisionModel(model)) {
    throw new Error(`Model ${model} does not support native PDF input. Use text extraction mode instead.`);
  }
  if (!meta.pdfBuffer) {
    throw new Error("PDF buffer not available for native vision processing");
  }
  const client = getOpenAIClient(apiKey);
  const prompt = buildPrompt(url, meta, defaultTags, promptTemplate || PROMPT_TEMPLATE);
  const base64Pdf = arrayBufferToBase64(meta.pdfBuffer);
  const fileContent = {
    type: "file",
    file: {
      filename: "document.pdf",
      file_data: `data:application/pdf;base64,${base64Pdf}`
    }
  };
  const textContent = {
    type: "text",
    text: prompt
  };
  const resp = await client.chat.completions.create({
    model,
    messages: [
      {
        role: "user",
        content: [fileContent, textContent]
      }
    ],
    max_tokens: 4096
  });
  const output = resp.choices?.[0]?.message?.content ?? "";
  return output.trim();
}
var cachedClient = null;
function getOpenAIClient(apiKey, baseUrl) {
  if (cachedClient?.key === apiKey && cachedClient.baseUrl === baseUrl) return cachedClient.client;
  const client = new openai_default({
    apiKey,
    baseURL: baseUrl || void 0,
    // Obsidian plugins run in an Electron renderer; allow browser usage explicitly.
    ...typeof window !== "undefined" ? { dangerouslyAllowBrowser: true } : {}
  });
  cachedClient = { key: apiKey, baseUrl, client };
  return client;
}

// src/note.ts
var import_obsidian4 = require("obsidian");
function sanitizeFilename(name, maxLen = 120) {
  let safe = name.trim();
  safe = safe.replace(/[<>:"/\\|?*]/g, "");
  safe = safe.replace(/\s+/g, " ").trim();
  safe = safe.replace(/[. ]+$/, "");
  if (!safe) safe = "untitled";
  if (safe.length > maxLen) safe = safe.slice(0, maxLen);
  return safe;
}
function ensureFrontmatterPresent(note) {
  if (!note.startsWith("---")) {
    throw new Error("Model output did not start with YAML frontmatter ('---').");
  }
  const second = note.indexOf("\n---", 3);
  if (second === -1) {
    throw new Error("Model output did not include a closing YAML frontmatter delimiter ('---').");
  }
  try {
    const yamlBlock = note.slice(3, second).trim();
    const parsed = (0, import_obsidian4.parseYaml)(yamlBlock);
    if (parsed === null || typeof parsed !== "object") {
      throw new Error("Frontmatter YAML is not an object.");
    }
  } catch (err) {
    console.log("Frontmatter parse failed. Attempting strict sanitization...");
    try {
      const yamlBlock = note.slice(3, second);
      const sanitized = yamlBlock.replace(/\\/g, "/");
      try {
        const parsed = (0, import_obsidian4.parseYaml)(sanitized.trim());
        if (parsed && typeof parsed === "object") {
          console.log("YAML Strategy 1 (global /) succeeded.");
          return `---
${sanitized.trim()}
---${note.slice(second + 3)}`;
        }
      } catch (e1) {
        console.warn("YAML Strategy 1 failed:", e1);
      }
      const sanitized2 = yamlBlock.replace(/title:\s*"(.*)"/g, (match, p1) => {
        return `title: "${p1.replace(/\\/g, "/")}"`;
      });
      try {
        const parsed2 = (0, import_obsidian4.parseYaml)(sanitized2.trim());
        if (parsed2 && typeof parsed2 === "object") {
          console.log("YAML Strategy 2 (targeted title) succeeded.");
          return `---
${sanitized2.trim()}
---${note.slice(second + 3)}`;
        }
      } catch (e22) {
        console.warn("YAML Strategy 2 failed:", e22);
      }
    } catch (fallbackErr) {
      console.error("All file sanitization strategies failed:", fallbackErr);
    }
    const msg = err instanceof Error ? err.message : "Invalid YAML frontmatter.";
    throw new Error(`Invalid YAML frontmatter: ${msg}`);
  }
  return note;
}
async function ensureFolderExists(vault, folder) {
  const normalized = folder ? (0, import_obsidian4.normalizePath)(folder) : "";
  if (!normalized) return "";
  const adapter = vault.adapter;
  if (!await adapter.exists(normalized)) {
    await vault.createFolder(normalized);
  }
  return normalized;
}
async function nextAvailablePath(vault, basePath) {
  const adapter = vault.adapter;
  if (!await adapter.exists(basePath)) return basePath;
  const extIndex = basePath.lastIndexOf(".");
  const base = extIndex === -1 ? basePath : basePath.slice(0, extIndex);
  const ext = extIndex === -1 ? "" : basePath.slice(extIndex);
  let counter = 2;
  let candidate = `${base} (${counter})${ext}`;
  while (await adapter.exists(candidate)) {
    counter += 1;
    candidate = `${base} (${counter})${ext}`;
  }
  return candidate;
}
async function saveNoteToVault(vault, folder, title, content) {
  const normalizedFolder = await ensureFolderExists(vault, folder);
  const filename = sanitizeFilename(title || "article") + ".md";
  const fullPath = normalizedFolder ? `${normalizedFolder}/${filename}` : filename;
  const uniquePath = await nextAvailablePath(vault, fullPath);
  const normalizedContent = content.endsWith("\n") ? content : `${content}
`;
  return vault.create((0, import_obsidian4.normalizePath)(uniquePath), normalizedContent);
}

// src/csv.ts
var import_papaparse = __toESM(require_papaparse());
var URL_COLUMN_PATTERNS = ["url", "link", "href", "source", "uri", "address"];
var LABEL_COLUMN_PATTERNS = ["label", "title", "name", "description", "desc"];
function isValidUrl(str2) {
  if (!str2 || typeof str2 !== "string") return false;
  const trimmed = str2.trim();
  if (!trimmed) return false;
  try {
    const url = new URL(trimmed.startsWith("http") ? trimmed : `https://${trimmed}`);
    return url.protocol === "http:" || url.protocol === "https:";
  } catch {
    return false;
  }
}
function detectUrlColumn(headers) {
  if (!headers || headers.length === 0) return null;
  const lowerHeaders = headers.map((h3) => h3.toLowerCase().trim());
  for (const pattern of URL_COLUMN_PATTERNS) {
    const index = lowerHeaders.indexOf(pattern);
    if (index !== -1) return headers[index];
  }
  for (const pattern of URL_COLUMN_PATTERNS) {
    const index = lowerHeaders.findIndex((h3) => h3.includes(pattern));
    if (index !== -1) return headers[index];
  }
  return headers[0];
}
function detectLabelColumn(headers) {
  if (!headers || headers.length === 0) return null;
  const lowerHeaders = headers.map((h3) => h3.toLowerCase().trim());
  for (const pattern of LABEL_COLUMN_PATTERNS) {
    const index = lowerHeaders.indexOf(pattern);
    if (index !== -1) return headers[index];
  }
  for (const pattern of LABEL_COLUMN_PATTERNS) {
    const index = lowerHeaders.findIndex((h3) => h3.includes(pattern));
    if (index !== -1) return headers[index];
  }
  return null;
}
function normalizeUrl(url) {
  const trimmed = url.trim();
  if (!trimmed) return "";
  if (/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(trimmed)) return trimmed;
  return `https://${trimmed}`;
}
function parseCsvContent(csvText) {
  const errors = [];
  if (!csvText || !csvText.trim()) {
    return { entries: [], errors: ["CSV content is empty"] };
  }
  const result = import_papaparse.default.parse(csvText, {
    header: true,
    skipEmptyLines: true,
    transformHeader: (header) => header.trim()
  });
  if (result.errors && result.errors.length > 0) {
    for (const err of result.errors) {
      errors.push(`Row ${err.row ?? "?"}: ${err.message}`);
    }
  }
  const headers = result.meta.fields || [];
  if (headers.length === 0) {
    return { entries: [], errors: ["No headers found in CSV"] };
  }
  const urlColumn = detectUrlColumn(headers);
  const labelColumn = detectLabelColumn(headers);
  if (!urlColumn) {
    return { entries: [], errors: ["Could not detect URL column in CSV"] };
  }
  const entries = [];
  const seenUrls = /* @__PURE__ */ new Set();
  for (let i3 = 0; i3 < result.data.length; i3++) {
    const row = result.data[i3];
    const rawUrl = row[urlColumn];
    if (!rawUrl || typeof rawUrl !== "string") {
      continue;
    }
    const url = normalizeUrl(rawUrl);
    if (!isValidUrl(url)) {
      errors.push(`Row ${i3 + 2}: Invalid URL "${rawUrl}"`);
      continue;
    }
    if (seenUrls.has(url)) {
      continue;
    }
    seenUrls.add(url);
    const entry = { url };
    if (labelColumn && row[labelColumn]) {
      entry.label = row[labelColumn].trim();
    }
    entries.push(entry);
  }
  return { entries, errors };
}
function parseUrlList(text) {
  const errors = [];
  const entries = [];
  const seenUrls = /* @__PURE__ */ new Set();
  const lines = text.split(/\r?\n/).filter((line) => line.trim());
  for (let i3 = 0; i3 < lines.length; i3++) {
    const line = lines[i3].trim();
    if (!line || line.startsWith("#")) continue;
    const commaIndex = line.indexOf(",");
    let urlPart = line;
    let labelPart = "";
    if (commaIndex !== -1) {
      urlPart = line.substring(0, commaIndex).trim();
      labelPart = line.substring(commaIndex + 1).trim();
      console.debug(`[CSV] Split line: URL="${urlPart}", Label="${labelPart}"`);
    }
    const url = normalizeUrl(urlPart);
    if (!isValidUrl(url)) {
      errors.push(`Line ${i3 + 1}: Invalid URL "${urlPart}"`);
      continue;
    }
    if (seenUrls.has(url)) continue;
    seenUrls.add(url);
    const entry = { url };
    if (labelPart) {
      entry.label = labelPart;
    }
    entries.push(entry);
  }
  return { entries, errors };
}
function parseUrlInput(text) {
  const trimmed = text.trim();
  if (!trimmed) {
    return { entries: [], errors: ["Input is empty"] };
  }
  const firstLine = trimmed.split(/\r?\n/)[0].toLowerCase();
  const hasCommas = firstLine.includes(",");
  const headerPatterns = ["url", "link", "href", "source", "uri", "label", "title", "name"];
  const looksLikeHeader = hasCommas && headerPatterns.some((pattern) => firstLine.includes(pattern));
  if (looksLikeHeader) {
    console.debug("[CSV] Detected header row, using PapaParse");
    return parseCsvContent(trimmed);
  }
  console.debug("[CSV] No header detected, using URL list parser");
  return parseUrlList(trimmed);
}
function getSampleCsvTemplate() {
  return `url,label
https://example.com/article1,First Article
https://example.com/document.pdf,PDF Document
https://example.com/article2,Second Article`;
}

// src/main.ts
init_pdf();
var fs3 = __toESM(require("fs"));
var path = __toESM(require("path"));
var SECRET_KEY_ID = "osint-ner-openai-key";
function ensureHttpScheme(url) {
  const trimmed = url.trim();
  if (!trimmed) return trimmed;
  if (/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(trimmed)) return trimmed;
  return `https://${trimmed}`;
}
function renderTwoStepProgress(step, label) {
  const bar = step === 1 ? "[# ]" : "[##]";
  return `Progress ${bar} (${step}/2) ${label}`;
}
var UrlInputModal = class extends import_obsidian5.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.value = "";
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Import article from URL" });
    const urlSetting = new import_obsidian5.Setting(contentEl).setName("Article URL");
    urlSetting.addText((text) => {
      text.inputEl.placeholder = "https://example.com/article";
      text.onChange((value) => this.value = value.trim());
      text.inputEl.addEventListener("keydown", (e3) => {
        if (e3.key === "Enter") {
          e3.preventDefault();
          this.close();
          this.onSubmit(this.value);
        }
      });
      text.inputEl.addEventListener("focus", () => text.inputEl.select());
      text.inputEl.focus();
    });
    urlSetting.addButton(
      (btn) => btn.setButtonText("Paste").setTooltip("Paste URL from clipboard").onClick(() => {
        void (async () => {
          try {
            const readText = navigator.clipboard?.readText;
            if (!readText) {
              new import_obsidian5.Notice("Clipboard unavailable in this context.");
              return;
            }
            const clip = await readText.call(navigator.clipboard);
            if (!clip) {
              new import_obsidian5.Notice("Clipboard is empty.");
              return;
            }
            this.value = clip.trim();
            const input = urlSetting.controlEl.querySelector("input");
            if (input) {
              input.value = this.value;
              input.focus();
              input.select();
            }
          } catch (err) {
            console.warn("Clipboard read failed", err);
            new import_obsidian5.Notice("Couldn't read clipboard in this context.");
          }
        })();
      })
    );
    new import_obsidian5.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Import").setCta().onClick(() => {
        this.close();
        void this.onSubmit(this.value);
      })
    );
  }
  onClose() {
    this.contentEl.empty();
  }
};
var BatchImportModal = class extends import_obsidian5.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.textArea = null;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Batch import from CSV" });
    contentEl.createEl("p", {
      text: "Paste a CSV with URLs or a simple list of URLs (one per line).",
      cls: "setting-item-description"
    });
    const textAreaContainer = contentEl.createDiv({ cls: "batch-import-textarea-container" });
    this.textArea = textAreaContainer.createEl("textarea", {
      attr: {
        rows: "12",
        placeholder: getSampleCsvTemplate()
      }
    });
    this.textArea.style.width = "100%";
    this.textArea.style.fontFamily = "monospace";
    this.textArea.style.fontSize = "12px";
    new import_obsidian5.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Paste from clipboard").onClick(() => {
        void (async () => {
          try {
            const readText = navigator.clipboard?.readText;
            if (!readText) {
              new import_obsidian5.Notice("Clipboard unavailable in this context.");
              return;
            }
            const clip = await readText.call(navigator.clipboard);
            if (this.textArea) {
              this.textArea.value = clip;
            }
          } catch (err) {
            console.warn("Clipboard read failed", err);
            new import_obsidian5.Notice("Couldn't read clipboard in this context.");
          }
        })();
      })
    ).addButton(
      (btn) => btn.setButtonText("Insert sample").onClick(() => {
        if (this.textArea) {
          this.textArea.value = getSampleCsvTemplate();
        }
      })
    );
    new import_obsidian5.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Start batch import").setCta().onClick(() => {
        const content = this.textArea?.value || "";
        if (!content.trim()) {
          new import_obsidian5.Notice("Please enter URLs to import.");
          return;
        }
        this.close();
        void this.onSubmit(content);
      })
    );
  }
  onClose() {
    this.contentEl.empty();
  }
};
var ManualImportModal = class extends import_obsidian5.Modal {
  constructor(app, url, onSubmit) {
    super(app);
    this.url = url;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Manual Import Required" });
    contentEl.createEl("p", {
      text: "We couldn't download the PDF automatically (likely due to a CAPTCHA or age verification).",
      cls: "setting-item-description"
    });
    contentEl.createEl("p", {
      text: `1. Open this URL in your browser: ${this.url}`,
      cls: "setting-item-description"
    }).createEl("a", { text: "Open Link", href: this.url, cls: "external-link" });
    contentEl.createEl("p", {
      text: "2. Download the PDF to your computer.",
      cls: "setting-item-description"
    });
    contentEl.createEl("p", {
      text: "3. Upload the downloaded file below:",
      cls: "setting-item-description"
    });
    const fileInput = contentEl.createEl("input", {
      type: "file",
      attr: { accept: ".pdf" }
    });
    fileInput.style.marginBottom = "20px";
    fileInput.style.display = "block";
    fileInput.addEventListener("change", async () => {
      if (fileInput.files?.length) {
        const file = fileInput.files[0];
        const buffer = await file.arrayBuffer();
        this.close();
        this.onSubmit(buffer);
      }
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};
var FolderInputModal = class extends import_obsidian5.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.value = "";
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Batch import from local folder" });
    contentEl.createEl("p", {
      text: "Enter the absolute path to a folder containing PDF or HTML files.",
      cls: "setting-item-description"
    });
    const folderSetting = new import_obsidian5.Setting(contentEl).setName("Folder Path");
    folderSetting.addText((text) => {
      text.inputEl.placeholder = "/Users/username/Documents/articles";
      text.onChange((value) => this.value = value.trim());
      text.inputEl.addEventListener("keydown", (e3) => {
        if (e3.key === "Enter") {
          e3.preventDefault();
          this.close();
          this.onSubmit(this.value);
        }
      });
      text.inputEl.focus();
    });
    new import_obsidian5.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Import Folder").setCta().onClick(() => {
        this.close();
        void this.onSubmit(this.value);
      })
    );
  }
  onClose() {
    this.contentEl.empty();
  }
};
var UrlToVaultPlugin = class extends import_obsidian5.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.settings = { ...DEFAULT_SETTINGS };
  }
  logVerbose(...args) {
    if (this.settings.verboseLogging) {
      console.debug("[OSINT-Entity-Extractor]", ...args);
    }
  }
  async onload() {
    await this.loadSettings();
    const openImportModal = () => new UrlInputModal(this.app, (url) => void this.runImport(url)).open();
    this.addCommand({
      id: "import-article-from-url",
      name: "Import article from URL",
      callback: () => {
        openImportModal();
      }
    });
    this.addCommand({
      id: "batch-import-from-csv",
      name: "Batch import from CSV/URL list",
      callback: () => {
        new BatchImportModal(this.app, (csv) => void this.runBatchImport(csv)).open();
      }
    });
    this.addCommand({
      id: "import-from-folder",
      name: "Batch import from local folder",
      callback: () => {
        new FolderInputModal(this.app, (folderPath) => void this.runFolderImport(folderPath)).open();
      }
    });
    this.addRibbonIcon("link", "Import article from URL", () => {
      openImportModal();
    });
    this.addSettingTab(new UrlToVaultSettingTab(this.app, this));
  }
  async loadSettings() {
    const saved = await this.loadData();
    this.settings = { ...DEFAULT_SETTINGS, ...saved ?? {} };
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async getApiKey() {
    if (this.app.secretStorage?.getSecret) {
      try {
        const secret = await this.app.secretStorage.getSecret(SECRET_KEY_ID);
        if (secret) return secret;
      } catch (err) {
        console.warn("SecretStorage getSecret failed", err);
      }
    }
    if (this.settings.apiKey) return this.settings.apiKey;
    if (typeof process !== "undefined" && process.env.OPENAI_API_KEY) {
      return process.env.OPENAI_API_KEY;
    }
    return "";
  }
  async setApiKey(value) {
    if (this.app.secretStorage?.setSecret) {
      try {
        await this.app.secretStorage.setSecret(SECRET_KEY_ID, value);
      } catch (err) {
        console.warn("SecretStorage setSecret failed", err);
      }
    }
    this.settings.apiKey = value;
    await this.saveSettings();
  }
  async testApiKey() {
    const apiKey = await this.getApiKey();
    if (this.settings.provider === "openai" && !apiKey) {
      throw new Error("No API key saved.");
    }
    try {
      const client = getOpenAIClient(this.getApiKeyForProvider(apiKey), this.getApiBaseUrl());
      if (this.settings.provider === "lmstudio") {
        await client.models.list();
        this.logVerbose("LM Studio connection test succeeded", { baseUrl: this.getApiBaseUrl() });
        return;
      }
      const modelToCheck = this.settings.model || "gpt-5-mini";
      await client.models.retrieve(modelToCheck);
      this.logVerbose("OpenAI key test succeeded", { modelChecked: modelToCheck });
    } catch (err) {
      const status = err?.status ?? err?.response?.status;
      if (status === 401) {
        throw new Error("OpenAI rejected the API key (401). Re-enter your key in settings.");
      }
      throw err;
    }
  }
  getApiKeyForProvider(apiKey) {
    if (this.settings.provider === "lmstudio") {
      return apiKey || "lm-studio";
    }
    return apiKey;
  }
  getApiBaseUrl() {
    if (this.settings.provider === "lmstudio") {
      return this.settings.apiBaseUrl?.trim() || "http://localhost:1234/v1";
    }
    return void 0;
  }
  async runImport(url) {
    const normalizedUrl = ensureHttpScheme(url);
    if (!normalizedUrl) {
      new import_obsidian5.Notice("Please enter a URL.");
      return null;
    }
    try {
      new URL(normalizedUrl);
    } catch {
      new import_obsidian5.Notice("Please enter a valid URL.");
      return null;
    }
    const apiKey = await this.getApiKey();
    if (this.settings.provider === "openai" && !apiKey) {
      new import_obsidian5.Notice("Set your OpenAI API key in the plugin settings first.", 6e3);
      return null;
    }
    const progress = new import_obsidian5.Notice(renderTwoStepProgress(1, "Fetching content..."), 0);
    try {
      const meta = await fetchAndExtractContent(
        normalizedUrl,
        this.settings.maxChars,
        this.settings.pdfMaxPages
      );
      return await this.processExtractedContent(meta, apiKey, progress, normalizedUrl);
    } catch (err) {
      console.error(err);
      let message = err instanceof Error ? err.message : String(err);
      const isBlockage = message.includes("403") || message.includes("401") || message.includes("Invalid PDF");
      if (isBlockage) {
        progress.hide();
        new import_obsidian5.Notice("Automated download failed. Switching to manual import...");
        return new Promise((resolve2) => {
          new ManualImportModal(this.app, normalizedUrl, async (buffer) => {
            try {
              const { extractPdfContent: extractPdfContent2 } = await Promise.resolve().then(() => (init_pdf(), pdf_exports));
              const meta = await extractPdfContent2(buffer, normalizedUrl, this.settings.maxChars, this.settings.pdfMaxPages);
              const progress2 = new import_obsidian5.Notice(renderTwoStepProgress(1, "Processing manual file..."), 0);
              const file = await this.processExtractedContent(meta, apiKey, progress2, normalizedUrl);
              resolve2(file);
            } catch (innerErr) {
              new import_obsidian5.Notice(`Manual import failed: ${innerErr}`, 8e3);
              resolve2(null);
            }
          }).open();
        });
      }
      if (message.includes("401")) {
        message += " (Check your API key or if the URL requires authentication)";
      }
      new import_obsidian5.Notice(`Import failed: ${message}`, 8e3);
      return null;
    } finally {
      progress.hide();
    }
  }
  // Refactored common processing logic
  async processExtractedContent(meta, apiKey, progress, normalizedUrl) {
    const isPdf = meta.contentType === "pdf";
    this.logVerbose("Fetched metadata", { ...meta, pdfBuffer: isPdf ? "[ArrayBuffer]" : void 0 });
    if (!meta.text) {
      const contentType = isPdf ? "PDF" : "article";
      new import_obsidian5.Notice(`No ${contentType} text extracted; sending minimal content to LLM.`, 6e3);
    }
    if (isPdf) {
      const pdfMeta = meta;
      this.logVerbose(`PDF detected: ${pdfMeta.pageCount} pages`);
    }
    const providerLabel = this.settings.provider === "lmstudio" ? "LM Studio" : "OpenAI";
    progress.setMessage(renderTwoStepProgress(2, `Formatting with ${providerLabel}...`));
    const promptTemplate = this.settings.useCustomPrompt && this.settings.customPrompt.trim() ? this.settings.customPrompt : void 0;
    if (this.settings.useCustomPrompt && !promptTemplate) {
      new import_obsidian5.Notice("Custom prompt is empty; using default prompt instead.", 5e3);
    }
    const defaultTags = normalizeTags(this.settings.defaultTags);
    let note;
    const useNativeVision = isPdf && this.settings.provider === "openai" && this.settings.pdfHandling === "native-vision" && isVisionModel(this.settings.model);
    if (useNativeVision && isPdf) {
      const pdfMeta = meta;
      this.logVerbose("Using native PDF vision processing");
      note = await this.callPdfVisionWithRetries(apiKey, normalizedUrl, pdfMeta, promptTemplate, defaultTags);
    } else {
      note = await this.callModelWithRetries(apiKey, normalizedUrl, meta, promptTemplate, defaultTags);
    }
    const validated = ensureFrontmatterPresent(note);
    const parts = [];
    parts.push(validated);
    if (this.settings.includeRaw) {
      const rawHeader = isPdf ? "## Extracted PDF text (plaintext)" : "## Extracted article (plaintext)";
      const rawBody = meta.text?.trim() ? meta.text.trim() : "_No text extracted._";
      parts.push("", rawHeader, "", rawBody);
    }
    if (this.settings.includeLinks && meta.links.length) {
      parts.push("", "## Extracted links");
      const linkLines = meta.links.map((l3) => {
        const text = l3.text || l3.href;
        return `- [${text}](${l3.href})`;
      });
      parts.push(...linkLines);
    }
    if (this.settings.includeImages && meta.images.length) {
      parts.push("", "## Extracted images");
      const imageLines = meta.images.map((img) => {
        const alt = img.alt || "image";
        return `- ![${alt}](${img.src})`;
      });
      parts.push(...imageLines);
    }
    const finalNote = parts.join("\n");
    const file = await saveNoteToVault(
      this.app.vault,
      this.settings.outputFolder,
      meta.title || (isPdf ? "document" : "article"),
      finalNote
    );
    if (this.settings.openAfterCreate) {
      await this.app.workspace.getLeaf(true).openFile(file);
    }
    progress.setMessage("Done");
    new import_obsidian5.Notice(`Saved: ${file.path}`);
    return file;
  }
  async runBatchImport(csvContent) {
    const { entries, errors } = parseUrlInput(csvContent);
    if (errors.length > 0) {
      this.logVerbose("CSV parsing errors:", errors);
      new import_obsidian5.Notice(`CSV parsing: ${errors.length} warning(s). Check console for details.`, 5e3);
    }
    if (entries.length === 0) {
      new import_obsidian5.Notice("No valid URLs found in the input.");
      return;
    }
    const apiKey = await this.getApiKey();
    if (this.settings.provider === "openai" && !apiKey) {
      new import_obsidian5.Notice("Set your OpenAI API key in the plugin settings first.", 6e3);
      return;
    }
    new import_obsidian5.Notice(`Starting batch import of ${entries.length} URL(s)...`);
    const progress = new import_obsidian5.Notice(`Batch: 0/${entries.length}`, 0);
    const results = {
      success: 0,
      failed: 0,
      errors: []
    };
    for (let i3 = 0; i3 < entries.length; i3++) {
      const entry = entries[i3];
      const label = entry.label || entry.url;
      progress.setMessage(`Batch: ${i3 + 1}/${entries.length} - ${label.slice(0, 40)}...`);
      try {
        const file = await this.runImportSilent(entry.url);
        if (file) {
          results.success++;
        } else {
          results.failed++;
          results.errors.push({ url: entry.url, message: "Import returned null" });
        }
      } catch (err) {
        results.failed++;
        const message = err instanceof Error ? err.message : String(err);
        results.errors.push({ url: entry.url, message });
        this.logVerbose(`Batch import error for ${entry.url}:`, err);
        if (!this.settings.batchContinueOnError) {
          progress.hide();
          new import_obsidian5.Notice(`Batch stopped due to error: ${message}`, 8e3);
          break;
        }
      }
      if (i3 < entries.length - 1) {
        await this.sleep(this.settings.batchDelayMs);
      }
    }
    progress.hide();
    const resultMsg = `Batch complete: ${results.success} succeeded, ${results.failed} failed`;
    new import_obsidian5.Notice(resultMsg, 6e3);
    if (this.settings.batchCreateReport && results.errors.length > 0) {
      await this.createBatchErrorReport(results);
    }
  }
  /**
   * Silent version of runImport that doesn't show per-item notices
   * Used by batch processing
   */
  async runImportSilent(url) {
    const normalizedUrl = ensureHttpScheme(url);
    if (!normalizedUrl) {
      throw new Error("Empty URL");
    }
    try {
      new URL(normalizedUrl);
    } catch {
      throw new Error("Invalid URL");
    }
    const apiKey = await this.getApiKey();
    const meta = await fetchAndExtractContent(
      normalizedUrl,
      this.settings.maxChars,
      this.settings.pdfMaxPages
    );
    const isPdf = meta.contentType === "pdf";
    this.logVerbose("Fetched metadata (batch)", { title: meta.title, isPdf });
    const promptTemplate = this.settings.useCustomPrompt && this.settings.customPrompt.trim() ? this.settings.customPrompt : void 0;
    const defaultTags = normalizeTags(this.settings.defaultTags);
    let note;
    const useNativeVision = isPdf && this.settings.provider === "openai" && this.settings.pdfHandling === "native-vision" && isVisionModel(this.settings.model);
    if (useNativeVision && isPdf) {
      const pdfMeta = meta;
      note = await this.callPdfVisionWithRetries(apiKey, normalizedUrl, pdfMeta, promptTemplate, defaultTags);
    } else {
      note = await this.callModelWithRetries(apiKey, normalizedUrl, meta, promptTemplate, defaultTags);
    }
    const validated = ensureFrontmatterPresent(note);
    const parts = [];
    parts.push(validated);
    if (this.settings.includeRaw) {
      const rawHeader = isPdf ? "## Extracted PDF text (plaintext)" : "## Extracted article (plaintext)";
      const rawBody = meta.text?.trim() ? meta.text.trim() : "_No text extracted._";
      parts.push("", rawHeader, "", rawBody);
    }
    if (this.settings.includeLinks && meta.links.length) {
      parts.push("", "## Extracted links");
      const linkLines = meta.links.map((l3) => {
        const text = l3.text || l3.href;
        return `- [${text}](${l3.href})`;
      });
      parts.push(...linkLines);
    }
    if (this.settings.includeImages && meta.images.length) {
      parts.push("", "## Extracted images");
      const imageLines = meta.images.map((img) => {
        const alt = img.alt || "image";
        return `- ![${alt}](${img.src})`;
      });
      parts.push(...imageLines);
    }
    const finalNote = parts.join("\n");
    return saveNoteToVault(
      this.app.vault,
      this.settings.outputFolder,
      meta.title || (isPdf ? "document" : "article"),
      finalNote
    );
  }
  async runFolderImport(folderPath) {
    if (!folderPath || !fs3.existsSync(folderPath)) {
      new import_obsidian5.Notice("Folder does not exist.");
      return;
    }
    const stat = fs3.statSync(folderPath);
    if (!stat.isDirectory()) {
      new import_obsidian5.Notice("Path is not a directory.");
      return;
    }
    const files = fs3.readdirSync(folderPath).filter((name) => {
      const lower = name.toLowerCase();
      return lower.endsWith(".pdf") || lower.endsWith(".html") || lower.endsWith(".htm");
    });
    if (files.length === 0) {
      new import_obsidian5.Notice("No supported files (PDF, HTML) found in folder.");
      return;
    }
    new import_obsidian5.Notice(`Starting folder import of ${files.length} file(s)...`);
    const progress = new import_obsidian5.Notice(`Folder: 0/${files.length}`, 0);
    const results = {
      success: 0,
      failed: 0,
      errors: []
    };
    const apiKey = await this.getApiKey();
    if (this.settings.provider === "openai" && !apiKey) {
      new import_obsidian5.Notice("Set your OpenAI API key in the plugin settings first.", 6e3);
      return;
    }
    for (let i3 = 0; i3 < files.length; i3++) {
      const fileName = files[i3];
      const filePath = path.join(folderPath, fileName);
      progress.setMessage(`Folder: ${i3 + 1}/${files.length} - ${fileName}...`);
      try {
        await this.runFolderImportSilent(filePath, fileName, apiKey);
        results.success++;
      } catch (err) {
        results.failed++;
        const message = err instanceof Error ? err.message : String(err);
        results.errors.push({ url: filePath, message });
        this.logVerbose(`Folder import error for ${fileName}:`, err);
        if (!this.settings.batchContinueOnError) {
          progress.hide();
          new import_obsidian5.Notice(`Folder import stopped due to error: ${message}`, 8e3);
          break;
        }
      }
      if (i3 < files.length - 1) {
        await this.sleep(this.settings.batchDelayMs);
      }
    }
    progress.hide();
    const resultMsg = `Folder import complete: ${results.success} succeeded, ${results.failed} failed`;
    new import_obsidian5.Notice(resultMsg, 6e3);
    if (this.settings.batchCreateReport && results.errors.length > 0) {
      await this.createBatchErrorReport(results);
    }
  }
  async runFolderImportSilent(filePath, fileName, apiKey) {
    const ext = path.extname(fileName).toLowerCase();
    let meta;
    if (ext === ".pdf") {
      const buffer = fs3.readFileSync(filePath);
      const arrayBuffer = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
      const fakeUrl = `file://${filePath}`;
      meta = await extractPdfContent(arrayBuffer, fakeUrl, this.settings.maxChars, this.settings.pdfMaxPages);
    } else {
      const html = fs3.readFileSync(filePath, "utf-8");
      const fakeUrl = `file://${filePath}`;
      meta = await extractFromHtml(html, fakeUrl, this.settings.maxChars);
    }
    const promptTemplate = this.settings.useCustomPrompt && this.settings.customPrompt.trim() ? this.settings.customPrompt : void 0;
    const defaultTags = normalizeTags(this.settings.defaultTags);
    let note;
    const isPdf = meta.contentType === "pdf";
    const useNativeVision = isPdf && this.settings.provider === "openai" && this.settings.pdfHandling === "native-vision" && isVisionModel(this.settings.model);
    if (useNativeVision && isPdf) {
      const pdfMeta = meta;
      note = await this.callPdfVisionWithRetries(apiKey, `file://${filePath}`, pdfMeta, promptTemplate, defaultTags);
    } else {
      note = await this.callModelWithRetries(apiKey, `file://${filePath}`, meta, promptTemplate, defaultTags);
    }
    const validated = ensureFrontmatterPresent(note);
    const parts = [];
    parts.push(validated);
    if (this.settings.includeRaw) {
      const rawHeader = isPdf ? "## Extracted PDF text (plaintext)" : "## Extracted article (plaintext)";
      const rawBody = meta.text?.trim() ? meta.text.trim() : "_No text extracted._";
      parts.push("", rawHeader, "", rawBody);
    }
    if (this.settings.includeLinks && meta.links.length) {
      parts.push("", "## Extracted links");
      parts.push(...meta.links.map((l3) => `- [${l3.text || l3.href}](${l3.href})`));
    }
    if (this.settings.includeImages && meta.images.length) {
      parts.push("", "## Extracted images");
      parts.push(...meta.images.map((img) => `- ![${img.alt || "image"}](${img.src})`));
    }
    const finalNote = parts.join("\n");
    let title = meta.title;
    if (!title || title === "document" || title === "article") {
      title = path.parse(fileName).name;
    }
    await saveNoteToVault(
      this.app.vault,
      this.settings.outputFolder,
      title,
      finalNote
    );
  }
  async createBatchErrorReport(results) {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
    const lines = [
      "---",
      `title: "Batch Import Report ${timestamp}"`,
      "type: batch_report",
      `total_success: ${results.success}`,
      `total_failed: ${results.failed}`,
      "---",
      "",
      "## Batch Import Errors",
      ""
    ];
    for (const error of results.errors) {
      lines.push(`- **${error.url}**`);
      lines.push(`  - Error: ${error.message}`);
      lines.push("");
    }
    const content = lines.join("\n");
    const filename = `batch-report-${timestamp}`;
    try {
      const file = await saveNoteToVault(
        this.app.vault,
        this.settings.outputFolder,
        filename,
        content
      );
      this.logVerbose("Created batch error report:", file.path);
    } catch (err) {
      console.warn("Failed to create batch error report:", err);
    }
  }
  sleep(ms2) {
    return new Promise((resolve2) => setTimeout(resolve2, ms2));
  }
  async callModelWithRetries(apiKey, url, meta, promptTemplate, defaultTags) {
    const maxRetries = this.settings.maxRetries ?? 0;
    let attempt = 0;
    let lastError;
    const provider = this.settings.provider;
    const providerLabel = provider === "lmstudio" ? "LM Studio" : "OpenAI";
    while (attempt <= maxRetries) {
      try {
        return await formatWithModel(
          this.getApiKeyForProvider(apiKey),
          this.settings.model,
          url,
          meta,
          defaultTags,
          promptTemplate,
          provider,
          this.getApiBaseUrl()
        );
      } catch (err) {
        lastError = err;
        const status = err?.status ?? err?.response?.status;
        const code = err?.code ?? err?.response?.data?.error?.code;
        const msg = err instanceof Error ? err.message : String(err);
        this.logVerbose(`${providerLabel} error`, { attempt, status, code, msg });
        if (status === 401 && provider === "openai") {
          throw new Error("OpenAI rejected the API key (401). Re-enter your key in settings.");
        }
        if (code === "insufficient_quota" && provider === "openai") {
          throw new Error("OpenAI quota exhausted. Check billing/usage.");
        }
        const retriable = status === 429 || status && status >= 500;
        if (!retriable || attempt === maxRetries) {
          break;
        }
        const delayMs = 500 * Math.pow(2, attempt);
        await new Promise((res) => setTimeout(res, delayMs));
        attempt += 1;
      }
    }
    throw lastError instanceof Error ? lastError : new Error(String(lastError));
  }
  async callPdfVisionWithRetries(apiKey, url, meta, promptTemplate, defaultTags) {
    const maxRetries = this.settings.maxRetries ?? 0;
    let attempt = 0;
    let lastError;
    while (attempt <= maxRetries) {
      try {
        return await formatPdfWithVision(
          apiKey,
          this.settings.model,
          url,
          meta,
          defaultTags,
          promptTemplate
        );
      } catch (err) {
        lastError = err;
        const status = err?.status ?? err?.response?.status;
        const code = err?.code ?? err?.response?.data?.error?.code;
        const msg = err instanceof Error ? err.message : String(err);
        this.logVerbose("OpenAI vision error", { attempt, status, code, msg });
        if (status === 401) {
          throw new Error("OpenAI rejected the API key (401). Re-enter your key in settings.");
        }
        if (code === "insufficient_quota") {
          throw new Error("OpenAI quota exhausted. Check billing/usage.");
        }
        const retriable = status === 429 || status && status >= 500;
        if (!retriable || attempt === maxRetries) {
          break;
        }
        const delayMs = 500 * Math.pow(2, attempt);
        await new Promise((res) => setTimeout(res, delayMs));
        attempt += 1;
      }
    }
    throw lastError instanceof Error ? lastError : new Error(String(lastError));
  }
};
/*! Bundled license information:

web-streams-polyfill/dist/ponyfill.mjs:
  (**
   * @license
   * web-streams-polyfill v4.0.0-beta.3
   * Copyright 2021 Mattias Buelens, Diwank Singh Tomer and other contributors.
   * This code is released under the MIT license.
   * SPDX-License-Identifier: MIT
   *)

formdata-node/lib/esm/blobHelpers.js:
  (*! Based on fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> & David Frank *)

formdata-node/lib/esm/Blob.js:
  (*! Based on fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> & David Frank *)

humanize-ms/index.js:
  (*!
   * humanize-ms - index.js
   * Copyright(c) 2014 dead_horse <dead_horse@qq.com>
   * MIT Licensed
   *)

node-domexception/index.js:
  (*! node-domexception. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> *)

papaparse/papaparse.js:
  (* @license
  Papa Parse
  v5.5.3
  https://github.com/mholt/PapaParse
  License: MIT
  *)
*/
//# sourceMappingURL=main.js.map
